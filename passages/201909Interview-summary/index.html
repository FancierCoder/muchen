<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://static.muchen.fun/images/touch-icon.png"><link rel="icon" href="https://static.muchen.fun/images/favicon.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="沐晨"><meta name="keywords" content="个人博客,个人见解,Java,Spring,IT,程序员,编程,技术,SpringBoot,JavaScript,分享,博客,Blog"><meta name="description" content="最近在面试新工作，记录一下面试中问到的问题，以及我的理解。"><meta property="og:type" content="article"><meta property="og:title" content="9月面试总结"><meta property="og:url" content="https://muchen.fun/passages/201909Interview-summary/index.html"><meta property="og:site_name" content="MuChen&#39;s Blog"><meta property="og:description" content="最近在面试新工作，记录一下面试中问到的问题，以及我的理解。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2019-09-23T07:36:56.000Z"><meta property="article:modified_time" content="2024-03-01T06:54:13.768Z"><meta property="article:author" content="沐晨"><meta property="article:tag" content="面试总结"><meta name="twitter:card" content="summary_large_image"><title>9月面试总结 - MuChen&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"muchen.fun",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:"b561ebd1192170893b7c07a8d4b71fc5",google:{measurement_id:"G-ZX0X3PHEXL"},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"O8vCwRAgytvziX1uG5WgRn8R-MdYXbMMI",app_key:"5Rl3Rhl9zc8BJNvrPcncKWFy",server_url:"https://lean.muchen.fun",path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml",include_content_in_search:!0});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>var _hmt;Fluid.ctx.dnt||(_hmt=_hmt||[],function(){var t=document.createElement("script"),e=(t.src="https://hm.baidu.com/hm.js?b561ebd1192170893b7c07a8d4b71fc5",document.getElementsByTagName("script")[0]);e.parentNode.insertBefore(t,e)}())</script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=G-ZX0X3PHEXL",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","G-ZX0X3PHEXL")})</script><meta name="generator" content="Hexo 7.1.1"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>沐晨</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://static.muchen.fun/picture/15.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="9月面试总结"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2019-09-23 15:36" pubdate>2019年9月23日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4.9k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 41 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">9月面试总结</h1><p id="updated-time" class="note note-info" style="display:none">本文最后更新于 2024-03-01T14:54:13+08:00</p><div class="markdown-body"><!-- more --><p>面试的问题都记录在下面，以及问题的一些解答。</p><h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><p><strong>谈谈你对 <code>HashMap</code> 的理解</strong></p><ul><li><p><code>HashMap</code> 是以数组+链表的方式存储的;</p></li><li><p><code>HashMap</code> 存储的是键值对映射，即 <code>key-value</code>;</p></li><li><p><code>HashMap</code> 可以接受 <code>null</code> 键和 <code>null</code> 值;</p></li><li><p><code>HashMap</code> 的键如果出现冲突，会以链表的方式链接到后面;</p></li><li><p><code>HashMap</code> 的链表会一直增长，在 <code>JDK 1.8</code> 中，当链表的长度大于 <code>8</code> 时，将使用红黑树代替。</p></li></ul><p><strong><code>JVM</code> 有哪些数据区</strong></p><ul><li>主要有五个区域: 堆、方法区、虚拟机栈、本地方法栈、程序计数器</li></ul><p><strong>说说<code>JVM</code> 运行过程</strong></p><ul><li><p>向操作系统申请空闲内存。系统查找内存分配表，然后把内存段的起始地址和终止地址给<code>JVM</code>，<code>JVM</code>准备加载类文件。</p></li><li><p>给堆、栈分配内存。</p></li><li><p>文件检查和分析 <code>class</code> 文件。</p></li><li><p>加载类。（类加载机制，如双亲委派机制）</p></li><li><p>执行方法。</p></li><li><p>释放内存。</p></li></ul><p><strong><code>Java</code> 中的锁机制有哪些</strong></p><p>常见的锁有 <code>synchronized</code>、<code>volatile</code> 等</p><blockquote><p><code>synchronized</code></p></blockquote><ul><li><p>当使用 <code>synchronized</code> 修饰类普通方法时，那么当前加锁的级别就是实例对象，当多个线程并发访问该对象的同步方法、同步代码块时，会进行同步。</p></li><li><p>当使用 <code>synchronized</code> 修饰类静态方法时，那么当前加锁的级别就是类，当多个线程并发访问该类（所有实例对象）的同步方法以及同步代码块时，会进行同步。</p></li><li><p>当使用 <code>synchronized</code> 修饰代码块时，那么当前加锁的级别就是 <code>synchronized(X)</code> 中配置的 <code>x</code> 对象实例，当多个线程并发访问该对象的同步方法、同步代码块以及当前的代码块时，会进行同步。</p></li><li><p>使用同步代码块时要注意的是不要使用 <code>String</code> 类型对象，因为 <code>String</code> 常量池的存在，所以很容易导致出问题。</p></li></ul><blockquote><p><code>volatile</code></p></blockquote><ul><li><code>volatile</code> 可以看做是一种 <code>synchronized</code> 的轻量级锁，它能够保证并发时，被它修饰的共享变量的可见性，从 <code>jmm</code> 的角度来看一下，每个线程拥有自己的工作内存，实际上线程所修改的共享变量是从主内存中拷贝的副本，当一个共享变量被 <code>volatile</code> 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</li></ul><p><strong>说说你知道的设计模式</strong></p><p>常用的设计模式有单例模式、工厂模式、代理模式、观察者模式、装饰模式、享元模式等</p><blockquote><p>单例模式</p></blockquote><ul><li><p>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p></li><li><p>实现方式通常有两种，分别是 <strong>饿汉式单例模式</strong> 和 <strong>懒汉式单例模式</strong></p></li></ul><blockquote><p>工厂模式</p></blockquote><ul><li><p>为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。</p></li><li><p>一个调用者想创建一个对象，只要知道其名称就可以了。</p></li><li><p>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</p></li><li><p>屏蔽产品的具体实现，调用者只关心产品的接口。</p></li></ul><blockquote><p>代理模式</p></blockquote><ul><li><p>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是生活中常见的中介。</p></li><li><p>代理模式主要有两个作用：中介隔离，开闭原则</p></li><li><p>主要有两种代理模式，分别是静态代理和动态代理</p></li></ul><blockquote><p>观察者模式</p></blockquote><ul><li><p>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p></li><li><p>观察者模式是一个比较特殊的设计模式，它定义了触发机制，观察者只要订阅了被观察者，就可以第一时间得到被观察者传递的信息。</p></li><li><p>在工作中，使用观察者模式的场景也比较多，比如消息队列消费等等。</p></li></ul><blockquote><p>装饰模式</p></blockquote><ul><li>装饰模式在一些类与类之间有叠加效应（也就是给一个类增加附加功能）的场景中非常好用，它可以说是继承的替代品，有更好的扩展性，也比较灵活。在 <code>Java JDK</code> 源码中也大面积用到了装饰模式，比如：<code>java.io.BufferedInputStream(InputStream)</code>。</li></ul><blockquote><p>享元模式</p></blockquote><ul><li>享元模式合理提高了对象的复用性，减少了程序的内存占用，还有一个提高性能的地方就是减少了对象创建的过程。</li></ul><h2 id="Spring-框架"><a href="#Spring-框架" class="headerlink" title="Spring 框架"></a>Spring 框架</h2><p><strong><code>Spring</code> 的 <code>IOC</code> 理解</strong></p><ul><li><p><code>IOC</code> 就是控制反转，是指创建对象的控制权的转移，以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到 <code>Spring</code> 容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。<code>DI</code> 依赖注入，和控制反转是同一个概念的不同角度的描述，即应用程序在运行时依赖 <code>IoC</code> 容器来动态注入对象需要的外部资源。</p></li><li><p>最直观的表达就是，<code>IOC</code> 让对象的创建不用去 <code>new</code> 了，可以由 <code>spring</code> 自动生产，使用 <code>java</code> 的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。</p></li></ul><p><strong><code>Spring</code> 的 <code>AOP</code> 理解</strong></p><ul><li><p>一般称为面向切面，作为面向对象的一种补充，<strong>用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块</strong>，这个模块被命名为“切面”（ <code>Aspect</code> ），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。</p></li><li><p><code>AOP</code> 实现的关键在于代理模式，<code>AOP</code>代理主要分为静态代理和动态代理。静态代理与动态代理区别在于生成 <code>AOP</code> 代理对象的时机不同。</p></li><li><p><code>AOP</code> 中的动态代理主要有两种方式，<code>JDK</code>动态代理和<code>CGLIB</code>动态代理</p></li></ul><p><strong><code>Spring</code> 框架中都用到了哪些设计模式？</strong></p><ul><li><p>工厂模式：<code>BeanFactory</code> 就是简单工厂模式的体现，用来创建对象的实例；</p></li><li><p>单例模式：<code>Bean</code> 默认为单例模式；</p></li><li><p>代理模式：<code>Spring</code> 的 <code>AOP</code> 功能用到了 <code>JDK</code> 的动态代理和 <code>CGLIB</code> 字节码生成技术；</p></li><li><p>模板方法：用来解决代码重复的问题。比如 <code>RestTemplate</code>, <code>JmsTemplate</code>, <code>JpaTemplate</code>。</p></li><li><p>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</p></li></ul><p><strong><code>Spring</code> 事务的实现方式和实现原理</strong></p><ul><li><p><code>Spring</code> 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，<code>spring</code> 是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过 <code>bin log</code> 或者 <code>redo log</code> 实现的。</p></li><li><p><code>Spring</code> 支持编程式事务管理和声明式事务管理两种方式：编程式事务管理使用 <code>TransactionTemplate</code> ；声明式事务管理建立在 <code>AOP</code> 之上的。其本质是通过 <code>AOP</code> 功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p></li></ul><h2 id="Spring-Boot-框架"><a href="#Spring-Boot-框架" class="headerlink" title="Spring Boot 框架"></a>Spring Boot 框架</h2><p><strong>为什么要用 <code>Spring Boot</code>？</strong></p><ul><li>Spring Boot 可以做到独立运行、简化配置、自动配置、无代码生成和 <code>XML</code> 配置、应用监控、上手容易等优点。</li></ul><h2 id="Mybatis-框架"><a href="#Mybatis-框架" class="headerlink" title="Mybatis 框架"></a>Mybatis 框架</h2><p><strong><code>#&#123;&#125;</code> 和 <code>$&#123;&#125;</code> 的区别是什么？</strong></p><ul><li><p><code>#&#123;&#125;</code> 是预编译处理，<code>$&#123;&#125;</code> 是字符串替换。</p></li><li><p><code>Mybatis</code> 在处理 <code>#&#123;&#125;</code> 时，会将 <code>sql</code> 中的 <code>#&#123;&#125;</code> 替换为 <code>?</code> 号，调用 <code>PreparedStatement</code> 的 <code>set</code> 方法来赋值；</p></li><li><p><code>Mybatis</code> 在处理 <code>$&#123;&#125;</code> 时，就是把 <code>$&#123;&#125;</code> 替换成变量的值。</p></li><li><p>使用 <code>#&#123;&#125;</code> 可以有效的防止 <code>SQL</code> 注入，提高系统安全性。</p></li></ul><p><strong><code>Mybatis</code> 的常用标签有哪些？</strong></p><ul><li>常用的有 <code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>、<code>&lt;resultMap&gt;</code></li></ul><p><strong>通常一个 <code>Xml</code> 映射文件，都会写一个 <code>Dao</code> 接口与之对应，请问，这个 <code>Dao</code> 接口的工作原理是什么？<code>Dao</code> 接口里的方法，参数不同时，方法能重载吗？</strong></p><ul><li><p>接口的全名，就是映射文件中的 <code>namespace</code> 的值；</p></li><li><p>接口的方法名，就是映射文件中 <code>Mapper</code> 的 <code>Statement</code> 的 <code>id</code> 值；</p></li><li><p>接口方法内的参数，就是传递给 <code>sql</code> 的参数。</p></li><li><p><code>Mapper</code>接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 <code>key</code> 值，可唯一定位一个 <code>MapperStatement</code>。在 <code>Mybatis</code> 中，每一个 <code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code> 标签，都会被解析为一个 <code>MapperStatement</code> 对象。</p></li><li><p><code>Mapper</code> 接口里的方法，是不能重载的，因为是使用<strong>全限名+方法名</strong>的保存和寻找策略；</p></li><li><p><code>Mapper</code> 接口的工作原理是 <code>JDK</code> 动态代理，<code>Mybatis</code>运行时会使用 <code>JDK</code> 动态代理为 <code>Mapper</code> 接口生成代理对象 <code>proxy</code>，代理对象会拦截接口方法，转而执行<code>MapperStatement</code>所代表的<code>sql</code>，然后将<code>sql</code>执行结果返回。</p></li></ul><p><strong><code>Mybatis</code> 是如何将 <code>sql</code> 执行结果封装为目标对象并返回的？都有哪些映射形式？</strong></p><ul><li><p>第一种是使用 <code>&lt;resultMap&gt;</code> 标签，逐一定义数据库列名和对象属性名之间的映射关系。</p></li><li><p>第二种是使用 <code>sql</code> 列的别名功能，将列的别名书写为对象属性名。</p></li><li><p>有了列名与属性名的映射关系后，<code>Mybatis</code> 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p></li></ul><p><strong>如何获取自动生成的(主)键值?</strong></p><ul><li>可以在 <code>&lt;insert&gt;</code> 内加上 <code>usegeneratedkeys=”true” keyproperty=”id”(假设主键名称为id)</code></li></ul><p><strong><code>Mybatis</code>一对一、一对多的关联查询是用什么标签实现的？</strong></p><ul><li>主要是通过 <code>&lt;association&gt;</code>, <code>&lt;collection&gt;</code> 来实现的</li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><strong><code>Redis</code> 支持哪些数据类型？</strong></p><ul><li>支持的有 <code>String</code>, <code>Hash</code>, <code>List</code>, <code>Set</code>, <code>zset</code>, 压缩列表等</li></ul><p><strong>什么是 <code>Redis</code> 持久化？<code>Redis</code>有哪几种持久化方式？优缺点是什么？</strong></p><ul><li><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p></li><li><p><code>Redis</code> 提供了两种持久化方式: <code>RDB</code>（默认）和 <code>AOF</code></p></li><li><p><code>RDB</code> 持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是 <code>fork</code> 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p></li><li><p><code>RDB</code> 持久化会清除原有的存储结构，只将数据存储到磁盘中。当需要从磁盘还原数据到内存的时候，再重新将数据组织成原来的数据结构。</p></li><li><p><code>AOF</code> 持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</p></li><li><p><code>AOF</code> 持久化会保留原来的存储格式，将数据按照原有的格式存储在磁盘中。拿散列表这样的数据结构来举例。可以将散列表的大小、每个数据被散列到的槽的编号等信息，都保存在磁盘中。有了这些信息，从磁盘中将数据还原到内存中的时候，就可以避免重新计算哈希值。</p></li><li><p><code>AOF</code>文件比<code>RDB</code>更新频率高，优先使用<code>AOF</code>还原数据。</p></li><li><p><code>AOF</code>比<code>RDB</code>更安全也更大</p></li><li><p><code>RDB</code>性能比<code>AOF</code>好</p></li><li><p>如果两个都配了优先加载<code>AOF</code></p></li></ul><p><strong>什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？</strong></p><ul><li><p>一般的缓存系统，都是按照 <code>key</code> 去缓存查询，如果不存在对应的 <code>value</code>，就应该去后端系统查找（比如<code>DB</code>）。一些恶意的请求会故意查询不存在的 <code>key</code>,请求量很大，就会对后端系统造成很大的压力。这就叫做<strong>缓存穿透</strong>。</p></li><li><p>避免的方法：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该 <code>key</code> 对应的数据 <code>insert</code> 了之后清理缓存。对一定不存在的 <code>key</code> 进行过滤；可以把所有的可能存在的 <code>key</code>放到一个大的<code>Bitmap</code>中，查询时通过该<code>Bitmap</code>过滤。</p></li><li><p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。这就叫做<strong>缓存雪崩</strong>。</p></li><li><p>避免的方法：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 <code>key</code> 只允许一个线程查询数据和写缓存，其他线程等待；做二级缓存，<code>A1</code>为原始缓存，<code>A2</code>为拷贝缓存，<code>A1</code>失效时，可以访问<code>A2</code>，<code>A1</code>缓存失效时间设置为短期，<code>A2</code>设置为长期；不同的 <code>key</code>，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p></li></ul><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p><strong>数据库事务的四个特性</strong></p><ul><li><p><code>ACID</code></p></li><li><p>原子性(<code>Atomicity</code>)：指的是事务中所有操作，要么全做，要么全不做。事务在执行过程中如果出现差错会全部回滚到最初的状态</p></li><li><p>一致性(<code>Correspondence</code>)：在事务开始之前以及结束之后，数据库的完整性约束不会被破坏</p></li><li><p>隔离性(<code>Isolation</code>)：隔离状态下执行事务，使他们好像是系统在给定时间内执行的唯一操作</p></li><li><p>持久性(<code>Durability</code>)：在事务完成后，该事务对数据库所做的操作都会全部持久的保存在数据库中，不会被回滚</p></li></ul><p><strong><code>MySQL</code>中 <code>MyISAM</code> 与 <code>InnoDB</code> 的区别</strong></p><ul><li><p><code>InnoDB</code>支持事务，而<code>MyISAM</code>不支持事务</p></li><li><p><code>InnoDB</code>支持行级锁，而<code>MyISAM</code>支持表级锁</p></li><li><p><code>InnoDB</code>支持<code>MVCC</code>, 而<code>MyISAM</code>不支持</p></li><li><p><code>InnoDB</code>支持外键，而<code>MyISAM</code>不支持</p></li><li><p><code>InnoDB</code>不支持全文索引，而<code>MyISAM</code>支持。</p></li><li><p><code>InnoDB</code>不能通过直接拷贝表文件的方法拷贝表到另外一台机器，<code>MyISAM</code> 支持</p></li><li><p><code>InnoDB</code>表支持多种行格式，<code>MyISAM</code>不支持</p></li><li><p><code>InnoDB</code>是索引组织表，<code>MyISAM</code> 是堆表</p></li></ul><p><strong><code>InnoDB</code>引擎的4大特性</strong></p><ul><li><p>插入缓冲（<code>insert buffer</code>)</p></li><li><p>二次写(<code>double write</code>)</p></li><li><p>自适应哈希索引(<code>ahi</code>)</p></li><li><p>预读(<code>read ahead</code>)</p></li></ul><p><strong><code>MyISAM</code> 与 <code>InnoDB</code>两者<code>select count(*)</code>哪个更快，为什么</strong></p><ul><li><code>MyISAM</code>更快，因为<code>MyISAM</code>内部维护了一个计数器，可以直接调取</li></ul><p><strong><code>InnoDB</code>的事务与日志的存放形式</strong></p><ul><li><p><code>redo</code>：在页修改的时候，先写到 <code>redo log buffer</code> 里面，然后写到 <code>redo log</code> 的文件系统缓存里面(<code>fwrite</code>)，然后再同步到磁盘文件（<code>fsync</code>）</p></li><li><p><code>undo</code>：在 <code>MySQL5.5</code> 之前，<code>undo</code> 只能存放在 <code>ibdata*</code> 文件里面，<code>5.6</code> 之后，可以通过设置 <code>innodb_undo_tablespaces</code> 参数把 <code>undo log</code> 存放在 <code>ibdata*</code> 之外</p></li></ul><p><strong><code>InnoDB</code>的事务是如何通过日志来实现的</strong></p><ul><li><p>事务在修改页时，要先记 <code>undo</code>，在记 <code>undo</code> 之前要记 <code>undo</code> 的 <code>redo</code>，然后修改数据页，再记数据页修改的 <code>redo</code>。</p></li><li><p><code>redo</code>（里面包括 <code>undo</code> 的修改） 一定要比数据页先持久化到磁盘。</p></li><li><p>当事务需要回滚时，因为有 <code>undo</code>，可以把数据页回滚到前镜像的状态，崩溃恢复时，如果 <code>redo log</code> 中事务没有对应的 <code>commit</code> 记录，那么需要用 <code>undo</code> 把该事务的修改回滚到事务开始之前。</p></li><li><p>如果有 <code>commit</code> 记录，就用 <code>redo</code> 前滚到该事务完成时并提交掉。</p></li></ul><p><strong><code>explain</code> 中的索引问题</strong></p><ul><li><p><code>explain</code> 结果中，一般来说，要看到尽量用 <code>index</code>(<code>type</code> 为 <code>const</code>、<code>ref</code> 等，<code>key</code> 列有值)，避免使用全表扫描(<code>type</code> 显式为 <code>ALL</code>)。</p></li><li><p>比如说有 <code>where</code> 条件且选择性不错的列，需要建立索引。</p></li><li><p>被驱动表的连接列，也需要建立索引。被驱动表的连接列也可能会跟 <code>where</code> 条件列一起建立联合索引。</p></li><li><p>当有排序或者 <code>group by</code> 的需求时，也可以考虑建立索引来达到直接排序和汇总的需求。</p></li></ul><p><strong><code>MySQL</code>中<code>InnoDB</code>引擎的行锁是通过加在什么上完成(或称实现)的？</strong></p><ul><li><p><code>InnoDB</code>是基于索引来完成行锁</p></li><li><p>例如，<code>select * from tab_with_index where id = 1 for update;</code><br><code>for update</code> 可以根据条件来完成行锁锁定,并且 <code>id</code> 是有索引键的列, 如果 <code>id</code> 不是索引键那么<code>InnoDB</code>将加上表锁</p></li></ul><p><strong>描述下 <code>MySQL</code> 中 <code>InnoDB</code> 支持的四种事务隔离级别名称，以及逐级之间的区别？</strong></p><ul><li><p>读未提交(<code>read uncommitted</code>)<br>读已提交(<code>read committed</code>)<br>可重复读(<code>repeatable read</code>)<br>串行(<code>serializable</code>)</p></li><li><p><code>Read Uncommitted</code>:可以读取其他 <code>session</code> 未提交的脏数据。<br><code>Read Committed</code>:允许不可重复读取，但不允许脏读取。提交后，其他会话可以看到提交的数据。<br><code>Repeatable Read</code>: 禁止不可重复读取和脏读取、以及幻读(<code>innodb</code> 独有)。<br><code>Serializable</code>: 事务只能一个接着一个地执行，但不能并发执行。事务隔离级别最高。<br>不同的隔离级别有不同的现象，并有不同的锁定&#x2F;并发机制，隔离级别越高，数据库的并发性就越差。</p></li></ul><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p><strong>为什么要使用 <code>kafka</code>，为什么要使用消息队列</strong></p><ul><li><p>缓冲和削峰：上游数据时有突发流量，下游可能扛不住，或者下游没有足够多的机器来保证冗余，<code>kafka</code> 在中间可以起到一个缓冲的作用，把消息暂存在 <code>kafka</code> 中，下游服务就可以按照自己的节奏进行慢慢处理。</p></li><li><p>解耦和扩展性：项目开始的时候，并不能确定具体需求。消息队列可以作为一个接口层，解耦重要的业务流程。只需要遵守约定，针对数据编程即可获取扩展能力。</p></li><li><p>冗余：可以采用一对多的方式，一个生产者发布消息，可以被多个订阅<code>topic</code>的服务消费到，供多个毫无关联的业务使用。</p></li><li><p>健壮性：消息队列可以堆积请求，所以消费端业务即使短时间死掉，也不会影响主要业务的正常进行。</p></li><li><p>异步通信：很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p></li></ul><p><strong><code>Kafka</code>中的 <code>broker</code> 是干什么的</strong></p><ul><li><code>broker</code> 是消息的代理，<code>Producers</code> 往 <code>Brokers</code> 里面的指定 <code>Topic</code> 中写消息，<code>Consumers</code> 从 <code>Brokers</code> 里面拉取指定 <code>Topic</code> 的消息，然后进行业务处理，<code>broker</code> 在中间起到一个代理保存消息的中转站。</li></ul><p><strong>Kafka中是怎么体现消息顺序性的？</strong></p><ul><li><code>kafka</code>每个 <code>partition</code> 中的消息在写入时都是有序的，消费时，每个<code>partition</code>只能被每一个<code>group</code>中的一个消费者消费，保证了消费时也是有序的。整个<code>topic</code>不保证有序。如果为了保证<code>topic</code>整个有序，那么将<code>partition</code>调整为<code>1</code>.</li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E9%9D%A2%E8%AF%95/" class="category-chain-item">面试</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" class="print-no-link">#面试总结</a></div></div><div class="license-box my-3"><div class="license-title"><div>9月面试总结</div><div>https://muchen.fun/passages/201909Interview-summary/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>沐晨</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2019年9月23日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/passages/java-lock/" title="Java锁机制"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Java锁机制</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/passages/leetcode-day190911/" title="LEETCODE：数组（一）"><span class="hidden-mobile">LEETCODE：数组（一）</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script>Fluid.utils.loadComments("#valine",function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.5.1/Valine.min.js",function(){var i=Object.assign({appId:"O8vCwRAgytvziX1uG5WgRn8R-MdYXbMMI",appKey:"5Rl3Rhl9zc8BJNvrPcncKWFy",path:"window.location.pathname",placeholder:"说点什么吧~",avatar:"retro",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"https://lean.muchen.fun",emojiCDN:null,emojiMaps:null,enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(i),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var i="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,t=t.getElementById("subtitle");t&&e&&e(t.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>var relativeDate=function(){var t,e,i,n=document.getElementById("updated-time");n&&((i=(t=n.textContent).match(e=/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/))&&(i=moment(i[0]).fromNow(),n.textContent=t.replace(e,i)),n.style.display="")};Fluid.utils.createScript("https://lib.baomitu.com/moment.js/2.29.4/moment.min.js",function(){"zh-cn".startsWith("en")?relativeDate():Fluid.utils.createScript("https://lib.baomitu.com/moment.js/2.29.4/locale/zh-cn.min.js",function(){relativeDate()})})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback(function(){if("anchors"in window){anchors.removeAll();var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>