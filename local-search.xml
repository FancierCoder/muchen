<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>设计模式之美学习（三十二）</title>
    <link href="/passages/design-pattern-learn-32/"/>
    <url>/passages/design-pattern-learn-32/</url>
    
    <content type="html"><![CDATA[<p>如何设计实现一个集群环境下的分布式单例模式？</p><a id="more"></a><h2 id="如何理解单例模式的唯一性？"><a href="#如何理解单例模式的唯一性？" class="headerlink" title="如何理解单例模式的唯一性？"></a>如何理解单例模式的唯一性？</h2><p>单例类中对象的唯一性的作用范围是“进程唯一”的。“进程唯一”指的是进程内唯一，进程间不唯一；“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”就意味着线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处。“集群唯一”指的是进程内唯一、进程间也唯一。</p><h2 id="如何实现线程唯一的单例？"><a href="#如何实现线程唯一的单例？" class="headerlink" title="如何实现线程唯一的单例？"></a>如何实现线程唯一的单例？</h2><p>我们通过一个 <code>HashMap</code> 来存储对象，其中 <code>key</code> 是线程 <code>ID</code>，<code>value</code> 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，<code>Java</code> 语言本身提供了 <code>ThreadLocal</code> 并发工具类，可以更加轻松地实现线程唯一单例。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdGenerator</span> </span>&#123;  <span class="hljs-keyword">private</span> AtomicLong id = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>);  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;Long, IdGenerator&gt; instances          = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">IdGenerator</span><span class="hljs-params">()</span> </span>&#123;&#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IdGenerator <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;    Long currentThreadId = Thread.currentThread().getId();    instances.putIfAbsent(currentThreadId, <span class="hljs-keyword">new</span> IdGenerator());    <span class="hljs-keyword">return</span> instances.get(currentThreadId);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> id.incrementAndGet();  &#125;&#125;</code></pre><h2 id="如何实现集群环境下的单例？"><a href="#如何实现集群环境下的单例？" class="headerlink" title="如何实现集群环境下的单例？"></a>如何实现集群环境下的单例？</h2><p>我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。为了保证任何时刻在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，需要显式地将对象从内存中删除，并且释放对对象的加锁。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdGenerator</span> </span>&#123;  <span class="hljs-keyword">private</span> AtomicLong id = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>);  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IdGenerator instance;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SharedObjectStorage storage = FileSharedObjectStorage(<span class="hljs-comment">/*入参省略，比如文件地址*/</span>);  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DistributedLock lock = <span class="hljs-keyword">new</span> DistributedLock();    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">IdGenerator</span><span class="hljs-params">()</span> </span>&#123;&#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> IdGenerator <span class="hljs-title">getInstance</span><span class="hljs-params">()</span>     <span class="hljs-title">if</span> <span class="hljs-params">(instance == <span class="hljs-keyword">null</span>)</span> </span>&#123;      lock.lock();      instance = storage.load(IdGenerator.class);    &#125;    <span class="hljs-keyword">return</span> instance;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> synchroinzed <span class="hljs-keyword">void</span> <span class="hljs-title">freeInstance</span><span class="hljs-params">()</span> </span>&#123;    storage.save(<span class="hljs-keyword">this</span>, IdGeneator.class);    instance = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//释放对象</span>    lock.unlock();  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">return</span> id.incrementAndGet();  &#125;&#125;<span class="hljs-comment">// IdGenerator使用举例</span>IdGenerator idGeneator = IdGenerator.getInstance();<span class="hljs-keyword">long</span> id = idGenerator.getId();IdGenerator.freeInstance();</code></pre><h2 id="如何实现一个多例模式？"><a href="#如何实现一个多例模式？" class="headerlink" title="如何实现一个多例模式？"></a>如何实现一个多例模式？</h2><p>“单例”指的是一个类只能创建一个对象。对应地，“多例”指的就是一个类可以创建多个对象，但是个数是有限制的，比如只能创建 <code>3</code> 个对象。多例的实现也比较简单，通过一个 <code>Map</code> 来存储对象类型和对象之间的对应关系，来控制对象的个数。</p><p>参考: <a href="https://time.geekbang.org/column/article/196790" target="_blank" rel="noopener">单例模式（下）：如何设计实现一个集群环境下的分布式单例模式？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式与范式(创建型)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（三十一）</title>
    <link href="/passages/design-pattern-learn-31/"/>
    <url>/passages/design-pattern-learn-31/</url>
    
    <content type="html"><![CDATA[<p>为什么不推荐使用单例模式？</p><a id="more"></a><h2 id="单例存在哪些问题？"><a href="#单例存在哪些问题？" class="headerlink" title="单例存在哪些问题？"></a>单例存在哪些问题？</h2><ul><li><p>单例对 <code>OOP</code> 特性的支持不友好</p></li><li><p>单例会隐藏类之间的依赖关系</p></li><li><p>单例对代码的扩展性不友好</p></li><li><p>单例对代码的可测试性不友好</p></li><li><p>单例不支持有参数的构造函数</p></li></ul><h2 id="单例有什么替代解决方案？"><a href="#单例有什么替代解决方案？" class="headerlink" title="单例有什么替代解决方案？"></a>单例有什么替代解决方案？</h2><p>为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。不过，静态方法这种实现思路，并不能解决我们之前提到的问题。如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类了。<br>比如，通过工厂模式、<code>IOC</code> 容器（比如 <code>Spring IOC</code> 容器）来保证，由程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。</p><p>有人把单例当作反模式，主张杜绝在项目中使用。个人觉得这有点极端。<strong>模式没有对错，关键看你怎么用</strong>。<br>如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题。对于一些全局的类，我们在其他地方 <code>new</code> 的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便。</p><p>参考: <a href="https://time.geekbang.org/column/article/194068" target="_blank" rel="noopener">单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式与范式(创建型)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shiro过滤器导致的前端跨域</title>
    <link href="/passages/shiro-cause-cors/"/>
    <url>/passages/shiro-cause-cors/</url>
    
    <content type="html"><![CDATA[<!-- more --><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>公司项目是前后端分离的，最近要求在请求时都要在请求头加入自定义的 <code>token</code>，在做接口调试时，前端总是请求不通，然而自己用 <code>POSTMAN</code> 等工具时都可以，这就出现了问题，也就是 <strong>复杂请求</strong> 的跨域问题。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><blockquote><p>部分文段摘自 <a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></p></blockquote><h3 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h3><p>浏览器将<code>CORS</code>请求分成两类：简单请求（<code>simple request</code>）和非简单请求（<code>not-so-simple request</code>）。</p><p>只要同时满足以下两大条件，就属于简单请求。</p><ul><li>请求方法是以下三种方法之一：<pre><code class="hljs plain">HEADGETPOST</code></pre></li><li><code>HTTP</code>的头信息不超出以下几种字段：<pre><code class="hljs plain">AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type: 只限于三个值 application&#x2F;x-www-form-urlencoded multipart&#x2F;form-data text&#x2F;plain</code></pre>这是为了兼容表单（<code>form</code>），因为历史上表单一直可以发出跨域请求。<code>AJAX</code> 的跨域设计就是，只要表单可以发，<code>AJAX</code> 就可以直接发。</li></ul><p>凡是不同时满足上面两个条件，就属于非简单请求。</p><h3 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h3><p>非简单请求的<code>CORS</code>请求，会在正式通信之前，增加一次<code>HTTP</code>查询请求，称为”预检”请求（<code>preflight</code>）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些<code>HTTP</code>动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>由于项目中的 <code>shiro</code> 使用了 <code>UserFilter</code>, 下面是其代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AccessControlFilter</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserFilter</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccessAllowed</span><span class="hljs-params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isLoginRequest(request, response)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            Subject subject = <span class="hljs-keyword">this</span>.getSubject(request, response);            <span class="hljs-keyword">return</span> subject.getPrincipal() != <span class="hljs-keyword">null</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onAccessDenied</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">this</span>.saveRequestAndRedirectToLogin(request, response);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><p>可以看出过滤器在过滤时上面的判断是用来判断是否为登录请求的，否则就去寻找登录凭证。而在 <code>OPTIONS</code> 请求中，是没有携带上 <code>token</code> 信息的，下面是当时情况下请求的 <code>header</code>:</p><pre><code class="hljs http">=== MimeHeaders ===host = 192.168.7.139:4000connection = keep-aliveaccept = */*access-control-request-method = POSTaccess-control-request-headers = content-type,x-admin-tokenorigin = http://192.168.7.117:8080sec-fetch-mode = corsreferer = http://192.168.7.117:8080/user-agent = Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36accept-encoding = gzip, deflateaccept-language = zh-CN,zh;q=0.9</code></pre><p>可以看到 <code>token</code> 是被带在了 <code>access-control-request-headers</code> 中，这样 <code>shiro</code> 是找不到登录凭证的，请求自然就被拒绝了。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>解决办法就是重写 <code>UserFilter</code>(具体看项目用的是哪个过滤器) 的 <code>isAccessAllowed</code> 方法，代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StatelessAuthcFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UserFilter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        HttpServletRequest httpRequest = WebUtils.toHttp(request);        HttpServletResponse httpResponse = WebUtils.toHttp(response);        <span class="hljs-keyword">if</span> (httpRequest.getMethod().equals(RequestMethod.OPTIONS.name())) &#123;            httpResponse.setHeader(<span class="hljs-string">"Access-control-Allow-Origin"</span>, httpRequest.getHeader(<span class="hljs-string">"Origin"</span>));            httpResponse.setHeader(<span class="hljs-string">"Access-Control-Allow-Methods"</span>, httpRequest.getMethod());            httpResponse.setHeader(<span class="hljs-string">"Access-Control-Allow-Headers"</span>, httpRequest.getHeader(<span class="hljs-string">"Access-Control-Request-Headers"</span>));            httpResponse.setStatus(HttpStatus.OK.value());            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.preHandle(request, response);    &#125;&#125;</code></pre><p>然后再去 shiro 配置中将 user 过滤器修改为自定义的过滤器：</p><pre><code class="hljs java"><span class="hljs-comment">/**     * Shiro过滤器配置     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ShiroFilterFactoryBean <span class="hljs-title">shiroFilterFactoryBean</span><span class="hljs-params">(SecurityManager securityManager)</span> </span>&#123;        ShiroFilterFactoryBean shiroFilterFactoryBean = <span class="hljs-keyword">new</span> ShiroFilterFactoryBean();        <span class="hljs-comment">// Shiro的核心安全接口,这个属性是必须的</span>        shiroFilterFactoryBean.setSecurityManager(securityManager);        <span class="hljs-comment">// 身份认证失败，则跳转到登录页面的配置</span>        shiroFilterFactoryBean.setLoginUrl(loginUrl);        <span class="hljs-comment">// 权限认证失败，则跳转到指定页面</span>        shiroFilterFactoryBean.setUnauthorizedUrl(unauthorizedUrl);        Map&lt;String, Filter&gt; filters = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();        filters.put(<span class="hljs-string">"user"</span>, <span class="hljs-keyword">new</span> StatelessAuthcFilter());        shiroFilterFactoryBean.setFilters(filters);        <span class="hljs-comment">// Shiro连接约束配置，即过滤链的定义</span>        Map&lt;String, String&gt; filterChainDefinitionMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();        <span class="hljs-comment">// 对静态资源设置匿名访问</span>        filterChainDefinitionMap.put(<span class="hljs-string">"/favicon.ico**"</span>, <span class="hljs-string">"anon"</span>);        filterChainDefinitionMap.put(<span class="hljs-string">"/css/**"</span>, <span class="hljs-string">"anon"</span>);        filterChainDefinitionMap.put(<span class="hljs-string">"/docs/**"</span>, <span class="hljs-string">"anon"</span>);        filterChainDefinitionMap.put(<span class="hljs-string">"/fonts/**"</span>, <span class="hljs-string">"anon"</span>);        filterChainDefinitionMap.put(<span class="hljs-string">"/img/**"</span>, <span class="hljs-string">"anon"</span>);        filterChainDefinitionMap.put(<span class="hljs-string">"/ajax/**"</span>, <span class="hljs-string">"anon"</span>);        filterChainDefinitionMap.put(<span class="hljs-string">"/js/**"</span>, <span class="hljs-string">"anon"</span>);        <span class="hljs-comment">// 不需要拦截的访问</span>        filterChainDefinitionMap.put(<span class="hljs-string">"/auth/login"</span>, <span class="hljs-string">"anon"</span>);        <span class="hljs-comment">// 所有请求需要认证</span>        filterChainDefinitionMap.put(<span class="hljs-string">"/**"</span>, <span class="hljs-string">"user"</span>);        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);        <span class="hljs-keyword">return</span> shiroFilterFactoryBean;    &#125;</code></pre><p>本以为这样就好了，但实际上在页面重定向后再请求接口还是有问题，这是因为重定向会会默认把请求头清空，所以还需要将 <code>onAccessDenied</code> 方法重写，完整的代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StatelessAuthcFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UserFilter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        HttpServletRequest httpRequest = WebUtils.toHttp(request);        HttpServletResponse httpResponse = WebUtils.toHttp(response);        <span class="hljs-keyword">if</span> (httpRequest.getMethod().equals(RequestMethod.OPTIONS.name())) &#123;            httpResponse.setHeader(<span class="hljs-string">"Access-control-Allow-Origin"</span>, httpRequest.getHeader(<span class="hljs-string">"Origin"</span>));            httpResponse.setHeader(<span class="hljs-string">"Access-Control-Allow-Methods"</span>, httpRequest.getMethod());            httpResponse.setHeader(<span class="hljs-string">"Access-Control-Allow-Headers"</span>, httpRequest.getHeader(<span class="hljs-string">"Access-Control-Request-Headers"</span>));            httpResponse.setStatus(HttpStatus.OK.value());            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.preHandle(request, response);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onAccessDenied</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        HttpServletResponse httpResp = WebUtils.toHttp(response);        HttpServletRequest httpReq = WebUtils.toHttp(request);        <span class="hljs-comment">/*系统重定向会默认把请求头清空，这里通过拦截器重新设置请求头，解决跨域问题*/</span>        httpResp.addHeader(<span class="hljs-string">"Access-Control-Allow-Origin"</span>, httpReq.getHeader(<span class="hljs-string">"Origin"</span>));        httpResp.addHeader(<span class="hljs-string">"Access-Control-Allow-Headers"</span>, <span class="hljs-string">"*"</span>);        httpResp.addHeader(<span class="hljs-string">"Access-Control-Allow-Methods"</span>, <span class="hljs-string">"*"</span>);        httpResp.addHeader(<span class="hljs-string">"Access-Control-Allow-Credentials"</span>, <span class="hljs-string">"true"</span>);        <span class="hljs-keyword">this</span>.saveRequestAndRedirectToLogin(request, response);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><p>这样就解决了 <code>shiro</code> 导致的跨域问题，如果内容对你有所帮助，可以分享给你的好友共同学习。</p>]]></content>
    
    
    <categories>
      
      <category>踩坑经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SHIRO</tag>
      
      <tag>跨域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（三十）</title>
    <link href="/passages/design-pattern-learn-30/"/>
    <url>/passages/design-pattern-learn-30/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>单例设计模式（<code>Singleton Design Pattern</code>）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称<strong>单例模式</strong>。</p><h2 id="如何实现一个单例？"><a href="#如何实现一个单例？" class="headerlink" title="如何实现一个单例？"></a>如何实现一个单例？</h2><p>要实现一个单例，我们需要关注的点无外乎下面几个：</p><ul><li><p>构造函数需要是 <code>private</code> 访问权限的，这样才能避免外部通过 <code>new</code> 创建实例；</p></li><li><p>考虑对象创建时的线程安全问题；</p></li><li><p>考虑是否支持延迟加载；</p></li><li><p>考虑 <code>getInstance()</code> 性能是否高（是否加锁）。</p></li></ul><h2 id="单例的用处"><a href="#单例的用处" class="headerlink" title="单例的用处"></a>单例的用处</h2><p>从业务概念上，有些数据在系统中只应该保存一份，就比较适合设计为单例类。比如，系统的配置信息类。除此之外，我们还可以使用单例解决资源访问冲突的问题。</p><h2 id="单例的实现"><a href="#单例的实现" class="headerlink" title="单例的实现"></a>单例的实现</h2><p>单例有下面几种经典的实现方式:</p><ul><li>饿汉式</li></ul><p>饿汉式的实现方式，在类加载的期间，就已经将 <code>instance</code> 静态实例初始化好了，所以，<code>instance</code> 实例的创建是线程安全的。不过，这样的实现方式不支持延迟加载实例。</p><ul><li>懒汉式</li></ul><p>懒汉式相对于饿汉式的优势是支持延迟加载。这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题，频繁的调用会产生性能瓶颈。</p><ul><li>双重检测</li></ul><p>双重检测实现方式既支持延迟加载、又支持高并发的单例实现方式。只要 <code>instance</code> 被创建之后，再调用 <code>getInstance()</code> 函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。</p><ul><li>静态内部类</li></ul><p>利用 <code>Java</code> 的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实现起来也比双重检测简单。</p><ul><li>枚举</li></ul><p>最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 <code>Java</code> 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。</p><p>参考：<a href="https://time.geekbang.org/column/article/194035" target="_blank" rel="noopener">为什么说支持懒加载的双重检测不比饿汉式更优？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式与范式(创建型)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（二十九）</title>
    <link href="/passages/design-pattern-learn-29/"/>
    <url>/passages/design-pattern-learn-29/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>面向对象设计中的最后一步是组装类并提供执行入口，也就是上帝类要做的事情。这个上帝类是没办法去掉的，但我们可以将上帝类做得很轻量级，把核心逻辑都剥离出去，下沉形成独立的类。上帝类只负责组装类和串联执行流程。这样做的好处是，代码结构更加清晰，底层核心逻辑更容易被复用。</p><p>面向对象设计和实现要做的事情，就是把合适的代码放到合适的类中。当我们要实现某个功能的时候，不管如何设计，所需要编写的代码量基本上是一样的，唯一的区别就是如何将这些代码划分到不同的类中。不同的人有不同的划分方法，对应得到的代码结构（比如类与类之间交互等）也不尽相同。</p><p>好的设计一定是结构清晰、有条理、逻辑性强，看起来一目了然，读完之后常常有一种原来如此的感觉。差的设计往往逻辑、代码乱塞一通，没有什么设计思路可言，看起来莫名其妙，读完之后一头雾水。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式(规范与重构)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（总结一）</title>
    <link href="/passages/design-pattern-learn-sum-2/"/>
    <url>/passages/design-pattern-learn-sum-2/</url>
    
    <content type="html"><![CDATA[<!-- more --><blockquote><p><a href="https://time.geekbang.org/column/article/193093" target="_blank" rel="noopener">原文地址</a></p></blockquote><h2 id="代码质量评判标准"><a href="#代码质量评判标准" class="headerlink" title="代码质量评判标准"></a>代码质量评判标准</h2><p><strong>如何评价代码质量的高低？</strong></p><p>代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、灵活、优雅、简洁。这些词汇是从不同的维度去评价代码质量的。它们之间有互相作用，并不是独立的，比如，代码的可读性好、可扩展性好就意味着代码的可维护性好。代码质量高低是一个综合各种因素得到的结论。我们并不能通过单一维度去评价一段代码的好坏。</p><p><strong>最常用的评价标准有哪几个？</strong></p><p>最常用到几个评判代码质量的标准有：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。其中，<strong>可维护性、可读性、可扩展性</strong>又是提到最多的、最重要的三个评价标准。</p><p><strong>如何才能写出高质量的代码？</strong></p><p>要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。</p><p><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2020/05/02/46102dd0-8c4c-11ea-a6fe-21fdf2c1cceb.png" srcset="/img/loading.gif" alt="image.png"></p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h3><p>现在主流的编程范式或者编程风格有三种，它们分别是<strong>面向过程、面向对象和函数式编程</strong>。面向对象这种编程风格又是这其中最主流的。现在比较流行的编程语言大部分都是面向对象编程语言。大部分项目也都是基于面向对象编程风格开发的。面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。</p><h3 id="面向对象四大特性"><a href="#面向对象四大特性" class="headerlink" title="面向对象四大特性"></a>面向对象四大特性</h3><p>封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方法来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 <code>Java</code> 中的 <code>private</code>、<code>protected</code>、<code>public</code> 关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。</p><p>如果说封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现。抽象存在的意义，一方面是修改实现不需要改变定义；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</p><p>继承用来表示类之间的 <code>is-a</code> 关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题。</p><p>多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、<code>duck-typing</code>。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。</p><h3 id="面向对象-VS-面向过程"><a href="#面向对象-VS-面向过程" class="headerlink" title="面向对象 VS 面向过程"></a>面向对象 VS 面向过程</h3><p>面向对象编程相比面向过程编程的优势主要有三个。</p><ul><li><p>对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。</p></li><li><p>面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。</p></li><li><p>从编程语言跟机器打交道方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。</p></li></ul><p>面向对象编程一般使用面向对象编程语言来进行，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。</p><p>面向对象和面向过程两种编程风格并不是非黑即白、完全对立的。在用面向对象编程语言开发的软件中，面向过程风格的代码并不少见，甚至在一些标准的开发库（比如 <code>JDK</code>、<code>Apache Commons</code>、<code>Google Guava</code>）中，也有很多面向过程风格的代码。</p><p>不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码。只要我们能避免面向过程编程风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用，我们就大可不用避讳在面向对象编程中写面向过程风格的代码。</p><h3 id="面向对象分析、设计与编程"><a href="#面向对象分析、设计与编程" class="headerlink" title="面向对象分析、设计与编程"></a>面向对象分析、设计与编程</h3><p>面向对象分析（<code>OOA</code>）、面向对象设计（<code>OOD</code>）、面向对象编程（<code>OOP</code>），是面向对象开发的三个主要环节。简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的的结果翻译成代码的过程。</p><p>需求分析的过程实际上是一个不断迭代优化的过程。我们不要试图一下就给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化。这样一个思考过程能让我们摆脱无从下手的窘境。</p><p>面向对象设计和实现要做的事情就是把合适的代码放到合适的类中。至于到底选择哪种划分方法，判定的标准是让代码尽量地满足“松耦合、高内聚”、单一职责、对扩展开放对修改关闭等我们之前讲到的各种设计原则和思想，尽量地做到代码可复用、易读、易扩展、易维护。</p><p>面向对象分析的产出是详细的需求描述。面向对象设计的产出是类。在面向对象设计这一环节中，我们将需求描述转化为具体的类的设计。这个环节的工作可以拆分为下面四个部分。</p><ul><li>划分职责进而识别出有哪些类</li></ul><p>根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。</p><ul><li>定义类及其属性和方法</li></ul><p>我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。</p><ul><li>定义类与类之间的交互关系</li></ul><p><code>UML</code> 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留了四个关系：泛化、实现、组合、依赖。</p><ul><li>将类组装起来并提供执行入口</li></ul><p>我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 <code>main()</code> 函数，也可能是一组给外部用的 <code>API</code> 接口。通过这个入口，我们能触发整个代码跑起来。</p><h3 id="接口-VS-抽象类"><a href="#接口-VS-抽象类" class="headerlink" title="接口 VS 抽象类"></a>接口 VS 抽象类</h3><p>抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。接口不能包含属性（<code>Java</code> 可以定义静态常量），只能声明方法，方法不能包含代码实现（<code>Java8</code> 以后可以有默认实现）。类实现接口的时候，必须实现接口中声明的所有方法。</p><p>抽象类是对成员变量和方法的抽象，是一种 <code>is-a</code> 关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种 <code>has-a</code> 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。</p><p>什么时候该用抽象类？什么时候该用接口？实际上，判断的标准很简单。如果要表示一种 <code>is-a</code> 的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示一种 <code>has-a</code> 关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。</p><h3 id="基于接口而非实现编程"><a href="#基于接口而非实现编程" class="headerlink" title="基于接口而非实现编程"></a>基于接口而非实现编程</h3><p>应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。</p><p>实际上，“基于接口而非实现编程”这条原则的另一个表述方式是，“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。</p><p>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。</p><h3 id="多用组合少用继承"><a href="#多用组合少用继承" class="headerlink" title="多用组合少用继承"></a>多用组合少用继承</h3><p><strong>为什么不推荐使用继承？</strong></p><p>继承是面向对象的四大特性之一，用来表示类之间的 <code>is-a</code> 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。</p><p><strong>组合相比继承有哪些优势？</strong></p><p>继承主要有三个作用：表示 <code>is-a</code> 关系、支持多态特性、代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。</p><p><strong>如何判断该用组合还是继承？</strong></p><p>尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。</p><h3 id="贫血模型-VS-充血模型"><a href="#贫血模型-VS-充血模型" class="headerlink" title="贫血模型 VS 充血模型"></a>贫血模型 VS 充血模型</h3><p>我们平时做 <code>Web</code> 项目的业务开发，大部分都是基于贫血模型的 <code>MVC</code> 三层架构，称为传统的开发模式。之所以称之为“传统”，是相对于新兴的基于充血模型的 <code>DDD</code> 开发模式来说的。基于贫血模型的传统开发模式，是典型的面向过程的编程风格。相反，基于充血模型的 <code>DDD</code> 开发模式，是典型的面向对象的编程风格。</p><p>不过，<code>DDD</code> 也并非银弹。对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用，基于充血模型的 <code>DDD</code> 开发模式有点大材小用，无法发挥作用。相反，对于业务复杂的系统开发来说，基于充血模型的 <code>DDD</code> 开发模式，因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，更加有优势。</p><p>基于充血模型的 <code>DDD</code> 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 <code>Service</code> 层。在基于充血模型的开发模式下，我们将部分原来在 <code>Service</code> 类中的业务逻辑移动到了一个充血的 <code>Domain</code> 领域模型中，让 <code>Service</code> 类的实现依赖这个 <code>Domain</code> 类。不过，<code>Service</code> 类并不会完全移除，而是负责一些不适合放在 <code>Domain</code> 类中的功能。比如，负责与 <code>Repository</code> 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作。</p><p>基于充血模型的 <code>DDD</code> 开发模式跟基于贫血模型的传统开发模式相比，<code>Controller</code> 层和 <code>Repository</code> 层的代码基本上相同。这是因为，<code>Repository</code> 层的 <code>Entity</code> 生命周期有限，<code>Controller</code> 层的 <code>VO</code> 只是单纯作为一种 <code>DTO</code>。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在 <code>Service</code> 层。所以，<code>Repository</code> 层和 <code>Controller</code> 层继续沿用贫血模型的设计思路是没有问题的。</p><p><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2020/05/02/5eb34cf0-8c51-11ea-a6fe-21fdf2c1cceb.png" srcset="/img/loading.gif" alt="image.png"></p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="SOLID-原则：SRP-单一职责原则"><a href="#SOLID-原则：SRP-单一职责原则" class="headerlink" title="SOLID 原则：SRP 单一职责原则"></a>SOLID 原则：SRP 单一职责原则</h3><p>一个类只负责完成一个职责或者功能。单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、松耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p><p>不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：</p><ul><li><p>类中的代码行数、函数或者属性过多；</p></li><li><p>类依赖的其他类过多或者依赖类的其他类过多；</p></li><li><p>私有方法过多；</p></li><li><p>比较难给类起一个合适的名字；</p></li><li><p>类中大量的方法都是集中操作类中的某几个属性。</p></li></ul><h3 id="SOLID-原则：OCP-开闭原则"><a href="#SOLID-原则：OCP-开闭原则" class="headerlink" title="SOLID 原则：OCP 开闭原则"></a>SOLID 原则：OCP 开闭原则</h3><p><strong>如何理解“对扩展开放、修改关闭”？</strong></p><p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。关于定义，我们有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。</p><p><strong>如何做到“对扩展开放、修改关闭”？</strong></p><p>我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。</p><p>很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 <code>23</code> 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。</p><h3 id="SOLID-原则：LSP-里式替换原则"><a href="#SOLID-原则：LSP-里式替换原则" class="headerlink" title="SOLID 原则：LSP 里式替换原则"></a>SOLID 原则：LSP 里式替换原则</h3><p>子类对象（<code>object of subtype/derived class</code>）能够替换程序（<code>program</code>）中父类对象（<code>object of base/parent class</code>）出现的任何地方，并且保证原来程序的逻辑行为（<code>behavior</code>）不变及正确性不被破坏。</p><p>里式替换原则是用来指导继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“<code>design by contract</code>，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数的原有“约定”。这里的“约定”包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。</p><p>理解这个原则，我们还要弄明白，里式替换原则跟多态的区别。虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</p><h3 id="SOLID-原则：ISP-接口隔离原则"><a href="#SOLID-原则：ISP-接口隔离原则" class="headerlink" title="SOLID 原则：ISP 接口隔离原则"></a>SOLID 原则：ISP 接口隔离原则</h3><p>接口隔离原则的描述是：客户端不应该强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。理解“接口隔离原则”的重点是理解其中的“接口”二字。这里有三种不同的理解。</p><p>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</p><p>如果把“接口”理解为单个 <code>API</code> 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</p><p>如果把“接口”理解为 <code>OOP</code> 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</p><p>单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考的角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p><h3 id="SOLID-原则：DIP-依赖倒置原则"><a href="#SOLID-原则：DIP-依赖倒置原则" class="headerlink" title="SOLID 原则：DIP 依赖倒置原则"></a>SOLID 原则：DIP 依赖倒置原则</h3><p><strong>控制反转</strong>：实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。</p><p><strong>依赖注入</strong>：依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 <code>new</code> 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或“注入”）给类来使用。</p><p><strong>依赖注入框架</strong>：我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</p><p><strong>依赖反转原则</strong>：依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不需要依赖具体实现细节，具体实现细节依赖抽象。</p><h3 id="KISS、YAGNI-原则"><a href="#KISS、YAGNI-原则" class="headerlink" title="KISS、YAGNI 原则"></a>KISS、YAGNI 原则</h3><p><code>KISS</code> 原则的中文描述是：尽量保持简单。<code>KISS</code> 原则是保持代码可读和可维护的重要手段。<code>KISS</code> 原则中的“简单“”并不是以代码行数来考量的。代码行数越少并不代表代码越简单，我们还要考虑逻辑复杂度、实现难度、代码的可读性等。而且，本身就复杂的问题，用复杂的方法解决，也并不违背 <code>KISS</code> 原则。除此之外，同样的代码，在某个业务场景下满足 <code>KISS</code> 原则，换一个应用场景可能就不满足了。</p><p>对于如何写出满足 KISS 原则的代码，有下面几条指导原则：</p><ul><li><p>不要使用同事可能不懂的技术来实现代码；</p></li><li><p>不要重复造轮子，善于使用已经有的工具类库；</p></li><li><p>不要过度优化。</p></li></ul><p><code>YAGNI</code> 原则的英文全称是：<code>You Ain’t Gonna Need It</code>。直译就是：你不会需要它。这条原则也算是万金油了。当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。</p><p><code>YAGNI</code> 原则跟 <code>KISS</code> 原则并非一回事儿。<code>KISS</code> 原则讲的是“如何做”的问题（尽量保持简单），而 <code>YAGNI</code> 原则说的是“要不要做”的问题（当前不需要的就不要做）。</p><h3 id="DRY-原则"><a href="#DRY-原则" class="headerlink" title="DRY 原则"></a>DRY 原则</h3><p><code>DRY</code> 原则中文描述是：不要重复自己，将它应用在编程中，可以理解为：不要写重复的代码。</p><p>三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复。实现逻辑重复，但功能语义不重复的代码，并不违反 <code>DRY</code> 原则。实现逻辑不重复，但功能语义重复的代码，也算是违反 <code>DRY</code> 原则。而代码执行重复也算是违反 <code>DRY</code> 原则。</p><p>除此之外，还有提高代码复用性的一些手段，包括：减少代码耦合、满足单一职责原则、模块化、业务与非业务逻辑分离、通用代码下沉、继承、多态、抽象、封装、应用模板等设计模式。复用意识也非常重要。在设计每个模块、类、函数的时候，要像设计一个外部 <code>API</code> 一样去思考它的复用性。</p><p>我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。</p><p>相比于代码的可复用性，<code>DRY</code> 原则适用性更强些。我们可以不写可复用的代码，但一定不能写重复的代码。</p><h3 id="LOD-原则"><a href="#LOD-原则" class="headerlink" title="LOD 原则"></a>LOD 原则</h3><p><strong>如何理解“高内聚、松耦合”？</strong></p><p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓“松耦合”指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</p><p><strong>如何理解“迪米特法则”？</strong></p><p>迪米特法则的描述为：不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</p><p><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2020/05/02/0f757980-8c54-11ea-a6fe-21fdf2c1cceb.png" srcset="/img/loading.gif" alt="image.png"></p><h2 id="规范与重构"><a href="#规范与重构" class="headerlink" title="规范与重构"></a>规范与重构</h2><h3 id="重构概述"><a href="#重构概述" class="headerlink" title="重构概述"></a>重构概述</h3><p><strong>重构的目的：为什么重构（why）？</strong></p><p>对于项目来言，重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步。对于个人而言，重构非常锻炼一个人的代码能力，并且是一件非常有成就感的事情。它是我们学习的经典设计思想、原则、模式、编程规范等理论知识的练兵场。</p><p><strong>重构的对象：重构什么（what）？</strong></p><p>按照重构的规模，我们可以将重构大致分为大规模高层次的重构和小规模低层次的重构。大规模高层次重构包括对代码分层、模块化、解耦、梳理类之间的交互关系、抽象复用组件等等。这部分工作利用的更多的是比较抽象、比较顶层的设计思想、原则、模式。小规模低层次的重构包括规范命名、注释、修正函数参数过多、消除超大类、提取重复代码等编程细节问题，主要是针对类、函数级别的重构。</p><p><strong>重构的方法：如何重构（how）？</strong></p><p>大规模高层次的重构难度比较大，需要有组织、有计划地进行，分阶段地小步快跑，时刻保持代码处于一个可运行的状态。而小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时随地都可以去做。</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p><strong>什么是单元测试？</strong></p><p>单元测试是代码层面的测试，用于测试“自己”编写的代码的逻辑正确性。单元测试顾名思义是测试一个“单元”，这个“单元”一般是类或函数，而不是模块或者系统。</p><p><strong>为什么要写单元测试？</strong></p><p>单元测试能有效地发现代码中的 <code>Bug</code>、代码设计上的问题。写单元测试的过程本身就是代码重构的过程。单元测试是对集成测试的有力补充，能帮助我们快速熟悉代码，是 <code>TDD</code> 可落地执行的折中方案。</p><p><strong>如何编写单元测试？</strong></p><p>写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将其翻译成代码的过程。我们可以利用一些测试框架来简化测试代码的编写。对于单元测试，我们需要建立以下正确的认知：</p><ul><li><p>编写单元测试尽管繁琐，但并不是太耗时；</p></li><li><p>我们可以稍微放低单元测试的质量要求；</p></li><li><p>覆盖率作为衡量单元测试好坏的唯一标准是不合理的；</p></li><li><p>写单元测试一般不需要了解代码的实现逻辑；</p></li><li><p>单元测试框架无法测试多半是代码的可测试性不好。</p></li></ul><p><strong>单元测试为何难落地执行？</strong></p><p>一方面，写单元测试本身比较繁琐，技术挑战不大，很多程序员不愿意去写。另一方面，国内研发比较偏向“快糙猛”，容易因为开发进度紧，导致单元测试的执行虎头蛇尾，最后，没有建立对单元测试的正确认识，觉得可有可无，单靠督促很难执行得很好。</p><h3 id="代码的可测试性"><a href="#代码的可测试性" class="headerlink" title="代码的可测试性"></a>代码的可测试性</h3><p><strong>什么是代码的可测试性？</strong></p><p>粗略地讲，所谓代码的可测试性，就是针对代码编写单元测试的难易程度。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很费劲，需要依靠单元测试框架很高级的特性，那往往就意味着代码设计得不够合理，代码的可测试性不好。</p><p><strong>编写可测试性代码的最有效手段</strong></p><p>依赖注入是编写可测试性代码的最有效手段。通过依赖注入，我们在编写单元测试代码的时候，可以通过 <code>mock</code> 的方法将不可控的依赖变得可控，这也是我们在编写单元测试的过程中最有技术挑战的地方。除了 <code>mock</code> 方式，我们还可以利用二次封装来解决某些代码行为不可控的情况。</p><p><strong>常见的 Anti-Patterns</strong></p><p>典型的、常见的测试不友好的代码有下面这 <code>5</code> 种：</p><ul><li><p>代码中包含未决行为逻辑；</p></li><li><p>滥用可变全局变量；</p></li><li><p>滥用静态方法；</p></li><li><p>使用复杂的继承关系；</p></li><li><p>高度耦合的代码。</p></li></ul><h3 id="大型重构：解耦"><a href="#大型重构：解耦" class="headerlink" title="大型重构：解耦"></a>大型重构：解耦</h3><p><strong>“解耦”为何如此重要？</strong></p><p>过于复杂的代码往往在可读性、可维护性上都不友好。解耦，保证代码松耦合、高内聚，是控制代码复杂度的有效手段。如果代码高内聚、松耦合，也就是意味着，代码结构清晰、分层、模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。</p><p><strong>代码是否需要“解耦”？</strong></p><p>间接的衡量标准有很多，比如：改动一个模块或类的代码受影响的模块或类是否有很多、改动一个模块或者类的代码依赖的模块或者类是否需要改动、代码的可测试性是否好等等。直接的衡量标准是把模块与模块之间及其类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。</p><p><strong>如何给代码“解耦”？</strong></p><p>给代码解耦的方法有：封装与抽象、中间层、模块化，以及一些其他的设计思想与原则，比如：单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则。当然，还有一些设计模式，比如观察者模式。</p><h3 id="小型重构：编码规范"><a href="#小型重构：编码规范" class="headerlink" title="小型重构：编码规范"></a>小型重构：编码规范</h3><p>上面这些知识的合理应用非常依赖个人经验，有时候用不好会适得其反。但是编码规范正好相反，大部分都简单明了，在代码的细节方面，能立竿见影地改善质量。除此之外，我们前面也讲到，持续低层次小规模重构依赖的基本上都是这些编码规范，也是改善代码可读性的有效手段。</p><p>总结罗列了 <code>20</code> 条我认为最应该关注、最好用的编码规范，分为三个大的方面：命名与注释（<code>Naming and Comments</code>）、代码风格（<code>Code Style</code>）、编程技巧（<code>Coding Tips</code>）。</p><p><strong>命名与注释</strong></p><ul><li><p>命名的关键是能准确的达意。对于不同作用域的命名，我们可以适当的选择不同的长度，作用域小的命名，比如临时变量等，可以适当的选择短一些的命名方式。除此之外，命名中个也可以使用一些耳熟能详的缩写。</p></li><li><p>我们借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。</p></li><li><p>命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名。除此之外，命名要符合项目的统一规范，也不要用些反直觉的命名。</p></li><li><p>接口有两种命名方式。一种是在接口中带前缀”<code>I</code>“，另一种是在接口的实现类中带后缀“<code>Impl</code>”。两种命名方式都可以，关键是要在项目中统一。对于抽象类的命名，我们更倾向于带有前缀“<code>Abstract</code>”。</p></li><li><p>注释的目的就是让代码更容易看懂，只要符合这个要求，你就可以写。总结一下的话，注释主要包含这样三个方面的内容：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明“如何用”。</p></li><li><p>注释本身有一定的维护成本，所以并非越多越好。类和函数一定要写注释，而且要写的尽可能全面详细些，而函数内部的注释会相对少一些，一般都是靠好的命名和提炼函数、解释性变量、总结性注释来做到代码易读。</p></li></ul><p><strong>代码风格</strong></p><p>代码风格都没有对错和优劣之分，不同的编程语言风格都不太一样，只要能在团队、项目中统一即可，不过，最好能跟业内推荐的风格、开源项目的代码风格相一致。所以，这里就不展开罗列了，你可以对照着自己熟悉的编程语言的代码风格，自己复习一下。</p><p><strong>编程技巧</strong></p><ul><li><p>将复杂的逻辑提炼拆分成函数和类；</p></li><li><p>通过拆分成多个函数的方式来处理参数过多的情况；</p></li><li><p>通过将参数封装为对象来处理参数过多的情况；</p></li><li><p>函数中不要使用参数来做代码执行逻辑的控制；</p></li><li><p>移除过深的嵌套层次，方法包括：去掉多余的 <code>if</code> 或 <code>else</code> 语句，使用 <code>continue</code>、<code>break</code>、<code>return</code> 关键字提前退出嵌套，调整执行顺序来减少嵌套，将部分嵌套逻辑抽象成函数；</p></li><li><p>用字面常量取代魔法数；</p></li><li><p>利用解释性变量来解释复杂表达式。</p></li></ul><p><strong>统一编码规范</strong></p><p>除了细节的知识点之外，最后，还有一条非常重要的，那就是，项目、团队，甚至公司，一定要制定统一的编码规范，并且通过 <code>Code Review</code> 督促执行，这对提高代码质量有立竿见影的效果。</p><p><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2020/05/02/63da2be0-8c56-11ea-a6fe-21fdf2c1cceb.png" srcset="/img/loading.gif" alt="image.png"></p><p>如果有帮助，欢迎你收藏这篇文章，并且把它分享给你的朋友。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式(规范与重构)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（二十八）</title>
    <link href="/passages/design-pattern-learn-28/"/>
    <url>/passages/design-pattern-learn-28/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>起代码风格，我们其实很难说哪种风格更好。最重要的，也是最需要我们做到的，是在团队、项目中保持风格统一，让代码像同一个人写出来的，整齐划一。这样能减少阅读干扰，提高代码的可读性。这才是我们在实际工作中想要实现的目标。</p><h2 id="类、函数多大才合适？"><a href="#类、函数多大才合适？" class="headerlink" title="类、函数多大才合适？"></a>类、函数多大才合适？</h2><p>总体上来讲，类或函数的代码行数不能太多，但也不能太少。类或函数的代码行数太多，一个类上千行，一个函数几百行，逻辑过于繁杂，阅读代码的时候，很容易就会看了后面忘了前面。相反，类或函数的代码行数太少，在代码总量相同的情况下，被分割成的类和函数就会相应增多，调用关系就会变得更复杂，阅读某个代码逻辑的时候，需要频繁地在 <code>n</code> 多类或者 <code>n</code> 多函数之间跳来跳去，阅读体验也不好。</p><p>那一个类或函数有多少行代码才最合适呢？</p><p>对于函数代码行数的最大限制，网上有一种说法，那就是不要超过一个显示屏的垂直高度。因为超过一屏之后，在阅读代码的时候，为了串联前后的代码逻辑，就可能需要频繁地上下滚动屏幕，阅读体验不好不说，还容易出错。</p><p>对于类的代码行数的最大限制，这个就更难给出一个确切的值了。当一个类的代码读起来让你感觉头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数过多了。</p><h2 id="一行代码多长最合适？"><a href="#一行代码多长最合适？" class="headerlink" title="一行代码多长最合适？"></a>一行代码多长最合适？</h2><p>在<code>Google Java Style Guide</code>文档中，一行代码最长限制为 <code>100</code> 个字符。不过，不同的编程语言、不同的规范、不同的项目团队，对此的限制可能都不相同。不管这个限制是多少，总体上来讲我们要遵循的一个原则是：一行代码最长不能超过 <code>IDE</code> 显示的宽度。需要滚动鼠标才能查看一行的全部代码，显然不利于代码的阅读。当然，这个限制也不能太小，太小会导致很多稍长点的语句被折成两行，也会影响到代码的整洁，不利于阅读。</p><h2 id="善用空行分割单元块"><a href="#善用空行分割单元块" class="headerlink" title="善用空行分割单元块"></a>善用空行分割单元块</h2><p>对于比较长的函数，如果逻辑上可以分为几个独立的代码块，在不方便将这些独立的代码块抽取成小函数的情况下，为了让逻辑更加清晰，除了上一节课中提到的用总结性注释的方法之外，我们还可以使用空行来分割各个代码块。</p><p>除此之外，在类的成员变量与函数之间、静态成员变量与普通成员变量之间、各函数之间、甚至各成员变量之间，我们都可以通过添加空行的方式，让这些不同模块的代码之间，界限更加明确。写代码就类似写文章，善于应用空行，可以让代码的整体结构看起来更加有清晰、有条理。</p><h2 id="四格缩进还是两格缩进？"><a href="#四格缩进还是两格缩进？" class="headerlink" title="四格缩进还是两格缩进？"></a>四格缩进还是两格缩进？</h2><p>“<code>PHP</code> 是世界上最好的编程语言？代码换行应该四格缩进还是两格缩进？”这应该是程序员争论得最多的两个话题了。据我所知，<code>Java</code> 语言倾向于两格缩进，<code>PHP</code> 语言倾向于四格缩进。至于到底应该是两格缩进还是四格缩进，这个取决于个人喜好。只要项目内部能够统一就行了。</p><p>当然，还有一个选择的标准，那就是跟业内推荐的风格统一、跟著名开源项目统一。当我们需要拷贝一些开源的代码到项目里的时候，能够让引入的代码跟我们项目本身的代码，保持风格统一。</p><p>不过，比较推荐使用两格缩进，这样可以节省空间。特别是在代码嵌套层次比较深的情况下，累计缩进较多的话，容易导致一个语句被折成两行，影响代码可读性。</p><h2 id="大括号是否要另起一行？"><a href="#大括号是否要另起一行？" class="headerlink" title="大括号是否要另起一行？"></a>大括号是否要另起一行？</h2><p>左大括号是否要另起一行呢？这个也有争论。据我所知，PHP 程序员喜欢另起一行，Java 程序员喜欢跟上一条语句放到一起。具体代码示例如下所示：</p><pre><code class="hljs plain">&#x2F;&#x2F; PHPclass ClassName&#123;    public function foo()    &#123;        &#x2F;&#x2F; method body    &#125;&#125;&#x2F;&#x2F; Javapublic class ClassName &#123;  public void foo() &#123;    &#x2F;&#x2F; method body  &#125;&#125;</code></pre><p>比较推荐，将括号放到跟语句同一行的风格。理由跟上面类似，节省代码行数。但是将大括号另起新的一行的方式，也有它的优势。这样的话，左右括号可以垂直对齐，哪些代码属于哪一个代码块，更一目了然。</p><p>不过，还是那句话，大括号跟上一条语句在同一行，还是另起新的一行，只要团队统一、业内统一、跟开源项目看齐就好了，没有绝对的优劣之分。</p><h2 id="类中成员的排列顺序"><a href="#类中成员的排列顺序" class="headerlink" title="类中成员的排列顺序"></a>类中成员的排列顺序</h2><p>在 <code>Java</code> 类文件中，先要书写类所属的包名，然后再罗列 <code>import</code> 引入的依赖类。在 <code>Google</code> 编码规范中，依赖类按照字母序从小到大排列。</p><p>在类中，成员变量排在函数的前面。成员变量之间或函数之间，都是按照“先静态（静态函数或静态成员变量）、后普通（非静态函数或非静态成员变量）”的方式来排列的。除此之外，成员变量之间或函数之间，还会按照作用域范围从大到小的顺序来排列，先写 <code>public</code> 成员变量或函数，然后是 <code>protected</code> 的，最后是 <code>private</code> 的。</p><p>不过，不同的编程语言中，类内部成员的排列顺序可能会有比较大的差别。比如 <code>C++</code> 中，成员变量会习惯性放到函数后面。除此之外，函数之间的排列顺序，会按照刚刚我们提到的作用域的大小来排列。实际上，还有另外一种排列习惯，那就是把有调用关系的函数放到一块。比如，一个 <code>public</code> 函数调用了另外一个 <code>private</code> 函数，那就把这两者放到一块。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p><strong>1. 函数、类多大才合适？</strong></p><p>函数的代码行数不要超过一屏幕的大小，比如 <code>50</code> 行。类的大小限制比较难确定。</p><p><strong>2. 一行代码多长最合适？</strong></p><p>最好不要超过 <code>IDE</code> 显示的宽度。当然，限制也不能太小，太小会导致很多稍微长点的语句被折成两行，也会影响到代码的整洁，不利于阅读。</p><p><strong>3. 善用空行分割单元块</strong></p><p>对于比较长的函数，为了让逻辑更加清晰，可以使用空行来分割各个代码块。在类内部，成员变量与函数之间、静态成员变量与普通成员变量之间、函数之间，甚至成员变量之间，都可以通过添加空行的方式，让不同模块的代码之间的界限更加明确。</p><p><strong>4. 四格缩进还是两格缩进？</strong></p><p>比较推荐使用两格缩进，这样可以节省空间，特别是在代码嵌套层次比较深的情况下。</p><p><strong>5. 大括号是否要另起一行？</strong></p><p>比较推荐将大括号放到跟上一条语句同一行的风格，这样可以节省代码行数。但是，将大括号另起一行，也有它的优势，那就是，左右括号可以垂直对齐，哪些代码属于哪一个代码块，更加一目了然。</p><p><strong>6. 类中成员的排列顺序</strong></p><p>在 <code>Google Java</code> 编程规范中，依赖类按照字母序从小到大排列。类中先写成员变量后写函数。成员变量之间或函数之间，先写静态成员变量或函数，后写普通变量或函数，并且按照作用域大小依次排列。</p><p>所有的代码风格都没有对错和优劣之分，只要能在团队、项目中统一即可，不过，最好能跟业内推荐的风格、开源项目的代码风格相一致。</p><p>参考：<a href="https://time.geekbang.org/column/article/188857" target="_blank" rel="noopener">理论五：让你最快速地改善代码质量的20条编程规范（中）</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(规范与重构)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（二十七）</title>
    <link href="/passages/design-pattern-learn-27/"/>
    <url>/passages/design-pattern-learn-27/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>编码规范大部分都简单明了，在代码细节方面，能立竿见影地改善质量。除此之外，持续低层次、小规模重构依赖的基本上都是编码规范，这也是改善代码可读性的有效手段。</p><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>大到项目名、模块名、包名、对外暴露的接口，小到类名、函数名、变量名、参数名，只要是做开发，我们就逃不过“起名字”这一关。命名的好坏，对于代码的可读性来说非常重要，甚至可以说是起决定性作用的。除此之外，命名能力也体现了一个程序员的基本编程素养。</p><p>取一个特别合适的名字是一件非常有挑战的事情，即便是对母语是英语的程序员来说，也是如此。而对于我们这些英语非母语的程序员来说，想要起一个能准确达意的名字，更是难上加难了。</p><p><strong>1. 命名多长最合适？</strong></p><p>在足够表达其含义的情况下，命名当然是越短越好。但是，大部分情况下，短的命名都没有长的命名更能达意。所以，很多书籍或者文章都不推荐在命名时使用缩写。对于一些默认的、大家都比较熟知的词，比较推荐用缩写。这样一方面能让命名短一些，另一方面又不影响阅读理解，比如，<code>sec</code> 表示 <code>second</code>、<code>str</code> 表示 <code>string</code>、<code>num</code> 表示 <code>number</code>、<code>doc</code> 表示 <code>document</code>。除此之外，对于作用域比较小的变量，我们可以使用相对短的命名，比如一些函数内的临时变量。相反，对于类名这种作用域比较大的，我更推荐用长的命名方式。</p><p>总之，命名的一个原则就是以能准确达意为目标。不过，对于代码的编写者来说，自己对代码的逻辑很清楚，总感觉用什么样的命名都可以达意，实际上，对于不熟悉你代码的同事来讲，可能就不这么认为了。所以，命名的时候，我们一定要学会换位思考，假设自己不熟悉这块代码，从代码阅读者的角度去考量命名是否足够直观。</p><p><strong>2. 利用上下文简化命名</strong></p><p>先来看一个简单的例子。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;  <span class="hljs-keyword">private</span> String userName;  <span class="hljs-keyword">private</span> String userPassword;  <span class="hljs-keyword">private</span> String userAvatarUrl;  <span class="hljs-comment">//...</span>&#125;</code></pre><p>在 <code>User</code> 类这样一个上下文中，我们没有在成员变量的命名中重复添加“<code>user</code>”这样一个前缀单词，而是直接命名为 <code>name</code>、<code>password</code>、<code>avatarUrl</code>。在使用这些属性时候，我们能借助对象这样一个上下文，表意也足够明确。具体代码如下所示：</p><pre><code class="hljs java">User user = <span class="hljs-keyword">new</span> User();user.getName(); <span class="hljs-comment">// 借助user对象这个上下文</span></code></pre><p>除了类之外，函数参数也可以借助函数这个上下文来简化命名。</p><p><strong>3. 命名要可读、可搜索</strong></p><p>先解释一下，这里所说的“可读”，指的是不要用一些特别生僻、难发音的英文单词来命名。虽然我们并不排斥一些独特的命名方式，但起码得让大部分人看一眼就能知道怎么读。</p><p>我们在 <code>IDE</code> 中编写代码的时候，经常会用“关键词联想”的方法来自动补全和搜索。比如，键入某个对象“<code>.get</code>”，希望 <code>IDE</code> 返回这个对象的所有 <code>get</code> 开头的方法。再比如，通过在 <code>IDE</code> 搜索框中输入“<code>Array</code>”，搜索 <code>JDK</code> 中数组相关的类。所以，我们在命名的时候，最好能符合整个项目的命名习惯。大家都用“<code>selectXXX</code>”表示查询，你就不要用“<code>queryXXX</code>”；大家都用“<code>insertXXX</code>”表示插入一条数据，你就要不用“<code>addXXX</code>”，统一规约是很重要的，能减少很多不必要的麻烦。</p><p><strong>4. 如何命名接口和抽象类？</strong></p><p>对于接口的命名，一般有两种比较常见的方式。一种是加前缀“<code>I</code>”，表示一个 <code>Interface</code>。比如 <code>IUserService</code>，对应的实现类命名为 <code>UserService</code>。另一种是不加前缀，比如 <code>UserService</code>，对应的实现类加后缀“<code>Impl</code>”，比如 <code>UserServiceImpl</code>。</p><p>对于抽象类的命名，也有两种方式，一种是带上前缀“<code>Abstract</code>”，比如 <code>AbstractConfiguration</code>；另一种是不带前缀“<code>Abstract</code>”。实际上，对于接口和抽象类，选择哪种命名方式都是可以的，只要项目里能够统一就行。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>命名很重要，注释跟命名同等重要。很多书籍认为，好的命名完全可以替代注释。如果需要注释，那说明命名不够好，需要在命名上下功夫，而不是添加注释。实际上，个人觉得，这样的观点有点太过极端。命名再好，毕竟有长度限制，不可能足够详尽，而这个时候，注释就是一个很好的补充。</p><p><strong>1. 注释到底该写什么？</strong></p><p>注释的目的就是让代码更容易看懂。只要符合这个要求的内容，你就可以将它写到注释里。总结一下，注释的内容主要包含这样三个方面：做什么、为什么、怎么做。举一个例子具体解释一下。</p><pre><code class="hljs java"><span class="hljs-comment">/*** (what) Bean factory to create beans. * * (why) The class likes Spring IOC framework, but is more lightweight. ** (how) Create objects from different sources sequentially:* user specified object &gt; SPI &gt; configuration &gt; default object.*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeansFactory</span> </span>&#123;  <span class="hljs-comment">// ...</span>&#125;</code></pre><p>有些人认为，注释是要提供一些代码没有的额外信息，所以不要写“做什么、怎么做”，这两方面在代码中都可以体现出来，只需要写清楚“为什么”，表明代码的设计意图即可。个人不是特别认可这样的观点，理由主要有下面 <code>3</code> 点。</p><ul><li>注释比代码承载的信息更多</li></ul><p>命名的主要目的是解释“做什么”。比如，<code>void increaseWalletAvailableBalance(BigDecimal amount)</code> 表明这个函数用来增加钱包的可用余额，<code>boolean isValidatedPassword</code> 表明这个变量用来标识是否是合法密码。函数和变量如果命名得好，确实可以不用再在注释中解释它是做什么的。但是，对于类来说，包含的信息比较多，一个简单的命名就不够全面详尽了。这个时候，在注释中写明“做什么”就合情合理了。</p><ul><li>注释起到总结性作用、文档的作用</li></ul><p>代码之下无秘密。阅读代码可以明确地知道代码是“怎么做”的，也就是知道代码是如何实现的，那注释中是不是就不用写“怎么做”了？实际上也可以写。在注释中，关于具体的代码实现思路，我们可以写一些总结性的说明、特殊情况的说明。这样能够让阅读代码的人通过注释就能大概了解代码的实现思路，阅读起来就会更加容易。<br>实际上，对于有些比较复杂的类或者接口，我们可能还需要在注释中写清楚“如何用”，举一些简单的 <code>quick start</code> 的例子，让使用者在不阅读代码的情况下，快速地知道该如何使用。</p><ul><li>一些总结性注释能让代码结构更清晰</li></ul><p>对于逻辑比较复杂的代码或者比较长的函数，如果不好提炼、不好拆分成小的函数调用，那我们可以借助总结性的注释来让代码结构更清晰、更有条理。</p><p><strong>2. 注释是不是越多越好？</strong></p><p>注释太多和太少都有问题。太多，有可能意味着代码写得不够可读，需要写很多注释来补充。除此之外，注释太多也会对代码本身的阅读起到干扰。而且，后期的维护成本也比较高，有时候代码改了，注释忘了同步修改，就会让代码阅读者更加迷惑。当然，如果代码中一行注释都没有，那只能说明这个程序员很懒，要适当督促一下，让他注意添加一些必要的注释。</p><p>类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性。</p><h2 id="重点总结"><a href="#重点总结" class="headerlink" title="重点总结"></a>重点总结</h2><p><strong>1. 关于命名</strong></p><ul><li><p>命名的关键是能准确达意。对于不同作用域的命名，我们可以适当地选择不同的长度。作用域小的变量（比如临时变量），可以适当地选择短一些的命名方式。除此之外，命名中也可以使用一些耳熟能详的缩写。</p></li><li><p>我们可以借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。</p></li><li><p>命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名。除此之外，命名要符合项目的统一规范，不要用些反直觉的命名。</p></li><li><p>接口有两种命名方式：一种是在接口中带前缀“I”；另一种是在接口的实现类中带后缀“Impl”。对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，一种是不带前缀。这两种命名方式都可以，关键是要在项目中统一。</p></li></ul><p><strong>2. 关于注释</strong></p><ul><li><p>注释的目的就是让代码更容易看懂。只要符合这个要求的内容，你就可以将它写到注释里。总结一下，注释的内容主要包含这样三个方面：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明“如何用”。</p></li><li><p>注释本身有一定的维护成本，所以并非越多越好。类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码可读性。</p></li></ul><p>参考：<a href="https://time.geekbang.org/column/article/188622" target="_blank" rel="noopener">理论五：让你最快速地改善代码质量的20条编程规范（上）</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(规范与重构)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（二十六）</title>
    <link href="/passages/design-pattern-learn-26/"/>
    <url>/passages/design-pattern-learn-26/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>重构可以分为大规模高层重构（简称“大型重构”）和小规模低层次重构（简称“小型重构”）。大型重构是对系统、模块、代码结构、类之间关系等顶层代码设计进行的重构。对于大型重构来说，最有效的一个手段，那就是“解耦”。解耦的目的是实现代码高内聚、松耦合。</p><ul><li>“解耦”为何如此重要？</li><li>如何判定代码是否需要“解耦”？</li><li>如何给代码“解耦”？</li></ul><h2 id="“解耦”为何如此重要？"><a href="#“解耦”为何如此重要？" class="headerlink" title="“解耦”为何如此重要？"></a>“解耦”为何如此重要？</h2><p>软件设计与开发最重要的工作之一就是应对复杂性。人处理复杂性的能力是有限的。过于复杂的代码往往在可读性、可维护性上都不友好。那如何来控制代码的复杂性呢？手段有很多，最关键的就是解耦，保证代码松耦合、高内聚。如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段，那么利用解耦的方法对代码重构，就是保证代码不至于复杂到无法控制的有效手段。</p><p>不管是阅读代码还是修改代码，“高内聚、松耦合”的特性可以让我们聚焦在某一模块或类中，不需要了解太多其他模块或类的代码，让我们的焦点不至于过于发散，降低了阅读和修改代码的难度。而且，因为依赖关系简单，耦合小，修改代码不至于牵一发而动全身，代码改动比较集中，引入 <code>bug</code> 的风险也就减少了很多。同时，“高内聚、松耦合”的代码可测试性也更加好，容易 <code>mock</code> 或者很少需要 <code>mock</code> 外部依赖的模块或者类。</p><p>除此之外，代码“高内聚、松耦合”，也就意味着，代码结构清晰、分层和模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。即便某个具体的类或者模块设计得不怎么合理，代码质量不怎么高，影响的范围是非常有限的。我们可以聚焦于这个模块或者类，做相应的小型重构。而相对于代码结构的调整，这种改动范围比较集中的小型重构的难度就容易多了。</p><h2 id="代码是否需要“解耦”？"><a href="#代码是否需要“解耦”？" class="headerlink" title="代码是否需要“解耦”？"></a>代码是否需要“解耦”？</h2><p>该怎么判断代码的耦合程度呢？或者说，怎么判断代码是否符合“高内聚、松耦合”呢？再或者说，如何判断系统是否需要解耦重构呢？</p><p>间接的衡量标准有很多，前面我们讲到了一些，比如，看修改代码会不会牵一发而动全身。除此之外，还有一个直接的衡量标准，也是我在阅读源码的时候经常会用到的，那就是把模块与模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。</p><p>如果依赖关系复杂、混乱，那从代码结构上来讲，可读性和可维护性肯定不是太好，那我们就需要考虑是否可以通过解耦的方法，让依赖关系变得清晰、简单。当然，这种判断还是有比较强的主观色彩，但是可以作为一种参考和梳理依赖的手段，配合间接的衡量标准一块来使用。</p><h2 id="如何给代码“解耦”？"><a href="#如何给代码“解耦”？" class="headerlink" title="如何给代码“解耦”？"></a>如何给代码“解耦”？</h2><p><strong>1. 封装与抽象</strong></p><p>封装和抽象作为两个非常通用的设计思想，可以应用在很多设计场景中，比如系统、模块、<code>lib</code>、组件、接口、类等等的设计。封装和抽象可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口。</p><p>比如，<code>Unix</code> 系统提供的 <code>open()</code> 文件操作函数，我们用起来非常简单，但是底层实现却非常复杂，涉及权限控制、并发控制、物理存储等等。我们通过将其封装成一个抽象的 <code>open()</code> 函数，能够有效控制代码复杂性的蔓延，将复杂性封装在局部代码中。除此之外，因为 <code>open()</code> 函数基于抽象而非具体的实现来定义，所以我们在改动 <code>open()</code> 函数的底层实现的时候，并不需要改动依赖它的上层代码，也符合我们前面提到的“高内聚、松耦合”代码的评判标准。</p><p><strong>2. 中间层</strong></p><p>引入中间层能简化模块或类之间的依赖关系。在引入数据存储中间层之前，<code>A、B、C</code> 三个模块都要依赖内存一级缓存、<code>Redis</code> 二级缓存、<code>DB</code> 持久化存储三个模块。在引入中间层之后，三个模块只需要依赖数据存储一个模块即可。</p><p>除此之外，我们在进行重构的时候，引入中间层可以起到过渡的作用，能够让开发和重构同步进行，不互相干扰。比如，某个接口设计得有问题，我们需要修改它的定义，同时，所有调用这个接口的代码都要做相应的改动。如果新开发的代码也用到这个接口，那开发就跟重构冲突了。为了让重构能小步快跑，我们可以分下面四个阶段来完成接口的修改。</p><ul><li>第一阶段：引入一个中间层，包裹老的接口，提供新的接口定义。</li><li>第二阶段：新开发的代码依赖中间层提供的新接口。</li><li>第三阶段：将依赖老接口的代码改为调用新接口。</li><li>第四阶段：确保所有的代码都调用新接口之后，删除掉老的接口。</li></ul><p>这样，每个阶段的开发工作量都不会很大，都可以在很短的时间内完成。重构跟开发冲突的概率也变小了。</p><p><strong>3. 模块化</strong></p><p>模块化是构建复杂系统常用的手段。不仅在软件行业，在建筑、机械制造等行业，这个手段也非常有用。对于一个大型复杂系统来说，没有人能掌控所有的细节。之所以我们能搭建出如此复杂的系统，并且能维护得了，最主要的原因就是将系统划分成各个独立的模块，让不同的人负责不同的模块，这样即便在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转。</p><p>聚焦到代码层面。合理地划分模块能有效地解耦代码，提高代码的可读性和可维护性。所以，我们在开发代码的时候，一定要有模块化意识，将每个模块都当作一个独立的 <code>lib</code> 一样来开发，只提供封装了内部实现细节的接口给其他模块使用，这样可以减少不同模块之间的耦合度。</p><p>模块化的思想无处不在，像 <code>SOA</code>、微服务、<code>lib</code> 库、系统内模块划分，甚至是类、函数的设计，都体现了模块化思想。如果追本溯源，模块化思想更加本质的东西就是分而治之。</p><p><strong>4. 其他设计思想和原则</strong></p><p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。很多设计原则都以实现代码的“高内聚、松耦合”为目的。</p><ul><li>单一职责原则</li></ul><p>内聚性和耦合性并非独立的。高内聚会让代码更加松耦合，而实现高内聚的重要指导原则就是单一职责原则。模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就相应的降低了。</p><ul><li>基于接口而非实现编程</li></ul><p>基于接口而非实现编程能通过接口这样一个中间层，隔离变化和具体的实现。这样做的好处是，在有依赖关系的两个模块或类之间，一个模块或者类的改动，不会影响到另一个模块或类。实际上，这就相当于将一种强依赖关系（强耦合）解耦为了弱依赖关系（弱耦合）。</p><ul><li>依赖注入</li></ul><p>跟基于接口而非实现编程思想类似，依赖注入也是将代码之间的强耦合变为弱耦合。尽管依赖注入无法将本应该有依赖关系的两个类，解耦为没有依赖关系，但可以让耦合关系没那么紧密，容易做到插拔替换。</p><ul><li>多用组合少用继承</li></ul><p>继承是一种强依赖关系，父类与子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有的子类。相反，组合关系是一种弱依赖关系，这种关系更加灵活，所以，对于继承结构比较复杂的代码，利用组合来替换继承，也是一种解耦的有效手段。</p><ul><li>迪米特法则</li></ul><p>迪米特法则讲的是，不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。从定义上，我们明显可以看出，这条原则的目的就是为了实现代码的松耦合。</p><p>除了上面的这些设计思想和原则之外，还有一些设计模式也是为了解耦依赖，比如观察者模式。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p><strong>1.“解耦”为何如此重要？</strong></p><p>过于复杂的代码往往在可读性、可维护性上都不友好。解耦保证代码松耦合、高内聚，是控制代码复杂度的有效手段。代码高内聚、松耦合，也就是意味着，代码结构清晰、分层模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。</p><p><strong>2. 代码是否需要“解耦”？</strong></p><p>间接的衡量标准有很多，比如，看修改代码是否牵一发而动全身。直接的衡量标准是把模块与模块、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。</p><p><strong>3. 如何给代码“解耦”？</strong></p><p>给代码解耦的方法有：封装与抽象、中间层、模块化，以及一些其他的设计思想与原则，比如：单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则等。当然，还有一些设计模式，比如观察者模式。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>在我们平时的开发中，解耦的思想到处可见，比如，<code>Spring</code> 中的 <code>AOP</code> 能实现业务与非业务代码的解耦，<code>IOC</code> 能实现对象的构造和使用的解耦。除此之外，你还能想到哪些解耦的应用场景吗？欢迎在留言区写下你的思考和答案。</li></ul><p>参考：<a href="https://time.geekbang.org/column/article/187761" target="_blank" rel="noopener">理论四：如何通过封装、抽象、模块化、中间层等解耦代码？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(规范与重构)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（二十五）</title>
    <link href="/passages/design-pattern-learn-25/"/>
    <url>/passages/design-pattern-learn-25/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>写单元测试并不难，也不需要太多技巧，相反，写出可测试的代码反倒是件非常有挑战的事情。所以，下面就再来聊一聊代码的可测试性，主要包括这样几个问题：</p><ul><li>什么是代码的可测试性？</li><li>如何写出可测试的代码？</li><li>有哪些常见的不好测试的代码？</li></ul><h2 id="常见的-Anti-Patterns"><a href="#常见的-Anti-Patterns" class="headerlink" title="常见的 Anti-Patterns"></a>常见的 Anti-Patterns</h2><p><strong>1. 未决行为</strong></p><p>所谓的未决行为逻辑就是，代码的输出是随机或者说不确定的，比如，跟时间、随机数有关的代码。</p><p><strong>2. 全局变量</strong></p><p>全局变量是一种面向过程的编程风格，有种种弊端。实际上，滥用全局变量也让编写单元测试变得困难。举个例子来解释一下。</p><p><code>RangeLimiter</code> 表示一个 <code>[-5, 5]</code> 的区间，<code>position</code> 初始在 <code>0</code> 位置，<code>move()</code> 函数负责移动 <code>position</code>。其中，<code>position</code> 是一个静态全局变量。<code>RangeLimiterTest</code> 类是为其设计的单元测试，不过，这里面存在很大的问题。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RangeLimiter</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicInteger position = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_LIMIT = <span class="hljs-number">5</span>;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_LIMIT = -<span class="hljs-number">5</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">int</span> delta)</span> </span>&#123;    <span class="hljs-keyword">int</span> currentPos = position.addAndGet(delta);    <span class="hljs-keyword">boolean</span> betweenRange = (currentPos &lt;= MAX_LIMIT) &amp;&amp; (currentPos &gt;= MIN_LIMIT);    <span class="hljs-keyword">return</span> betweenRange;  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RangeLimiterTest</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testMove_betweenRange</span><span class="hljs-params">()</span> </span>&#123;    RangeLimiter rangeLimiter = <span class="hljs-keyword">new</span> RangeLimiter();    assertTrue(rangeLimiter.move(<span class="hljs-number">1</span>));    assertTrue(rangeLimiter.move(<span class="hljs-number">3</span>));    assertTrue(rangeLimiter.move(-<span class="hljs-number">5</span>));  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testMove_exceedRange</span><span class="hljs-params">()</span> </span>&#123;    RangeLimiter rangeLimiter = <span class="hljs-keyword">new</span> RangeLimiter();    assertFalse(rangeLimiter.move(<span class="hljs-number">6</span>));  &#125;&#125;</code></pre><p>上面的单元测试有可能会运行失败。假设单元测试框架顺序依次执行 <code>testMove_betweenRange()</code> 和 <code>testMove_exceedRange()</code> 两个测试用例。在第一个测试用例执行完成之后，<code>position</code> 的值变成了 -1；再执行第二个测试用例的时候，<code>position</code> 变成了 <code>5</code>，<code>move()</code> 函数返回 <code>true</code>，<code>assertFalse</code> 语句判定失败。所以，第二个测试用例运行失败。</p><p>当然，如果 <code>RangeLimiter</code> 类有暴露重设（<code>reset</code>）<code>position</code> 值的函数，我们可以在每次执行单元测试用例之前，把 <code>position</code> 重设为 <code>0</code>，这样就能解决刚刚的问题。</p><p>不过，每个单元测试框架执行单元测试用例的方式可能是不同的。有的是顺序执行，有的是并发执行。对于并发执行的情况，即便我们每次都把 <code>position</code> 重设为 <code>0</code>，也并不奏效。如果两个测试用例并发执行，第 <code>16、17、18、23</code> 这四行代码可能会交叉执行，影响到 <code>move()</code> 函数的执行结果。</p><p><strong>3. 静态方法</strong></p><p>前面我们也提到，静态方法跟全局变量一样，也是一种面向过程的编程思维。在代码中调用静态方法，有时候会导致代码不易测试。主要原因是静态方法也很难 <code>mock</code>。但是，这个要分情况来看。只有在这个静态方法执行耗时太长、依赖外部资源、逻辑复杂、行为未决等情况下，我们才需要在单元测试中 <code>mock</code> 这个静态方法。除此之外，如果只是类似 <code>Math.abs()</code> 这样的简单静态方法，并不会影响代码的可测试性，因为本身并不需要 <code>mock</code>。</p><p><strong>4. 复杂继承</strong></p><p>相比组合关系，继承关系的代码结构更加耦合、不灵活，更加不易扩展、不易维护。实际上，继承关系也更加难测试。这也印证了代码的可测试性跟代码质量的相关性。</p><p>如果父类需要 <code>mock</code> 某个依赖对象才能进行单元测试，那所有的子类、子类的子类……在编写单元测试的时候，都要 <code>mock</code> 这个依赖对象。对于层次很深（在继承关系类图中表现为纵向深度）、结构复杂（在继承关系类图中表现为横向广度）的继承关系，越底层的子类要 <code>mock</code> 的对象可能就会越多，这样就会导致，底层子类在写单元测试的时候，要一个一个 <code>mock</code> 很多依赖对象，而且还需要查看父类代码，去了解该如何 <code>mock</code> 这些依赖对象。</p><p>如果我们利用组合而非继承来组织类之间的关系，类之间的结构层次比较扁平，在编写单元测试的时候，只需要 <code>mock</code> 类所组合依赖的对象即可。</p><p><strong>5. 高耦合代码</strong></p><p>如果一个类职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合，那我们在编写单元测试的时候，可能需要 <code>mock</code> 这十几个依赖的对象。不管是从代码设计的角度来说，还是从编写单元测试的角度来说，这都是不合理的。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p><strong>1. 什么是代码的可测试性？</strong></p><p>粗略地讲，所谓代码的可测试性，就是针对代码编写单元测试的难易程度。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很费劲，需要依靠单元测试框架中很高级的特性，那往往就意味着代码设计得不够合理，代码的可测试性不好。</p><p><strong>2. 编写可测试性代码的最有效手段</strong></p><p>依赖注入是编写可测试性代码的最有效手段。通过依赖注入，我们在编写单元测试的时候，可以通过 <code>mock</code> 的方法解依赖外部服务，这也是我们在编写单元测试的过程中最有技术挑战的地方。</p><p><strong>3. 常见的 <code>Anti-Patterns</code></strong></p><p>常见的测试不友好的代码有下面这 <code>5</code> 种：</p><ul><li>代码中包含未决行为逻辑</li><li>滥用可变全局变量</li><li>滥用静态方法</li><li>使用复杂的继承关系</li><li>高度耦合的代码</li></ul><p>参考：<a href="https://time.geekbang.org/column/article/186691" target="_blank" rel="noopener">理论三：什么是代码的可测试性？如何写出可测试性好的代码？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(规范与重构)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（二十四）</title>
    <link href="/passages/design-pattern-learn-24/"/>
    <url>/passages/design-pattern-learn-24/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>如何保证重构不出错呢？你需要熟练掌握各种设计原则、思想、模式，还需要对所重构的业务和代码有足够的了解。除了这些个人能力因素之外，最可落地执行、最有效的保证重构不出错的手段应该就是<strong>单元测试</strong>（<code>Unit Testing</code>）了。当重构完成之后，如果新的代码仍然能通过单元测试，那就说明代码原有逻辑的正确性未被破坏，原有的外部可见行为未变，符合对重构的定义。</p><ul><li>什么是单元测试？</li><li>为什么要写单元测试？</li><li>如何编写单元测试？</li><li>如何在团队中推行单元测试？</li></ul><h2 id="什么是单元测试？"><a href="#什么是单元测试？" class="headerlink" title="什么是单元测试？"></a>什么是单元测试？</h2><p>单元测试由研发工程师自己来编写，用来测试自己写的代码的正确性。常常将它跟集成测试放到一块来对比。单元测试相对于集成测试（<code>Integration Testing</code>）来说，测试的粒度更小一些。集成测试的测试对象是整个系统或者某个功能模块，比如测试用户注册、登录功能是否正常，是一种端到端（<code>end to end</code>）的测试。而单元测试的测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行。这是代码层级的测试。</p><p>实际上，写单元测试本身不需要什么高深技术。它更多的是考验程序员思维的缜密程度，看能否设计出覆盖各种正常及异常情况的测试用例，来保证代码在任何预期或非预期的情况下都能正确运行。</p><h2 id="为什么要写单元测试？"><a href="#为什么要写单元测试？" class="headerlink" title="为什么要写单元测试？"></a>为什么要写单元测试？</h2><p>单元测试除了能有效地为重构保驾护航之外，也是保证代码质量最有效的两个手段之一（另一个是 <code>Code Review</code>）。</p><p><strong>1. 单元测试能有效地帮你发现代码中的 <code>bug</code></strong></p><p>能否写出 <code>bug free</code> 的代码，是判断工程师编码能力的重要标准之一，也是很多大厂面试考察的重点，特别是像 <code>FLAG</code> 这样的外企。</p><p><strong>2. 写单元测试能帮你发现代码设计上的问题</strong></p><p>代码的可测试性是评判代码质量的一个重要标准。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很吃力，需要依靠单元测试框架里很高级的特性才能完成，那往往就意味着代码设计得不够合理，比如，没有使用依赖注入、大量使用静态函数、全局变量、代码高度耦合等。</p><p><strong>3. 单元测试是对集成测试的有力补充</strong></p><p>程序运行的 bug 往往出现在一些边界条件、异常情况下，比如，除数未判空、网络超时。而大部分异常情况都比较难在测试环境中模拟。</p><p>除此之外，对于一些复杂系统来说，集成测试也无法覆盖得很全面。复杂系统往往有很多模块。每个模块都有各种输入、输出、异常情况，组合起来，整个系统就有无数测试场景需要模拟，无数的测试用例需要设计，再强大的测试团队也无法穷举完备。</p><p>尽管单元测试无法完全替代集成测试，但如果我们能保证每个类、每个函数都能按照我们的预期来执行，底层 <code>bug</code> 少了，那组装起来的整个系统，出问题的概率也就相应减少了。</p><p><strong>4. 写单元测试的过程本身就是代码重构的过程</strong></p><p>要把持续重构作为开发的一部分来执行，那么写单元测试实际上就是落地执行持续重构的一个有效途径。设计和实现代码的时候，我们很难把所有的问题都想清楚。而编写单元测试就相当于对代码的一次自我 <code>Code Review</code>，在这个过程中，我们可以发现一些设计上的问题（比如代码设计的不可测试）以及代码编写方面的问题（比如一些边界条件处理不当）等，然后针对性的进行重构。</p><p><strong>5. 阅读单元测试能帮助你快速熟悉代码</strong></p><p>阅读代码最有效的手段，就是先了解它的业务背景和设计思路，然后再去看代码，这样代码读起来就会轻松很多。但是大部分程序员都不怎么喜欢写文档和注释，而大部分程序员写的代码又很难做到“不言自明”。在没有文档和注释的情况下，单元测试就起了替代性作用。单元测试用例实际上就是用户用例，反映了代码的功能和如何使用。借助单元测试，我们不需要深入的阅读代码，便能知道代码实现了什么功能，有哪些特殊情况需要考虑，有哪些边界条件需要处理。</p><p><strong>6. 单元测试是 <code>TDD</code> 可落地执行的改进方案</strong></p><p>测试驱动开发（<code>Test-Driven Development</code>，简称 <code>TDD</code>）是一个经常被提及但很少被执行的开发模式。它的核心指导思想就是测试用例先于代码编写。不过，要让程序员能彻底地接受和习惯这种开发模式还是挺难的，毕竟很多程序员连单元测试都懒得写，更何况在编写代码之前先写好测试用例了。</p><p>单元测试正好是对 <code>TDD</code> 的一种改进方案，先写代码，紧接着写单元测试，最后根据单元测试反馈出来问题，再回过头去重构代码。这个开发流程更加容易被接受，更加容易落地执行，而且又兼顾了 <code>TDD</code> 的优点。</p><h2 id="如何编写单元测试？"><a href="#如何编写单元测试？" class="headerlink" title="如何编写单元测试？"></a>如何编写单元测试？</h2><p>写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将这些测试用例翻译成代码的过程。</p><p>在把测试用例翻译成代码的时候，我们可以利用单元测试框架，来简化测试代码的编写。比如，<code>Java</code> 中比较出名的单元测试框架有 <code>Junit、TestNG、Spring Test</code> 等。这些框架提供了通用的执行流程（比如执行测试用例的 <code>TestCaseRunner</code>）和工具类库（比如各种 <code>Assert</code> 判断函数）等。借助它们，我们在编写测试代码的时候，只需要关注测试用例本身的编写即可。</p><p><strong>1. 写单元测试真的是件很耗时的事情吗？</strong></p><p>尽管单元测试的代码量可能是被测代码本身的 <code>1～2</code> 倍，写的过程很繁琐，但并不是很耗时。毕竟我们不需要考虑太多代码设计上的问题，测试代码实现起来也比较简单。不同测试用例之间的代码差别可能并不是很大，简单 <code>copy-paste</code> 改改就行。</p><p><strong>2. 对单元测试的代码质量有什么要求吗？</strong></p><p>单元测试毕竟不会在产线上运行，而且每个类的测试代码也比较独立，基本不互相依赖。所以，相对于被测代码，我们对单元测试代码的质量可以放低一些要求。命名稍微有些不规范，代码稍微有些重复，也都是没有问题的。</p><p><strong>3. 单元测试只要覆盖率高就够了吗？</strong></p><p>单元测试覆盖率是比较容易量化的指标，常常作为单元测试写得好坏的评判标准。有很多现成的工具专门用来做覆盖率统计，比如，<code>JaCoCo、Cobertura、Emma、Clover</code>。覆盖率的计算方式有很多种，比较简单的是语句覆盖，稍微高级点的有：条件覆盖、判定覆盖、路径覆盖。</p><p>不管覆盖率的计算方式如何高级，将覆盖率作为衡量单元测试质量的唯一标准是不合理的。实际上，更重要的是要看测试用例是否覆盖了所有可能的情况，特别是一些 <code>corner case</code>。</p><p><strong>4. 写单元测试需要了解代码的实现逻辑吗？</strong></p><p>单元测试不要依赖被测试函数的具体实现逻辑，它只关心被测函数实现了什么功能。我们切不可为了追求覆盖率，逐行阅读代码，然后针对实现逻辑编写单元测试。否则，一旦对代码进行重构，在代码的外部行为不变的情况下，对代码的实现逻辑进行了修改，那原本的单元测试都会运行失败，也就起不到为重构保驾护航的作用了，也违背了我们写单元测试的初衷。</p><p><strong>5. 如何选择单元测试框架？</strong></p><p>写单元测试本身不需要太复杂的技术，大部分单元测试框架都能满足。在公司内部，起码团队内部需要统一单元测试框架。如果自己写的代码用已经选定的单元测试框架无法测试，那多半是代码写得不够好，代码的可测试性不够好。这个时候，我们要重构自己的代码，让其更容易测试，而不是去找另一个更加高级的单元测试框架。</p><h2 id="单元测试为何难落地执行？"><a href="#单元测试为何难落地执行？" class="headerlink" title="单元测试为何难落地执行？"></a>单元测试为何难落地执行？</h2><p>写单元测试确实是一件考验耐心的活儿。一般情况下，单元测试的代码量要大于被测试代码量，甚至是要多出好几倍。很多人往往会觉得写单元测试比较繁琐，并且没有太多挑战，而不愿意去做。有很多团队和项目在刚开始推行单元测试的时候，还比较认真，执行得比较好。但当开发任务紧了之后，就开始放低对单元测试的要求，一旦出现破窗效应，慢慢的，大家就都不写了，这种情况很常见。</p><p>还有一种情况就是，由于历史遗留问题，原来的代码都没有写单元测试，代码已经堆砌了十几万行了，不可能再一个一个去补单元测试。这种情况下，我们首先要保证新写的代码都要有单元测试，其次，每次在改动到某个类时，如果没有单元测试就顺便补上，不过这要求工程师们有足够强的主人翁意识（<code>ownership</code>），毕竟光靠 <code>leader</code> 督促，很多事情是很难执行到位的。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p><strong>1. 什么是单元测试？</strong></p><p>单元测试是代码层面的测试，由研发自己来编写，用于测试“自己”编写的代码的逻辑的正确性。单元测试顾名思义是测试一个“单元”，有别于集成测试，这个“单元”一般是类或函数，而不是模块或者系统。</p><p><strong>2. 为什么要写单元测试？</strong></p><p>写单元测试的过程本身就是代码 <code>Code Review</code> 和重构的过程，能有效地发现代码中的 <code>bug</code> 和代码设计上的问题。除此之外，单元测试还是对集成测试的有力补充，还能帮助我们快速熟悉代码，是 <code>TDD</code> 可落地执行的改进方案。</p><p><strong>3. 如何编写单元测试？</strong></p><p>写单元测试就是针对代码设计各种测试用例，以覆盖各种输入、异常、边界情况，并将其翻译成代码。我们可以利用一些测试框架来简化单元测试的编写。除此之外，对于单元测试，我们需要建立以下正确的认知：</p><ul><li>编写单元测试尽管繁琐，但并不是太耗时；</li><li>我们可以稍微放低对单元测试代码质量的要求；</li><li>覆盖率作为衡量单元测试质量的唯一标准是不合理的；</li><li>单元测试不要依赖被测代码的具体实现逻辑；</li><li>单元测试框架无法测试，多半是因为代码的可测试性不好。</li></ul><p><strong>4. 单元测试为何难落地执行？</strong></p><p>一方面，写单元测试本身比较繁琐，技术挑战不大，很多程序员不愿意去写；另一方面，国内研发比较偏向“快、糙、猛”，容易因为开发进度紧，导致单元测试的执行虎头蛇尾。最后，关键问题还是团队没有建立对单元测试正确的认识，觉得可有可无，单靠督促很难执行得很好。</p><p>参考：<a href="https://time.geekbang.org/column/article/185684" target="_blank" rel="noopener">理论二：为了保证重构不出错，有哪些非常能落地的技术手段？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(规范与重构)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（二十三）</title>
    <link href="/passages/design-pattern-learn-23/"/>
    <url>/passages/design-pattern-learn-23/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>“重构”这个词对于大部分工程师来说都不陌生。不过，大部分人都只是“听得多做得少”，真正进行过代码重构的人不多，而把持续重构作为开发的一部分的人，就更是少之又少了。</p><p>一方面，重构代码对一个工程师能力的要求，要比单纯写代码高得多。重构需要你能洞察出代码存在的坏味道或者设计上的不足，并且能合理、熟练地利用设计思想、原则、模式、编程规范等理论知识解决这些问题。</p><p>另一方面，很多工程师对为什么要重构、到底重构什么、什么时候重构、又该如何重构等相关问题理解不深，对重构没有系统性、全局性的认识，面对一堆烂代码，没有重构技巧的指导，只能想到哪改到哪，并不能全面地改善代码质量。</p><ul><li>重构的目的（<code>why</code>）、对象（<code>what</code>）、时机（<code>when</code>）、方法（<code>how</code>）</li></ul><h2 id="重构的目的：为什么要重构（why）？"><a href="#重构的目的：为什么要重构（why）？" class="headerlink" title="重构的目的：为什么要重构（why）？"></a>重构的目的：为什么要重构（why）？</h2><p>重构这个词可能不需要过多解释，但还是简单来看一下，大师是怎么描述它的。软件设计大师 <code>Martin Fowler</code> 是这样定义重构的：“<strong>重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。</strong>”</p><p>重构是时刻保证代码质量的一个极其有效的手段，不至于让代码腐化到无可救药的地步。项目在演进，代码不停地在堆砌。如果没有人为代码的质量负责任，代码总是会往越来越混乱的方向演进。当混乱到一定程度之后，量变引起质变，项目的维护成本已经高过重新开发一套新代码的成本，想要再去重构，已经没有人能做到了。</p><p>其次，优秀的代码或架构不是一开始就能完全设计好的，就像优秀的公司和产品也都是迭代出来的。我们无法 <code>100%</code> 预见未来的需求，也没有足够的精力、时间、资源为遥远的未来买单，所以，随着系统的演进，重构代码也是不可避免的。</p><p>最后，重构是避免过度设计的有效手段。在我们维护代码的过程中，真正遇到问题的时候，再对代码进行重构，能有效避免前期投入太多时间做过度的设计，做到有的放矢。</p><p>除此之外，重构对一个工程师本身技术的成长也有重要的意义。</p><p>重构实际上是对我们学习的经典设计思想、设计原则、设计模式、编程规范的一种应用。重构实际上就是将这些理论知识，应用到实践的一个很好的场景，能够锻炼我们熟练使用这些理论知识的能力。除此之外，平时堆砌业务逻辑，你可能总觉得没啥成长，而将一个比较烂的代码重构成一个比较好的代码，会让你很有成就感。</p><p>重构能力也是衡量一个工程师代码能力的有效手段。所谓“初级工程师在维护代码，高级工程师在设计代码，资深工程师在重构代码”，这句话的意思是说，初级工程师在已有代码框架下修改 <code>bug</code>、修改添加功能代码；高级工程师从零开始设计代码结构、搭建代码框架；而资深工程师为代码质量负责，需要发觉代码存在的问题，重构代码，时刻保证代码质量处于一个可控的状态。</p><h2 id="重构的对象：到底重构什么（what）？"><a href="#重构的对象：到底重构什么（what）？" class="headerlink" title="重构的对象：到底重构什么（what）？"></a>重构的对象：到底重构什么（what）？</h2><p>根据重构的规模，可以笼统地分为大规模高层次重构（以下简称为“大型重构”）和小规模低层次的重构（以下简称为“小型重构”）。</p><p>大型重构指的是对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等。这类重构的工具就是我们学习过的那些设计思想、原则和模式。这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时会比较长，引入 <code>bug</code> 的风险也会相对比较大。</p><p>小型重构指的是对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等等。小型重构更多的是利用我们能后面要讲到的编码规范。这类重构要修改的地方比较集中，比较简单，可操作性较强，耗时会比较短，引入 <code>bug</code> 的风险相对来说也会比较小。你只需要熟练掌握各种编码规范，就可以做到得心应手。</p><h2 id="重构的时机：什么时候重构（when）？"><a href="#重构的时机：什么时候重构（when）？" class="headerlink" title="重构的时机：什么时候重构（when）？"></a>重构的时机：什么时候重构（when）？</h2><p>什么时候重构？是代码烂到一定程度之后才去重构吗？当然不是。因为当代码真的烂到出现“开发效率低，招了很多人，天天加班，出活却不多，线上 <code>bug</code> 频发，领导发飙，中层束手无策，工程师抱怨不断，查找 <code>bug</code> 困难”的时候，基本上重构也无法解决问题了。</p><p>提倡的重构策略是<strong>持续重构</strong>。平时没有事情的时候，你可以看看项目中有哪些写得不够好的、可以优化的代码，主动去重构一下。或者，在修改、添加某个功能代码的时候，你也可以顺手把不符合编码规范、不好的设计重构一下。总之，就像把单元测试、<code>Code Review</code> 作为开发的一部分，我们如果能把持续重构也作为开发的一部分，成为一种开发习惯，对项目、对自己都会很有好处。</p><p>尽管我们说重构能力很重要，但持续重构意识更重要。我们要正确地看待代码质量和重构这件事情。技术在更新、需求在变化、人员在流动，代码质量总会在下降，代码总会存在不完美，重构就会持续在进行。时刻具有持续重构意识，才能避免开发初期就过度设计，避免代码维护的过程中质量的下降。而那些看到别人代码有点瑕疵就一顿乱骂，或者花尽心思去构思一个完美设计的人，往往都是因为没有树立正确的代码质量观，没有持续重构意识。</p><h2 id="重构的方法：又该如何重构（how）？"><a href="#重构的方法：又该如何重构（how）？" class="headerlink" title="重构的方法：又该如何重构（how）？"></a>重构的方法：又该如何重构（how）？</h2><p>按照重构的规模，重构可以笼统地分为大型重构和小型重构。对于这两种不同规模的重构，我们要区别对待。</p><p>对于大型重构来说，因为涉及的模块、代码会比较多，如果项目代码质量又比较差，耦合比较严重，往往会牵一发而动全身，本来觉得一天就能完成的重构，你会发现越改越多、越改越乱，没一两个礼拜都搞不定。而新的业务开发又与重构相冲突，最后只能半途而废，<code>revert</code> 掉所有的改动，很失落地又去堆砌烂代码了。</p><p>在进行大型重构的时候，我们要提前做好完善的重构计划，有条不紊地分阶段来进行。每个阶段完成一小部分代码的重构，然后提交、测试、运行，发现没有问题之后，再继续进行下一阶段的重构，保证代码仓库中的代码一直处于可运行、逻辑正确的状态。每个阶段，我们都要控制好重构影响到的代码范围，考虑好如何兼容老的代码逻辑，必要的时候还需要写一些兼容过渡代码。只有这样，我们才能让每一阶段的重构都不至于耗时太长（最好一天就能完成），不至于与新的功能开发相冲突。</p><p>对于重构这件事情，资深的工程师、项目 <code>leader</code> 要负起责任来，没事就重构一下代码，时刻保证代码质量处在一个良好的状态。否则，一旦出现“破窗效应”，一个人往里堆了一些烂代码，之后就会有更多的人往里堆更烂的代码。毕竟往项目里堆砌烂代码的成本太低了。不过，保持代码质量最好的方法还是打造一种好的技术氛围，以此来驱动大家主动去关注代码质量，持续重构代码。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p><strong>建立持续重构意识可能比教一些重构技巧更重要，因为很多技术问题本身就不是单纯靠技术来解决的，更重要的是要有这种认知和意识。</strong></p><p><strong>1. 重构的目的：为什么重构（<code>why</code>）？</strong></p><p>对于项目来言，重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步。对于个人而言，重构非常锻炼一个人的代码能力，并且是一件非常有成就感的事情。它是我们学习的经典设计思想、原则、模式、编程规范等理论知识的练兵场。</p><p><strong>2. 重构的对象：重构什么（<code>what</code>）？</strong></p><p>按照重构的规模，我们可以将重构大致分为大规模高层次的重构和小规模低层次的重构。大规模高层次重构包括对代码分层、模块化、解耦、梳理类之间的交互关系、抽象复用组件等等。这部分工作利用的更多的是比较抽象、比较顶层的设计思想、原则、模式。小规模低层次的重构包括规范命名、注释、修正函数参数过多、消除超大类、提取重复代码等等编程细节问题，主要是针对类、函数级别的重构。小规模低层次的重构更多的是利用编码规范这一理论知识。</p><p><strong>3. 重构的时机：什么时候重构（<code>when</code>）？</strong></p><p>一定要建立持续重构意识，把重构作为开发必不可少的部分，融入到日常开发中，而不是等到代码出现很大问题的时候，再大刀阔斧地重构。</p><p><strong>4. 重构的方法：如何重构（<code>how</code>）？</strong></p><p>大规模高层次的重构难度比较大，需要组织、有计划地进行，分阶段地小步快跑，时刻让代码处于一个可运行的状态。而小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时随地都可以去做。</p><p>参考：<a href="https://time.geekbang.org/column/article/179679" target="_blank" rel="noopener">理论一：什么情况下要重构？到底重构什么？又该如何重构？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(规范与重构)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>针对非业务的通用框架开发，如何做需求分析和设计？</title>
    <link href="/passages/design-pattern-learn-sum-1/"/>
    <url>/passages/design-pattern-learn-sum-1/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><p>对于非业务通用框架的开发，我们在做需求分析的时候，除了功能性需求分析之外，还需要考虑框架的非功能性需求。比如，框架的易用性、性能、扩展性、容错性、通用性等。</p><p>对于复杂框架的设计，很多人往往觉得无从下手。有几个小技巧，其中包括：画产品线框图、聚焦简单应用场景、设计实现最小原型、画系统设计图等。这些方法的目的都是为了让问题简化、具体、明确，提供一个迭代设计开发的基础，逐步推进。</p><p>实际上，不仅仅是软件设计开发，不管做任何事情，如果我们总是等到所有的东西都想好了再开始，那这件事情可能永远都开始不了。有句老话讲：万事开头难，所以，先迈出第一步很重要。</p><p>写代码的过程本就是一个修修改改、不停调整的过程，肯定不是一气呵成的。那些大牛开源项目的设计和实现，也都是在不停优化、修改过程中产生的。比如，我们熟悉的 <code>Unix</code> 系统，第一版很简单、粗糙，代码不到 <code>1</code> 万行。所以，迭代思维很重要，不要刚开始就追求完美。</p><p>面向对象设计和实现要做的事情，就是把合适的代码放到合适的类中。至于到底选择哪种划分方法，判定的标准是让代码尽量地满足低耦合、高内聚、单一职责、对扩展开放对修改关闭等之前讲的各种设计原则和思想，尽量地做到代码可复用、易读、易扩展、易维护。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式(设计原则)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>由浅入深了解GC原理</title>
    <link href="/passages/java-gc/"/>
    <url>/passages/java-gc/</url>
    
    <content type="html"><![CDATA[<!-- more --><p><code>GC</code>（<code>Garbage Collection</code>)很大程度上帮助<code>Java</code>程序员解决了内存释放的问题，有了<code>GC</code>，就不需要再手动的去控制内存的释放。</p><p>在阅读之前需要了解的相关概念：</p><blockquote><p><code>Java</code> 堆内存分为新生代和老年代，新生代中又分为<code>1</code>个 <code>Eden</code> 区域 和 <code>2</code> 个 <code>Survivor</code> 区域。</p></blockquote><h2 id="一、什么是GC（Garbage-Collection"><a href="#一、什么是GC（Garbage-Collection" class="headerlink" title="一、什么是GC（Garbage Collection)"></a>一、什么是GC（Garbage Collection)</h2><p><code>GC</code>垃圾收集，<code>Java</code>提供的<code>GC</code>可以自动监测对象是否超过作用域从而达到自动回收内存的目的。</p><p>每个程序员都遇到过内存溢出的情况，程序运行时，内存空间是有限的，那么如何及时的把不再使用的对象清除将内存释放出来，这就是GC要做的事。</p><p><strong>需要<code>GC</code>的内存区域</strong></p><p><code>JVM</code> 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 <code>JAVA</code> 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的。</p><blockquote><p>注意：<br>对于 <code>Java8</code>，<code>HotSpots</code> 取消了永久代，那么是不是也就没有方法区了呢？当然不是，方法区是一个规范，规范没变，它就一直在。那么取代永久代的就是元空间。它可永久代有什么不同的？存储位置不同，永久代物理是是堆的一部分，和新生代，老年代地址是连续的，而元空间属于本地内存；存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中。</p></blockquote><p><strong><code>GC</code>的对象</strong></p><p>当一个对象到<code>GC Roots</code>不可达时，在下一个垃圾回收周期中尝试回收该对象，如果对象重写了<code>finalize()</code>，并在这个方法中成功自救(将自身赋予某个引用)，那么这个对象不会被回收。但如果这个对象没有重写<code>finalize()</code>方法或已执行过这个方法，该对象将会被回收。</p><p>需要进行回收的对象就是已经没有存活的对象，判断一个对象是否存活常用的有两种办法：引用计数算法和可达性分析算法。</p><ul><li><p>引用计数算法：<br>每个对象有一个引用计数属性，新增一个引用时计数加<code>1</code>，引用释放时计数减<code>1</code>，计数为<code>0</code>时可以回收。此方法简单，无法解决对象相互循环引用的问题。</p></li><li><p>可达性分析算法（Reachability Analysis）：<br>从<code>GC Roots</code>开始向下搜索，搜索所走过的路径称为引用链。当一个对象到<code>GC Roots</code>没有任何引用链相连时，则证明此对象是不可用的，不可达对象。</p></li></ul><blockquote><p>在Java语言中，<code>GC Roots</code>包括：</p><ul><li>虚拟机栈中引用的对象；</li><li>方法区中类静态属性实体引用的对象；</li><li>方法区中常量引用的对象；</li><li>本地方法栈中<code>JNI</code>引用的对象。</li></ul></blockquote><p><strong>什么时候触发<code>GC</code></strong></p><ul><li><p>程序调用<code>System.gc</code>时，但不是必然执行</p></li><li><p>系统自身来决定<code>GC</code>触发的时机（根据<code>Eden</code>区和<code>From Space</code>区的内存大小来决定。当内存大小不足时，则会启动<code>GC</code>线程并停止应用线程）</p></li></ul><blockquote><p><code>GC</code>又分为 <code>Minor GC</code> 和 <code>Full GC</code> (也称为 <code>Major GC</code>)<br><code>Minor GC</code>触发条件：当<code>Eden</code>区满时，触发<code>Minor GC</code>。<br><code>Full GC</code>触发条件：</p><ul><li>调用<code>System.gc</code>时，系统建议执行<code>Full GC</code>，但是不必然执行</li><li>老年代空间不足</li><li>方法去空间不足</li><li>通过<code>Minor GC</code>后进入老年代的平均大小大于老年代的可用内存</li><li>由<code>Eden</code>区、<code>From Space</code>区向<code>To Space</code>区复制时，对象大小大于<code>To Space</code>可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul></blockquote><p><strong><code>GC</code>做了什么事</strong></p><p>主要做了清理对象，整理内存的工作。<code>Java</code>堆分为新生代和老年代，采用了不同的回收方式。</p><h2 id="GC常用算法"><a href="#GC常用算法" class="headerlink" title="GC常用算法"></a>GC常用算法</h2><p><code>GC</code>常用算法有：<strong>标记-清除算法，标记-压缩算法，复制算法，分代收集算法</strong>。</p><p>目前主流的<code>JVM</code>（<code>HotSpot</code>）采用的是分代收集算法。</p><p><strong>标记-清除算法(<code>Mark-Sweep</code>)</strong></p><p>首先标记出所有需要回收的对象，标记完成后回收所有被标记的对象。不足主要体现在效率和空间，从效率的角度讲，标记和清除效率都不高；从空间的角度讲，标记清除后会产生大量不连续的内存碎片， 内存碎片太多可能会导致需要分配较大对象时，无法找到足够的连续内存而提前触发一次垃圾收集动作。</p><p>从堆栈和静态存储区出发，遍历所有的引用，进而找出所有存活的对象，如果活着，就标记。只有全部标记完毕的时候，清理动作才开始。在清理的时候，没有标记的对象将会被释放，不会发生任何动作。但是剩下的堆空间是不连续的，垃圾回收器要是希望得到连续空间的话，就得重新整理剩下的对象。</p><p>优点：标记—清除算法中每个活着的对象的引用只需要找到一个即可，找到一个就可以判断它为活的。此外，更重要的是，这个算法并不移动对象的位置。</p><p>缺点：它的缺点就是效率比较低（递归与全堆对象遍历）。每个活着的对象都要在标记阶段遍历一遍；所有对象都要在清除阶段扫描一遍，因此算法复杂度较高。没有移动对象，导致可能出现很多碎片空间无法利用的情况。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/12/31/feaeacf0-2bca-11ea-8d25-11ed44f6b9f6.png" srcset="/img/loading.gif" alt="image.png"></p><p><strong>标记-压缩算法（标记-整理）(<code>Mark-Compact</code>)</strong></p><p>过程与标记-清除算法一样，不过不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。在标记阶段，该算法也将所有对象标记为存活和死亡两种状态；不同的是，在第二个阶段，该算法并没有直接对死亡的对象进行清理，而是将所有存活的对象整理一下，放到另一处空间，然后把剩下的所有对象全部清除。这样就达到了标记-整理的目的。</p><p>优点：该算法不会像标记-清除算法那样产生大量的碎片空间。</p><p>缺点：如果存活的对象过多，整理阶段将会执行较多复制操作，导致算法效率降低。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/12/31/615a8860-2bcb-11ea-8d25-11ed44f6b9f6.png" srcset="/img/loading.gif" alt="image.png"></p><p><strong>复制(<code>Copying</code>)算法</strong></p><p>将可用内存分为两块，每次只用其中一块，当一块内存用完了，就将还存活的对象复制到另外一块上，然后再把已经使用过的内存空间一次性清理掉，循环下去。这样每次只需对整个半区进行内存回收，内存分配时也不需要考虑内存碎片等复杂情况，只需要移动指针，按照顺序分配即可。</p><p>优点：实现简单；不产生内存碎片</p><p>缺点：内存缩小为原来的一半，代价太高</p><blockquote><p>现在商用虚拟机都采用这种算法来回收新生代，不过<code>1:1</code>的比例非常不科学，因此新生代的内存被划分为一块较大的<code>Eden</code>空间和两块较小的<code>Survivor</code>空间，每次使用<code>Eden</code>和其中一块<code>Survivor</code>。每次回收时，将<code>Eden</code>和<code>Survivor</code>中还存活着的对象一次性复制到另外一块<code>Survivor</code>空间上，最后清理掉<code>Eden</code>和刚才用过的<code>Survivor</code>空间。<code>HotSpot</code>虚拟机默认<code>Eden</code>区和<code>Survivor</code>区的比例为<code>8:1</code>，意思是每次新生代中可用内存空间为整个新生代容量的<code>90%</code>。当然，我们无法保证每次回收都少于<code>10%</code>的对象存活，当<code>Survivor</code>空间不够用时，需要依赖老年代进行分配担保(<code>Handle Promotion</code>)。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/12/31/1be1b140-2bcc-11ea-8d25-11ed44f6b9f6.png" srcset="/img/loading.gif" alt="image.png"></p></blockquote><p><strong>分代收集(<code>Generational Collection</code>)算法</strong></p><p>分代收集算法根据对象的生存周期，将堆分为新生代(<code>Young</code>)和老年代(<code>Tenur</code>)。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用<strong>复制算法</strong>。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用<strong>标记-整理</strong>或者<strong>标记-清除</strong>。</p><p>新生代(<code>Young</code>)分为<code>Eden</code>区，<code>From</code>区与<code>To</code>区：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/12/31/a0da5f50-2bcc-11ea-8d25-11ed44f6b9f6.png" srcset="/img/loading.gif" alt="image.png"></p><p>当系统创建一个对象的时候，总是在<code>Eden</code>区操作，当这个区满了，那么就会触发一次<code>YoungGC</code>，也就是年轻代的垃圾回收。一般来说这时候并不是所有的对象都没用了，所以就会把还能用的对象复制到<code>From</code>区：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/12/31/bd4ec400-2bcc-11ea-8d25-11ed44f6b9f6.png" srcset="/img/loading.gif" alt="image.png"></p><p>这样整个<code>Eden</code>区就被清理干净了，可以继续创建新的对象，当<code>Eden</code>区再次被用完，就再触发一次<code>YoungGC</code>，然后注意，这个时候跟刚才稍稍有点区别。这次触发<code>YoungGC</code>后，会将<code>Eden</code>区与<code>From</code>区还在被使用的对象复制到<code>To</code>区：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/12/31/df0d3950-2bcc-11ea-8d25-11ed44f6b9f6.png" srcset="/img/loading.gif" alt="image.png"></p><p>再下一次<code>YoungGC</code>的时候，则是将<code>Eden</code>区与<code>To</code>区中的还在被使用的对象复制到<code>From</code>区：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/12/31/f36c1150-2bcc-11ea-8d25-11ed44f6b9f6.png" srcset="/img/loading.gif" alt="image.png"></p><p>经过若干次<code>YoungGC</code>后，有些对象在<code>From</code>与<code>To</code>之间来回游荡，这时候<code>From</code>区与<code>To</code>区亮出了底线（阈值），这些家伙要是还没有被回收，就会被复制到老年代：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/12/31/235fea80-2bcd-11ea-8d25-11ed44f6b9f6.png" srcset="/img/loading.gif" alt="image.png"> </p><p>老年代经过这么几次折腾，也就扛不住了（空间被用完），那就来次集体大扫除(<code>Full GC</code>)，也就是全量回收。如果<code>Full GC</code>使用太频繁的话，无疑会对系统性能产生很大的影响。所以要合理设置年轻代与老年代的大小，尽量减少<code>Full GC</code>的操作。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><strong>收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现</strong></p><p><strong><code>Serial</code>收集器</strong></p><p>串行收集器是最古老，最稳定以及效率高的收集器，但是可能会产生较长的停顿，只使用一个线程去回收。<br>启用命令：<code>-XX:+UseSerialGC</code></p><p><strong><code>Parallel</code>收集器</strong></p><p>并行GC的好处是提升垃圾回收的性能，减少串行回收带来的问题，也有停顿，但可以并行回收，一边标记对象一边执行线程，整体上提升了回收的性能。<br>启用命令：<br><code>-XX:+UseParallelGC</code> </p><ul><li>使用<code>Parallel</code>收集器 + 老年代串行</li></ul><p><code>-XX:+UseParallelOldGC</code></p><ul><li>使用<code>Parallel</code>收集器 + 老年代并行</li></ul><p><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/12/31/0ea3c130-2bd6-11ea-8d25-11ed44f6b9f6.png" srcset="/img/loading.gif" alt="image.png"></p><p><strong><code>CMS</code>收集器</strong></p><p><code>CMS</code>收集器是以获取最短回收停顿时间为目标的收集器，基于”标记-清除”(<code>Mark-Sweep</code>)算法实现，整个过程分为四个步骤：</p><ul><li><p>初始标记 (<code>Stop the World</code>事件<code>CPU</code>停顿很短) ，仅标记<code>GC Roots</code>能直接关联到的对象，速度快；</p></li><li><p>并发标记 (收集垃圾跟用户线程一起执行) ，初始标记和重新标记仍需要 <code>Stop the World</code>，并发标记过程就是进行 <code>GC Roots Tracing</code>的过程；</p></li><li><p>重新标记 (<code>Stop the World</code>事件<code>CPU</code>停顿，比初始标记稍长，远比并发标记短)，修正并发标记期因用户程序继续运作而导致标记产生变动的那部分对象的标记记录，这个阶段停顿时间比初始标记阶段稍长些，比并发标记时间短；</p></li><li><p>并发清理-清除算法。</p></li></ul><p>整个过程中最耗时的并发标记和并发清除过程，收集器线程都可与用户线程一起工作，总体上来说，<code>CMS</code>收集器的内存回收过程是与用户线程一起并发执行的。</p><p><code>CMS</code>收集器优点：并发收集，低停顿</p><p><code>CMS</code>收集器缺点：</p><ul><li><p><code>CMS</code>收集器对<code>CPU</code>资源非常敏感</p></li><li><p><code>CMS</code>处理器无法处理浮动垃圾</p></li><li><p><code>CMS</code>基于“标记–清除”算法实现，会产生大量空间碎片，会在大对象分配时提前触发<code>Full GC</code>。为解决这个问题，<code>CMS</code>提供了一个开关参数，用于在<code>CMS</code>要进行<code>Full GC</code>时开启内存碎片的合并整理过程，内存整理的过程无法并发，停顿时间变长；</p></li></ul><p><code>CMS</code>也提供了整理碎片的参数：</p><p><code>-XX:+ UseCMSCompactAtFullCollection</code> <code>Full GC</code>后，进行一次整理</p><ul><li>整理过程是独占的，会引起停顿时间变长</li></ul><p><code>-XX:+CMSFullGCsBeforeCompaction</code></p><ul><li>设置进行几次<code>Full GC</code>后，进行一次碎片整理</li></ul><p><code>-XX:ParallelCMSThreads</code></p><ul><li>设定<code>CMS</code>的线程数量（一般情况约等于可用CPU数量）</li></ul><p><code>CMS</code>的提出是想改善<code>GC</code>的停顿时间，在<code>GC</code>过程中的确做到了减少<code>GC</code>时间，但是同样导致产生大量内存碎片，又需要消耗大量时间去整理碎片，从本质上并没有改善时间。  </p><p><strong><code>G1</code>(<code>Garbage First</code>)收集器</strong></p><p><code>G1</code>是一款面向服务端应用的垃圾收集器。与<code>CMS</code>收集器相比<code>G1</code>收集器有以下特点：</p><ul><li><p>空间整合：<code>G1</code>收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次<code>GC</code>。</p></li><li><p>可预测停顿：这是<code>G1</code>的另一大优势，降低停顿时间是<code>G1</code>和<code>CMS</code>的共同关注点，但<code>G1</code>除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为<code>N</code>毫秒的时间片段内，消耗在垃圾收集上的时间不得超过<code>N</code>毫秒，这几乎已经是实时<code>Java</code>（<code>RTSJ</code>）的垃圾收集器的特征了。</p></li><li><p>并行于并发：充分使用多个<code>CPU</code>来缩短<code>Stop the World</code>停顿时间。</p></li><li><p>分代收集：采用不同方式处理新创建的对象和已存活一段时间，熬过多次<code>GC</code>的旧对象，以获取更好的收集效果。</p></li></ul><p>使用<code>G1</code>收集器时，<code>Java</code>堆的内存布局与其他收集器有很大差别，它将整个<code>Java</code>堆划分为多个大小相等的独立区域（<code>Region</code>），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）<code>Region</code>的集合。</p><p><code>G1</code>运作步骤：</p><ul><li>初始标记(<code>Initial-Mark</code>)(<code>Stop the World</code>事件<code>CPU</code>停顿只处理垃圾)；</li></ul><p>这个阶段是停顿的(<code>Stop the World Event</code>)，并且会触发一次普通<code>Mintor GC</code>。<br>对应<code>GC log</code>:<code>GC pause</code> (<code>young</code>) (<code>inital-mark</code>)</p><ul><li><code>Root Region Scanning</code>；</li></ul><p>程序运行过程中会回收<code>survivor</code>区(存活到老年代)，这一过程必须在<code>young GC</code>之前完成。</p><ul><li>并发标记(<code>Concurrent Marking</code>)(与用户线程并发执行)；</li></ul><p>在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被<code>young GC</code>中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</p><ul><li>最终标记(<code>Stop the World</code>事件<code>CPU</code>停顿处理垃圾)；</li></ul><p>此阶段是用来收集 <strong>并发标记阶段</strong> 产生新的垃圾(并发阶段和应用程序一同运行)；<code>G1</code>中采用了比<code>CMS</code>更快的初始快照算法:<code>snapshot-at-the-beginning</code> (<code>SATB</code>)。</p><ul><li>筛选回收(<code>Stop the World</code>事件根据用户期望的<code>GC</code>停顿时间回收)；</li></ul><p>多线程清除失活对象，会有<code>Stop the World</code>事件。<code>G1</code>将回收区域的存活对象拷贝到新区域，清除<code>Remember Sets</code>，并发清空回收区域并把它返回到空闲区域链表中。</p><h2 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h2><p><strong><code>finalize</code>的作用</strong></p><ul><li><p><code>finalize()</code>是<code>Object</code>的<code>protected</code>方法，子类可以覆盖该方法以实现资源清理工作，<code>GC</code>在回收对象之前调用该方法；</p></li><li><p><code>finalize()</code>与<code>C++</code>中的析构函数不是对应的。<code>C++</code>中的析构函数调用的时机是确定的（对象离开作用域或<code>delete</code>掉），但<code>Java</code>中的<code>finalize</code>的调用具有不确定性；</p></li><li><p>不建议用<code>finalize</code>方法完成“非内存资源”的清理工作，但建议用于：<br>① 清理本地对象(通过<code>JNI</code>创建的对象)；<br>② 作为确保某些非内存资源(如<code>Socket</code>、文件等)释放的一个补充：在<code>finalize</code>方法中显式调用其他资源释放方法。</p></li></ul><p><strong><code>finalize</code>的问题</strong></p><ul><li><p>一些与<code>finalize</code>相关的方法，由于一些致命的缺陷，已经被废弃了，如<code>System.runFinalizersOnExit()</code>方法、<code>Runtime.runFinalizersOnExit()</code>方法；</p></li><li><p><code>System.gc()</code>与<code>System.runFinalization()</code>方法增加了<code>finalize</code>方法执行的机会，但不可盲目依赖它们；</p></li><li><p><code>Java</code>语言规范并不保证<code>finalize</code>方法会被及时地执行、而且根本不会保证它们会被执行；</p></li><li><p><code>finalize</code>方法可能会带来性能问题。因为<code>JVM</code>通常在单独的低优先级线程中完成<code>finalize</code>的执行；</p></li><li><p>对象再生问题：<code>finalize</code>方法中，可将待回收对象赋值给<code>GC Roots</code>可达的对象引用，从而达到对象再生的目的；</p></li><li><p><code>finalize</code>方法至多由<code>GC</code>执行一次(用户当然可以手动调用对象的<code>finalize</code>方法，但并不影响<code>GC</code>对<code>finalize</code>的行为)。</p></li></ul><p><strong><code>finalize</code>的执行过程(生命周期)</strong></p><p>当对象变成(<code>GC Roots</code>)不可达时，<code>GC</code>会判断该对象是否覆盖了<code>finalize</code>方法，若未覆盖，则直接将其回收。否则，若对象未执行过<code>finalize</code>方法，将其放入<code>F-Queue</code>队列，由一低优先级线程执行该队列中对象的<code>finalize</code>方法。执行<code>finalize</code>方法完毕后，<code>GC</code>会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。</p><p>具体的<code>finalize</code>流程：</p><p>对象可由两种状态，涉及到两类状态空间，一是终结状态空间 <code>F = {unfinalized, finalizable, finalized}</code>；二是可达状态空间 <code>R = {reachable, finalizer-reachable, unreachable}</code>。各状态含义如下：</p><ul><li><code>unfinalized</code>: 新建对象会先进入此状态，<code>GC</code>并未准备执行其<code>finalize</code>方法，因为该对象是可达的。</li><li><code>finalizable</code>: 表示<code>GC</code>可对该对象执行<code>finalize</code>方法，<code>GC</code>已检测到该对象不可达。正如前面所述，<code>GC</code>通过<code>F-Queue</code>队列和一专用线程完成<code>finalize</code>的执行。</li><li><code>finalized</code>: 表示<code>GC</code>已经对该对象执行过<code>finalize</code>方法。</li><li><code>reachable</code>: 表示<code>GC Roots</code>引用可达。</li><li><code>finalizer-reachable</code>(<code>f-reachable</code>)：表示不是<code>reachable</code>，但可通过某个<code>finalizable</code>对象可达。</li><li><code>unreachable</code>：对象不可通过上面两种途径可达。</li></ul><p>状态变迁图：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/12/31/a172d520-2bd4-11ea-8d25-11ed44f6b9f6.png" srcset="/img/loading.gif" alt="image.png"></p><p>状态变迁说明：</p><ul><li>新建对象首先处于<code>[reachable, unfinalized]</code>状态(<code>A</code>)；</li><li>随着程序的运行，一些引用关系会消失，导致状态变迁，从<code>reachable</code>状态变迁到<code>f-reachable</code>(<code>B, C, D</code>)或<code>unreachable</code>(<code>E, F</code>)状态；</li><li>若<code>JVM</code>检测到处于<code>unfinalized</code>状态的对象变成<code>f-reachable</code>或<code>unreachable</code>，<code>JVM</code>会将其标记为<code>finalizable</code>状态(<code>G,H</code>)。若对象原处于<code>[unreachable, unfinalized]</code>状态，则同时将其标记为<code>f-reachable</code>(<code>H</code>)；</li><li>在某个时刻，<code>JVM</code>取出某个<code>finalizable</code>对象，将其标记为<code>finalized</code>并在某个线程中执行其<code>finalize</code>方法。由于是在活动线程中引用了该对象，该对象将变迁到(<code>reachable, finalized</code>)状态(<code>K</code>或<code>J</code>)。该动作将影响某些其他对象从<code>f-reachable</code>状态重新回到<code>reachable</code>状态(<code>L, M, N</code>)；</li><li>处于<code>finalizable</code>状态的对象不能同时是<code>unreahable</code>的，由上一点可知，将对象<code>finalizable</code>对象标记为<code>finalized</code>时会由某个线程执行该对象的<code>finalize</code>方法，致使其变成<code>reachable</code>。这也是图中只有八个状态点的原因；</li><li>程序员手动调用<code>finalize</code>方法并不会影响到上述内部标记的变化，因此<code>JVM</code>只会至多调用<code>finalize</code>一次，即使该对象“复活”也是如此。程序员手动调用多少次不影响<code>JVM</code>的行为；</li><li>若<code>JVM</code>检测到<code>finalized</code>状态的对象变成<code>unreachable</code>，回收其内存(<code>I</code>)；</li><li>若对象并未覆盖<code>finalize</code>方法，<code>JVM</code>会进行优化，直接回收对象（<code>O</code>）。</li></ul><p>注：<code>System.runFinalizersOnExit()</code>等方法可以使对象即使处于<code>reachable</code>状态，<code>JVM</code>仍对其执行<code>finalize</code>方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>GC</code>垃圾收集，<code>Java</code>提供的<code>GC</code>可以自动监测对象是否超过作用域从而达到自动回收内存的目的。</p><p>判断一个对象是否存活常用的有两种办法：引用计数算法和可达性分析算法。</p><p><code>GC</code>常用算法有：<strong>标记-清除算法，标记-压缩算法，复制算法，分代收集算法</strong>。</p><p>不管选择哪种<code>GC</code>算法，<code>Stop the World</code>都是不可避免的。<code>Stop the World</code>意味着从应用中停下来并进入到<code>GC</code>执行过程中去。一旦<code>Stop the World</code>发生，除了<code>GC</code>所需的线程外，其他线程都将停止工作，中断了的线程直到<code>GC</code>任务结束才继续它们的任务。<code>GC</code>调优通常就是为了改善<code>Stop the World</code>的时间。</p><p>关于程序设计的几点建议：</p><ul><li><p>尽早释放无用对象的引用。大多数程序员在使用临时变量的时候，都是让引用变量在退出活动域（<code>scope</code>）后，自动设置为 <code>null</code>.我们在使用这种方式时候，必须特别注意一些复杂的对象图，例如数组，队列，树，图等，这些对象之间有相互引用关系较为复杂。对于这类对象，<code>GC</code> 回收它们一般效率较低。如果程序允许，尽早将不用的引用对象赋为 <code>null</code>，这样可以加速<code>GC</code>的工作。 </p></li><li><p>尽量少用<code>finalize</code>函数。<code>finalize</code>函数是<code>Java</code>提供给程序员一个释放对象或资源的机会。但是，它会加大<code>GC</code>的工作量，因此尽量少采用<code>finalize</code>方式回收资源。 </p></li><li><p>如果需要使用经常使用的图片，可以使用<code>soft</code>应用类型。它可以尽可能将图片保存在内存中，供程序调用，而不引起<code>OutOfMemoryException</code>。</p></li><li><p>注意集合数据类型，包括数组，树，图，链表等数据结构，这些数据结构对<code>GC</code>来说，回收更为复杂。另外，注意一些全局的变量，以及一些静态变量。这些变量往往容易引起悬挂对象(<code>dangling reference</code>)，造成内存浪费。 </p></li><li><p>当程序有一定的等待时间，程序员可以手动执行<code>System.gc()</code>，通知<code>GC</code>运行，但是<code>Java</code>语言规范并不保证<code>GC</code>一定会执行。使用增量式<code>GC</code>可以缩短<code>Java</code>程序的暂停时间。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java GC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（二十二）</title>
    <link href="/passages/design-pattern-learn-22/"/>
    <url>/passages/design-pattern-learn-22/</url>
    
    <content type="html"><![CDATA[<!-- more --><ul><li>为什么要分 <code>MVC</code> 三层来开发？</li><li>为什么要针对每层定义不同的数据对象？</li></ul><h2 id="业务开发包括哪些工作？"><a href="#业务开发包括哪些工作？" class="headerlink" title="业务开发包括哪些工作？"></a>业务开发包括哪些工作？</h2><p>平时做业务系统的设计与开发，无外乎有这样三方面的工作要做：接口设计、数据库设计和业务模型设计（也就是业务逻辑）。</p><p>数据库和接口的设计非常重要，一旦设计好并投入使用之后，这两部分都不能轻易改动。改动数据库表结构，需要涉及数据的迁移和适配；改动接口，需要推动接口的使用者作相应的代码修改。这两种情况，即便是微小的改动，执行起来都会非常麻烦。因此，我们在设计接口和数据库的时候，一定要多花点心思和时间，切不可过于随意。相反，业务逻辑代码侧重内部实现，不涉及被外部依赖的接口，也不包含持久化的数据，所以对改动的容忍性更大。</p><p>从代码实现角度来说，大部分业务系统的开发都可以分为 <code>Controller</code>、<code>Service</code>、<code>Repository</code> 三层。<code>Controller</code> 层负责接口暴露，<code>Repository</code> 层负责数据读写，<code>Service</code> 层负责核心业务逻辑，也就是业务模型。</p><p>除此之外，前面还提到两种开发模式，基于贫血模型的传统开发模式和基于充血模型的 <code>DDD</code> 开发模式。前者是一种面向过程的编程风格，后者是一种面向对象的编程风格。不管是 <code>DDD</code> 还是 <code>OOP</code>，高级开发模式的存在一般都是为了应对复杂系统，应对系统的复杂性。</p><h2 id="为什么要分-MVC-三层开发？"><a href="#为什么要分-MVC-三层开发？" class="headerlink" title="为什么要分 MVC 三层开发？"></a>为什么要分 MVC 三层开发？</h2><p>刚刚提到，大部分业务系统的开发都可以分为三层：<code>Contoller</code> 层、<code>Service</code> 层、<code>Repository</code> 层。对于这种分层方式，我相信大部分人都很认同，甚至成为了一种开发习惯，但你有没有想过，为什么我们要分层开发？很多业务都比较简单，一层代码搞定所有的数据读取、业务逻辑、接口暴露不好吗？</p><p>对于这个问题，总结了以下几点原因。</p><p><strong>1. 分层能起到代码复用的作用</strong></p><p>同一个 <code>Repository</code> 可能会被多个 <code>Service</code> 来调用，同一个 <code>Service</code> 可能会被多个 <code>Controller</code> 调用。比如，<code>UserService</code> 中的 <code>getUserById()</code> 接口封装了通过 <code>ID</code> 获取用户信息的逻辑，这部分逻辑可能会被 <code>UserController</code> 和 <code>AdminController</code> 等多个 <code>Controller</code> 使用。如果没有 <code>Service</code> 层，每个 <code>Controller</code> 都要重复实现这部分逻辑，显然会违反 <code>DRY</code> 原则。</p><p><strong>2. 分层能起到隔离变化的作用</strong></p><p>分层体现了一种抽象和封装的设计思想。比如，<code>Repository</code> 层封装了对数据库访问的操作，提供了抽象的数据访问接口。基于接口而非实现编程的设计思想，<code>Service</code> 层使用 <code>Repository</code> 层提供的接口，并不关心其底层依赖的是哪种具体的数据库。当我们需要替换数据库的时候，比如从 <code>MySQL</code> 到 <code>Oracle</code>，从 <code>Oracle</code> 到 <code>Redis</code>，只需要改动 <code>Repository</code> 层的代码，<code>Service</code> 层的代码完全不需要修改。</p><p>除此之外，<code>Controller</code>、<code>Service</code>、<code>Repository</code> 三层代码的稳定程度不同、引起变化的原因不同，所以分成三层来组织代码，能有效地隔离变化。比如，<code>Repository</code> 层基于数据库表，而数据库表改动的可能性很小，所以 <code>Repository</code> 层的代码最稳定，而 <code>Controller</code> 层提供适配给外部使用的接口，代码经常会变动。分层之后，<code>Controller</code> 层中代码的频繁改动并不会影响到稳定的 <code>Repository</code> 层。</p><p><strong>3. 分层能起到隔离关注点的作用</strong></p><p><code>Repository</code> 层只关注数据的读写。<code>Service</code> 层只关注业务逻辑，不关注数据的来源。<code>Controller</code> 层只关注与外界打交道，数据校验、封装、格式转换，并不关心业务逻辑。三层之间的关注点不同，分层之后，职责分明，更加符合单一职责原则，代码的内聚性更好。</p><p><strong>4. 分层能提高代码的可测试性</strong></p><p>单元测试不依赖不可控的外部组件，比如数据库。分层之后，<code>Repsitory</code> 层的代码通过依赖注入的方式供 <code>Service</code> 层使用，当要测试包含核心业务逻辑的 <code>Service</code> 层代码的时候，我们可以用 <code>mock</code> 的数据源替代真实的数据库，注入到 <code>Service</code> 层代码中。</p><p><strong>5. 分层能应对系统的复杂性</strong></p><p>所有的代码都放到一个类中，那这个类的代码就会因为需求的迭代而无限膨胀。当一个类或一个函数的代码过多之后，可读性、可维护性就会变差。那我们就要想办法拆分。拆分有垂直和水平两个方向。水平方向基于业务来做拆分，就是模块化；垂直方向基于流程来做拆分，就是这里说的分层。</p><p>还是那句话，不管是分层、模块化，还是 <code>OOP</code>、<code>DDD</code>，以及各种设计模式、原则和思想，都是为了应对复杂系统，应对系统的复杂性。对于简单系统来说，其实是发挥不了作用的，就是俗话说的“杀鸡焉用牛刀”。</p><h2 id="BO、VO、Entity-存在的意义是什么？"><a href="#BO、VO、Entity-存在的意义是什么？" class="headerlink" title="BO、VO、Entity 存在的意义是什么？"></a>BO、VO、Entity 存在的意义是什么？</h2><p>针对 <code>Controller</code>、<code>Service</code>、<code>Repository</code> 三层，每层都会定义相应的数据对象，它们分别是 <code>VO</code>（<code>View Object</code>）、<code>BO</code>（<code>Business Object</code>）、<code>Entity</code>，例如 <code>UserVo</code>、<code>UserBo</code>、<code>UserEntity</code>。在实际的开发中，<code>VO</code>、<code>BO</code>、<code>Entity</code> 可能存在大量的重复字段，甚至三者包含的字段完全一样。在开发的过程中，经常需要重复定义三个几乎一样的类，显然是一种重复劳动。</p><p><strong>相对于每层定义各自的数据对象来说，是不是定义一个公共的数据对象更好些呢？</strong></p><p>实际上，更加推荐每层都定义各自的数据对象这种设计思路，主要有以下 <code>3</code> 个方面的原因。</p><ul><li><p><code>VO</code>、<code>BO</code>、<code>Entity</code> 并非完全一样。比如，我们可以在 <code>UserEntity</code>、<code>UserBo</code> 中定义 <code>Password</code> 字段，但显然不能在 <code>UserVo</code> 中定义 <code>Password</code> 字段，否则就会将用户的密码暴露出去。</p></li><li><p><code>VO</code>、<code>BO</code>、<code>Entity</code> 三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的。所以，也并不能算违背 <code>DRY</code> 原则。在前面讲到 <code>DRY</code> 原则的时候，针对这种情况，如果合并为同一个类，那也会存在后期因为需求的变化而需要再拆分的问题。</p></li><li><p>为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护自己的数据对象，层与层之间通过接口交互。数据从下一层传递到上一层的时候，将下一层的数据对象转化成上一层的数据对象，再继续处理。虽然这样的设计稍微有些繁琐，每层都需要定义各自的数据对象，需要做数据对象之间的转化，但是分层清晰。对于非常大的项目来说，结构清晰是第一位的！</p></li></ul><p><strong>既然 <code>VO</code>、<code>BO</code>、<code>Entity</code> 不能合并，那如何解决代码重复的问题呢？</strong></p><p>继承可以解决代码重复问题。我们可以将公共的字段定义在父类中，让 <code>VO</code>、<code>BO</code>、<code>Entity</code> 都继承这个父类，各自只定义特有的字段。因为这里的继承层次很浅，也不复杂，所以使用继承并不会影响代码的可读性和可维护性。后期如果因为业务的需要，有些字段需要从父类移动到子类，或者从子类提取到父类，代码改起来也并不复杂。</p><p>前面在讲“多用组合，少用继承”设计思想的时候提到，组合也可以解决代码重复的问题，所以，这里我们还可以将公共的字段抽取到公共的类中，<code>VO</code>、<code>BO</code>、<code>Entity</code> 通过组合关系来复用这个类的代码。</p><p><strong>代码重复问题解决了，那不同分层之间的数据对象该如何互相转化呢？</strong></p><p>最简单的转化方式是手动复制。自己写代码在两个对象之间，一个字段一个字段的赋值。但这样的做法显然是没有技术含量的低级劳动。<code>Java</code> 中提供了多种数据对象转化工具，比如 <code>BeanUtils</code>、<code>Dozer</code> 等，可以大大简化繁琐的对象转化工作。如果你是用其他编程语言来做开发，也可以借鉴 <code>Java</code> 这些工具类的设计思路，自己在项目中实现对象转化工具类。</p><p><strong><code>VO</code>、<code>BO</code>、<code>Entity</code> 都是基于贫血模型的，而且为了兼容框架或开发库（比如 <code>MyBatis</code>、<code>Dozer</code>、<code>BeanUtils</code>），我们还需要定义每个字段的 <code>set</code> 方法。这些都违背 <code>OOP</code> 的封装特性，会导致数据被随意修改。那到底该怎么办好呢？</strong></p><p><code>Entity</code> 和 <code>VO</code> 的生命周期是有限的，都仅限在本层范围内。而对应的 <code>Repository</code> 层和 <code>Controller</code> 层也都不包含太多业务逻辑，所以也不会有太多代码随意修改数据，即便设计成贫血、定义每个字段的 <code>set</code> 方法，相对来说也是安全的。</p><p>不过，<code>Service</code> 层包含比较多的业务逻辑代码，所以 <code>BO</code> 就存在被任意修改的风险了。但是，设计的问题本身就没有最优解，只有权衡。为了使用方便，我们只能做一些妥协，放弃 <code>BO</code> 的封装特性，由程序员自己来负责这些数据对象的不被错误使用。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p><strong>1. 为什么要分 <code>MVC</code> 三层开发？</strong></p><p>对于这个问题，总结了以下 <code>5</code> 点原因:</p><ul><li>分层能起到代码复用的作用</li><li>分层能起到隔离变化的作用</li><li>分层能起到隔离关注点的作用</li><li>分层能提高代码的可测试性</li><li>分层能应对系统的复杂性</li></ul><p><strong>2. <code>BO</code>、<code>VO</code>、<code>Entity</code> 存在的意义是什么？</strong></p><p>从设计的角度来说，<code>VO</code>、<code>BO</code>、<code>Entity</code> 的设计思路并不违反 <code>DRY</code> 原则，为了分层清晰、减少耦合，多维护几个类的成本也并不是不能接受的。但是，如果你真的有代码洁癖，对于代码重复的问题，我们可以通过继承或者组合来解决。</p><p>如何进行数据对象之间的转化？最简单的方式就是手动复制。当然，你也可以使用 <code>Java</code> 中提供了数据对象转化工具，比如 <code>BeanUtils</code>、<code>Dozer</code> 等，可以大大简化繁琐的对象转化工作。</p><p>尽管 <code>VO</code>、<code>BO</code>、<code>Entity</code> 的设计违背 <code>OOP</code> 的封装特性，有被随意修改的风险。但 <code>Entity</code> 和 <code>VO</code> 的生命周期是有限的，都仅限在本层范围内，相对来说是安全的。<code>Service</code> 层包含比较多的业务逻辑代码，所以 <code>BO</code> 就存在被任意修改的风险了。为了使用方便，我们只能做一些妥协，放弃 <code>BO</code> 的封装特性，由程序员自己来负责这些数据对象的不被错误使用。</p><p><strong>3. 总结用到的设计原则和思想</strong></p><p>从表面上看，做业务开发可能并不是特别有技术挑战，但是实际上，如果你要做到知其然知其所以然，做到透彻理解、真的懂，并不是件容易的事情。深挖一下，你会发现这其中还是蕴含了很多设计原则、思想和模式的。</p><p>参考：<a href="https://time.geekbang.org/column/article/183007" target="_blank" rel="noopener">实战一（下）：如何实现一个遵从设计原则的积分兑换系统？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(设计原则)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（二十一）</title>
    <link href="/passages/design-pattern-learn-21/"/>
    <url>/passages/design-pattern-learn-21/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>对于一个工程师来说，如果要追求长远发展，你就不能一直只把自己放在执行者的角色，不能只是一个代码实现者，你还要有独立负责一个系统的能力，能端到端（<code>end to end</code>）开发一个完整的系统。这其中的工作就包括：<strong>前期的需求沟通分析、中期的代码设计实现、后期的系统上线维护等</strong>。</p><p>前面我们还提到过，大部分工程师都是做业务开发的。很多工程师都觉得，做业务开发没啥技术含量，没有成长，就是简单的 <code>CRUD</code>，翻译业务逻辑，根本用不上设计原则、思想、模式。</p><p><strong>技术人也要有一些产品思维。对于产品设计、需求分析，我们要学会“借鉴”，一定不要自己闷头想</strong>。一方面这样做很难想全面，另一方面从零开始设计也比较浪费时间。除此之外，我们还可以通过线框图和用户用例来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。</p><p><strong>面向对象设计聚焦在代码层面（主要是针对类），那系统设计就是聚焦在架构层面（主要是针对模块）</strong>，两者有很多相似之处。很多设计原则和思想不仅仅可以应用到代码设计中，还能用到架构设计中。实际上，我们可以借鉴面向对象设计的步骤，来做系统设计。</p><p><strong>面向对象设计的本质就是把合适的代码放到合适的类中</strong>。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰，代码整体结构一目了然。类比面向对象设计，系统设计实际上就是将合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。在面向对象设计中，类设计好之后，我们需要设计类之间的交互关系。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互了。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>对公司业务及已有系统的熟悉程度，有时候甚至会超过个人的技术能力，更能决定一个人在公司内部的发展前途。但是，当我们出去面试的时候，面试官大部分情况下更加关注你的技术能力，而非特定的业务细节，特别是你做的业务并不是太复杂，或者跟要面试岗位无关的时候。<br>这两者听起来比较矛盾。作为一名技术人，为了谋求更好的发展，你觉得是应该多花点时间研究业务呢，还是要多花点心思在技术上呢？</li></ul><p>参考：<a href="https://time.geekbang.org/column/article/182001" target="_blank" rel="noopener">实战一（上）：针对业务系统的开发，如何做需求分析和设计？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(设计原则)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（二十）</title>
    <link href="/passages/design-pattern-learn-20/"/>
    <url>/passages/design-pattern-learn-20/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>迪米特法则它不像 <code>SOLID</code>、<code>KISS</code>、<code>DRY</code> 原则那样，人尽皆知，但它却非常实用。利用这个原则，能够帮我们实现代码的“高内聚、松耦合”。</p><ul><li>什么是“高内聚、松耦合”？</li><li>如何利用迪米特法则来实现“高内聚、松耦合”？</li><li>有哪些代码设计是明显违背迪米特法则的？对此又该如何重构？</li></ul><h2 id="什么是“高内聚、松耦合”？"><a href="#什么是“高内聚、松耦合”？" class="headerlink" title="什么是“高内聚、松耦合”？"></a>什么是“高内聚、松耦合”？</h2><p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效地提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。很多设计原则都以实现代码的“高内聚、松耦合”为目的，比如单一职责原则、基于接口而非实现编程等。</p><p>实际上，“高内聚、松耦合”是一个比较通用的设计思想，可以用来指导不同粒度代码的设计与开发，比如系统、模块、类，甚至是函数，也可以应用到不同的开发场景中，比如微服务、框架、组件、类库等。</p><p>在这个设计思想中，“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。</p><p><strong>到底什么是“高内聚”呢？</strong></p><p>所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。实际上，<a href="/passages/design-pattern-learn-13/">单一职责原则</a>是实现代码高内聚非常有效的设计原则。</p><p><strong>什么是“松耦合”？</strong></p><p>所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。依赖注入、接口隔离、基于接口而非实现编程，以及迪米特法则，都是为了实现代码的松耦合。</p><p><strong>“内聚”和“耦合”之间的关系</strong></p><p>“高内聚”有助于“松耦合”，同理，“低内聚”也会导致“紧耦合”。</p><h2 id="“迪米特法则”理论描述"><a href="#“迪米特法则”理论描述" class="headerlink" title="“迪米特法则”理论描述"></a>“迪米特法则”理论描述</h2><p>迪米特法则的英文翻译是：<code>Law of Demeter</code>，缩写是 <code>LOD</code>。它还有另外一个更加达意的名字，叫作最小知识原则，英文翻译为：<code>The Least Knowledge Principle</code>。</p><blockquote><p><code>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.</code></p></blockquote><p>把它直译成中文，就是下面这个样子：</p><blockquote><p>每个模块（<code>unit</code>）只应该了解那些与它关系密切的模块（<code>units: only units “closely” related to the current unit</code>）的有限知识（<code>knowledge</code>）。或者说，每个模块只和自己的朋友“说话”（<code>talk</code>），不和陌生人“说话”（<code>talk</code>）。</p></blockquote><p>对刚刚的定义重新描述一下：</p><blockquote><p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。</p></blockquote><h2 id="理论解读与代码实战一"><a href="#理论解读与代码实战一" class="headerlink" title="理论解读与代码实战一"></a>理论解读与代码实战一</h2><p>先来看上面原则中的前半部分，“<strong>不该有直接依赖关系的类之间，不要有依赖</strong>”。举个例子解释一下。</p><p>这个例子实现了简化版的搜索引擎爬取网页的功能。代码中包含三个主要的类。其中，<code>NetworkTransporter</code> 类负责底层网络通信，根据请求获取数据；<code>HtmlDownloader</code> 类用来通过 <code>URL</code> 获取网页；<code>Document</code> 表示网页文档，后续的网页内容抽取、分词、索引都是以此为处理对象。具体的代码实现如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkTransporter</span> </span>&#123;    <span class="hljs-comment">// 省略属性和其他方法...</span>    <span class="hljs-keyword">public</span> Byte[] send(HtmlRequest htmlRequest) &#123;      <span class="hljs-comment">//...</span>    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HtmlDownloader</span> </span>&#123;  <span class="hljs-keyword">private</span> NetworkTransporter transporter;<span class="hljs-comment">//通过构造函数或IOC注入</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Html <span class="hljs-title">downloadHtml</span><span class="hljs-params">(String url)</span> </span>&#123;    Byte[] rawHtml = transporter.send(<span class="hljs-keyword">new</span> HtmlRequest(url));    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Html(rawHtml);  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Document</span> </span>&#123;  <span class="hljs-keyword">private</span> Html html;  <span class="hljs-keyword">private</span> String url;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Document</span><span class="hljs-params">(String url)</span> </span>&#123;    <span class="hljs-keyword">this</span>.url = url;    HtmlDownloader downloader = <span class="hljs-keyword">new</span> HtmlDownloader();    <span class="hljs-keyword">this</span>.html = downloader.downloadHtml(url);  &#125;  <span class="hljs-comment">//...</span>&#125;</code></pre><p>这段代码虽然“能用”，能实现我们想要的功能，但是它不够“好用”，有比较多的设计缺陷。</p><p><strong>首先来看 <code>NetworkTransporter</code> 类</strong>。作为一个底层网络通信类，我们希望它的功能尽可能通用，而不只是服务于下载 <code>HTML</code>，所以，我们不应该直接依赖太具体的发送对象 <code>HtmlRequest</code>。从这一点上讲，<code>NetworkTransporter</code> 类的设计违背迪米特法则，依赖了不该有直接依赖关系的 <code>HtmlRequest</code> 类。</p><p>应该如何进行重构，让 <code>NetworkTransporter</code> 类满足迪米特法则呢？这里有个形象的比喻。假如你现在要去商店买东西，你肯定不会直接把钱包给收银员，让收银员自己从里面拿钱，而是你从钱包里把钱拿出来交给收银员。这里的 <code>HtmlRequest</code> 对象就相当于钱包，<code>HtmlRequest</code> 里的 <code>address</code> 和 <code>content</code> 对象就相当于钱。我们应该把 <code>address</code> 和 <code>content</code> 交给 <code>NetworkTransporter</code>，而非是直接把 <code>HtmlRequest</code> 交给 <code>NetworkTransporter</code>。根据这个思路，<code>NetworkTransporter</code> 重构之后的代码如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkTransporter</span> </span>&#123;    <span class="hljs-comment">// 省略属性和其他方法...</span>    <span class="hljs-keyword">public</span> Byte[] send(String address, Byte[] data) &#123;      <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre><p><strong>再来看 <code>HtmlDownloader</code> 类</strong>。这个类的设计没有问题。不过，我们修改了 <code>NetworkTransporter</code> 的 <code>send()</code> 函数的定义，而这个类用到了 <code>send()</code> 函数，所以我们需要对它做相应的修改，修改后的代码如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HtmlDownloader</span> </span>&#123;  <span class="hljs-keyword">private</span> NetworkTransporter transporter;<span class="hljs-comment">//通过构造函数或IOC注入</span>    <span class="hljs-comment">// HtmlDownloader这里也要有相应的修改</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Html <span class="hljs-title">downloadHtml</span><span class="hljs-params">(String url)</span> </span>&#123;    HtmlRequest htmlRequest = <span class="hljs-keyword">new</span> HtmlRequest(url);    Byte[] rawHtml = transporter.send(      htmlRequest.getAddress(), htmlRequest.getContent().getBytes());    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Html(rawHtml);  &#125;&#125;</code></pre><p><strong>最后来看下 <code>Document</code> 类</strong>。这个类的问题比较多，主要有三点。第一，构造函数中的 <code>downloader.downloadHtml()</code> 逻辑复杂，耗时长，不应该放到构造函数中，会影响代码的可测试性。代码的可测试性我们后面会讲到，这里你先知道有这回事就可以了。第二，<code>HtmlDownloader</code> 对象在构造函数中通过 <code>new</code> 来创建，违反了基于接口而非实现编程的设计思想，也会影响到代码的可测试性。第三，从业务含义上来讲，<code>Document</code> 网页文档没必要依赖 <code>HtmlDownloader</code> 类，违背了迪米特法则。</p><p>虽然 <code>Document</code> 类的问题很多，但修改起来比较简单，只要一处改动就可以解决所有问题。修改之后的代码如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Document</span> </span>&#123;  <span class="hljs-keyword">private</span> Html html;  <span class="hljs-keyword">private</span> String url;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Document</span><span class="hljs-params">(String url, Html html)</span> </span>&#123;    <span class="hljs-keyword">this</span>.html = html;    <span class="hljs-keyword">this</span>.url = url;  &#125;  <span class="hljs-comment">//...</span>&#125;<span class="hljs-comment">// 通过一个工厂方法来创建Document</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DocumentFactory</span> </span>&#123;  <span class="hljs-keyword">private</span> HtmlDownloader downloader;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DocumentFactory</span><span class="hljs-params">(HtmlDownloader downloader)</span> </span>&#123;    <span class="hljs-keyword">this</span>.downloader = downloader;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Document <span class="hljs-title">createDocument</span><span class="hljs-params">(String url)</span> </span>&#123;    Html html = downloader.downloadHtml(url);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Document(url, html);  &#125;&#125;</code></pre><h2 id="理论解读与代码实战二"><a href="#理论解读与代码实战二" class="headerlink" title="理论解读与代码实战二"></a>理论解读与代码实战二</h2><p>再来看一下这条原则中的后半部分：“<strong>有依赖关系的类之间，尽量只依赖必要的接口</strong>”。还是结合一个例子来讲解。</p><p>下面这段代码非常简单，<code>Serialization</code> 类负责对象的序列化和反序列化。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Serialization</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">serialize</span><span class="hljs-params">(Object object)</span> </span>&#123;    String serializedResult = ...;    <span class="hljs-comment">//...</span>    <span class="hljs-keyword">return</span> serializedResult;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">deserialize</span><span class="hljs-params">(String str)</span> </span>&#123;    Object deserializedResult = ...;    <span class="hljs-comment">//...</span>    <span class="hljs-keyword">return</span> deserializedResult;  &#125;&#125;</code></pre><p>单看这个类的设计，没有一点问题。不过，如果我们把它放到一定的应用场景里，那就还有继续优化的空间。假设在我们的项目中，有些类只用到了序列化操作，而另一些类只用到反序列化操作。那基于迪米特法则后半部分“有依赖关系的类之间，尽量只依赖必要的接口”，只用到序列化操作的那部分类不应该依赖反序列化接口。同理，只用到反序列化操作的那部分类不应该依赖序列化接口。</p><p>根据这个思路，我们应该将 <code>Serialization</code> 类拆分为两个更小粒度的类，一个只负责序列化（<code>Serializer</code> 类），一个只负责反序列化（<code>Deserializer</code> 类）。拆分之后，使用序列化操作的类只需要依赖 <code>Serializer</code> 类，使用反序列化操作的类只需要依赖 <code>Deserializer</code> 类。拆分之后的代码如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Serializer</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">serialize</span><span class="hljs-params">(Object object)</span> </span>&#123;    String serializedResult = ...;    ...    <span class="hljs-keyword">return</span> serializedResult;  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Deserializer</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">deserialize</span><span class="hljs-params">(String str)</span> </span>&#123;    Object deserializedResult = ...;    ...    <span class="hljs-keyword">return</span> deserializedResult;  &#125;&#125;</code></pre><p>尽管拆分之后的代码更能满足迪米特法则，但却违背了高内聚的设计思想。高内聚要求相近的功能要放到同一个类中，这样可以方便功能修改的时候，修改的地方不至于过于分散。对于刚刚这个例子来说，如果我们修改了序列化的实现方式，比如从 <code>JSON</code> 换成了 <code>XML</code>，那反序列化的实现逻辑也需要一并修改。在未拆分的情况下，我们只需要修改一个类即可。在拆分之后，我们需要修改两个类。显然，这种设计思路的代码改动范围变大了。</p><p>实际上，通过引入两个接口就能轻松解决这个问题，具体的代码如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Serializable</span> </span>&#123;  <span class="hljs-function">String <span class="hljs-title">serialize</span><span class="hljs-params">(Object object)</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Deserializable</span> </span>&#123;  <span class="hljs-function">Object <span class="hljs-title">deserialize</span><span class="hljs-params">(String text)</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Serialization</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span>, <span class="hljs-title">Deserializable</span> </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">serialize</span><span class="hljs-params">(Object object)</span> </span>&#123;    String serializedResult = ...;    ...    <span class="hljs-keyword">return</span> serializedResult;  &#125;    <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">deserialize</span><span class="hljs-params">(String str)</span> </span>&#123;    Object deserializedResult = ...;    ...    <span class="hljs-keyword">return</span> deserializedResult;  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoClass_1</span> </span>&#123;  <span class="hljs-keyword">private</span> Serializable serializer;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo</span><span class="hljs-params">(Serializable serializer)</span> </span>&#123;    <span class="hljs-keyword">this</span>.serializer = serializer;  &#125;  <span class="hljs-comment">//...</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoClass_2</span> </span>&#123;  <span class="hljs-keyword">private</span> Deserializable deserializer;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo</span><span class="hljs-params">(Deserializable deserializer)</span> </span>&#123;    <span class="hljs-keyword">this</span>.deserializer = deserializer;  &#125;  <span class="hljs-comment">//...</span>&#125;</code></pre><p>尽管我们还是要往 <code>DemoClass_1</code> 的构造函数中，传入包含序列化和反序列化的 <code>Serialization</code> 实现类，但是，我们依赖的 <code>Serializable</code> 接口只包含序列化操作，<code>DemoClass_1</code> 无法使用 <code>Serialization</code> 类中的反序列化接口，对反序列化操作无感知，这也就符合了迪米特法则后半部分所说的“依赖有限接口”的要求。</p><p>实际上，上面的的代码实现思路，也体现了“基于接口而非实现编程”的设计原则，结合迪米特法则，我们可以总结出一条新的设计原则，那就是“基于最小接口而非最大实现编程”。有些同学之前问，新的设计模式和设计原则是怎么创造出来的，实际上，就是在大量的实践中，针对开发痛点总结归纳出来的套路。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p><strong>如何理解“高内聚、松耦合”？</strong></p><p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。</p><p>所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</p><p><strong>如何理解“迪米特法则”？</strong></p><p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</p><p>参考：<a href="https://time.geekbang.org/column/article/179615" target="_blank" rel="noopener">理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(设计原则)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（十九）</title>
    <link href="/passages/design-pattern-learn-19/"/>
    <url>/passages/design-pattern-learn-19/</url>
    
    <content type="html"><![CDATA[<!-- more --><p><code>DRY</code> 原则：<code>Don’t Repeat Yourself</code></p><h2 id="代码复用性（Code-Reusability）"><a href="#代码复用性（Code-Reusability）" class="headerlink" title="代码复用性（Code Reusability）"></a>代码复用性（Code Reusability）</h2><p>代码的复用性是评判代码质量的一个非常重要的标准。</p><p><strong>什么是代码的复用性？</strong></p><p>首先来区分三个概念：代码复用性（<code>Code Reusability</code>）、代码复用（<code>Code Resue</code>）和 <code>DRY</code> 原则。</p><p>代码复用表示一种行为：我们在开发新功能的时候，尽量复用已经存在的代码。代码的可复用性表示一段代码可被复用的特性或能力：我们在编写代码的时候，让代码尽量可复用。<code>DRY</code> 原则是一条原则：不要写重复的代码。从定义描述上，它们好像有点类似，但深究起来，三者的区别还是蛮大的。</p><p><strong>首先，“不重复”并不代表“可复用”</strong>。在一个项目代码中，可能不存在任何重复的代码，但也并不表示里面有可复用的代码，不重复和可复用完全是两个概念。所以，从这个角度来说，<code>DRY</code> 原则跟代码的可复用性讲的是两回事。</p><p><strong>其次，“复用”和“可复用性”关注角度不同</strong>。代码“可复用性”是从代码开发者的角度来讲的，“复用”是从代码使用者的角度来讲的。比如，<code>A</code> 同事编写了一个 <code>UrlUtils</code> 类，代码的“可复用性”很好。<code>B</code> 同事在开发新功能的时候，直接“复用”<code>A</code> 同事编写的 <code>UrlUtils</code> 类。</p><p>尽管复用、可复用性、<code>DRY</code> 原则这三者从理解上有所区别，但实际上要达到的目的都是类似的，都是为了减少代码量，提高代码的可读性、可维护性。除此之外，复用已经经过测试的老代码，<code>bug</code> 会比从零重新开发要少。</p><p>“复用”这个概念不仅可以指导细粒度的模块、类、函数的设计开发，实际上，一些框架、类库、组件等的产生也都是为了达到复用的目的。比如，<code>Spring</code> 框架、<code>Google Guava</code> 类库、<code>UI</code> 组件等等。</p><h2 id="怎么提高代码复用性？"><a href="#怎么提高代码复用性？" class="headerlink" title="怎么提高代码复用性？"></a>怎么提高代码复用性？</h2><ul><li>减少代码耦合</li></ul><p>对于高度耦合的代码，当我们希望复用其中的一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。所以，高度耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。</p><ul><li>满足单一职责原则</li></ul><p>如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合。根据上一点，也就会影响到代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用。</p><ul><li>模块化</li></ul><p>这里的“模块”，不单单指一组类构成的模块，还可以理解为单个类、函数。我们要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。</p><ul><li>业务与非业务逻辑分离</li></ul><p>越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。所以，为了复用跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。</p><ul><li>通用代码下沉、</li></ul><p>从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码我们尽量下沉到更下层。</p><ul><li>继承、多态、抽象、封装</li></ul><p>在讲面向对象特性的时候，我们讲到，利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。</p><ul><li>应用模板等设计模式</li></ul><p>一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用。关于应用设计模式提高代码复用性这一部分，我们留在后面慢慢来讲解。</p><p>除了刚刚的几点，还有一些跟编程语言相关的特性，也能提高代码的复用性，比如泛型编程等。实际上，除了上面讲到的这些方法之外，复用意识也非常重要。在写代码的时候，我们要多去思考一下，这个部分代码是否可以抽取出来，作为一个独立的模块、类或者函数供多处使用。在设计每个模块、类、函数的时候，要像设计一个外部 <code>API</code> 那样，去思考它的复用性。</p><h2 id="辩证思考和灵活应用"><a href="#辩证思考和灵活应用" class="headerlink" title="辩证思考和灵活应用"></a>辩证思考和灵活应用</h2><p>实际上，编写可复用的代码并不简单。如果我们在编写代码的时候，已经有复用的需求场景，那根据复用的需求去开发可复用的代码，可能还不算难。但是，如果当下并没有复用的需求，我们只是希望现在编写的代码具有可复用的特点，能在未来某个同事开发某个新功能的时候复用得上。在这种没有具体复用需求的情况下，我们就需要去预测将来代码会如何复用，这就比较有挑战了。</p><p>实际上，除非有非常明确的复用需求，否则，为了暂时用不到的复用需求，花费太多的时间、精力，投入太多的开发成本，并不是一个值得推荐的做法。这也违反我们之前讲到的 <code>YAGNI</code> 原则。</p><p>除此之外，有一个著名的原则，叫作“<code>Rule of Three</code>”。这条原则可以用在很多行业和场景中，你可以自己去研究一下。如果把这个原则用在这里，那就是说，我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后我们开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。</p><p>也就是说，第一次编写代码的时候，我们不考虑复用性；第二次遇到复用场景的时候，再进行重构使其复用。需要注意的是，“<code>Rule of Three</code>”中的“<code>Three</code>”并不是真的就指确切的“三”，这里就是指“二”。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p><strong>DRY 原则</strong></p><p>大致有三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复。实现逻辑重复，但功能语义不重复的代码，并不违反 <code>DRY</code> 原则。实现逻辑不重复，但功能语义重复的代码，也算是违反 <code>DRY</code> 原则。除此之外，代码执行重复也算是违反 DRY 原则。</p><p><strong>代码复用性</strong></p><p>提高代码可复用性的一些方法，有以下 7 点。</p><ul><li>减少代码耦合</li><li>满足单一职责原则</li><li>模块化</li><li>业务与非业务逻辑分离</li><li>通用代码下沉</li><li>继承、多态、抽象、封装</li><li>应用模板等设计模式</li></ul><p>实际上，除了上面讲到的这些方法之外，复用意识也非常重要。在设计每个模块、类、函数的时候，要像设计一个外部 <code>API</code> 一样去思考它的复用性。</p><p>在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。</p><p>相比于代码的可复用性，<code>DRY</code> 原则适用性更强一些。我们可以不写可复用的代码，但一定不能写重复的代码。</p><p>参考：<a href="https://time.geekbang.org/column/article/179607" target="_blank" rel="noopener">理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(设计原则)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java的内存结构</title>
    <link href="/passages/java-memory-structure/"/>
    <url>/passages/java-memory-structure/</url>
    
    <content type="html"><![CDATA[<!-- more --><p><code>Java</code> 的运行时数据区域分为五大数据区域。这些区域各有各的用途，创建及销毁时间。如下图所示，其中方法区和堆是所有线程共享的，虚拟机栈，本地方法栈和程序计数器则为线程私有的。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/12/18/a5328860-2164-11ea-b270-e1ada5ee6906.png" srcset="/img/loading.gif" alt="image.png"><br>根据<code>Java</code>虚拟机规范，<code>Java</code>虚拟机管理的内存分为<strong>方法区、堆、虚拟机栈、本地方法栈、程序计数器栈</strong>五大区域。</p><h2 id="程序计数器-Program-Counter-Register"><a href="#程序计数器-Program-Counter-Register" class="headerlink" title="程序计数器(Program Counter Register)"></a>程序计数器(Program Counter Register)</h2><p>程序计数器是一块很小的内存空间，它是线程私有的，可以认作为当前线程的行号指示器。</p><p>在虚拟机的概念模型里,字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。由于<code>Java</code>虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，对于一个处理器(如果是多核<code>CPU</code>那就是一核)来说，在一个确定的时刻只会执行一条线程中的指令，而一条线程中有多个指令，为了线程切换可以恢复到正确执行位置，每个线程都需有独立的一个程序计数器，不同线程之间的程序计数器互不影响，独立存储。</p><p>如果线程执行的是个<code>Java</code>方法，那么计数器记录的是虚拟机字节码指令的地址。如果为<code>native</code>底层方法，那么计数器为空(<code>Undefined</code>)。这块内存区域是虚拟机规范中唯一没有<code>OutOfMemoryError</code>的区域。</p><h2 id="Java栈-虚拟机栈-Java-Virtual-Mechine-Stacks"><a href="#Java栈-虚拟机栈-Java-Virtual-Mechine-Stacks" class="headerlink" title="Java栈(虚拟机栈)(Java Virtual Mechine Stacks)"></a>Java栈(虚拟机栈)(Java Virtual Mechine Stacks)</h2><p><code>Java</code>栈同计数器也为线程私有，生命周期相同，就是平时说的栈，<strong>栈描述的是<code>Java</code>方法执行的内存模型</strong>。<br>每个方法被执行的时候都会创建一个<strong>栈帧</strong>用于<strong>存储局部变量表，操作栈，动态链接，方法出口</strong>等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><blockquote><p>栈帧(<code>Stack Frame</code>): 是用来存储数据和部分过程结果的数据结构。<br>栈帧的位置:  内存 -&gt; 运行时数据区 -&gt; 某个线程对应的虚拟机栈 -&gt; <code>here</code><br>栈帧大小确定时间: 编译期确定，不受运行期数据影响。</p></blockquote><p>通常有人将<code>Java</code>内存区分为栈(<code>Stacks</code>)和堆(<code>Heap</code>)，实际上<code>Java</code>内存比这复杂，这么区分可能是因为我们最关注的与对象内存分配关系最密切的是这两个，平时说的栈一般就是指局部变量表。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/12/18/ce696dc0-2169-11ea-b270-e1ada5ee6906.png" srcset="/img/loading.gif" alt="image.png"><br><strong>局部变量表</strong>: 一片连续的内存空间，用来存放方法参数，以及方法内定义的局部变量，存放着编译期间已知的数据类型(八大基本类型和对象引用(<code>reference</code>类型)，<code>returnAddress</code>类型。它的最小的局部变量表空间单位为<code>Slot</code>，虚拟机没有指明<code>Slot</code>的大小，但在<code>JVM</code>中，<code>long</code>和<code>double</code>类型数据明确规定为<code>64</code>位，这两个类型占<code>2</code>个<code>Slot</code>，其它基本类型固定占用<code>1</code>个<code>Slot</code>。</p><p><strong><code>reference</code>类型</strong>: 与基本类型不同的是它不等同本身，即使是<code>String</code>，内部也是<code>char</code>数组组成，它可能是指向一个对象起始位置指针，也可能指向一个代表对象的句柄或其他与该对象有关的位置。</p><p><strong><code>returnAddress</code>类型</strong>: 指向一条字节码指令的地址</p><p>需要注意的是，<strong>局部变量表所需要的内存空间在编译期完成分配，当进入一个方法时，这个方法在栈中需要分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表大小</strong>。</p><p><code>Java</code>虚拟机栈可能出现两种类型的异常：</p><ul><li>线程请求的栈深度大于虚拟机允许的栈深度，将抛出<code>StackOverflowError</code>。</li><li>虚拟机栈空间可以动态扩展，当动态扩展是无法申请到足够的空间时，抛出<code>OutOfMemory</code>异常。</li></ul><h2 id="本地方法栈-Native-Method-Stack"><a href="#本地方法栈-Native-Method-Stack" class="headerlink" title="本地方法栈(Native Method Stack)"></a>本地方法栈(Native Method Stack)</h2><p>本地方法栈是与虚拟机栈发挥的作用十分相似，区别是虚拟机栈执行的是<code>Java</code>方法(也就是字节码)，而本地方法栈则为虚拟机使用到的<code>native</code>方法服务，可能底层会调用<code>C</code>或者<code>C++</code>，我们打开<code>jdk</code>安装目录可以看到也有很多用<code>C</code>编写的文件，可能就是<code>native</code>方法所调用的<code>C</code>代码。</p><h2 id="堆-Java-Heap"><a href="#堆-Java-Heap" class="headerlink" title="堆(Java Heap)"></a>堆(Java Heap)</h2><p>堆是<code>Java</code>虚拟机管理内存最大的一块内存区域，因为堆存放的对象是线程共享的，所以多线程的时候也需要同步机制。<code>Java</code>堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一作用就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p><p><code>Java</code>虚拟机规范中的描述是: 所有的对象实例以及数组都要在堆上分配，但是随着<code>JIT</code>编译器的发展与逃逸分析技术逐断成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</p><blockquote><p>即时编译器: 可以把<code>Java</code>的字节码，包括需要被解释的指令的程序转换成可以直接发送给处理器的指令的程序)</p><p>逃逸分析: 通过逃逸分析来决定某些实例或者变量是否要在堆中进行分配，如果开启了逃逸分析，即可将这些变量直接在栈上进行分配，而非堆上进行分配。这些变量的指针可以被全局所引用，或者其其它线程所引用。</p></blockquote><p><code>Java</code>堆是垃圾收集器管理的主要区域，因此很多时候也被称做“<code>GC</code>堆”。从内存回收的角度来看，由于收集器基本都采用分代收集算法，所以<code>Java</code>堆中还可以细分为: 新生代和老年代，再细致一点的有<code>Eden</code>空间、<code>From Survivor</code>空间、<code>To Survivor</code>空间等。</p><p>根据<code>Java</code>虛拟机规范的规定，<code>Java</code> 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的(通过<code>-Xmx</code>和<code>-Xms</code>控制)。如果堆中没有内存完成实例分配，而且堆无法扩展将报<code>OOM</code>错误(<code>OutOfMemoryError</code>)。</p><h2 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区(Method Area)"></a>方法区(Method Area)</h2><p>方法区同堆一样，是所有线程共享的内存区域，为了区分堆，又被称为非堆。</p><p>方法区用于存储已被虚拟机加载的类信息、常量、静态变量，如<code>static</code>修饰的变量加载类的时候就被加载到方法区中。</p><blockquote><p><strong>运行时常量池</strong>(<code>Runtime Constant Pool</code>)是方法区的一部分，<code>class</code>文件除了有类的字段、接口、方法等描述信息之外，还有常量池(<code>Constant Pool Table</code>)用于存放编译期间生成的各种字面量和符号引用，这部分内容将在类加载后进人方法区的运行时常量池中存放。</p></blockquote><p>在老版<code>JDK</code>，方法区也被称为永久代。因为没有强制要求方法区必须实现垃圾回收，<code>HotSpot</code>虚拟机以永久代来实现方法区，从而<code>JVM</code>的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。不过自从<code>JDK7</code>之后，<code>Hotspot</code>虚拟机便将运行时常量池从永久代移除了。<code>JDK8</code>真正开始废弃永久代，使用元空间(<code>Metaspace</code>)替代。</p><h2 id="直接内存-Direct-Memory"><a href="#直接内存-Direct-Memory" class="headerlink" title="直接内存(Direct Memory)"></a>直接内存(Direct Memory)</h2><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致<code>OutOfMemoryError</code>异常的出现.</p><p>在<code>JDK 1.4</code>中新加人了<code>NIO</code> (<code>New Input/Output</code>)类，引人了一种基于通道(<code>Channel</code> 与缓冲区(<code>Buffer</code>) 的<code>IO</code>方式，它可以使用<code>Native</code>函数库直接分配堆外内存，然后通过一个存储在<code>Java</code>堆中的<code>DirectByteBuffer</code>对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为它避免了在<code>Java</code>堆和<code>Native</code>堆中来回复制数据。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Java</code>虚拟机管理的内存分为<strong>方法区、堆、虚拟机栈、本地方法栈、程序计数器栈</strong>五大区域。</p><p>程序计数器是一块很小的内存空间，它是线程私有的，可以认作为当前线程的行号指示器。</p><p><code>Java</code>栈同计数器也为线程私有，生命周期相同，就是平时说的栈，<strong>栈描述的是<code>Java</code>方法执行的内存模型</strong>。</p><p>本地方法栈是与虚拟机栈发挥的作用十分相似，区别是虚拟机栈执行的是<code>Java</code>方法(也就是字节码)，而本地方法栈则为虚拟机使用到的<code>native</code>方法服务.</p><p>堆是<code>Java</code>虚拟机管理内存最大的一块内存区域，因为堆存放的对象是线程共享的，所以多线程的时候也需要同步机制，几乎所有的对象实例都在这里分配内存。</p><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但它的存在能在一些场景中显著提高性能。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java内存结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（十八）</title>
    <link href="/passages/design-pattern-learn-18/"/>
    <url>/passages/design-pattern-learn-18/</url>
    
    <content type="html"><![CDATA[<!-- more --><h2 id="如何理解“KISS-原则”？"><a href="#如何理解“KISS-原则”？" class="headerlink" title="如何理解“KISS 原则”？"></a>如何理解“KISS 原则”？</h2><p><code>KISS</code> 原则的英文描述有好几个版本，比如下面这几个。</p><ul><li><code>Keep It Simple and Stupid.</code></li><li><code>Keep It Short and Simple.</code></li><li><code>Keep It Simple and Straightforward.</code></li></ul><p>不过，它们要表达的意思其实差不多，翻译成中文就是：尽量保持简单。</p><p><code>KISS</code> 原则算是一个万金油类型的设计原则，可以应用在很多场景中。它不仅经常用来指导软件开发，还经常用来指导更加广泛的系统设计、产品设计等，比如，冰箱、建筑、<code>iPhone</code> 手机的设计等等。</p><p>代码的可读性和可维护性是衡量代码质量非常重要的两个标准。而 <code>KISS</code> 原则就是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，<code>bug</code> 比较难隐藏。即便出现 <code>bug</code>，修复起来也比较简单。</p><p>不过，这条原则只是告诉我们，要保持代码“<code>Simple and Stupid</code>”，但并没有讲到，什么样的代码才是“<code>Simple and Stupid</code>”的，更没有给出特别明确的方法论，来指导如何开发出“<code>Simple and Stupid</code>”的代码。所以，看着非常简单，但不能落地，这就有点像我们常说的“心灵鸡汤”。这里应该叫“技术鸡汤”。</p><h2 id="代码行数越少就越“简单”吗？"><a href="#代码行数越少就越“简单”吗？" class="headerlink" title="代码行数越少就越“简单”吗？"></a>代码行数越少就越“简单”吗？</h2><p>一起看一个例子，下面这三段代码可以实现同样一个功能：检查输入的字符串 <code>ipAddress</code> 是否是合法的 <code>IP</code> 地址。</p><p>一个合法的 <code>IP</code> 地址由四个数字组成，并且通过“.”来进行分割。每组数字的取值范围是 <code>0~255</code>。第一组数字比较特殊，不允许为 <code>0</code>。对比这三段代码，你觉得哪一段代码最符合 <code>KISS</code> 原则呢？如果让你来实现这个功能，你会选择用哪种实现方法呢？</p><pre><code class="hljs java"><span class="hljs-comment">// 第一种实现方式: 使用正则表达式</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidIpAddressV1</span><span class="hljs-params">(String ipAddress)</span> </span>&#123;  <span class="hljs-keyword">if</span> (StringUtils.isBlank(ipAddress)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  String regex = <span class="hljs-string">"^(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\."</span>          + <span class="hljs-string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."</span>          + <span class="hljs-string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."</span>          + <span class="hljs-string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$"</span>;  <span class="hljs-keyword">return</span> ipAddress.matches(regex);&#125;<span class="hljs-comment">// 第二种实现方式: 使用现成的工具类</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidIpAddressV2</span><span class="hljs-params">(String ipAddress)</span> </span>&#123;  <span class="hljs-keyword">if</span> (StringUtils.isBlank(ipAddress)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  String[] ipUnits = StringUtils.split(ipAddress, <span class="hljs-string">'.'</span>);  <span class="hljs-keyword">if</span> (ipUnits.length != <span class="hljs-number">4</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;    <span class="hljs-keyword">int</span> ipUnitIntValue;    <span class="hljs-keyword">try</span> &#123;      ipUnitIntValue = Integer.parseInt(ipUnits[i]);    &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">if</span> (ipUnitIntValue &lt; <span class="hljs-number">0</span> || ipUnitIntValue &gt; <span class="hljs-number">255</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; ipUnitIntValue == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<span class="hljs-comment">// 第三种实现方式: 不使用任何工具类</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidIpAddressV3</span><span class="hljs-params">(String ipAddress)</span> </span>&#123;  <span class="hljs-keyword">char</span>[] ipChars = ipAddress.toCharArray();  <span class="hljs-keyword">int</span> length = ipChars.length;  <span class="hljs-keyword">int</span> ipUnitIntValue = -<span class="hljs-number">1</span>;  <span class="hljs-keyword">boolean</span> isFirstUnit = <span class="hljs-keyword">true</span>;  <span class="hljs-keyword">int</span> unitsCount = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;    <span class="hljs-keyword">char</span> c = ipChars[i];    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'.'</span>) &#123;      <span class="hljs-keyword">if</span> (ipUnitIntValue &lt; <span class="hljs-number">0</span> || ipUnitIntValue &gt; <span class="hljs-number">255</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      <span class="hljs-keyword">if</span> (isFirstUnit &amp;&amp; ipUnitIntValue == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      <span class="hljs-keyword">if</span> (isFirstUnit) isFirstUnit = <span class="hljs-keyword">false</span>;      ipUnitIntValue = -<span class="hljs-number">1</span>;      unitsCount++;      <span class="hljs-keyword">continue</span>;    &#125;    <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">'0'</span> || c &gt; <span class="hljs-string">'9'</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">if</span> (ipUnitIntValue == -<span class="hljs-number">1</span>) ipUnitIntValue = <span class="hljs-number">0</span>;    ipUnitIntValue = ipUnitIntValue * <span class="hljs-number">10</span> + (c - <span class="hljs-string">'0'</span>);  &#125;  <span class="hljs-keyword">if</span> (ipUnitIntValue &lt; <span class="hljs-number">0</span> || ipUnitIntValue &gt; <span class="hljs-number">255</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">if</span> (unitsCount != <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><p>第一种实现方式利用的是正则表达式，只用三行代码就把这个问题搞定了。它的代码行数最少，那是不是就最符合 <code>KISS</code> 原则呢？答案是否定的。虽然代码行数最少，看似最简单，实际上却很复杂。这正是因为它使用了正则表达式。</p><p>一方面，正则表达式本身是比较复杂的，写出完全没有 <code>bug</code> 的正则表达本身就比较有挑战；另一方面，并不是每个程序员都精通正则表达式。对于不怎么懂正则表达式的同事来说，看懂并且维护这段正则表达式是比较困难的。这种实现方式会导致代码的可读性和可维护性变差，所以，从 <code>KISS</code> 原则的设计初衷上来讲，这种实现方式并不符合 <code>KISS</code> 原则。</p><p>第二种实现方式使用了 <code>StringUtils</code> 类、<code>Integer</code> 类提供的一些现成的工具函数，来处理 <code>IP</code> 地址字符串。</p><p>第三种实现方式，不使用任何工具函数，而是通过逐一处理 <code>IP</code> 地址中的字符，来判断是否合法。从代码行数上来说，这两种方式差不多。但是，第三种要比第二种更加有难度，更容易写出 <code>bug</code>。</p><p>从可读性上来说，第二种实现方式的代码逻辑更清晰、更好理解。所以，在这两种实现方式中，第二种实现方式更加“简单”，更加符合 <code>KISS</code> 原则。</p><p>不过，你可能会想，第三种实现方式虽然实现起来稍微有点复杂，但性能要比第二种实现方式高一些啊。从性能的角度来说，选择第三种实现方式是不是更好些呢？</p><p>先解释一下，为什么说第三种实现方式性能会更高一些。一般来说，工具类的功能都比较通用和全面，所以，在代码实现上，需要考虑和处理更多的细节，执行效率就会有所影响。而第三种实现方式，完全是自己操作底层字符，只针对 <code>IP</code> 地址这一种格式的数据输入来做处理，没有太多多余的函数调用和其他不必要的处理逻辑，所以，在执行效率上，这种类似定制化的处理代码方式肯定比通用的工具类要高些。</p><p>不过，尽管第三种实现方式性能更高些，但我还是更倾向于选择第二种实现方法。那是因为第三种实现方式实际上是一种过度优化。除非 <code>isValidIpAddress()</code> 函数是影响系统性能的瓶颈代码，否则，这样优化的投入产出比并不高，增加了代码实现的难度、牺牲了代码的可读性，性能上的提升却并不明显。</p><h2 id="代码逻辑复杂就违背-KISS-原则吗？"><a href="#代码逻辑复杂就违背-KISS-原则吗？" class="headerlink" title="代码逻辑复杂就违背 KISS 原则吗？"></a>代码逻辑复杂就违背 KISS 原则吗？</h2><p>并不是代码行数越少就越“简单”，还要考虑逻辑复杂度、实现难度、代码的可读性等。那如果一段代码的逻辑复杂、实现难度大、可读性也不太好，是不是就一定违背 <code>KISS</code> 原则呢？先看一段代码：</p><pre><code class="hljs java"><span class="hljs-comment">// KMP algorithm: a, b分别是主串和模式串；n, m分别是主串和模式串的长度。</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> m)</span> </span>&#123;  <span class="hljs-keyword">int</span>[] next = getNexts(b, m);  <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;    <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; a[i] != b[j]) &#123; <span class="hljs-comment">// 一直找到a[i]和b[j]</span>      j = next[j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">if</span> (a[i] == b[j]) &#123;      ++j;    &#125;    <span class="hljs-keyword">if</span> (j == m) &#123; <span class="hljs-comment">// 找到匹配模式串的了</span>      <span class="hljs-keyword">return</span> i - m + <span class="hljs-number">1</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// b表示模式串，m表示模式串的长度</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] getNexts(<span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> m) &#123;  <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];  next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;  <span class="hljs-keyword">int</span> k = -<span class="hljs-number">1</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; ++i) &#123;    <span class="hljs-keyword">while</span> (k != -<span class="hljs-number">1</span> &amp;&amp; b[k + <span class="hljs-number">1</span>] != b[i]) &#123;      k = next[k];    &#125;    <span class="hljs-keyword">if</span> (b[k + <span class="hljs-number">1</span>] == b[i]) &#123;      ++k;    &#125;    next[i] = k;  &#125;  <span class="hljs-keyword">return</span> next;&#125;</code></pre><p>这段代码完全符合我们刚提到的逻辑复杂、实现难度大、可读性差的特点，但它并不违反 <code>KISS</code> 原则。为什么这么说呢？</p><p><code>KMP</code> 算法以快速高效著称。当我们需要处理长文本字符串匹配问题（几百 <code>MB</code> 大小文本内容的匹配），或者字符串匹配是某个产品的核心功能（比如 <code>Vim</code>、<code>Word</code> 等文本编辑器），又或者字符串匹配算法是系统性能瓶颈的时候，我们就应该选择尽可能高效的 <code>KMP</code> 算法。而 <code>KMP</code> 算法本身具有逻辑复杂、实现难度大、可读性差的特点。本身就复杂的问题，用复杂的方法解决，并不违背 <code>KISS</code> 原则。</p><p>不过，平时的项目开发中涉及的字符串匹配问题，大部分都是针对比较小的文本。在这种情况下，直接调用编程语言提供的现成的字符串匹配函数就足够了。如果非得用 <code>KMP</code> 算法、<code>BM</code> 算法来实现字符串匹配，那就真的违背 <code>KISS</code> 原则了。也就是说，同样的代码，在某个业务场景下满足 <code>KISS</code> 原则，换一个应用场景可能就不满足了。</p><h2 id="如何写出满足-KISS-原则的代码？"><a href="#如何写出满足-KISS-原则的代码？" class="headerlink" title="如何写出满足 KISS 原则的代码？"></a>如何写出满足 KISS 原则的代码？</h2><ul><li>不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。</li><li>不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 <code>bug</code> 的概率会更高，维护的成本也比较高。</li><li>不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 <code>if-else</code>、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。</li></ul><p>实际上，代码是否足够简单是一个挺主观的评判。同样的代码，有的人觉得简单，有的人觉得不够简单。而往往自己编写的代码，自己都会觉得够简单。所以，评判代码是否简单，还有一个很有效的间接方法，那就是 <code>code review</code>。如果在 <code>code review</code> 的时候，同事对你的代码有很多疑问，那就说明你的代码有可能不够“简单”，需要优化啦。</p><p>我们在做开发的时候，一定不要过度设计，不要觉得简单的东西就没有技术含量。实际上，越是能用简单的方法解决复杂的问题，越能体现一个人的能力。</p><h2 id="YAGNI-跟-KISS-说的是一回事吗？"><a href="#YAGNI-跟-KISS-说的是一回事吗？" class="headerlink" title="YAGNI 跟 KISS 说的是一回事吗？"></a>YAGNI 跟 KISS 说的是一回事吗？</h2><p><code>YAGNI</code> 原则的英文全称是：<code>You Ain’t Gonna Need It</code>。直译就是：你不会需要它。这条原则也算是万金油了。当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。</p><p>比如，不要在项目中提前引入不需要依赖的开发包。对于 <code>Java</code> 程序员来说，我们经常使用 <code>Maven</code> 或者 <code>Gradle</code> 来管理依赖的类库（<code>library</code>）。有些同事为了避免开发中 <code>library</code> 包缺失而频繁地修改 <code>Maven</code> 或者 <code>Gradle</code> 配置文件，提前往项目里引入大量常用的 <code>library</code> 包。实际上，这样的做法也是违背 <code>YAGNI</code> 原则的。</p><p>从刚刚的分析可以看出，<code>YAGNI</code> 原则跟 <code>KISS</code> 原则并非一回事儿。<code>KISS</code> 原则讲的是“如何做”的问题（尽量保持简单），而 <code>YAGNI</code> 原则说的是“要不要做”的问题（当前不需要的就不要做）。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p><code>KISS</code> 原则是保持代码可读和可维护的重要手段。<code>KISS</code> 原则中的“简单”并不是以代码行数来考量的。代码行数越少并不代表代码越简单，我们还要考虑逻辑复杂度、实现难度、代码的可读性等。而且，本身就复杂的问题，用复杂的方法解决，并不违背 <code>KISS</code> 原则。除此之外，同样的代码，在某个业务场景下满足 <code>KISS</code> 原则，换一个应用场景可能就不满足了。</p><p>如何写出满足 <code>KISS</code> 原则的代码，有下面几条指导原则：</p><ul><li>不要使用同事可能不懂的技术来实现代码；</li><li>不要重复造轮子，要善于使用已经有的工具类库；</li><li>不要过度优化。</li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>你怎么看待在开发中重复造轮子这件事情？什么时候要重复造轮子？什么时候应该使用现成的工具类库、开源框架？</li></ul><p>参考：<a href="https://time.geekbang.org/column/article/177448" target="_blank" rel="noopener">理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(设计原则)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java的内存模型</title>
    <link href="/passages/java-memory-model/"/>
    <url>/passages/java-memory-model/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>首先给出定义，<code>Java</code>内存模型（<code>Java Memory Model</code> ,<code>JMM</code>）是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了<code>Java</code>程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p><p>在弄懂<code>JMM</code>之前，我们要先了解下<code>CPU</code>和内存是如何交互的。</p><h2 id="CPU和高速缓存以及内存-主存-的交互"><a href="#CPU和高速缓存以及内存-主存-的交互" class="headerlink" title="CPU和高速缓存以及内存(主存)的交互"></a>CPU和高速缓存以及内存(主存)的交互</h2><p><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/12/17/9e3867c0-20a9-11ea-8db3-9950b8386e73.png" srcset="/img/loading.gif" alt="image.png"><br>从图中可以看出在多<code>CPU</code>的系统中，每个<code>CPU</code>都有都有各自的高速缓存，一般分为<code>L1</code>、<code>L2</code>、<code>L3</code>缓存，因为这些缓存的存在，提供了数据的访问性能，也减轻了数据总线上数据传输的压力，而主内存却只有一个 。<br><code>CPU</code>要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找，每个<code>CPU</code>有且只有一套自己的缓存。</p><p>但是问题也就来了，如果两个<code>CPU</code>同时去操作同一个内存地址，会发生什么？也就是说，如何保证多个处理器运算涉及到同一个内存区域时，多线程场景下的缓存一致性问题？运行时如何保证数据一致性？那就是<strong>内存屏障</strong>(<code>Memory Barrier</code>)。</p><p><strong>内存屏障</strong></p><p><code>CPU</code>中的高速缓存提高了数据访问性能，避免每次都向内存索取，但是不能实时的和内存发生信息交换。在不同<code>CPU</code>执行的不同线程对同一个变量的缓存值可能是不同的，由此就出现了内存屏障，硬件层的内存屏障分为两种：<code>Load Barrier</code> 和 <code>Store Barrier</code>即读屏障和写屏障。</p><p>内存屏障的作用主要有两点：</p><ul><li>阻止屏障两侧指令重排序</li><li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。</li></ul><p>之所以扯了那么多计算机内存模型，是因为<code>Java</code>内存模型的设定符合了计算机的规范。</p><p>实际上，<code>JMM</code>是<code>JVM</code>的一种规范，定义了<code>JVM</code>的内存模型。<br>它屏蔽了各种硬件和操作系统的访问差异，不像<code>C</code>那样直接访问硬件内存，相对安全很多。<br>它的主要目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。可以保证并发编程场景中的原子性、可见性和有序性。</p><h2 id="Java内存模型的应用"><a href="#Java内存模型的应用" class="headerlink" title="Java内存模型的应用"></a>Java内存模型的应用</h2><p><code>Java</code>中的几个关键字：<code>volatile</code>、<code>final</code>、<code>synchronized</code>，可以帮助程序员把代码中的并发需求描述给编译器。<code>Java</code>内存模型中定义了它们的行为，以确保正确同步的<code>Java</code>代码在所有的处理器架构上都能正确执行。</p><p><strong>volatile</strong></p><p>在<code>Java</code>中，<code>volatile</code>关键字可以解决上面的问题，<code>Java</code>屏蔽掉这些差异，通过<code>JVM</code>生成内存屏障的指令。</p><p>当我们声明某个变量为<code>volatile</code>修饰时，这个变量就有了线程可见性，<code>volatile</code>会在读写操作前后添加内存屏障。<code>volatile</code>字段的每次读行为都能看到其它线程最后一次对该字段的写行为，通过它就可以避免拿到缓存中陈旧数据。它们必须保证在被写入之后，会被刷新到主内存中，这样就可以立即对其它线程可以见。</p><p><strong>final</strong></p><p>如果一个类包含<code>final</code>字段，且在构造函数中初始化，那么正确的构造一个对象后，<code>final</code>字段被设置后对于其它线程是可见的。</p><p>注意这里所说的正确构造对象，意思是在对象的构造过程中，不允许对该对象进行引用，不然的话，可能存在其它线程在对象还没构造完成时就对该对象进行访问，造成其他的问题。</p><p><strong>synchronized</strong></p><p>对于一个被<code>synchronized</code>修饰的<code>monitor</code>对象，只能够被一个线程持有，意味着一旦有线程进入了同步代码块，那么其它线程就不能进入，直到第一个进入的线程退出代码块。</p><p>在一个线程退出同步块时，线程释放<code>monitor</code>对象，它的作用是把<code>CPU</code>缓存数据（本地缓存数据）刷新到主内存中，从而实现该线程的行为可以被其它线程看到。在其它线程进入到该代码块时，需要获得<code>monitor</code>对象，它在作用是使<code>CPU</code>缓存失效，从而使变量从主内存中重新加载，然后就可以看到之前线程对该变量的修改。</p><p>但从缓存的角度看，这个问题只会影响多处理器的机器，对于单核来说没什么问题，但是它还有一个语义是禁止指令的重排序，对于编译器来说，同步块中的代码不会移动到获取和释放<code>monitor</code>的外面。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>JMM</code>是<code>JVM</code>的一种规范，定义了<code>JVM</code>的内存模型。它的主要目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。可以保证并发编程场景中的原子性、可见性和有序性。</p><p>在<code>Java</code>中，<code>volatile</code>、<code>final</code>、<code>synchronized</code>这三个关键字是对与内存模型的具体实现。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java内存模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（十七）</title>
    <link href="/passages/design-pattern-learn-17/"/>
    <url>/passages/design-pattern-learn-17/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>首先提出问题：</p><ul><li><p>“依赖反转”这个概念指的是“谁跟谁”的“什么依赖”被反转了？“反转”两个字该如何理解？</p></li><li><p>我们还经常听到另外两个概念：“控制反转”和“依赖注入”。这两个概念跟“依赖反转”有什么区别和联系呢？它们说的是同一个事情吗？</p></li><li><p>如果你熟悉 <code>Java</code> 语言，那 <code>Spring</code> 框架中的 <code>IOC</code> 跟这些概念又有什么关系呢？</p></li></ul><h2 id="控制反转（IOC）"><a href="#控制反转（IOC）" class="headerlink" title="控制反转（IOC）"></a>控制反转（IOC）</h2><p>控制反转的英文翻译是 <code>Inversion Of Control</code>，缩写为 <code>IOC</code>。此处我要强调一下，如果你是 <code>Java</code> 工程师的话，暂时别把这个“<code>IOC</code>”跟 <code>Spring</code> 框架的 <code>IOC</code> 联系在一起。</p><p>先通过一个例子来看一下，什么是控制反转。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceTest</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">doTest</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// ... </span>  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//这部分逻辑可以放到框架中</span>    <span class="hljs-keyword">if</span> (doTest()) &#123;      System.out.println(<span class="hljs-string">"Test succeed."</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      System.out.println(<span class="hljs-string">"Test failed."</span>);    &#125;  &#125;&#125;</code></pre><p>在上面的代码中，所有的流程都由程序员来控制。如果我们抽象出一个下面这样一个框架，我们再来看，如何利用框架来实现同样的功能。具体的代码实现如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCase</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (doTest()) &#123;      System.out.println(<span class="hljs-string">"Test succeed."</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      System.out.println(<span class="hljs-string">"Test failed."</span>);    &#125;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doTest</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JunitApplication</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;TestCase&gt; testCases = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(TestCase testCase)</span> </span>&#123;    testCases.add(testCase);  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">for</span> (TestCase <span class="hljs-keyword">case</span>: testCases) &#123;      <span class="hljs-keyword">case</span>.run();    &#125;  &#125;&#125;</code></pre><p>把这个简化版本的测试框架引入到工程中之后，只需要在框架预留的扩展点，也就是 <code>TestCase</code> 类中的 <code>doTest()</code> 抽象函数中，填充具体的测试代码就可以实现之前的功能了，完全不需要写负责执行流程的 <code>main()</code> 函数了。 具体的代码如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestCase</span> </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">doTest</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// ... </span>  &#125;&#125;<span class="hljs-comment">// 注册操作还可以通过配置的方式来实现，不需要程序员显示调用register()</span>JunitApplication.register(<span class="hljs-keyword">new</span> UserServiceTest();</code></pre><p>框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。</p><p>这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。</p><p>实际上，实现控制反转的方法有很多，除了刚才例子中所示的类似于模板设计模式的方法之外，还有依赖注入等方法，所以，控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。</p><h2 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h2><p>接下来，我们再来看依赖注入。依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。依赖注入的英文翻译是 <code>Denpendecny Injection</code>，缩写为 <code>DI</code>。对于这个概念，有一个非常形象的说法，那就是：依赖注入是一个标价 <code>25</code> 美元，实际上只值 <code>5</code> 美分的概念。也就是说，这个概念听起来很“高大上”，实际上，理解、应用起来非常简单。</p><p>用一句话来概括就是：不通过 <code>new()</code> 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。</p><p>通过一个例子来解释一下。在这个例子中，<code>Notification</code> 类负责消息推送，依赖 <code>MessageSender</code> 类实现推送商品促销、验证码等消息给用户。我们分别用依赖注入和非依赖注入两种方式来实现一下。具体的实现代码如下所示：</p><pre><code class="hljs java"><span class="hljs-comment">// 非依赖注入实现方式</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Notification</span> </span>&#123;  <span class="hljs-keyword">private</span> MessageSender messageSender;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Notification</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>.messageSender = <span class="hljs-keyword">new</span> MessageSender(); <span class="hljs-comment">//此处有点像hardcode</span>  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(String cellphone, String message)</span> </span>&#123;    <span class="hljs-comment">//...省略校验逻辑等...</span>    <span class="hljs-keyword">this</span>.messageSender.send(cellphone, message);  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageSender</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(String cellphone, String message)</span> </span>&#123;    <span class="hljs-comment">//....</span>  &#125;&#125;<span class="hljs-comment">// 使用Notification</span>Notification notification = <span class="hljs-keyword">new</span> Notification();<span class="hljs-comment">// 依赖注入的实现方式</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Notification</span> </span>&#123;  <span class="hljs-keyword">private</span> MessageSender messageSender;    <span class="hljs-comment">// 通过构造函数将messageSender传递进来</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Notification</span><span class="hljs-params">(MessageSender messageSender)</span> </span>&#123;    <span class="hljs-keyword">this</span>.messageSender = messageSender;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(String cellphone, String message)</span> </span>&#123;    <span class="hljs-comment">//...省略校验逻辑等...</span>    <span class="hljs-keyword">this</span>.messageSender.send(cellphone, message);  &#125;&#125;<span class="hljs-comment">//使用Notification</span>MessageSender messageSender = <span class="hljs-keyword">new</span> MessageSender();Notification notification = <span class="hljs-keyword">new</span> Notification(messageSender);</code></pre><p>通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。这一点在我们之前讲“开闭原则”的时候也提到过。当然，上面代码还有继续优化的空间，我们还可以把 <code>MessageSender</code> 定义成接口，基于接口而非实现编程。改造后的代码如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Notification</span> </span>&#123;  <span class="hljs-keyword">private</span> MessageSender messageSender;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Notification</span><span class="hljs-params">(MessageSender messageSender)</span> </span>&#123;    <span class="hljs-keyword">this</span>.messageSender = messageSender;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(String cellphone, String message)</span> </span>&#123;    <span class="hljs-keyword">this</span>.messageSender.send(cellphone, message);  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MessageSender</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(String cellphone, String message)</span></span>;&#125;<span class="hljs-comment">// 短信发送类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MessageSender</span> </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(String cellphone, String message)</span> </span>&#123;    <span class="hljs-comment">//....</span>  &#125;&#125;<span class="hljs-comment">// 站内信发送类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InboxSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MessageSender</span> </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(String cellphone, String message)</span> </span>&#123;    <span class="hljs-comment">//....</span>  &#125;&#125;<span class="hljs-comment">//使用Notification</span>MessageSender messageSender = <span class="hljs-keyword">new</span> SmsSender();Notification notification = <span class="hljs-keyword">new</span> Notification(messageSender);</code></pre><p>尽管依赖注入非常简单，但却非常有用，它是编写可测试性代码最有效的手段。</p><h2 id="依赖注入框架（DI-Framework）"><a href="#依赖注入框架（DI-Framework）" class="headerlink" title="依赖注入框架（DI Framework）"></a>依赖注入框架（DI Framework）</h2><p>在采用依赖注入实现的 <code>Notification</code> 类中，虽然我们不需要用类似 <code>hard code</code> 的方式，在类内部通过 <code>new</code> 来创建 <code>MessageSender</code> 对象，但是，这个创建对象、组装（或注入）对象的工作仅仅是被移动到了更上层代码而已，还是需要我们程序员自己来实现。具体代码如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;    MessageSender sender = <span class="hljs-keyword">new</span> SmsSender(); <span class="hljs-comment">//创建对象</span>    Notification notification = <span class="hljs-keyword">new</span> Notification(sender);<span class="hljs-comment">//依赖注入</span>    notification.sendMessage(<span class="hljs-string">"13918942177"</span>, <span class="hljs-string">"短信验证码：2346"</span>);  &#125;&#125;</code></pre><p>在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂。如果这部分工作都是靠程序员自己写代码来完成，容易出错且开发成本也比较高。而对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架来自动完成。</p><p>这个框架就是“依赖注入框架”。我们只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</p><p>实际上，现成的依赖注入框架有很多，比如 <code>Google Guice</code>、<code>Java Spring</code>、<code>Pico Container</code>、<code>Butterfly Container</code> 等。不过，如果你熟悉 <code>Java Spring</code> 框架，你可能会说，<code>Spring</code> 框架自己声称是<strong>控制反转容器</strong>（<code>Inversion Of Control Container</code>）。</p><p>实际上，这两种说法都没错。只是控制反转容器这种表述是一种非常宽泛的描述，<code>DI</code> 依赖注入框架的表述更具体、更有针对性。因为我们前面讲到实现控制反转的方式有很多，除了依赖注入，还有模板模式等，而 <code>Spring</code> 框架的控制反转主要是通过依赖注入来实现的。不过这点区分并不是很明显，也不是很重要。</p><h2 id="依赖反转原则（DIP）"><a href="#依赖反转原则（DIP）" class="headerlink" title="依赖反转原则（DIP）"></a>依赖反转原则（DIP）</h2><p>为了追本溯源，先给出这条原则最原汁原味的英文描述：</p><blockquote><p><code>High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.</code></p></blockquote><p>将它翻译成中文，大概意思就是：高层模块（<code>high-level modules</code>）不要依赖低层模块（<code>low-level</code>）。高层模块和低层模块应该通过抽象（<code>abstractions</code>）来互相依赖。除此之外，抽象（<code>abstractions</code>）不要依赖具体实现细节（<code>details</code>），具体实现细节（<code>details</code>）依赖抽象（<code>abstractions</code>）。</p><p>所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计，跟前面讲到的控制反转类似。拿 <code>Tomcat</code> 这个 <code>Servlet</code> 容器作为例子来解释一下。</p><p><code>Tomcat</code> 是运行 <code>Java Web</code> 应用程序的容器。我们编写的 <code>Web</code> 应用程序代码只需要部署在 <code>Tomcat</code> 容器下，便可以被 <code>Tomcat</code> 容器调用执行。按照之前的划分原则，<code>Tomcat</code> 就是高层模块，我们编写的 <code>Web</code> 应用程序代码就是低层模块。<code>Tomcat</code> 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 <code>Sevlet</code> 规范。<code>Servlet</code> 规范不依赖具体的 <code>Tomcat</code> 容器和应用程序的实现细节，而 <code>Tomcat</code> 容器和应用程序依赖 <code>Servlet</code> 规范。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p><strong>1. 控制反转</strong></p><p>实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。</p><p><strong>2. 依赖注入</strong></p><p>依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 <code>new</code> 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。</p><p><strong>3. 依赖注入框架</strong></p><p>我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</p><p><strong>4. 依赖反转原则</strong></p><p>依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式(设计原则)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（十六）</title>
    <link href="/passages/design-pattern-learn-16/"/>
    <url>/passages/design-pattern-learn-16/</url>
    
    <content type="html"><![CDATA[<!-- more --><h2 id="如何理解“接口隔离原则”？"><a href="#如何理解“接口隔离原则”？" class="headerlink" title="如何理解“接口隔离原则”？"></a>如何理解“接口隔离原则”？</h2><p>接口隔离原则的英文翻译是“<code>Interface Segregation Principle</code>”，缩写为 <code>ISP</code>。<code>Robert Martin</code> 在 <code>SOLID</code> 原则中是这样定义它的：“<code>Clients should not be forced to depend upon interfaces that they do not use。</code>”直译成中文的话就是：客户端不应该强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。</p><p>实际上，“接口”这个名词可以用在很多场合中。生活中我们可以用它来指插座接口等。在软件开发中，我们既可以把它看作一组抽象的约定，也可以具体指系统与系统之间的 <code>API</code> 接口，还可以特指面向对象编程语言中的接口等。</p><p>前面我提到，理解接口隔离原则的关键，就是理解其中的“接口”二字。在这条原则中，我们可以把“接口”理解为下面三种东西：</p><ul><li>一组 <code>API</code> 接口集合</li><li>单个 <code>API</code> 接口或函数</li><li><code>OOP</code> 中的接口概念</li></ul><h2 id="把“接口”理解为一组-API-接口集合"><a href="#把“接口”理解为一组-API-接口集合" class="headerlink" title="把“接口”理解为一组 API 接口集合"></a>把“接口”理解为一组 API 接口集合</h2><p>微服务用户系统提供了一组跟用户相关的 <code>API</code> 给其他系统使用，比如：注册、登录、获取用户信息等。具体代码如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">register</span><span class="hljs-params">(String cellphone, String password)</span></span>;  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String cellphone, String password)</span></span>;  <span class="hljs-function">UserInfo <span class="hljs-title">getUserInfoById</span><span class="hljs-params">(<span class="hljs-keyword">long</span> id)</span></span>;  <span class="hljs-function">UserInfo <span class="hljs-title">getUserInfoByCellphone</span><span class="hljs-params">(String cellphone)</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;  <span class="hljs-comment">//...</span>&#125;</code></pre><p>现在，我们的后台管理系统要实现删除用户的功能，希望用户系统提供一个删除用户的接口。这个时候我们该如何来做呢？你可能会说，这不是很简单吗，我只需要在 <code>UserService</code> 中新添加一个 <code>deleteUserByCellphone()</code> 或 <code>deleteUserById()</code> 接口就可以了。这个方法可以解决问题，但是也隐藏了一些安全隐患。</p><p>删除用户是一个非常慎重的操作，我们只希望通过后台管理系统来执行，所以这个接口只限于给后台管理系统使用。如果我们把它放到 <code>UserService</code> 中，那所有使用到 <code>UserService</code> 的系统，都可以调用这个接口。不加限制地被其他业务系统调用，就有可能导致误删用户。</p><p>当然，最好的解决方案是从架构设计的层面，通过接口鉴权的方式来限制接口的调用。不过，如果暂时没有鉴权框架来支持，我们还可以从代码设计的层面，尽量避免接口被误用。我们参照接口隔离原则，调用者不应该强迫依赖它不需要的接口，将删除接口单独放到另外一个接口 <code>RestrictedUserService</code> 中，然后将 <code>RestrictedUserService</code> 只打包提供给后台管理系统来使用。具体的代码实现如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">register</span><span class="hljs-params">(String cellphone, String password)</span></span>;  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String cellphone, String password)</span></span>;  <span class="hljs-function">UserInfo <span class="hljs-title">getUserInfoById</span><span class="hljs-params">(<span class="hljs-keyword">long</span> id)</span></span>;  <span class="hljs-function">UserInfo <span class="hljs-title">getUserInfoByCellphone</span><span class="hljs-params">(String cellphone)</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RestrictedUserService</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">deleteUserByCellphone</span><span class="hljs-params">(String cellphone)</span></span>;  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">deleteUserById</span><span class="hljs-params">(<span class="hljs-keyword">long</span> id)</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span>, <span class="hljs-title">RestrictedUserService</span> </span>&#123;  <span class="hljs-comment">// ...省略实现代码...</span>&#125;</code></pre><p>在刚刚的这个例子中，我们把接口隔离原则中的接口，理解为一组接口集合，它可以是某个微服务的接口，也可以是某个类库的接口等等。在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。</p><h2 id="把“接口”理解为单个-API-接口或函数"><a href="#把“接口”理解为单个-API-接口或函数" class="headerlink" title="把“接口”理解为单个 API 接口或函数"></a>把“接口”理解为单个 API 接口或函数</h2><p>现在我们再换一种理解方式，把接口理解为单个接口或函数。那接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。</p><p>接口隔离原则跟单一职责原则有点类似，不过稍微还是有点区别。单一职责原则针对的是模块、类、接口的设计。而接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p><h2 id="把“接口”理解为-OOP-中的接口概念"><a href="#把“接口”理解为-OOP-中的接口概念" class="headerlink" title="把“接口”理解为 OOP 中的接口概念"></a>把“接口”理解为 OOP 中的接口概念</h2><p>我们还可以把“接口”理解为 <code>OOP</code> 中的接口概念，比如 <code>Java</code> 中的 <code>interface</code>。</p><p>假设我们的项目中用到了三个外部系统：<code>Redis</code>、<code>MySQL</code>、<code>Kafka</code>。每个系统都对应一系列配置信息，比如地址、端口、访问超时时间等。为了在内存中存储这些配置信息，供项目中的其他模块来使用，我们分别设计实现了三个 <code>Configuration</code> 类：<code>RedisConfig</code>、<code>MysqlConfig</code>、<code>KafkaConfig</code>。具体的代码实现如下所示。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;    <span class="hljs-keyword">private</span> ConfigSource configSource; <span class="hljs-comment">//配置中心（比如zookeeper）</span>    <span class="hljs-keyword">private</span> String address;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> timeout;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxTotal;    <span class="hljs-comment">//省略其他配置: maxWaitMillis,maxIdle,minIdle...</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RedisConfig</span><span class="hljs-params">(ConfigSource configSource)</span> </span>&#123;        <span class="hljs-keyword">this</span>.configSource = configSource;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.address;    &#125;    <span class="hljs-comment">//...省略其他get()、init()方法...</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">//从configSource加载配置到address/timeout/maxTotal...</span>    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaConfig</span> </span>&#123; <span class="hljs-comment">//...省略... &#125;</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MysqlConfig</span> </span>&#123; <span class="hljs-comment">//...省略... &#125;</span></code></pre><p>现在，有一个新的功能需求，希望支持 <code>Redis</code> 和 <code>Kafka</code> 配置信息的热更新。所谓“热更新（<code>hot update</code>）”就是，如果在配置中心中更改了配置信息，我们希望在不用重启系统的情况下，能将最新的配置信息加载到内存中（也就是 <code>RedisConfig</code>、<code>KafkaConfig</code> 类中）。但是，因为某些原因，我们并不希望对 <code>MySQL</code> 的配置信息进行热更新。</p><p>为了实现这样一个功能需求，我们设计实现了一个 <code>ScheduledUpdater</code> 类，以固定时间频率（<code>periodInSeconds</code>）来调用 <code>RedisConfig</code>、<code>KafkaConfig</code> 的 <code>update()</code> 方法更新配置信息。具体的代码实现如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Updater</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> <span class="hljs-title">implemets</span> <span class="hljs-title">Updater</span> </span>&#123;  <span class="hljs-comment">//...省略其他属性和方法...</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Updater</span> </span>&#123;  <span class="hljs-comment">//...省略其他属性和方法...</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MysqlConfig</span> </span>&#123; <span class="hljs-comment">//...省略其他属性和方法... &#125;</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledUpdater</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> initialDelayInSeconds;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> periodInSeconds;    <span class="hljs-keyword">private</span> Updater updater;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduleUpdater</span><span class="hljs-params">(Updater updater, <span class="hljs-keyword">long</span> initialDelayInSeconds, <span class="hljs-keyword">long</span> periodInSeconds)</span> </span>&#123;        <span class="hljs-keyword">this</span>.updater = updater;        <span class="hljs-keyword">this</span>.initialDelayInSeconds = initialDelayInSeconds;        <span class="hljs-keyword">this</span>.periodInSeconds = periodInSeconds;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        executor.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                updater.update();            &#125;        &#125;, <span class="hljs-keyword">this</span>.initialDelayInSeconds, <span class="hljs-keyword">this</span>.periodInSeconds, TimeUnit.SECONDS);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;  ConfigSource configSource = <span class="hljs-keyword">new</span> ZookeeperConfigSource(<span class="hljs-comment">/*省略参数*/</span>);  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> RedisConfig redisConfig = <span class="hljs-keyword">new</span> RedisConfig(configSource);  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> KafkaConfig kafkaConfig = <span class="hljs-keyword">new</span> KakfaConfig(configSource);  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> MySqlConfig mysqlConfig = <span class="hljs-keyword">new</span> MysqlConfig(configSource);  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    ScheduledUpdater redisConfigUpdater = <span class="hljs-keyword">new</span> ScheduledUpdater(redisConfig, <span class="hljs-number">300</span>, <span class="hljs-number">300</span>);    redisConfigUpdater.run();        ScheduledUpdater kafkaConfigUpdater = <span class="hljs-keyword">new</span> ScheduledUpdater(kafkaConfig, <span class="hljs-number">60</span>, <span class="hljs-number">60</span>);    redisConfigUpdater.run();  &#125;&#125;</code></pre><p>刚刚的热更新的需求我们已经搞定了。现在，我们又有了一个新的监控功能需求。通过命令行来查看 <code>Zookeeper</code> 中的配置信息是比较麻烦的。所以，我们希望能有一种更加方便的配置信息查看方式。</p><p>我们可以在项目中开发一个内嵌的 <code>SimpleHttpServer</code>，输出项目的配置信息到一个固定的 <code>HTTP</code> 地址，比如：<code>http://127.0.0.1:2389/config</code>。只需要在浏览器中输入这个地址，就可以显示出系统的配置信息。不过，出于某些原因，我们只想暴露 <code>MySQL</code> 和 <code>Redis</code> 的配置信息，不想暴露 <code>Kafka</code> 的配置信息。</p><p>改造之后的代码如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Updater</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Viewer</span> </span>&#123;  <span class="hljs-function">String <span class="hljs-title">outputInPlainText</span><span class="hljs-params">()</span></span>;  <span class="hljs-function">Map&lt;String, String&gt; <span class="hljs-title">output</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> <span class="hljs-title">implemets</span> <span class="hljs-title">Updater</span>, <span class="hljs-title">Viewer</span> </span>&#123;  <span class="hljs-comment">//...省略其他属性和方法...</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">outputInPlainText</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, String&gt; <span class="hljs-title">output</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//...&#125;</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Updater</span> </span>&#123;  <span class="hljs-comment">//...省略其他属性和方法...</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MysqlConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Viewer</span> </span>&#123;  <span class="hljs-comment">//...省略其他属性和方法...</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">outputInPlainText</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, String&gt; <span class="hljs-title">output</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//...&#125;</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleHttpServer</span> </span>&#123;  <span class="hljs-keyword">private</span> String host;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> port;  <span class="hljs-keyword">private</span> Map&lt;String, List&lt;Viewer&gt;&gt; viewers = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleHttpServer</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port)</span> </span>&#123;<span class="hljs-comment">//...&#125;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewers</span><span class="hljs-params">(String urlDirectory, Viewer viewer)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!viewers.containsKey(urlDirectory)) &#123;      viewers.put(urlDirectory, <span class="hljs-keyword">new</span> ArrayList&lt;Viewer&gt;());    &#125;    <span class="hljs-keyword">this</span>.viewers.get(urlDirectory).add(viewer);  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    ConfigSource configSource = <span class="hljs-keyword">new</span> ZookeeperConfigSource();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> RedisConfig redisConfig = <span class="hljs-keyword">new</span> RedisConfig(configSource);    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> KafkaConfig kafkaConfig = <span class="hljs-keyword">new</span> KakfaConfig(configSource);    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> MySqlConfig mysqlConfig = <span class="hljs-keyword">new</span> MySqlConfig(configSource);        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ScheduledUpdater redisConfigUpdater =            <span class="hljs-keyword">new</span> ScheduledUpdater(redisConfig, <span class="hljs-number">300</span>, <span class="hljs-number">300</span>);        redisConfigUpdater.run();                ScheduledUpdater kafkaConfigUpdater =            <span class="hljs-keyword">new</span> ScheduledUpdater(kafkaConfig, <span class="hljs-number">60</span>, <span class="hljs-number">60</span>);        redisConfigUpdater.run();                SimpleHttpServer simpleHttpServer = <span class="hljs-keyword">new</span> SimpleHttpServer(“<span class="hljs-number">127.0</span>.0.1”, <span class="hljs-number">2389</span>);        simpleHttpServer.addViewer(<span class="hljs-string">"/config"</span>, redisConfig);        simpleHttpServer.addViewer(<span class="hljs-string">"/config"</span>, mysqlConfig);        simpleHttpServer.run();    &#125;&#125;</code></pre><p>至此，热更新和监控的需求就都实现了。来回顾一下这个例子的设计思想。</p><p>我们设计了两个功能非常单一的接口：<code>Updater</code> 和 <code>Viewer</code>。<code>ScheduledUpdater</code> 只依赖 <code>Updater</code> 这个跟热更新相关的接口，不需要被强迫去依赖不需要的 <code>Viewer</code> 接口，满足接口隔离原则。同理，<code>SimpleHttpServer</code> 只依赖跟查看信息相关的 <code>Viewer</code> 接口，不依赖不需要的 <code>Updater</code> 接口，也满足接口隔离原则。</p><p>你可能会说，如果我们不遵守接口隔离原则，不设计 <code>Updater</code> 和 <code>Viewer</code> 两个小接口，而是设计一个大而全的 <code>Config</code> 接口，让 <code>RedisConfig</code>、<code>KafkaConfig</code>、<code>MysqlConfig</code> 都实现这个 <code>Config</code> 接口，并且将原来传递给 <code>ScheduledUpdater</code> 的 <code>Updater</code> 和传递给 <code>SimpleHttpServer</code> 的 <code>Viewer</code>，都替换为 <code>Config</code>，那会有什么问题呢？我们先来看一下，按照这个思路来实现的代码是什么样的。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Config</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>;  <span class="hljs-function">String <span class="hljs-title">outputInPlainText</span><span class="hljs-params">()</span></span>;  <span class="hljs-function">Map&lt;String, String&gt; <span class="hljs-title">output</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Config</span> </span>&#123;  <span class="hljs-comment">//...需要实现Config的三个接口update/outputIn.../output</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Config</span> </span>&#123;  <span class="hljs-comment">//...需要实现Config的三个接口update/outputIn.../output</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MysqlConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Config</span> </span>&#123;  <span class="hljs-comment">//...需要实现Config的三个接口update/outputIn.../output</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledUpdater</span> </span>&#123;  <span class="hljs-comment">//...省略其他属性和方法..</span>  <span class="hljs-keyword">private</span> Config config;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduleUpdater</span><span class="hljs-params">(Config config, <span class="hljs-keyword">long</span> initialDelayInSeconds, <span class="hljs-keyword">long</span> periodInSeconds)</span> </span>&#123;      <span class="hljs-keyword">this</span>.config = config;      <span class="hljs-comment">//...</span>  &#125;  <span class="hljs-comment">//...</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleHttpServer</span> </span>&#123;  <span class="hljs-keyword">private</span> String host;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> port;  <span class="hljs-keyword">private</span> Map&lt;String, List&lt;Config&gt;&gt; viewers = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleHttpServer</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port)</span> </span>&#123;<span class="hljs-comment">//...&#125;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewer</span><span class="hljs-params">(String urlDirectory, Config config)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!viewers.containsKey(urlDirectory)) &#123;      viewers.put(urlDirectory, <span class="hljs-keyword">new</span> ArrayList&lt;Config&gt;());    &#125;    viewers.get(urlDirectory).add(config);  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>&#125;</code></pre><p>这样的设计思路也是能工作的，但是对比前后两个设计思路，在同样的代码量、实现复杂度、同等可读性的情况下，第一种设计思路显然要比第二种好很多。为什么这么说呢？主要有两点原因。</p><p><strong>首先，第一种设计思路更加灵活、易扩展、易复用。</strong>因为 <code>Updater</code>、<code>Viewer</code> 职责更加单一，单一就意味了通用、复用性好。比如，我们现在又有一个新的需求，开发一个 <code>Metrics</code> 性能统计模块，并且希望将 <code>Metrics</code> 也通过 <code>SimpleHttpServer</code> 显示在网页上，以方便查看。这个时候，尽管 <code>Metrics</code> 跟 <code>RedisConfig</code> 等没有任何关系，但我们仍然可以让 <code>Metrics</code> 类实现非常通用的 <code>Viewer</code> 接口，复用 <code>SimpleHttpServer</code> 的代码实现。具体的代码如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiMetrics</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Viewer</span> </span>&#123;<span class="hljs-comment">//...&#125;</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DbMetrics</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Viewer</span> </span>&#123;<span class="hljs-comment">//...&#125;</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    ConfigSource configSource = <span class="hljs-keyword">new</span> ZookeeperConfigSource();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> RedisConfig redisConfig = <span class="hljs-keyword">new</span> RedisConfig(configSource);    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> KafkaConfig kafkaConfig = <span class="hljs-keyword">new</span> KakfaConfig(configSource);    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> MySqlConfig mySqlConfig = <span class="hljs-keyword">new</span> MySqlConfig(configSource);    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ApiMetrics apiMetrics = <span class="hljs-keyword">new</span> ApiMetrics();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DbMetrics dbMetrics = <span class="hljs-keyword">new</span> DbMetrics();        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SimpleHttpServer simpleHttpServer = <span class="hljs-keyword">new</span> SimpleHttpServer(“<span class="hljs-number">127.0</span>.0.1”, <span class="hljs-number">2389</span>);        simpleHttpServer.addViewer(<span class="hljs-string">"/config"</span>, redisConfig);        simpleHttpServer.addViewer(<span class="hljs-string">"/config"</span>, mySqlConfig);        simpleHttpServer.addViewer(<span class="hljs-string">"/metrics"</span>, apiMetrics);        simpleHttpServer.addViewer(<span class="hljs-string">"/metrics"</span>, dbMetrics);        simpleHttpServer.run();    &#125;&#125;</code></pre><p><strong>其次，第二种设计思路在代码实现上做了一些无用功。</strong>因为 <code>Config</code> 接口中包含两类不相关的接口，一类是 <code>update()</code>，一类是 <code>output()</code> 和 <code>outputInPlainText()</code>。理论上，<code>KafkaConfig</code> 只需要实现 <code>update()</code> 接口，并不需要实现 <code>output()</code> 相关的接口。同理，<code>MysqlConfig</code> 只需要实现 <code>output()</code> 相关接口，并不需要实现 <code>update()</code> 接口。但第二种设计思路要求 <code>RedisConfig</code>、<code>KafkaConfig</code>、<code>MySqlConfig</code> 必须同时实现 <code>Config</code> 的所有接口函数（<code>update、output、outputInPlainText</code>）。除此之外，如果我们要往 <code>Config</code> 中继续添加一个新的接口，那所有的实现类都要改动。相反，如果我们的接口粒度比较小，那涉及改动的类就比较少。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p><strong>1. 如何理解“接口隔离原则”？</strong></p><p>理解“接口隔离原则”的重点是理解其中的“接口”二字。这里有三种不同的理解。</p><p>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</p><p>如果把“接口”理解为单个 <code>API</code> 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</p><p>如果把“接口”理解为 <code>OOP</code> 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</p><p><strong>2. 接口隔离原则与单一职责原则的区别</strong></p><p>单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p><p>参考：<a href="https://time.geekbang.org/column/article/177442" target="_blank" rel="noopener">理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(设计原则)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（十五）</title>
    <link href="/passages/design-pattern-learn-15/"/>
    <url>/passages/design-pattern-learn-15/</url>
    
    <content type="html"><![CDATA[<!-- more --><h2 id="如何理解“里式替换原则”？"><a href="#如何理解“里式替换原则”？" class="headerlink" title="如何理解“里式替换原则”？"></a>如何理解“里式替换原则”？</h2><p>里式替换原则的英文翻译是：<code>Liskov Substitution Principle</code>，缩写为 <code>LSP</code>。这个原则最早是在 <code>1986</code> 年由 <code>Barbara Liskov</code> 提出，他是这么描述这条原则的：</p><blockquote><p>If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。</p></blockquote><p>在 <code>1996</code> 年，<code>Robert Martin</code> 在他的 <code>SOLID</code> 原则中，重新描述了这个原则，英文原话是这样的：</p><blockquote><p>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。</p></blockquote><p>综合两者的描述，将这条原则用中文描述出来，是这样的：子类对象（<code>object of subtype/derived class</code>）能够替换程序（<code>program</code>）中父类对象（<code>object of base/parent class</code>）出现的任何地方，并且保证原来程序的逻辑行为（<code>behavior</code>）不变及正确性不被破坏。</p><p>虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。</p><h2 id="哪些代码明显违背了-LSP？"><a href="#哪些代码明显违背了-LSP？" class="headerlink" title="哪些代码明显违背了 LSP？"></a>哪些代码明显违背了 LSP？</h2><p>里式替换原则还有另外一个更加能落地、更有指导意义的描述，那就是“<code>Design By Contract</code>”，中文翻译就是“按照协议来设计”。</p><p>子类在设计的时候，要遵守父类的行为约定（或者叫协议）。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。这里的行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。实际上，定义中父类和子类之间的关系，也可以替换成接口和实现类之间的关系。</p><p>为了更好地理解这句话，举几个违反里式替换原则的例子来解释一下。</p><p><strong>1. 子类违背父类声明要实现的功能</strong></p><p>父类中提供的 <code>sortOrdersByAmount()</code> 订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个 <code>sortOrdersByAmount()</code> 订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则。</p><p><strong>2. 子类违背父类对输入、输出、异常的约定</strong></p><p>在父类中，某个函数约定：运行出错的时候返回 <code>null</code>；获取数据为空的时候返回空集合（<code>empty collection</code>）。而子类重载函数之后，实现变了，运行出错返回异常（<code>exception</code>），获取不到数据返回 <code>null</code>。那子类的设计就违背里式替换原则。</p><p>在父类中，某个函数约定，输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出，也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则。</p><p>在父类中，某个函数约定，只会抛出 <code>ArgumentNullException</code> 异常，那子类的设计实现中只允许抛出 <code>ArgumentNullException</code> 异常，任何其他异常的抛出，都会导致子类违背里式替换原则。</p><p><strong>3. 子类违背父类注释中所罗列的任何特殊说明</strong></p><p>父类中定义的 <code>withdraw()</code> 提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写 <code>withdraw()</code> 函数之后，针对 <code>VIP</code> 账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。</p><p>以上便是三种典型的违背里式替换原则的情况。除此之外，判断子类的设计实现是否违背里式替换原则，还有一个小窍门，那就是拿父类的单元测试去验证子类的代码。如果某些单元测试运行失败，就有可能说明，子类的设计实现没有完全地遵守父类的约定，子类有可能违背了里式替换原则。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>里式替换原则是用来指导继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“<code>design by contract</code>，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。</p><p>理解这个原则，我们还要弄明白里式替换原则跟多态的区别。虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</p><p>参考：<a href="https://time.geekbang.org/column/article/177110" target="_blank" rel="noopener">理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(设计原则)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（十四）</title>
    <link href="/passages/design-pattern-learn-14/"/>
    <url>/passages/design-pattern-learn-14/</url>
    
    <content type="html"><![CDATA[<!-- more --><h2 id="如何理解“对扩展开放、修改关闭”？"><a href="#如何理解“对扩展开放、修改关闭”？" class="headerlink" title="如何理解“对扩展开放、修改关闭”？"></a>如何理解“对扩展开放、修改关闭”？</h2><p>开闭原则的英文全称是 <code>Open Closed Principle</code>，简写为 <code>OCP</code>。它的英文描述是：<code>software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification</code>。我们把它翻译成中文就是：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。</p><p>这个描述比较简略，如果我们详细表述一下，那就是，添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。</p><h2 id="修改代码就意味着违背开闭原则吗？"><a href="#修改代码就意味着违背开闭原则吗？" class="headerlink" title="修改代码就意味着违背开闭原则吗？"></a>修改代码就意味着违背开闭原则吗？</h2><p>实际上，我们也没必要纠结某个代码改动是“修改”还是“扩展”，更没必要太纠结它是否违反“开闭原则”。我们回到这条原则的设计初衷：只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。</p><p>而且，我们要认识到，添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，这个是做不到的。类需要创建、组装、并且做一些初始化操作，才能构建成可运行的的程序，这部分代码的修改是在所难免的。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。</p><h2 id="如何做到“对扩展开放、修改关闭”？"><a href="#如何做到“对扩展开放、修改关闭”？" class="headerlink" title="如何做到“对扩展开放、修改关闭”？"></a>如何做到“对扩展开放、修改关闭”？</h2><p>开闭原则讲的就是代码的扩展性问题，是判断一段代码是否易扩展的“金标准”。如果某段代码在应对未来需求变化的时候，能够做到“对扩展开放、对修改关闭”，那就说明这段代码的扩展性比较好。所以，问如何才能做到“对扩展开放、对修改关闭”，也就粗略地等同于在问，如何才能写出扩展性好的代码。</p><p><strong>先来看一些更加偏向顶层的指导思想。为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。这些“潜意识”可能比任何开发技巧都重要。</strong></p><p>在写代码的时候后，我们要多花点时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活地插入到扩展点上，做到“对扩展开放、对修改关闭”。</p><p>还有，在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。</p><p><strong>再来看下，支持开闭原则的一些更加具体的方法论。</strong></p><p>在众多的设计原则、思想、模式中，最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态等）。</p><p>实际上，多态、依赖注入、基于接口而非实现编程，以及前面提到的抽象意识，说的都是同一种设计思路，只是从不同的角度、不同的层面来阐述而已。这也体现了“很多设计原则、思想、模式都是相通的”这一思想。</p><h2 id="如何在项目中灵活应用开闭原则？"><a href="#如何在项目中灵活应用开闭原则？" class="headerlink" title="如何在项目中灵活应用开闭原则？"></a>如何在项目中灵活应用开闭原则？</h2><p>如果你开发的是一个业务导向的系统，比如金融系统、电商系统、物流系统等，要想识别出尽可能多的扩展点，就要对业务有足够的了解，能够知道当下以及未来可能要支持的业务需求。如果你开发的是跟业务无关的、通用的、偏底层的系统，比如，框架、组件、类库，你需要了解“它们会被如何使用？今后你打算添加哪些功能？使用者未来会有哪些更多的功能需求？”等问题。</p><p>有一句话说得好，“唯一不变的只有变化本身”。即便我们对业务、对系统有足够的了解，那也不可能识别出所有的扩展点，即便你能识别出所有的扩展点，为这些地方都预留扩展点，这样做的成本也是不可接受的。我们没必要为一些遥远的、不一定发生的需求去提前买单，做过度设计。</p><p>最合理的做法是，对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候之后，我们就可以事先做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候，再通过重构代码的方式来支持扩展的需求。</p><p>而且，开闭原则也并不是免费的。有些情况下，代码的扩展性会跟可读性相冲突。比如，为了更好地支持扩展性，我们对代码进行了重构，重构之后的代码要比之前的代码复杂很多，理解起来也更加有难度。很多时候，我们都需要在扩展性和可读性之间做权衡。在某些场景下，代码的扩展性很重要，我们就可以适当地牺牲一些代码的可读性；在另一些场景下，代码的可读性更加重要，那我们就适当地牺牲一些代码的可扩展性。总之，这里没有一个放之四海而皆准的参考标准，全凭实际的应用场景来决定。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p><strong>1. 如何理解“对扩展开放、对修改关闭”？</strong></p><p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。关于定义，我们有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。</p><p><strong>2. 如何做到“对扩展开放、修改关闭”？</strong></p><p>我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。</p><p>很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 <code>23</code> 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。</p><p>参考：<a href="https://time.geekbang.org/column/article/176075" target="_blank" rel="noopener">理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(设计原则)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（十三）</title>
    <link href="/passages/design-pattern-learn-13/"/>
    <url>/passages/design-pattern-learn-13/</url>
    
    <content type="html"><![CDATA[<!-- more --><h2 id="如何理解单一职责原则（SRP）？"><a href="#如何理解单一职责原则（SRP）？" class="headerlink" title="如何理解单一职责原则（SRP）？"></a>如何理解单一职责原则（SRP）？</h2><p><code>SOLID</code> 原则并非单纯的 <code>1</code> 个原则，而是由 <code>5</code> 个设计原则组成的，它们分别是：单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，依次对应 <code>SOLID</code> 中的 <code>S、O、L、I、D</code> 这 <code>5</code> 个英文字母。</p><p>单一职责原则的英文是 <code>Single Responsibility Principle</code>，缩写为 <code>SRP</code>。这个原则的英文描述是这样的：<code>A class or module should have a single reponsibility</code>。如果我们把它翻译成中文，那就是：一个类或者模块只负责完成一个职责（或者功能）。</p><p>这个原则描述的对象包含两个，一个是类（<code>class</code>），一个是模块（<code>module</code>）。关于这两个概念，有两种理解方式。一种理解是：把模块看作比类更加抽象的概念，类也可以看作模块。另一种理解是：把模块看作比类更加粗粒度的代码块，模块中包含多个类，多个类组成一个模块。</p><p>单一职责原则的定义描述非常简单，也不难理解。一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。</p><h2 id="如何判断类的职责是否足够单一？"><a href="#如何判断类的职责是否足够单一？" class="headerlink" title="如何判断类的职责是否足够单一？"></a>如何判断类的职责是否足够单一？</h2><p>评价一个类的职责是否足够单一，我们并没有一个非常明确的、可以量化的标准，可以说，这是件非常主观、仁者见仁智者见智的事情。实际上，在真正的软件开发中，我们也没必要过于未雨绸缪，过度设计。所以，<strong>我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构。</strong></p><p>下面这几条判断原则，比起很主观地去思考类是否职责单一，要更有指导意义、更具有可执行性：</p><ul><li><p>类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；</p></li><li><p>类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；</p></li><li><p>私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 <code>public</code> 方法，供更多的类使用，从而提高代码的复用性；</p></li><li><p>比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 <code>Manager</code>、<code>Context</code> 之类的词语来命名，这就说明类的职责定义得可能不够清晰；</p></li><li><p>类中大量的方法都是集中操作类中的某几个属性，比如，在 <code>UserInfo</code> 例子中，如果一半的方法都是在操作 <code>address</code> 信息，那就可以考虑将这几个属性和对应的方法拆分出来。</p></li></ul><p>实际上，从另一个角度来看，当一个类的代码，读起来让你头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数、函数、属性过多了。实际上，等你做多项目了，代码写多了，在开发中慢慢“品尝”，自然就知道什么是“放盐少许”了，这就是所谓的“专业第六感”。</p><h2 id="类的职责是否设计得越单一越好？"><a href="#类的职责是否设计得越单一越好？" class="headerlink" title="类的职责是否设计得越单一越好？"></a>类的职责是否设计得越单一越好？</h2><p>为了满足单一职责原则，是不是把类拆得越细就越好呢？答案是否定的。我们还是通过一个例子来解释一下。<code>Serialization</code> 类实现了一个简单协议的序列化和反序列功能，具体代码如下：</p><pre><code class="hljs java"><span class="hljs-comment">/** * Protocol format: identifier-string;&#123;gson string&#125; * For example: UEUEUE;&#123;"a":"A","b":"B"&#125; */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Serialization</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String IDENTIFIER_STRING = <span class="hljs-string">"UEUEUE;"</span>;  <span class="hljs-keyword">private</span> Gson gson;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Serialization</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>.gson = <span class="hljs-keyword">new</span> Gson();  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">serialize</span><span class="hljs-params">(Map&lt;String, String&gt; object)</span> </span>&#123;    StringBuilder textBuilder = <span class="hljs-keyword">new</span> StringBuilder();    textBuilder.append(IDENTIFIER_STRING);    textBuilder.append(gson.toJson(object));    <span class="hljs-keyword">return</span> textBuilder.toString();  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, String&gt; <span class="hljs-title">deserialize</span><span class="hljs-params">(String text)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!text.startsWith(IDENTIFIER_STRING)) &#123;        <span class="hljs-keyword">return</span> Collections.emptyMap();    &#125;    String gsonStr = text.substring(IDENTIFIER_STRING.length());    <span class="hljs-keyword">return</span> gson.fromJson(gsonStr, Map.class);  &#125;&#125;</code></pre><p>如果我们想让类的职责更加单一，我们对 <code>Serialization</code> 类进一步拆分，拆分成一个只负责序列化工作的 <code>Serializer</code> 类和另一个只负责反序列化工作的 <code>Deserializer</code> 类。拆分后的具体代码如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Serializer</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String IDENTIFIER_STRING = <span class="hljs-string">"UEUEUE;"</span>;  <span class="hljs-keyword">private</span> Gson gson;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Serializer</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>.gson = <span class="hljs-keyword">new</span> Gson();  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">serialize</span><span class="hljs-params">(Map&lt;String, String&gt; object)</span> </span>&#123;    StringBuilder textBuilder = <span class="hljs-keyword">new</span> StringBuilder();    textBuilder.append(IDENTIFIER_STRING);    textBuilder.append(gson.toJson(object));    <span class="hljs-keyword">return</span> textBuilder.toString();  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Deserializer</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String IDENTIFIER_STRING = <span class="hljs-string">"UEUEUE;"</span>;  <span class="hljs-keyword">private</span> Gson gson;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Deserializer</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>.gson = <span class="hljs-keyword">new</span> Gson();  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, String&gt; <span class="hljs-title">deserialize</span><span class="hljs-params">(String text)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!text.startsWith(IDENTIFIER_STRING)) &#123;        <span class="hljs-keyword">return</span> Collections.emptyMap();    &#125;    String gsonStr = text.substring(IDENTIFIER_STRING.length());    <span class="hljs-keyword">return</span> gson.fromJson(gsonStr, Map.class);  &#125;&#125;</code></pre><p>虽然经过拆分之后，<code>Serializer</code> 类和 <code>Deserializer</code> 类的职责更加单一了，但也随之带来了新的问题。如果我们修改了协议的格式，数据标识从“<code>UEUEUE</code>”改为“<code>DFDFDF</code>”，或者序列化方式从 <code>JSON</code> 改为了 <code>XML</code>，那 <code>Serializer</code> 类和 <code>Deserializer</code> 类都需要做相应的修改，代码的内聚性显然没有原来 <code>Serialization</code> 高了。而且，如果我们仅仅对 <code>Serializer</code> 类做了协议修改，而忘记了修改 <code>Deserializer</code> 类的代码，那就会导致序列化、反序列化不匹配，程序运行出错，也就是说，拆分之后，代码的可维护性变差了。</p><p>不管是应用设计原则还是设计模式，最终的目的还是提高代码的可读性、可扩展性、复用性、可维护性等。我们在考虑应用某一个设计原则是否合理的时候，也可以以此作为最终的考量标准。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p><strong>1. 如何理解单一职责原则（<code>SRP</code>）？</strong></p><p>一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。</p><p><strong>2. 如何判断类的职责是否足够单一？</strong></p><p>不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：</p><ul><li>类中的代码行数、函数或者属性过多；</li><li>类依赖的其他类过多，或者依赖类的其他类过多；</li><li>私有方法过多；</li><li>比较难给类起一个合适的名字；</li><li>类中大量的方法都是集中操作类中的某几个属性。</li></ul><p><strong>3. 类的职责是否设计得越单一越好？</strong></p><p>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p><p>参考：<a href="https://time.geekbang.org/column/article/171771" target="_blank" rel="noopener">理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(设计原则)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（十二）</title>
    <link href="/passages/design-pattern-learn-12/"/>
    <url>/passages/design-pattern-learn-12/</url>
    
    <content type="html"><![CDATA[<!-- more --><h2 id="如何进行面向对象设计？"><a href="#如何进行面向对象设计？" class="headerlink" title="如何进行面向对象设计？"></a>如何进行面向对象设计？</h2><p>面向对象分析的产出是详细的需求描述，那面向对象设计的产出就是类。在面向对象设计环节，我们将需求描述转化为具体的类的设计。我们把这一设计环节拆解细化一下，主要包含以下几个部分：</p><ul><li>划分职责进而识别出有哪些类；</li><li>定义类及其属性和方法；</li><li>定义类与类之间的交互关系；</li><li>将类组装起来并提供执行入口。</li></ul><h2 id="如何进行面向对象编程？"><a href="#如何进行面向对象编程？" class="headerlink" title="如何进行面向对象编程？"></a>如何进行面向对象编程？</h2><p>面向对象设计完成之后，我们已经定义清晰了类、属性、方法、类之间的交互，并且将所有的类组装起来，提供了统一的执行入口。接下来，面向对象编程的工作，就是将这些设计思路翻译成代码实现。</p><h2 id="辩证思考与灵活应用"><a href="#辩证思考与灵活应用" class="headerlink" title="辩证思考与灵活应用"></a>辩证思考与灵活应用</h2><p>在之前的讲解中，面向对象分析、设计、实现，每个环节的界限划分都比较清楚。而且，设计和实现基本上是按照功能点的描述，逐句照着翻译过来的。这样做的好处是先做什么、后做什么，非常清晰、明确，有章可循，即便是没有太多设计经验的初级工程师，都可以按部就班地参照着这个流程来做分析、设计和实现。</p><p>不过，在平时的工作中，大部分程序员往往都是在脑子里或者草纸上完成面向对象分析和设计，然后就开始写代码了，边写边思考边重构，并不会严格地按照刚刚的流程来执行。而且，说实话，即便我们在写代码之前，花很多时间做分析和设计，绘制出完美的类图、<code>UML</code> 图，也不可能把每个细节、交互都想得很清楚。在落实到代码的时候，我们还是要反复迭代、重构、打破重写。</p><p>毕竟，整个软件开发本来就是一个迭代、修修补补、遇到问题解决问题的过程，是一个不断重构的过程。我们没法严格地按照顺序执行各个步骤。这就类似你去学驾照，驾校教的都是比较正规的流程，先做什么，后做什么，你只要照着做就能顺利倒车入库，但实际上，等你开熟练了，倒车入库很多时候靠的都是经验和感觉。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>面向对象分析的产出是详细的需求描述。面向对象设计的产出是类。在面向对象设计这一环节中，我们将需求描述转化为具体的类的设计。这个环节的工作可以拆分为下面四个部分。</p><p><strong>1. 划分职责进而识别出有哪些类</strong></p><p>根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。</p><p><strong>2. 定义类及其属性和方法</strong></p><p>我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。</p><p><strong>3. 定义类与类之间的交互关系</strong></p><p><code>UML</code> 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。从更加贴近编程的角度，对类与类之间的关系做了调整，保留四个关系：泛化、实现、组合、依赖。</p><p><strong>4. 将类组装起来并提供执行入口</strong></p><p>我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 <code>main()</code> 函数，也可能是一组给外部用的 <code>API</code> 接口。通过这个入口，我们能触发整个代码跑起来。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>软件设计的自由度很大，这也是软件的复杂之处。不同的人对类的划分、定义、类之间交互的设计，可能都不大一样。那除了上面的设计思路，你还有没有其他设计思路呢？</li></ul><p>参考：<a href="https://time.geekbang.org/column/article/171767" target="_blank" rel="noopener">实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(面向对象)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（十一）</title>
    <link href="/passages/design-pattern-learn-11/"/>
    <url>/passages/design-pattern-learn-11/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>面向对象分析（<code>OOA</code>）、面向对象设计（<code>OOD</code>）、面向对象编程（<code>OOP</code>），是面向对象开发的三个主要环节。</p><h2 id="案例介绍和难点剖析"><a href="#案例介绍和难点剖析" class="headerlink" title="案例介绍和难点剖析"></a>案例介绍和难点剖析</h2><p>假设，你正在参与开发一个微服务。微服务通过 <code>HTTP</code> 协议暴露接口给其他系统调用，说直白点就是，其他系统通过 <code>URL</code> 来调用微服务的接口。有一天，你的 <code>leader</code> 找到你说，“为了保证接口调用的安全性，我们希望设计实现一个接口调用鉴权功能，只有经过认证之后的系统才能调用我们的接口，没有认证过的系统调用我们的接口会被拒绝。我希望由你来负责这个任务的开发，争取尽快上线。”</p><p><code>leader</code> 丢下这些话就走了。这个时候，你该如何来做呢？有没有脑子里一团浆糊，一时间无从下手的感觉呢？为什么会有这种感觉呢？主要有下面两点原因。</p><p><strong>1. 需求不明确</strong></p><p>面向对象分析主要的分析对象是“需求”，因此，面向对象分析可以粗略地看成“需求分析”。实际上，不管是需求分析还是面向对象分析，我们首先要做的都是将笼统的需求细化到足够清晰、可执行。我们需要通过沟通、挖掘、分析、假设、梳理，搞清楚具体的需求有哪些，哪些是现在要做的，哪些是未来可能要做的，哪些是不用考虑做的。</p><p><strong>2. 缺少锻炼</strong></p><p>开发这样通用的框架，对工程师的需求分析能力、设计能力、编码能力，甚至逻辑思维能力的要求，都是比较高的。如果你平时做的都是简单的 <code>CRUD</code> 业务开发，那这方面的锻炼肯定不会很多，所以，一旦遇到这种开发需求，很容易因为缺少锻炼，脑子放空，不知道从何入手，完全没有思路。</p><h2 id="对案例进行需求分析"><a href="#对案例进行需求分析" class="headerlink" title="对案例进行需求分析"></a>对案例进行需求分析</h2><p>实际上，这跟做算法题类似，先从最简单的方案想起，然后再优化。</p><p><strong>1. 第一轮基础分析</strong></p><p>对于如何做鉴权这样一个问题，最简单的解决方案就是，通过用户名加密码来做认证。我们给每个允许访问我们服务的调用方，派发一个应用名（或者叫应用 <code>ID</code>、<code>AppID</code>）和一个对应的密码（或者叫秘钥）。调用方每次进行接口请求的时候，都携带自己的 <code>AppID</code> 和密码。微服务在接收到接口调用请求之后，会解析出 <code>AppID</code> 和密码，跟存储在微服务端的 <code>AppID</code> 和密码进行比对。如果一致，说明认证成功，则允许接口调用请求；否则，就拒绝接口调用请求。</p><p><strong>2. 第二轮分析优化</strong></p><p>不过，这样的验证方式，每次都要明文传输密码。密码很容易被截获，是不安全的。</p><p>提出问题，然后再解决问题，是一个非常好的迭代优化方法。对于刚刚这个问题，我们可以借助 <code>OAuth</code> 的验证思路来解决。调用方将请求接口的 <code>URL</code> 跟 <code>AppID</code>、密码拼接在一起，然后进行加密，生成一个 <code>token</code>。调用方在进行接口请求的的时候，将这个 <code>token</code> 及 <code>AppID</code>，随 <code>URL</code> 一块传递给微服务端。微服务端接收到这些数据之后，根据 <code>AppID</code> 从数据库中取出对应的密码，并通过同样的 <code>token</code> 生成算法，生成另外一个 <code>token</code>。用这个新生成的 <code>token</code> 跟调用方传递过来的 <code>token</code> 对比。如果一致，则允许接口调用请求；否则，就拒绝接口调用请求。</p><p><strong>3. 第三轮分析优化</strong></p><p>不过，这样的设计仍然存在重放攻击的风险，还是不够安全。每个 <code>URL</code> 拼接上 <code>AppID</code>、密码生成的 <code>token</code> 都是固定的。未认证系统截获 <code>URL</code>、<code>token</code> 和 <code>AppID</code> 之后，还是可以通过重放攻击的方式，伪装成认证系统，调用这个 <code>URL</code> 对应的接口。</p><p>为了解决这个问题，我们可以进一步优化 <code>token</code> 生成算法，引入一个随机变量，让每次接口请求生成的 <code>token</code> 都不一样。我们可以选择时间戳作为随机变量。原来的 <code>token</code> 是对 <code>URL</code>、<code>AppID</code>、密码三者进行加密生成的，现在我们将 <code>URL</code>、<code>AppID</code>、密码、时间戳四者进行加密来生成 <code>token</code>。调用方在进行接口请求的时候，将 <code>token</code>、<code>AppID</code>、时间戳，随 <code>URL</code> 一并传递给微服务端。</p><p>微服务端在收到这些数据之后，会验证当前时间戳跟传递过来的时间戳，是否在一定的时间窗口内（比如一分钟）。如果超过一分钟，则判定 <code>token</code> 过期，拒绝接口请求。如果没有超过一分钟，则说明 <code>token</code> 没有过期，就再通过同样的 <code>token</code> 生成算法，在服务端生成新的 <code>token</code>，与调用方传递过来的 <code>token</code> 比对，看是否一致。如果一致，则允许接口调用请求；否则，就拒绝接口调用请求。</p><p><strong>4. 第四轮分析优化</strong></p><p>这样还是不够安全啊。未认证系统还是可以在这一分钟的 <code>token</code> 失效窗口内，通过截获请求、重放请求，来调用我们的接口啊！</p><p>不过，攻与防之间，本来就没有绝对的安全。我们能做的就是，尽量提高攻击的成本。这个方案虽然还有漏洞，但是实现起来足够简单，而且不会过度影响接口本身的性能（比如响应时间）。所以，权衡安全性、开发成本、对系统性能的影响，这个方案算是比较折中、比较合理的了。</p><p>实际上，还有一个细节我们没有考虑到，那就是，如何在微服务端存储每个授权调用方的 <code>AppID</code> 和密码。当然，这个问题并不难。最容易想到的方案就是存储到数据库里，比如 <code>MySQL</code>。不过，开发像鉴权这样的非业务功能，最好不要与具体的第三方系统有过度的耦合。</p><p>针对 <code>AppID</code> 和密码的存储，我们最好能灵活地支持各种不同的存储方式，比如 <code>ZooKeeper</code>、本地配置文件、自研配置中心、<code>MySQL</code>、<code>Redis</code> 等。我们不一定针对每种存储方式都去做代码实现，但起码要留有扩展点，保证系统有足够的灵活性和扩展性，能够在我们切换存储方式的时候，尽可能地减少代码的改动。</p><p><strong>5. 最终确定需求</strong></p><ul><li>调用方进行接口请求的时候，将 <code>URL</code>、<code>AppID</code>、密码、时间戳拼接在一起，通过加密算法生成 <code>token</code>，并且将 <code>token</code>、<code>AppID</code>、时间戳拼接在 <code>URL</code> 中，一并发送到微服务端。</li><li>微服务端在接收到调用方的接口请求之后，从请求中拆解出 <code>token</code>、<code>AppID</code>、时间戳。</li><li>微服务端首先检查传递过来的时间戳跟当前时间，是否在 <code>token</code> 失效时间窗口内。如果已经超过失效时间，那就算接口调用鉴权失败，拒绝接口调用请求。</li><li>如果 <code>token</code> 验证没有过期失效，微服务端再从自己的存储中，取出 <code>AppID</code> 对应的密码，通过同样的 <code>token</code> 生成算法，生成另外一个 <code>token</code>，与调用方传递过来的 <code>token</code> 进行匹配；如果一致，则鉴权成功，允许接口调用，否则就拒绝接口调用。</li></ul><p>这就是我们需求分析的整个思考过程，从最粗糙、最模糊的需求开始，通过“提出问题 - 解决问题”的方式，循序渐进地进行优化，最后得到一个足够清晰、可落地的需求描述。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>针对框架、类库、组件等非业务系统的开发，其中一个比较大的难点就是，需求一般都比较抽象、模糊，需要你自己去挖掘，做合理取舍、权衡、假设，把抽象的问题具象化，最终产生清晰的、可落地的需求定义。需求定义是否清晰、合理，直接影响了后续的设计、编码实现是否顺畅。所以，作为程序员，你一定不要只关心设计与实现，前期的需求分析同等重要。</p><p>需求分析的过程实际上是一个不断迭代优化的过程。我们不要试图一下就能给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化，这样一个思考过程能让我们摆脱无从下手的窘境。</p><p>参考：<a href="https://time.geekbang.org/column/article/171760" target="_blank" rel="noopener">实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(面向对象)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（十）</title>
    <link href="/passages/design-pattern-learn-10/"/>
    <url>/passages/design-pattern-learn-10/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>如何分别用基于贫血模型的传统开发模式，以及基于充血模型的 <code>DDD</code> 开发模式，设计实现一个钱包系统。</p><h2 id="钱包业务背景介绍"><a href="#钱包业务背景介绍" class="headerlink" title="钱包业务背景介绍"></a>钱包业务背景介绍</h2><p>一般来讲，每个虚拟钱包账户都会对应用户的一个真实的支付账户，有可能是银行卡账户，也有可能是三方支付账户（比如支付宝、微信钱包）。为了方便后续的讲解，我们限定钱包暂时只支持充值、提现、支付、查询余额、查询交易流水这五个核心的功能，其他比如冻结、透支、转赠等不常用的功能，我们暂不考虑。为了让你理解这五个核心功能是如何工作的，接下来，我们来一块儿看下它们的业务实现流程。</p><p><strong>1. 充值</strong></p><p>用户通过三方支付渠道，把自己银行卡账户内的钱，充值到虚拟钱包账号中。这整个过程，我们可以分解为三个主要的操作流程：第一个操作是从用户的银行卡账户转账到应用的公共银行卡账户；第二个操作是将用户的充值金额加到虚拟钱包余额上；第三个操作是记录刚刚这笔交易流水。</p><p><strong>2. 支付</strong></p><p>用户用钱包内的余额，支付购买应用内的商品。实际上，支付的过程就是一个转账的过程，从用户的虚拟钱包账户划钱到商家的虚拟钱包账户上，然后触发真正的银行转账操作，从应用的公共银行账户转钱到商家的银行账户（注意，这里并不是从用户的银行账户转钱到商家的银行账户）。除此之外，我们也需要记录这笔支付的交易流水信息。</p><p><strong>3. 提现</strong></p><p>除了充值、支付之外，用户还可以将虚拟钱包中的余额，提现到自己的银行卡中。这个过程实际上就是扣减用户虚拟钱包中的余额，并且触发真正的银行转账操作，从应用的公共银行账户转钱到用户的银行账户。同样，我们也需要记录这笔提现的交易流水信息。</p><p><strong>4. 查询余额</strong></p><p>查询余额功能比较简单，我们看一下虚拟钱包中的余额数字即可。</p><p><strong>5. 查询交易流水</strong></p><p>查询交易流水也比较简单。我们只支持三种类型的交易流水：充值、支付、提现。在用户充值、支付、提现的时候，我们会记录相应的交易信息。在需要查询的时候，我们只需要将之前记录的交易流水，按照时间、类型等条件过滤之后，显示出来即可。</p><h2 id="钱包系统的设计思路"><a href="#钱包系统的设计思路" class="headerlink" title="钱包系统的设计思路"></a>钱包系统的设计思路</h2><p>根据刚刚讲的业务实现流程和数据流转图，我们可以把整个钱包系统的业务划分为两部分，其中一部分单纯跟应用内的虚拟钱包账户打交道，另一部分单纯跟银行账户打交道。我们基于这样一个业务划分，给系统解耦，将整个钱包系统拆分为两个子系统：虚拟钱包系统和三方支付系统。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/11/30/f0f94c80-1376-11ea-9851-a125d350ec5f.png" srcset="/img/loading.gif" alt="image.png"><br>接来下只聚焦于虚拟钱包系统的设计与实现。对于三方支付系统以及整个钱包系统的设计与实现，你可以自己思考下。</p><p><strong>现在我们来看下，如果要支持钱包的这五个核心功能，虚拟钱包系统需要对应实现哪些操作</strong>。下面有一张图，列出了这五个功能都会对应虚拟钱包的哪些操作。注意，交易流水的记录和查询，暂时在图中打了个问号，那是因为这块比较特殊，我们待会再讲。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/11/30/60d4b490-1377-11ea-9851-a125d350ec5f.png" srcset="/img/loading.gif" alt="image.png"><br>从图中我们可以看出，虚拟钱包系统要支持的操作非常简单，就是余额的加加减减。其中，充值、提现、查询余额三个功能，只涉及一个账户余额的加减操作，而支付功能涉及两个账户的余额加减操作：一个账户减余额，另一个账户加余额。</p><p><strong>现在，我们再来看一下图中问号的那部分，也就是交易流水该如何记录和查询？</strong>我们先来看一下，交易流水都需要包含哪些信息。我觉得下面这几个信息是必须包含的。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/11/30/b493c300-1377-11ea-9851-a125d350ec5f.png" srcset="/img/loading.gif" alt="image2.png"></p><p>从图中我们可以发现，交易流水的数据格式包含两个钱包账号，一个是入账钱包账号，一个是出账钱包账号。为什么要有两个账号信息呢？这主要是为了兼容支付这种涉及两个账户的交易类型。不过，对于充值、提现这两种交易类型来说，我们只需要记录一个钱包账户信息就够了，所以，这样的交易流水数据格式的设计稍微有点浪费存储空间。</p><p>实际上，我们还有另外一种交易流水数据格式的设计思路，可以解决这个问题。我们把“支付”这个交易类型，拆为两个子类型：支付和被支付。支付单纯表示出账，余额扣减，被支付单纯表示入账，余额增加。这样我们在设计交易流水数据格式的时候，只需要记录一个账户信息即可。我画了一张两种交易流水数据格式的对比图，你可以对比着看一下。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/11/30/ed195dc0-1377-11ea-9851-a125d350ec5f.png" srcset="/img/loading.gif" alt="image3.png"></p><p><strong>那以上两种交易流水数据格式的设计思路，你觉得哪一个更好呢？</strong></p><p>答案是第一种设计思路更好些。因为交易流水有两个功能：一个是业务功能，比如，提供用户查询交易流水信息；另一个是非业务功能，保证数据的一致性。这里主要是指支付操作数据的一致性。</p><p>支付实际上就是一个转账的操作，在一个账户上加上一定的金额，在另一个账户上减去相应的金额。我们需要保证加金额和减金额这两个操作，要么都成功，要么都失败。如果一个成功，一个失败，就会导致数据的不一致，一个账户明明减掉了钱，另一个账户却没有收到钱。</p><p>保证数据一致性的方法有很多，比如依赖数据库事务的原子性，将两个操作放在同一个事务中执行。但是，这样的做法不够灵活，因为我们的有可能做了分库分表，支付涉及的两个账户可能存储在不同的库中，无法直接利用数据库本身的事务特性，在一个事务中执行两个账户的操作。当然，我们还有一些支持分布式事务的开源框架，但是，为了保证数据的强一致性，它们的实现逻辑一般都比较复杂、本身的性能也不高，会影响业务的执行时间。所以，更加权衡的一种做法就是，不保证数据的强一致性，只实现数据的最终一致性，也就是我们刚刚提到的交易流水要实现的非业务功能。</p><p>对于支付这样的类似转账的操作，我们在操作两个钱包账户余额之前，先记录交易流水，并且标记为“待执行”，当两个钱包的加减金额都完成之后，我们再回过头来，将交易流水标记为“成功”。在给两个钱包加减金额的过程中，如果有任意一个操作失败，我们就将交易记录的状态标记为“失败”。我们通过后台补漏 <code>Job</code>，拉取状态为“失败”或者长时间处于“待执行”状态的交易记录，重新执行或者人工介入处理。</p><p>如果选择第二种交易流水的设计思路，使用两条交易流水来记录支付操作，那记录两条交易流水本身又存在数据的一致性问题，有可能入账的交易流水记录成功，出账的交易流水信息记录失败。所以，权衡利弊，我们选择第一种稍微有些冗余的数据格式设计思路。</p><p><strong>现在，我们再思考这样一个问题：充值、提现、支付这些业务交易类型，是否应该让虚拟钱包系统感知？换句话说，我们是否应该在虚拟钱包系统的交易流水中记录这三种类型？</strong></p><p>答案是否定的。虚拟钱包系统不应该感知具体的业务交易类型。我们前面讲到，虚拟钱包支持的操作，仅仅是余额的加加减减操作，不涉及复杂业务概念，职责单一、功能通用。如果耦合太多业务概念到里面，势必影响系统的通用性，而且还会导致系统越做越复杂。因此，我们不希望将充值、支付、提现这样的业务概念添加到虚拟钱包系统中。</p><p>但是，<strong>如果我们不在虚拟钱包系统的交易流水中记录交易类型，那在用户查询交易流水的时候，如何显示每条交易流水的交易类型呢？</strong></p><p>从系统设计的角度，我们不应该在虚拟钱包系统的交易流水中记录交易类型。从产品需求的角度来说，我们又必须记录交易流水的交易类型。听起来比较矛盾，这个问题该如何解决呢？</p><p>我们可以通过记录两条交易流水信息的方式来解决。我们前面讲到，整个钱包系统分为两个子系统，上层钱包系统的实现，依赖底层虚拟钱包系统和三方支付系统。对于钱包系统来说，它可以感知充值、支付、提现等业务概念，所以，我们在钱包系统这一层额外再记录一条包含交易类型的交易流水信息，而在底层的虚拟钱包系统中记录不包含交易类型的交易流水信息。</p><p>为了让你更好地理解刚刚的设计思路，下面有一张图，你可以对比着上面的讲解一块儿来看。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/11/30/98a95960-1378-11ea-9851-a125d350ec5f.png" srcset="/img/loading.gif" alt="image4.png"><br>通过查询上层钱包系统的交易流水信息，去满足用户查询交易流水的功能需求，而虚拟钱包中的交易流水就只是用来解决数据一致性问题。实际上，它的作用还有很多，比如用来对账等。</p><p>整个虚拟钱包的设计思路到此讲完了。接下来，我们来看一下，如何分别用基于贫血模型的传统开发模式和基于充血模型的 <code>DDD</code> 开发模式，来实现这样一个虚拟钱包系统？</p><h2 id="基于贫血模型的传统开发模式"><a href="#基于贫血模型的传统开发模式" class="headerlink" title="基于贫血模型的传统开发模式"></a>基于贫血模型的传统开发模式</h2><p>这是一个典型的 <code>Web</code> 后端项目的三层结构。其中，<code>Controller</code> 和 <code>VO</code> 负责暴露接口，具体的代码实现如下所示。注意，<code>Controller</code> 中，接口实现比较简单，主要就是调用 <code>Service 的方法</code>，所以，我省略了具体的代码实现。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VirtualWalletController</span> </span>&#123;  <span class="hljs-comment">// 通过构造函数或者IOC框架注入</span>  <span class="hljs-keyword">private</span> VirtualWalletService virtualWalletService;    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">(Long walletId)</span> </span>&#123; ... &#125; <span class="hljs-comment">//查询余额</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debit</span><span class="hljs-params">(Long walletId, BigDecimal amount)</span> </span>&#123; ... &#125; <span class="hljs-comment">//出账</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">credit</span><span class="hljs-params">(Long walletId, BigDecimal amount)</span> </span>&#123; ... &#125; <span class="hljs-comment">//入账</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Long fromWalletId, Long toWalletId, BigDecimal amount)</span> </span>&#123; ...&#125; <span class="hljs-comment">//转账</span>&#125;</code></pre><p><code>Service</code> 和 <code>BO</code> 负责核心业务逻辑，<code>Repository</code> 和 <code>Entity</code> 负责数据存取。<code>Repository</code> 这一层的代码实现比较简单，不是讲解的重点，所以也省略掉了。<code>Service</code> 层的代码如下所示。注意，这里省略了一些不重要的校验代码，比如，对 <code>amount</code> 是否小于 <code>0</code>、钱包是否存在的校验等等。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VirtualWalletBo</span> </span>&#123;<span class="hljs-comment">//省略getter/setter/constructor方法</span>  <span class="hljs-keyword">private</span> Long id;  <span class="hljs-keyword">private</span> Long createTime;  <span class="hljs-keyword">private</span> BigDecimal balance;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VirtualWalletService</span> </span>&#123;  <span class="hljs-comment">// 通过构造函数或者IOC框架注入</span>  <span class="hljs-keyword">private</span> VirtualWalletRepository walletRepo;  <span class="hljs-keyword">private</span> VirtualWalletTransactionRepository transactionRepo;    <span class="hljs-function"><span class="hljs-keyword">public</span> VirtualWalletBo <span class="hljs-title">getVirtualWallet</span><span class="hljs-params">(Long walletId)</span> </span>&#123;    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);    VirtualWalletBo walletBo = convert(walletEntity);    <span class="hljs-keyword">return</span> walletBo;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">(Long walletId)</span> </span>&#123;    <span class="hljs-keyword">return</span> virtualWalletRepo.getBalance(walletId);  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debit</span><span class="hljs-params">(Long walletId, BigDecimal amount)</span> </span>&#123;    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);    BigDecimal balance = walletEntity.getBalance();    <span class="hljs-keyword">if</span> (balance.compareTo(amount) &lt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSufficientBalanceException(...);    &#125;    walletRepo.updateBalance(walletId, balance.subtract(amount));  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">credit</span><span class="hljs-params">(Long walletId, BigDecimal amount)</span> </span>&#123;    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);    BigDecimal balance = walletEntity.getBalance();    walletRepo.updateBalance(walletId, balance.add(amount));  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Long fromWalletId, Long toWalletId, BigDecimal amount)</span> </span>&#123;    VirtualWalletTransactionEntity transactionEntity = <span class="hljs-keyword">new</span> VirtualWalletTransactionEntity();    transactionEntity.setAmount(amount);    transactionEntity.setCreateTime(System.currentTimeMillis());    transactionEntity.setFromWalletId(fromWalletId);    transactionEntity.setToWalletId(toWalletId);    transactionEntity.setStatus(Status.TO_BE_EXECUTED);    Long transactionId = transactionRepo.saveTransaction(transactionEntity);    <span class="hljs-keyword">try</span> &#123;      debit(fromWalletId, amount);      credit(toWalletId, amount);    &#125; <span class="hljs-keyword">catch</span> (InsufficientBalanceException e) &#123;      transactionRepo.updateStatus(transactionId, Status.CLOSED);      ...rethrow exception e...    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;      transactionRepo.updateStatus(transactionId, Status.FAILED);      ...rethrow exception e...    &#125;    transactionRepo.updateStatus(transactionId, Status.EXECUTED);  &#125;&#125;</code></pre><p>以上便是利用基于贫血模型的传统开发模式来实现的虚拟钱包系统。尽管我们对代码稍微做了简化，但整体的业务逻辑就是上面这样子。其中大部分代码逻辑都非常简单，最复杂的是 <code>Service</code> 中的 <code>transfer()</code> 转账函数。我们为了保证转账操作的数据一致性，添加了一些跟 <code>transaction</code> 相关的记录和状态更新的代码，理解起来稍微有点难度，你可以对照着之前讲的设计思路，自己多思考一下。</p><h2 id="基于充血模型的-DDD-开发模式"><a href="#基于充血模型的-DDD-开发模式" class="headerlink" title="基于充血模型的 DDD 开发模式"></a>基于充血模型的 DDD 开发模式</h2><p>再来看一下，如何利用基于充血模型的 <code>DDD</code> 开发模式来实现这个系统？</p><p>基于充血模型的 <code>DDD</code> 开发模式，跟基于贫血模型的传统开发模式的主要区别就在 <code>Service</code> 层，<code>Controller</code> 层和 <code>Repository</code> 层的代码基本上相同。所以，我们重点看一下，<code>Service</code> 层按照基于充血模型的 <code>DDD</code> 开发模式该如何来实现。</p><p>在这种开发模式下，我们把虚拟钱包 <code>VirtualWallet</code> 类设计成一个充血的 <code>Domain</code> 领域模型，并且将原来在 <code>Service</code> 类中的部分业务逻辑移动到 <code>VirtualWallet</code> 类中，让 <code>Service</code> 类的实现依赖 <code>VirtualWallet</code> 类。具体的代码实现如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VirtualWallet</span> </span>&#123; <span class="hljs-comment">// Domain领域模型(充血模型)</span>  <span class="hljs-keyword">private</span> Long id;  <span class="hljs-keyword">private</span> Long createTime = System.currentTimeMillis();;  <span class="hljs-keyword">private</span> BigDecimal balance = BigDecimal.ZERO;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">VirtualWallet</span><span class="hljs-params">(Long preAllocatedId)</span> </span>&#123;    <span class="hljs-keyword">this</span>.id = preAllocatedId;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">balance</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.balance;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debit</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.balance.compareTo(amount) &lt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InsufficientBalanceException(...);    &#125;    <span class="hljs-keyword">this</span>.balance.subtract(amount);  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">credit</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123;    <span class="hljs-keyword">if</span> (amount.compareTo(BigDecimal.ZERO) &lt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidAmountException(...);    &#125;    <span class="hljs-keyword">this</span>.balance.add(amount);  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VirtualWalletService</span> </span>&#123;  <span class="hljs-comment">// 通过构造函数或者IOC框架注入</span>  <span class="hljs-keyword">private</span> VirtualWalletRepository walletRepo;  <span class="hljs-keyword">private</span> VirtualWalletTransactionRepository transactionRepo;    <span class="hljs-function"><span class="hljs-keyword">public</span> VirtualWallet <span class="hljs-title">getVirtualWallet</span><span class="hljs-params">(Long walletId)</span> </span>&#123;    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);    VirtualWallet wallet = convert(walletEntity);    <span class="hljs-keyword">return</span> wallet;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">(Long walletId)</span> </span>&#123;    <span class="hljs-keyword">return</span> virtualWalletRepo.getBalance(walletId);  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debit</span><span class="hljs-params">(Long walletId, BigDecimal amount)</span> </span>&#123;    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);    VirtualWallet wallet = convert(walletEntity);    wallet.debit(amount);    walletRepo.updateBalance(walletId, wallet.balance());  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">credit</span><span class="hljs-params">(Long walletId, BigDecimal amount)</span> </span>&#123;    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);    VirtualWallet wallet = convert(walletEntity);    wallet.credit(amount);    walletRepo.updateBalance(walletId, wallet.balance());  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Long fromWalletId, Long toWalletId, BigDecimal amount)</span> </span>&#123;    <span class="hljs-comment">//...跟基于贫血模型的传统开发模式的代码一样...</span>  &#125;&#125;</code></pre><p>看了上面的代码，你可能会说，领域模型 <code>VirtualWallet</code> 类很单薄，包含的业务逻辑很简单。相对于原来的贫血模型的设计思路，这种充血模型的设计思路，貌似并没有太大优势。这也是大部分业务系统都使用基于贫血模型开发的原因。不过，如果虚拟钱包系统需要支持更复杂的业务逻辑，那充血模型的优势就显现出来了。比如，我们要支持透支一定额度和冻结部分余额的功能。这个时候，我们重新来看一下 <code>VirtualWallet</code> 类的实现代码。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VirtualWallet</span> </span>&#123;  <span class="hljs-keyword">private</span> Long id;  <span class="hljs-keyword">private</span> Long createTime = System.currentTimeMillis();;  <span class="hljs-keyword">private</span> BigDecimal balance = BigDecimal.ZERO;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isAllowedOverdraft = <span class="hljs-keyword">true</span>;  <span class="hljs-keyword">private</span> BigDecimal overdraftAmount = BigDecimal.ZERO;  <span class="hljs-keyword">private</span> BigDecimal frozenAmount = BigDecimal.ZERO;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">VirtualWallet</span><span class="hljs-params">(Long preAllocatedId)</span> </span>&#123;    <span class="hljs-keyword">this</span>.id = preAllocatedId;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">freeze</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unfreeze</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123; ...&#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increaseOverdraftAmount</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decreaseOverdraftAmount</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeOverdraft</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">openOverdraft</span><span class="hljs-params">()</span> </span>&#123; ... &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">balance</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.balance;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">getAvaliableBalance</span><span class="hljs-params">()</span> </span>&#123;    BigDecimal totalAvaliableBalance = <span class="hljs-keyword">this</span>.balance.subtract(<span class="hljs-keyword">this</span>.frozenAmount);    <span class="hljs-keyword">if</span> (isAllowedOverdraft) &#123;      totalAvaliableBalance += <span class="hljs-keyword">this</span>.overdraftAmount;    &#125;    <span class="hljs-keyword">return</span> totalAvaliableBalance;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debit</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123;    BigDecimal totalAvaliableBalance = getAvaliableBalance();    <span class="hljs-keyword">if</span> (totoalAvaliableBalance.compareTo(amount) &lt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InsufficientBalanceException(...);    &#125;    <span class="hljs-keyword">this</span>.balance.subtract(amount);  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">credit</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123;    <span class="hljs-keyword">if</span> (amount.compareTo(BigDecimal.ZERO) &lt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidAmountException(...);    &#125;    <span class="hljs-keyword">this</span>.balance.add(amount);  &#125;&#125;</code></pre><p>领域模型 <code>VirtualWallet</code> 类添加了简单的冻结和透支逻辑之后，功能看起来就丰富了很多，代码也没那么单薄了。如果功能继续演进，我们可以增加更加细化的冻结策略、透支策略、支持钱包账号（<code>VirtualWallet id</code> 字段）自动生成的逻辑（不是通过构造函数经外部传入 <code>ID</code>，而是通过分布式 <code>ID</code> 生成算法来自动生成 <code>ID</code>）等等。<code>VirtualWallet</code> 类的业务逻辑会变得越来越复杂，也就很值得设计成充血模型了。</p><h2 id="辩证思考与灵活应用"><a href="#辩证思考与灵活应用" class="headerlink" title="辩证思考与灵活应用"></a>辩证思考与灵活应用</h2><p>对于虚拟钱包系统的设计与两种开发模式的代码实现，你应该有个比较清晰的了解了。不过，还有两个问题值得讨论一下。</p><p>第一个要讨论的问题是：<strong>在基于充血模型的 <code>DDD</code> 开发模式中，将业务逻辑移动到 <code>Domain</code> 中，<code>Service</code> 类变得很薄，但在我们的代码设计与实现中，并没有完全将 <code>Servic</code>e 类去掉，这是为什么？或者说，<code>Service</code> 类在这种情况下担当的职责是什么？哪些功能逻辑会放到 <code>Service</code> 类中？</strong></p><p>区别于 <code>Domain</code> 的职责，<code>Service</code> 类主要有下面这样几个职责。</p><p>1.<code>Service</code> 类负责与 <code>Repository</code> 交流。在上面的设计与代码实现中，<code>VirtualWalletService</code> 类负责与 <code>Repository</code> 层打交道，调用 <code>Respository</code> 类的方法，获取数据库中的数据，转化成领域模型 <code>VirtualWallet</code>，然后由领域模型 <code>VirtualWallet</code> 来完成业务逻辑，最后调用 <code>Repository</code> 类的方法，将数据存回数据库。</p><p>之所以让 <code>VirtualWalletService</code> 类与 <code>Repository</code> 打交道，而不是让领域模型 <code>VirtualWallet</code> 与 <code>Repository</code> 打交道，那是因为我们想保持领域模型的独立性，不与任何其他层的代码（<code>Repository</code> 层的代码）或开发框架（比如 <code>Spring</code>、<code>MyBatis</code>）耦合在一起，将流程性的代码逻辑（比如从 <code>DB</code> 中取数据、映射数据）与领域模型的业务逻辑解耦，让领域模型更加可复用。</p><p>2.<code>Service</code> 类负责跨领域模型的业务聚合功能。<code>VirtualWalletService</code> 类中的 <code>transfer()</code> 转账函数会涉及两个钱包的操作，因此这部分业务逻辑无法放到 <code>VirtualWallet</code> 类中，所以，我们暂且把转账业务放到 <code>VirtualWalletService</code> 类中了。当然，虽然功能演进，使得转账业务变得复杂起来之后，也可以将转账业务抽取出来，设计成一个独立的领域模型。</p><p>3.<code>Service</code> 类负责一些非功能性及与三方系统交互的工作。比如幂等、事务、发邮件、发消息、记录日志、调用其他系统的 <code>RPC</code> 接口等，都可以放到 <code>Service</code> 类中。</p><p><strong>第二个要讨论问题是：在基于充血模型的 <code>DDD</code> 开发模式中，尽管 <code>Service</code> 层被改造成了充血模型，但是 <code>Controller</code> 层和 <code>Repository</code> 层还是贫血模型，是否有必要也进行充血领域建模呢？</strong></p><p>答案是没有必要。<code>Controller</code> 层主要负责接口的暴露，<code>Repository</code> 层主要负责与数据库打交道，这两层包含的业务逻辑并不多，前面我们也提到了，如果业务逻辑比较简单，就没必要做充血建模，即便设计成充血模型，类也非常单薄，看起来也很奇怪。</p><p>尽管这样的设计是一种面向过程的编程风格，但我们只要控制好面向过程编程风格的副作用，照样可以开发出优秀的软件。那这里的副作用怎么控制呢？</p><p>就拿 <code>Repository</code> 的 <code>Entity</code> 来说，即便它被设计成贫血模型，违反面相对象编程的封装特性，有被任意代码修改数据的风险，但 <code>Entity</code> 的生命周期是有限的。一般来讲，我们把它传递到 <code>Service</code> 层之后，就会转化成 <code>BO</code> 或者 <code>Domain</code> 来继续后面的业务逻辑。<code>Entity</code> 的生命周期到此就结束了，所以也并不会被到处任意修改。</p><p>再来说说 <code>Controller</code> 层的 <code>VO</code>。实际上 <code>VO</code> 是一种 <code>DTO</code>（<code>Data Transfer Object</code>，数据传输对象）。它主要是作为接口的数据传输承载体，将数据发送给其他系统。从功能上来讲，它理应不包含业务逻辑、只包含数据。所以，将它设计成贫血模型也是比较合理的。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>基于充血模型的 <code>DDD</code> 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 <code>Service</code> 层。在基于充血模型的开发模式下，我们将部分原来在 <code>Service</code> 类中的业务逻辑移动到了一个充血的 <code>Domain</code> 领域模型中，让 <code>Service</code> 类的实现依赖这个 <code>Domain</code> 类。</p><p>在基于充血模型的 <code>DDD</code> 开发模式下，<code>Service</code> 类并不会完全移除，而是负责一些不适合放在 <code>Domain</code> 类中的功能。比如，负责与 <code>Repository</code> 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作。</p><p>基于充血模型的 <code>DDD</code> 开发模式跟基于贫血模型的传统开发模式相比，<code>Controller</code> 层和 <code>Repository</code> 层的代码基本上相同。这是因为，<code>Repository</code> 层的 <code>Entity</code> 生命周期有限，<code>Controller</code> 层的 <code>VO</code> 只是单纯作为一种 <code>DTO</code>。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在 <code>Service</code> 层。所以，<code>Repository</code> 层和 <code>Controller</code> 层继续沿用贫血模型的设计思路是没有问题的。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>欢迎在留言区说一说你对 <code>DDD</code> 的看法。</li></ul><p>参考：<a href="https://time.geekbang.org/column/article/169631" target="_blank" rel="noopener">实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(面向对象)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（九）</title>
    <link href="/passages/design-pattern-learn-9/"/>
    <url>/passages/design-pattern-learn-9/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>我们都知道，很多业务系统都是基于 <code>MVC</code> 三层架构来开发的。实际上，更确切点讲，这是一种基于贫血模型的 <code>MVC</code> 三层架构开发模式。</p><p>虽然这种开发模式已经成为标准的 <code>Web</code> 项目的开发模式，但它却违反了面向对象编程风格，是一种彻彻底底的面向过程的编程风格，因此而被有些人称为反模式（<code>anti-pattern</code>）。特别是<strong>领域驱动设计</strong>（<code>Domain Driven Design</code>，简称 <code>DDD</code>）盛行之后，这种基于贫血模型的传统的开发模式就更加被人诟病。而基于充血模型的 <code>DDD</code> 开发模式越来越被人提倡。</p><p>基于上面的描述，我们先搞清楚下面几个问题：</p><ul><li>什么是贫血模型？什么是充血模型？</li><li>为什么说基于贫血模型的传统开发模式违反 <code>OOP</code>?</li><li>基于贫血模型的传统开发模式既然违反 <code>OOP</code>，那又为什么如此流行？</li><li>什么情况下我们应该考虑使用基于充血模型的 <code>DDD</code> 开发模式？</li></ul><h2 id="什么是基于贫血模型的传统开发模式？"><a href="#什么是基于贫血模型的传统开发模式？" class="headerlink" title="什么是基于贫血模型的传统开发模式？"></a>什么是基于贫血模型的传统开发模式？</h2><p>对于大部分的后端开发工程师来说，<code>MVC</code> 三层架构都不会陌生。</p><p><code>MVC</code> 三层架构中的 <code>M</code> 表示 <code>Model</code>，<code>V</code> 表示 <code>View</code>，<code>C</code> 表示 <code>Controller</code>。它将整个项目分为三层：展示层、逻辑层、数据层。<code>MVC</code> 三层开发架构是一个比较笼统的分层方式，落实到具体的开发层面，很多项目也并不会 <code>100%</code> 遵从 MVC 固定的分层方式，而是会根据具体的项目需求，做适当的调整。</p><p>比如，现在很多 <code>Web</code> 或者 <code>App</code> 项目都是前后端分离的，后端负责暴露接口给前端调用。这种情况下，我们一般就将后端项目分为 <code>Repository</code> 层、<code>Service</code> 层、<code>Controller</code> 层。其中，<code>Repository</code> 层负责数据访问，<code>Service</code> 层负责业务逻辑，<code>Controller</code> 层负责暴露接口。当然，这只是其中一种分层和命名方式。不同的项目、不同的团队，可能会对此有所调整。不过，万变不离其宗，只要是依赖数据库开发的 <code>Web</code> 项目，基本的分层思路都大差不差。</p><p><strong>再来看一下，什么是贫血模型？</strong></p><p>目前几乎所有的业务后端系统，都是基于贫血模型的。举一个简单的例子来解释一下。</p><pre><code class="hljs java"><span class="hljs-comment">////////// Controller+VO(View Object) //////////</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;  <span class="hljs-keyword">private</span> UserService userService; <span class="hljs-comment">//通过构造函数或者IOC框架注入</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserVo <span class="hljs-title">getUserById</span><span class="hljs-params">(Long userId)</span> </span>&#123;    UserBo userBo = userService.getUser(userId);    UserVo userVo = [...convert userBo to userVo...];    <span class="hljs-keyword">return</span> userVo;  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserVo</span> </span>&#123;<span class="hljs-comment">//省略其他属性、get/set/construct方法</span>  <span class="hljs-keyword">private</span> Long id;  <span class="hljs-keyword">private</span> String name;  <span class="hljs-keyword">private</span> String cellphone;&#125;<span class="hljs-comment">////////// Service+BO(Business Object) //////////</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;  <span class="hljs-keyword">private</span> UserRepository userRepository; <span class="hljs-comment">//通过构造函数或者IOC框架注入</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserBo <span class="hljs-title">getUserById</span><span class="hljs-params">(Long userId)</span> </span>&#123;    UserEntity userEntity = userRepository.getUserById(userId);    UserBo userBo = [...convert userEntity to userBo...];    <span class="hljs-keyword">return</span> userBo;  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserBo</span> </span>&#123;<span class="hljs-comment">//省略其他属性、get/set/construct方法</span>  <span class="hljs-keyword">private</span> Long id;  <span class="hljs-keyword">private</span> String name;  <span class="hljs-keyword">private</span> String cellphone;&#125;<span class="hljs-comment">////////// Repository+Entity //////////</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> UserEntity <span class="hljs-title">getUserById</span><span class="hljs-params">(Long userId)</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserEntity</span> </span>&#123;<span class="hljs-comment">//省略其他属性、get/set/construct方法</span>  <span class="hljs-keyword">private</span> Long id;  <span class="hljs-keyword">private</span> String name;  <span class="hljs-keyword">private</span> String cellphone;&#125;</code></pre><p>平时开发 <code>Web</code> 后端项目的时候，基本上都是这么组织代码的。其中，<code>UserEntity</code> 和 <code>UserRepository</code> 组成了数据访问层，<code>UserBo</code> 和 <code>UserService</code> 组成了业务逻辑层，<code>UserVo</code> 和 <code>UserController</code> 在这里属于接口层。</p><p>从代码中可以发现，<code>UserBo</code> 是一个纯粹的数据结构，只包含数据，不包含任何业务逻辑。业务逻辑集中在 <code>UserService</code> 中。我们通过 <code>UserService</code> 来操作 <code>UserBo</code>。换句话说，<code>Service</code> 层的数据和业务逻辑，被分割为 <code>BO</code> 和 <code>Service</code> 两个类中。像 <code>UserBo</code> 这样，只包含数据，不包含业务逻辑的类，就叫作<strong>贫血模型</strong>（<code>Anemic Domain Model</code>）。同理，<code>UserEntity</code>、<code>UserVo</code> 都是基于贫血模型设计的。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。</p><h2 id="什么是基于充血模型的-DDD-开发模式？"><a href="#什么是基于充血模型的-DDD-开发模式？" class="headerlink" title="什么是基于充血模型的 DDD 开发模式？"></a>什么是基于充血模型的 DDD 开发模式？</h2><p><strong>首先，我们先来看一下，什么是充血模型？</strong></p><p>在贫血模型中，数据和业务逻辑被分割到不同的类中。<strong>充血模型</strong>（<code>Rich Domain Model</code>）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。</p><p><strong>接下来，再来看一下，什么是领域驱动设计？</strong></p><p>领域驱动设计，即 <code>DDD</code>，主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。领域驱动设计这个概念并不新颖，早在 <code>2004</code> 年就被提出了，到现在已经有十几年的历史了。不过，它被大众熟知，还是基于另一个概念的兴起，那就是微服务。</p><p>除了监控、调用链追踪、<code>API</code> 网关等服务治理系统的开发之外，微服务还有另外一个更加重要的工作，那就是针对公司的业务，合理地做微服务拆分。而领域驱动设计恰好就是用来指导划分服务的。所以，微服务加速了领域驱动设计的盛行。</p><p>领域驱动设计有点儿类似敏捷开发、<code>SOA</code>、<code>PAAS</code> 等概念，听起来很高大上，但实际上只值“五分钱”。即便你没有听说过领域驱动设计，对这个概念一无所知，只要你是在开发业务系统，也或多或少都在使用它。做好领域驱动设计的关键是，看你对自己所做业务的熟悉程度，而并不是对领域驱动设计这个概念本身的掌握程度。即便你对领域驱动搞得再清楚，但是对业务不熟悉，也并不一定能做出合理的领域设计。所以，不要把领域驱动设计当银弹，不要花太多的时间去过度地研究它。</p><p>实际上，基于充血模型的 <code>DDD</code> 开发模式实现的代码，也是按照 <code>MVC</code> 三层架构分层的。<code>Controller</code> 层还是负责暴露接口，<code>Repository</code> 层还是负责数据存取，<code>Service</code> 层负责核心业务逻辑。它跟基于贫血模型的传统开发模式的区别主要在 <code>Service</code> 层。</p><p>在基于贫血模型的传统开发模式中，<code>Service</code> 层包含 <code>Service</code> 类和 <code>BO</code> 类两部分，<code>BO</code> 是贫血模型，只包含数据，不包含具体的业务逻辑。业务逻辑集中在 <code>Service</code> 类中。在基于充血模型的 <code>DDD</code> 开发模式中，<code>Service</code> 层包含 <code>Service</code> 类和 <code>Domain</code> 类两部分。<code>Domain</code> 就相当于贫血模型中的 <code>BO</code>。不过，<code>Domain</code> 与 <code>BO</code> 的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而 <code>Service</code> 类变得非常单薄。总结一下的话就是，基于贫血模型的传统的开发模式，重 <code>Service</code> 轻 <code>BO</code>；基于充血模型的 <code>DDD</code> 开发模式，轻 <code>Service</code> 重 <code>Domain</code>。</p><h2 id="为什么基于贫血模型的传统开发模式如此受欢迎？"><a href="#为什么基于贫血模型的传统开发模式如此受欢迎？" class="headerlink" title="为什么基于贫血模型的传统开发模式如此受欢迎？"></a>为什么基于贫血模型的传统开发模式如此受欢迎？</h2><p>基于贫血模型的传统开发模式，将数据与业务逻辑分离，违反了 <code>OOP</code> 的封装特性，实际上是一种面向过程的编程风格。但是，现在几乎所有的 <code>Web</code> 项目，都是基于这种贫血模型的开发模式，甚至连 <code>Java Spring</code> 框架的官方 <code>demo</code>，都是按照这种开发模式来编写的。</p><p>面向过程编程风格有种种弊端，比如，数据和操作分离之后，数据本身的操作就不受限制了。任何代码都可以随意修改数据。既然基于贫血模型的这种传统开发模式是面向过程编程风格的，那它又为什么会被广大程序员所接受呢？</p><p>第一点原因是，大部分情况下，我们开发的系统业务可能都比较简单，简单到就是基于 <code>SQL</code> 的 <code>CRUD</code> 操作，所以，我们根本不需要动脑子精心设计充血模型，贫血模型就足以应付这种简单业务的开发工作。除此之外，因为业务比较简单，即便我们使用充血模型，那模型本身包含的业务逻辑也并不会很多，设计出来的领域模型也会比较单薄，跟贫血模型差不多，没有太大意义。</p><p>第二点原因是，充血模型的设计要比贫血模型更加有难度。因为充血模型是一种面向对象的编程风格。我们从一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑。而不是像贫血模型那样，我们只需要定义数据，之后有什么功能开发需求，我们就在 <code>Service</code> 层定义什么操作，不需要事先做太多设计。</p><p>第三点原因是，思维已固化，转型有成本。基于贫血模型的传统开发模式经历了这么多年，已经深得人心、习以为常。你随便问一个旁边的大龄同事，基本上他过往参与的所有 <code>Web</code> 项目应该都是基于这个开发模式的，而且也没有出过啥大问题。如果转向用充血模型、领域驱动设计，那势必有一定的学习成本、转型成本。很多人在没有遇到开发痛点的情况下，是不愿意做这件事情的。</p><h2 id="什么项目应该考虑使用基于充血模型的-DDD-开发模式？"><a href="#什么项目应该考虑使用基于充血模型的-DDD-开发模式？" class="headerlink" title="什么项目应该考虑使用基于充血模型的 DDD 开发模式？"></a>什么项目应该考虑使用基于充血模型的 DDD 开发模式？</h2><p>基于贫血模型的传统的开发模式，比较适合业务比较简单的系统开发。相对应的，基于充血模型的 <code>DDD</code> 开发模式，更适合业务复杂的系统开发。比如，包含各种利息计算模型、还款模型等复杂业务的金融系统。</p><p>这两种开发模式，落实到代码层面，区别不就是一个将业务逻辑放到 <code>Service</code> 类中，一个将业务逻辑放到 <code>Domain</code> 领域模型中吗？为什么基于贫血模型的传统开发模式，就不能应对复杂业务系统的开发？而基于充血模型的 <code>DDD</code> 开发模式就可以呢？</p><p>实际上，除了我们能看到的代码层面的区别之外（一个业务逻辑放到 <code>Service</code> 层，一个放到领域模型中），还有一个非常重要的区别，那就是两种不同的开发模式会导致不同的开发流程。基于充血模型的 <code>DDD</code> 开发模式的开发流程，在应对复杂业务系统的开发的时候更加有优势。为什么这么说呢？先来回忆一下，我们平时基于贫血模型的传统的开发模式，都是怎么实现一个功能需求的。</p><p>不夸张地讲，我们平时的开发，大部分都是 <code>SQL</code> 驱动（<code>SQL-Driven</code>）的开发模式。我们接到一个后端接口的开发需求的时候，就去看接口需要的数据对应到数据库中，需要哪张表或者哪几张表，然后思考如何编写 <code>SQL</code> 语句来获取数据。之后就是定义 <code>Entity</code>、<code>BO</code>、<code>VO</code>，然后模板式地往对应的 <code>Repository</code>、<code>Service</code>、<code>Controller</code> 类中添加代码。</p><p>业务逻辑包裹在一个大的 <code>SQL</code> 语句中，而 <code>Service</code> 层可以做的事情很少。<code>SQL</code> 都是针对特定的业务功能编写的，复用性差。当我要开发另一个业务功能的时候，只能重新写个满足新需求的 <code>SQL</code> 语句，这就可能导致各种长得差不多、区别很小的 <code>SQL</code> 语句满天飞。</p><p>所以，在这个过程中，很少有人会应用领域模型、<code>OOP</code> 的概念，也很少有代码复用意识。对于简单业务系统来说，这种开发方式问题不大。但对于复杂业务系统的开发来说，这样的开发方式会让代码越来越混乱，最终导致无法维护。</p><p>如果我们在项目中，应用基于充血模型的 <code>DDD</code> 的开发模式，那对应的开发流程就完全不一样了。在这种开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。领域模型相当于可复用的业务中间层。新功能需求的开发，都基于之前定义好的这些领域模型来完成。</p><p>越复杂的系统，对代码的复用性、易维护性要求就越高，我们就越应该花更多的时间和精力在前期设计上。而基于充血模型的 <code>DDD</code> 开发模式，正好需要我们前期做大量的业务调研、领域模型设计，所以它更加适合这种复杂系统的开发。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>平时做 <code>Web</code> 项目的业务开发，大部分都是基于贫血模型的 <code>MVC</code> 三层架构，这里把它称为传统的开发模式。之所以称之为“传统”，是相对于新兴的基于充血模型的 <code>DDD</code> 开发模式来说的。基于贫血模型的传统开发模式，是典型的面向过程的编程风格。相反，基于充血模型的 <code>DDD</code> 开发模式，是典型的面向对象的编程风格。</p><p>不过，<code>DDD</code> 也并非银弹。对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用，基于充血模型的 <code>DDD</code> 开发模式有点大材小用，无法发挥作用。相反，对于业务复杂的系统开发来说，基于充血模型的 <code>DDD</code> 开发模式，因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，更加有优势。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>对于举的例子中，<code>UserEntity</code>、<code>UserBo</code>、<code>UserVo</code> 包含的字段都差不多，是否可以合并为一个类呢？</li></ul><p>参考：<a href="https://time.geekbang.org/column/article/169600" target="_blank" rel="noopener">实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(面向对象)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（八）</title>
    <link href="/passages/design-pattern-learn-8/"/>
    <url>/passages/design-pattern-learn-8/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>在面向对象编程中，有一条非常经典的设计原则，那就是：组合优于继承，多用组合少用继承。为什么不推荐使用继承？组合相比继承有哪些优势？如何判断该用组合还是继承？</p><h2 id="为什么不推荐使用继承？"><a href="#为什么不推荐使用继承？" class="headerlink" title="为什么不推荐使用继承？"></a>为什么不推荐使用继承？</h2><p>继承是面向对象的四大特性之一，用来表示类之间的 <code>is-a</code> 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。所以，对于是否应该在项目中使用继承，网上有很多争议。很多人觉得继承是一种反模式，应该尽量少用，甚至不用。为什么会有这样的争议？</p><p>假设我们要设计一个关于鸟的类。我们将“鸟类”这样一个抽象的事物概念，定义为一个抽象类 <code>AbstractBird</code>。所有更细分的鸟，比如麻雀、鸽子、乌鸦等，都继承这个抽象类。</p><p>我们知道，大部分鸟都会飞，那我们可不可以在 <code>AbstractBird</code> 抽象类中，定义一个 <code>fly()</code> 方法呢？答案是否定的。尽管大部分鸟都会飞，但也有特例，比如鸵鸟就不会飞。鸵鸟继承具有 <code>fly()</code> 方法的父类，那鸵鸟就具有“飞”这样的行为，这显然不符合我们对现实世界中事物的认识。当然，你可能会说，在鸵鸟这个子类中重写（<code>override</code>）<code>fly()</code> 方法，让它抛出 <code>UnSupportedMethodException</code> 异常不就可以了吗？具体的代码实现如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractBird</span> </span>&#123;  <span class="hljs-comment">//...省略其他属性和方法...</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ostrich</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBird</span> </span>&#123; <span class="hljs-comment">//鸵鸟</span>  <span class="hljs-comment">//...省略其他属性和方法...</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnSupportedMethodException(<span class="hljs-string">"I can't fly.'"</span>);  &#125;&#125;</code></pre><p>这种设计思路虽然可以解决问题，但不够优美。因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，都需要重写 <code>fly()</code> 方法，抛出异常。这样的设计，一方面，徒增了编码的工作量；另一方面，也违背了最小知识原则（<code>Least Knowledge Principle</code>，也叫最少知识原则或者迪米特法则），暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。</p><p>那再通过 <code>AbstractBird</code> 类派生出两个更加细分的抽象类：会飞的鸟类 <code>AbstractFlyableBird</code> 和不会飞的鸟类 <code>AbstractUnFlyableBird</code>，让麻雀、乌鸦这些会飞的鸟都继承 <code>AbstractFlyableBird</code>，让鸵鸟、企鹅这些不会飞的鸟，都继承 <code>AbstractUnFlyableBird</code> 类，不就可以了吗？具体的继承关系如下图所示：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/11/25/1a48e790-0f2a-11ea-b8f5-dd65ff6642d5.png" srcset="/img/loading.gif" alt="image.png"><br>从图中可以看出，继承关系变成了三层。不过，整体上来讲，目前的继承关系还比较简单，层次比较浅，也算是一种可以接受的设计思路。再继续加点难度。在刚刚这个场景中，我们只关注“鸟会不会飞”，但如果我们还关注“鸟会不会叫”，那这个时候，又该如何设计类之间的继承关系呢？</p><p>是否会飞？是否会叫？两个行为搭配起来会产生四种情况：会飞会叫、不会飞会叫、会飞不会叫、不会飞不会叫。如果我们继续沿用刚才的设计思路，那就需要再定义四个抽象类（<code>AbstractFlyableTweetableBird</code>、<code>AbstractFlyableUnTweetableBird</code>、<code>AbstractUnFlyableTweetableBird</code>、<code>AbstractUnFlyableUnTweetableBird</code>）。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/11/25/78493c50-0f2a-11ea-b8f5-dd65ff6642d5.png" srcset="/img/loading.gif" alt="image.png"><br>如果还需要考虑“是否会下蛋”这样一个行为，那估计就要组合爆炸了。类的继承层次会越来越深、继承关系会越来越复杂。而这种层次很深、很复杂的继承关系，一方面，会导致代码的可读性变差。因为我们要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码……一直追溯到最顶层父类的代码。另一方面，这也破坏了类的封装特性，将父类的实现细节暴露给了子类。子类的实现依赖父类的实现，两者高度耦合，一旦父类代码修改，就会影响所有子类的逻辑。</p><p>总之，继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。这也是为什么不推荐使用继承。那刚刚例子中继承存在的问题，又该如何来解决呢?</p><h2 id="组合相比继承有哪些优势？"><a href="#组合相比继承有哪些优势？" class="headerlink" title="组合相比继承有哪些优势？"></a>组合相比继承有哪些优势？</h2><p>实际上，可以利用组合（<code>composition</code>）、接口、委托（<code>delegation</code>）三个技术手段，一块儿来解决刚刚继承存在的问题。</p><p>前面讲到接口的时候说过，接口表示具有某种行为特性。针对“会飞”这样一个行为特性，我们可以定义一个 <code>Flyable</code> 接口，只让会飞的鸟去实现这个接口。对于会叫、会下蛋这些行为特性，我们可以类似地定义 <code>Tweetable</code> 接口、<code>EggLayable</code> 接口。将这个设计思路翻译成 <code>Java</code> 代码的话，就是下面这个样子：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyable</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Tweetable</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tweet</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EggLayable</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">layEgg</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ostrich</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Tweetable</span>, <span class="hljs-title">EggLayable</span> </span>&#123;<span class="hljs-comment">//鸵鸟</span>  <span class="hljs-comment">//... 省略其他属性和方法...</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tweet</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">layEgg</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sparrow</span> <span class="hljs-title">impelents</span> <span class="hljs-title">Flayable</span>, <span class="hljs-title">Tweetable</span>, <span class="hljs-title">EggLayable</span> </span>&#123;<span class="hljs-comment">//麻雀</span>  <span class="hljs-comment">//... 省略其他属性和方法...</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tweet</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">layEgg</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>&#125;</code></pre><p>不过，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍 <code>layEgg()</code> 方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？</p><p>可以针对三个接口再定义三个实现类，它们分别是：实现了 <code>fly()</code> 方法的 <code>FlyAbility</code> 类、实现了 <code>tweet()</code> 方法的 <code>TweetAbility</code> 类、实现了 <code>layEgg()</code> 方法的 <code>EggLayAbility</code> 类。然后，通过组合和委托技术来消除代码重复。具体的代码实现如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyable</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span>；&#125;<span class="hljs-keyword">public</span> class FlyAbility implements Flyable </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>&#125;<span class="hljs-comment">//省略Tweetable/TweetAbility/EggLayable/EggLayAbility</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ostrich</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Tweetable</span>, <span class="hljs-title">EggLayable</span> </span>&#123;<span class="hljs-comment">//鸵鸟</span>  <span class="hljs-keyword">private</span> TweetAbility tweetAbility = <span class="hljs-keyword">new</span> TweetAbility(); <span class="hljs-comment">//组合</span>  <span class="hljs-keyword">private</span> EggLayAbility eggLayAbility = <span class="hljs-keyword">new</span> EggLayAbility(); <span class="hljs-comment">//组合</span>  <span class="hljs-comment">//... 省略其他属性和方法...</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tweet</span><span class="hljs-params">()</span> </span>&#123;    tweetAbility.tweet(); <span class="hljs-comment">// 委托</span>  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">layEgg</span><span class="hljs-params">()</span> </span>&#123;    eggLayAbility.layEgg(); <span class="hljs-comment">// 委托</span>  &#125;&#125;</code></pre><p>继承主要有三个作用：表示 <code>is-a</code> 关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成。比如 <code>is-a</code> 关系，我们可以通过组合和接口的 <code>has-a</code> 关系来替代；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。</p><h2 id="如何判断该用组合还是继承？"><a href="#如何判断该用组合还是继承？" class="headerlink" title="如何判断该用组合还是继承？"></a>如何判断该用组合还是继承？</h2><p>尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，我们要定义更多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。所以，在实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合。</p><p>如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。</p><p>除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（<code>decorator pattern</code>）、策略模式（<code>strategy pattern</code>）、组合模式（<code>composite pattern</code>）等都使用了组合关系，而模板模式（<code>template pattern</code>）使用了继承关系。</p><p>前面讲到继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，<code>A</code> 类和 <code>B</code> 类并不一定具有继承关系。比如，<code>Crawler</code> 类和 <code>PageAnalyzer</code> 类，它们都用到了 <code>URL</code> 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 <code>Crawler</code> 类和 <code>PageAnalyzer</code> 类继承同一个父类，而父类中定义的却只是 <code>URL</code> 相关的操作，会觉得这个代码写得莫名其妙，理解不了。这个时候，使用组合就更加合理、更加灵活。具体的代码实现如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Url</span> </span>&#123;  <span class="hljs-comment">//...省略属性和方法</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Crawler</span> </span>&#123;  <span class="hljs-keyword">private</span> Url url; <span class="hljs-comment">// 组合</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Crawler</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>.url = <span class="hljs-keyword">new</span> Url();  &#125;  <span class="hljs-comment">//...</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageAnalyzer</span> </span>&#123;  <span class="hljs-keyword">private</span> Url url; <span class="hljs-comment">// 组合</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PageAnalyzer</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>.url = <span class="hljs-keyword">new</span> Url();  &#125;  <span class="hljs-comment">//..</span>&#125;</code></pre><p>还有一些特殊的场景要求我们必须使用继承。如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。比如下面这样一段代码，其中 <code>FeignClient</code> 是一个外部类，我们没有权限去修改这部分代码，但是我们希望能重写这个类在运行时执行的 <code>encode()</code> 函数。这个时候，我们只能采用继承来实现了。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignClient</span> </span>&#123; <span class="hljs-comment">// feign client框架代码</span>  <span class="hljs-comment">//...省略其他代码...</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(String url)</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demofunction</span><span class="hljs-params">(FeignClient feignClient)</span> </span>&#123;  <span class="hljs-comment">//...</span>  feignClient.encode(url);  <span class="hljs-comment">//...</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomizedFeignClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FeignClient</span> </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(String url)</span> </span>&#123; <span class="hljs-comment">//...重写encode的实现...&#125;</span>&#125;<span class="hljs-comment">// 调用</span>FeignClient client = <span class="hljs-keyword">new</span> CustomizedFeignClient();demofunction(client);</code></pre><p>尽管有些人说，要杜绝继承，<code>100%</code> 用组合代替继承，但是这里的观点没那么极端！之所以“多用组合少用继承”这个口号喊得这么响，只是因为，长期以来，过度使用继承。还是那句话，组合并不完美，继承也不是一无是处。只要我们控制好它们的副作用、发挥它们各自的优势，在不同的场合下，恰当地选择使用继承还是组合，这才是我们所追求的境界。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p><strong>1. 为什么不推荐使用继承？</strong></p><p>继承是面向对象的四大特性之一，用来表示类之间的 <code>is-a</code> 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。</p><p><strong>2. 组合相比继承有哪些优势？</strong></p><p>继承主要有三个作用：表示 <code>is-a</code> 关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。</p><p><strong>3. 如何判断该用组合还是继承？</strong></p><p>尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>在基于 <code>MVC</code> 架构开发 <code>Web</code> 应用的时候，经常会在数据库层定义 <code>Entity</code>，在 <code>Service</code> 业务层定义 <code>BO</code>（<code>Business Object</code>），在 <code>Controller</code> 接口层定义 <code>VO</code>（<code>View Object</code>）。大部分情况下，<code>Entity</code>、<code>BO</code>、<code>VO</code> 三者之间的代码有很大重复，但又不完全相同。该如何处理 <code>Entity</code>、<code>BO</code>、<code>VO</code> 代码重复的问题呢？</li></ul><p>参考：<a href="https://time.geekbang.org/column/article/169593" target="_blank" rel="noopener">为何说要多用组合少用继承？如何决定该用组合还是继承？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(面向对象)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（七）</title>
    <link href="/passages/design-pattern-learn-7/"/>
    <url>/passages/design-pattern-learn-7/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>基于接口而非实现编程。这个原则非常重要，是一种非常有效的提高代码质量的手段，在平时的开发中特别经常被用到。</p><h2 id="如何解读原则中的“接口”二字？"><a href="#如何解读原则中的“接口”二字？" class="headerlink" title="如何解读原则中的“接口”二字？"></a>如何解读原则中的“接口”二字？</h2><p>“基于接口而非实现编程”这条原则的英文描述是：<code>“Program to an interface, not an implementation”</code>。理解这条原则的时候，千万不要一开始就与具体的编程语言挂钩，局限在编程语言的“接口”语法中（比如 <code>Java</code> 中的 <code>interface</code> 接口语法）。这条原则最早出现于 <code>1994</code> 年 <code>GoF</code> 的《设计模式》这本书，它先于很多编程语言而诞生（比如 <code>Java</code> 语言），是一条比较抽象、泛化的设计思想。</p><p>实际上，理解这条原则的关键，就是理解其中的“接口”两个字。从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。如果落实到具体的编码，“基于接口而非实现编程”这条原则中的“接口”，可以理解为编程语言中的接口或者抽象类。</p><p>这条原则能非常有效地提高代码质量，之所以这么说，那是因为，应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。</p><p>“基于接口而非实现编程”这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。<strong>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。</strong>而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。</p><h2 id="如何将这条原则应用到实战中？"><a href="#如何将这条原则应用到实战中？" class="headerlink" title="如何将这条原则应用到实战中？"></a>如何将这条原则应用到实战中？</h2><p>假设我们的系统中有很多涉及图片处理和存储的业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，我们封装了图片存储相关的代码逻辑，提供了一个统一的 <code>AliyunImageStore</code> 类，供整个系统来使用。具体的代码实现如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AliyunImageStore</span> </span>&#123;  <span class="hljs-comment">//...省略属性、构造函数等...</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createBucketIfNotExisting</span><span class="hljs-params">(String bucketName)</span> </span>&#123;    <span class="hljs-comment">// ...创建bucket代码逻辑...</span>    <span class="hljs-comment">// ...失败会抛出异常..</span>  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">generateAccessToken</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// ...根据accesskey/secrectkey等生成access token</span>  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">uploadToAliyun</span><span class="hljs-params">(Image image, String bucketName, String accessToken)</span> </span>&#123;    <span class="hljs-comment">//...上传图片到阿里云...</span>    <span class="hljs-comment">//...返回图片存储在阿里云上的地址(url）...</span>  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Image <span class="hljs-title">downloadFromAliyun</span><span class="hljs-params">(String url, String accessToken)</span> </span>&#123;    <span class="hljs-comment">//...从阿里云下载图片...</span>  &#125;&#125;<span class="hljs-comment">// AliyunImageStore类的使用举例</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageProcessingJob</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String BUCKET_NAME = <span class="hljs-string">"ai_images_bucket"</span>;  <span class="hljs-comment">//...省略其他无关代码...</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>&#123;    Image image = ...; <span class="hljs-comment">//处理图片，并封装为Image对象</span>    AliyunImageStore imageStore = <span class="hljs-keyword">new</span> AliyunImageStore(<span class="hljs-comment">/*省略参数*/</span>);    imageStore.createBucketIfNotExisting(BUCKET_NAME);    String accessToken = imageStore.generateAccessToken();    imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);  &#125;  &#125;</code></pre><p>整个上传流程包含三个步骤：创建 <code>bucket</code>（你可以简单理解为存储目录）、生成 <code>access token</code> 访问凭证、携带 <code>access token</code> 上传图片到指定的 <code>bucket</code> 中。代码实现非常简单，类中的几个方法定义得都很干净，用起来也很清晰，乍看起来没有太大问题，完全能满足我们将图片存储在阿里云的业务需求。</p><p>不过，软件开发中唯一不变的就是变化。过了一段时间后，我们自建了私有云，不再将图片存储到阿里云了，而是将图片存储到自建私有云上。为了满足这样一个需求的变化，我们该如何修改代码呢？</p><p>我们需要重新设计实现一个存储图片到私有云的 <code>PrivateImageStore</code> 类，并用它替换掉项目中所有的 <code>AliyunImageStore</code> 类对象。这样的修改听起来并不复杂，只是简单替换而已，对整个代码的改动并不大。不过，我们经常说，“细节是魔鬼”。这句话在软件开发中特别适用。实际上，刚刚的设计实现方式，就隐藏了很多容易出问题的“魔鬼细节”，一块来看看都有哪些。</p><p>新的 <code>PrivateImageStore</code> 类需要设计实现哪些方法，才能在尽量最小化代码修改的情况下，替换掉 <code>AliyunImageStore</code> 类呢？这就要求我们必须将 <code>AliyunImageStore</code> 类中所定义的所有 <code>public</code> 方法，在 <code>PrivateImageStore</code> 类中都逐一定义并重新实现一遍。而这样做就会存在一些问题，我总结了下面两点。<br>首先，<code>AliyunImageStore</code> 类中有些函数命名暴露了实现细节，比如，<code>uploadToAliyun()</code> 和 <code>downloadFromAliyun()</code>。如果开发这个功能的同事没有接口意识、抽象思维，那这种暴露实现细节的命名方式就不足为奇了，毕竟最初我们只考虑将图片存储在阿里云上。而我们把这种包含“<code>aliyun</code>”字眼的方法，照抄到 <code>PrivateImageStore</code> 类中，显然是不合适的。如果我们在新类中重新命名 <code>uploadToAliyun()</code>、<code>downloadFromAliyun()</code> 这些方法，那就意味着，我们要修改项目中所有使用到这两个方法的代码，代码修改量可能就会很大。</p><p>其次，将图片存储到阿里云的流程，跟存储到私有云的流程，可能并不是完全一致的。比如，阿里云的图片上传和下载的过程中，需要生产 <code>access token</code>，而私有云不需要 <code>access token</code>。一方面，<code>AliyunImageStore</code> 中定义的 <code>generateAccessToken()</code> 方法不能照抄到 <code>PrivateImageStore</code> 中；另一方面，我们在使用 <code>AliyunImageStore</code> 上传、下载图片的时候，代码中用到了 <code>generateAccessToken()</code> 方法，如果要改为私有云的上传下载流程，这些代码都需要做调整。</p><p>那这两个问题该如何解决呢？解决这个问题的根本方法就是，在编写代码的时候，要遵从“基于接口而非实现编程”的原则，具体来讲，我们需要做到下面这 <code>3</code> 点。</p><ul><li><p>函数的命名不能暴露任何实现细节。比如，前面提到的 <code>uploadToAliyun()</code> 就不符合要求，应该改为去掉 <code>aliyun</code> 这样的字眼，改为更加抽象的命名方式，比如：<code>upload()</code>。</p></li><li><p>封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。</p></li><li><p>为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。</p></li></ul><p>按照这个思路，把代码重构一下。重构后的代码如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ImageStore</span> </span>&#123;  <span class="hljs-function">String <span class="hljs-title">upload</span><span class="hljs-params">(Image image, String bucketName)</span></span>;  <span class="hljs-function">Image <span class="hljs-title">download</span><span class="hljs-params">(String url)</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AliyunImageStore</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImageStore</span> </span>&#123;  <span class="hljs-comment">//...省略属性、构造函数等...</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">upload</span><span class="hljs-params">(Image image, String bucketName)</span> </span>&#123;    createBucketIfNotExisting(bucketName);    String accessToken = generateAccessToken();    <span class="hljs-comment">//...上传图片到阿里云...</span>    <span class="hljs-comment">//...返回图片在阿里云上的地址(url)...</span>  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> Image <span class="hljs-title">download</span><span class="hljs-params">(String url)</span> </span>&#123;    String accessToken = generateAccessToken();    <span class="hljs-comment">//...从阿里云下载图片...</span>  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createBucketIfNotExisting</span><span class="hljs-params">(String bucketName)</span> </span>&#123;    <span class="hljs-comment">// ...创建bucket...</span>    <span class="hljs-comment">// ...失败会抛出异常..</span>  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">generateAccessToken</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// ...根据accesskey/secrectkey等生成access token</span>  &#125;&#125;<span class="hljs-comment">// 上传下载流程改变：私有云不需要支持access token</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrivateImageStore</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImageStore</span>  </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">upload</span><span class="hljs-params">(Image image, String bucketName)</span> </span>&#123;    createBucketIfNotExisting(bucketName);    <span class="hljs-comment">//...上传图片到私有云...</span>    <span class="hljs-comment">//...返回图片的url...</span>  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> Image <span class="hljs-title">download</span><span class="hljs-params">(String url)</span> </span>&#123;    <span class="hljs-comment">//...从私有云下载图片...</span>  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createBucketIfNotExisting</span><span class="hljs-params">(String bucketName)</span> </span>&#123;    <span class="hljs-comment">// ...创建bucket...</span>    <span class="hljs-comment">// ...失败会抛出异常..</span>  &#125;&#125;<span class="hljs-comment">// ImageStore的使用举例</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageProcessingJob</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String BUCKET_NAME = <span class="hljs-string">"ai_images_bucket"</span>;  <span class="hljs-comment">//...省略其他无关代码...</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>&#123;    Image image = ...;<span class="hljs-comment">//处理图片，并封装为Image对象</span>    ImageStore imageStore = <span class="hljs-keyword">new</span> PrivateImageStore(...);    imagestore.upload(image, BUCKET_NAME);  &#125;&#125;</code></pre><p>除此之外，很多人在定义接口的时候，希望通过实现类来反推接口的定义。先把实现类写好，然后看实现类中有哪些方法，照抄到接口定义中。如果按照这种思考方式，就有可能导致接口定义不够抽象，依赖具体的实现。这样的接口设计就没有意义了。不过，如果你觉得这种思考方式更加顺畅，那也没问题，只是将实现类的方法搬移到接口定义中的时候，要有选择性的搬移，不要将跟具体实现相关的方法搬移到接口中，比如 <code>AliyunImageStore</code> 中的 <code>generateAccessToken()</code> 方法。</p><p>总结一下，我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。</p><h2 id="是否需要为每个类定义接口？"><a href="#是否需要为每个类定义接口？" class="headerlink" title="是否需要为每个类定义接口？"></a>是否需要为每个类定义接口？</h2><p>为了满足这条原则，我是不是需要给每个实现类都定义对应的接口呢？在开发的时候，是不是任何代码都要只依赖接口，完全不依赖实现编程呢？</p><p>做任何事情都要讲求一个“度”，过度使用这条原则，非得给每个类都定义接口，接口满天飞，也会导致不必要的开发负担。至于什么时候，该为某个类定义接口，实现基于接口的编程，什么时候不需要定义接口，直接使用实现类编程，我们做权衡的根本依据，还是要回归到设计原则诞生的初衷上来。只要搞清楚了这条原则是为了解决什么样的问题而产生的，你就会发现，很多之前模棱两可的问题，都会变得豁然开朗。</p><p>前面也提到，这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。</p><p>从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。</p><p>除此之外，越是不稳定的系统，越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>1.“基于接口而非实现编程”，这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。</p><ol start="2"><li>我们在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。</li></ol><p>3.“基于接口而非实现编程”这条原则，不仅仅可以指导非常细节的编程开发，还能指导更加上层的架构设计、系统设计等。比如，服务端与客户端之间的“接口”设计、类库的“接口”设计。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>上面的代码例子中，尽管通过接口来隔离了两个具体的实现。但是，在项目中很多地方，我们都是通过下面第 <code>8</code> 行的方式来使用接口的。这就会产生一个问题，那就是，如果我们要替换图片存储方式，还是需要修改很多类似第 <code>8</code> 行那样的代码。这样的设计还是不够完美，对此，有更好的实现思路吗？<pre><code class="hljs java"><span class="hljs-comment">// ImageStore的使用举例</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageProcessingJob</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String BUCKET_NAME = <span class="hljs-string">"ai_images_bucket"</span>;  <span class="hljs-comment">//...省略其他无关代码...</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>&#123;    Image image = ...;<span class="hljs-comment">//处理图片，并封装为Image对象</span>    ImageStore imageStore = <span class="hljs-keyword">new</span> PrivateImageStore(<span class="hljs-comment">/*省略构造函数*/</span>);    imagestore.upload(image, BUCKET_NAME);  &#125;</code></pre></li></ul><p>参考：<a href="https://time.geekbang.org/column/article/165114" target="_blank" rel="noopener">为什么基于接口而非实现编程？有必要为每个类都定义接口吗？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(面向对象)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（六）</title>
    <link href="/passages/design-pattern-learn-6/"/>
    <url>/passages/design-pattern-learn-6/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>在面向对象编程中，抽象类和接口是两个经常被用到的语法概念，是面向对象四大特性，以及很多设计模式、设计思想、设计原则编程实现的基础。比如，我们可以使用接口来实现面向对象的抽象特性、多态特性和基于接口而非实现的设计原则，使用抽象类来实现面向对象的继承特性和模板设计模式等等。</p><p>不过，并不是所有的面向对象编程语言都支持这两个语法概念，比如，<code>C++</code> 这种编程语言只支持抽象类，不支持接口；而像 <code>Python</code> 这样的动态编程语言，既不支持抽象类，也不支持接口。尽管有些编程语言没有提供现成的语法来支持接口和抽象类，我们仍然可以通过一些手段来模拟实现这两个语法概念。</p><p>这两个语法概念不仅在工作中经常会被用到，在面试中也经常被提及。比如，“接口和抽象类的区别是什么？什么时候用接口？什么时候用抽象类？抽象类和接口存在的意义是什么？能解决哪些编程问题？”等等。</p><h2 id="什么是抽象类和接口？区别在哪里？"><a href="#什么是抽象类和接口？区别在哪里？" class="headerlink" title="什么是抽象类和接口？区别在哪里？"></a>什么是抽象类和接口？区别在哪里？</h2><p>不同的编程语言对接口和抽象类的定义方式可能有些差别，但差别并不会很大。</p><p><strong>首先来看一下，在 <code>Java</code> 这种编程语言中，我们是如何定义抽象类的。</strong></p><p>下面这段代码是一个比较典型的抽象类的使用场景（模板设计模式）。<code>Logger</code> 是一个记录日志的抽象类，<code>FileLogger</code> 和 <code>MessageQueueLogger</code> 继承 <code>Logger</code>，分别实现两种不同的日志记录方式：记录日志到文件中和记录日志到消息队列中。<code>FileLogger</code> 和 <code>MessageQueueLogger</code> 两个子类复用了父类 <code>Logger</code> 中的 <code>name</code>、<code>enabled</code>、<code>minPermittedLevel</code> 属性和 <code>log()</code> 方法，但因为这两个子类写日志的方式不同，它们又各自重写了父类中的 <code>doLog()</code> 方法。</p><pre><code class="hljs java"><span class="hljs-comment">// 抽象类</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span> </span>&#123;  <span class="hljs-keyword">private</span> String name;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> enabled;  <span class="hljs-keyword">private</span> Level minPermittedLevel;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Logger</span><span class="hljs-params">(String name, <span class="hljs-keyword">boolean</span> enabled, Level minPermittedLevel)</span> </span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.enabled = enabled;    <span class="hljs-keyword">this</span>.minPermittedLevel = minPermittedLevel;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(Level level, String message)</span> </span>&#123;    <span class="hljs-keyword">boolean</span> loggable = enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intValue());    <span class="hljs-keyword">if</span> (!loggable) <span class="hljs-keyword">return</span>;    doLog(level, message);  &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doLog</span><span class="hljs-params">(Level level, String message)</span></span>;&#125;<span class="hljs-comment">// 抽象类的子类：输出日志到文件</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileLogger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Logger</span> </span>&#123;  <span class="hljs-keyword">private</span> Writer fileWriter;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileLogger</span><span class="hljs-params">(String name, <span class="hljs-keyword">boolean</span> enabled,    Level minPermittedLevel, String filepath)</span> </span>&#123;    <span class="hljs-keyword">super</span>(name, enabled, minPermittedLevel);    <span class="hljs-keyword">this</span>.writer = <span class="hljs-keyword">new</span> FileWriter(filepath);   &#125;    <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doLog</span><span class="hljs-params">(Level level, String mesage)</span> </span>&#123;    <span class="hljs-comment">// 格式化level和message,输出到日志文件</span>    fileWriter.write(...);  &#125;&#125;<span class="hljs-comment">// 抽象类的子类: 输出日志到消息中间件(比如kafka)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageQueueLogger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Logger</span> </span>&#123;  <span class="hljs-keyword">private</span> MessageQueueClient msgQueueClient;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MessageQueueLogger</span><span class="hljs-params">(String name, <span class="hljs-keyword">boolean</span> enabled,    Level minPermittedLevel, MessageQueueClient msgQueueClient)</span> </span>&#123;    <span class="hljs-keyword">super</span>(name, enabled, minPermittedLevel);    <span class="hljs-keyword">this</span>.msgQueueClient = msgQueueClient;  &#125;    <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doLog</span><span class="hljs-params">(Level level, String mesage)</span> </span>&#123;    <span class="hljs-comment">// 格式化level和message,输出到消息中间件</span>    msgQueueClient.send(...);  &#125;&#125;</code></pre><p>通过上面的这个例子来看一下，抽象类具有哪些特性。</p><ul><li><p>抽象类不允许被实例化，只能被继承。也就是说，你不能 <code>new</code> 一个抽象类的对象出来（<code>Logger logger = new Logger(…);</code> 会报编译错误）。</p></li><li><p>抽象类可以包含属性和方法。方法既可以包含代码实现（比如 <code>Logger</code> 中的 <code>log()</code> 方法），也可以不包含代码实现（比如 <code>Logger</code> 中的 <code>doLog()</code> 方法）。不包含代码实现的方法叫作抽象方法。</p></li><li><p>子类继承抽象类，必须实现抽象类中的所有抽象方法。对应到例子代码中就是，所有继承 <code>Logger</code> 抽象类的子类，都必须重写 <code>doLog()</code> 方法。</p></li></ul><p><strong>再来看一下，在 <code>Java</code> 这种编程语言中，我们如何定义接口。</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Filter</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(RpcRequest req)</span> <span class="hljs-keyword">throws</span> RpcException</span>;&#125;<span class="hljs-comment">// 接口实现类：鉴权过滤器</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthencationFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(RpcRequest req)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;    <span class="hljs-comment">//...鉴权逻辑..</span>  &#125;&#125;<span class="hljs-comment">// 接口实现类：限流过滤器</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RateLimitFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(RpcRequest req)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;    <span class="hljs-comment">//...限流逻辑...</span>  &#125;&#125;<span class="hljs-comment">// 过滤器使用demo</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;  <span class="hljs-comment">// filters.add(new AuthencationFilter());</span>  <span class="hljs-comment">// filters.add(new RateLimitFilter());</span>  <span class="hljs-keyword">private</span> List&lt;Filter&gt; filters = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRpcRequest</span><span class="hljs-params">(RpcRequest req)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">for</span> (Filter filter : fitlers) &#123;        filter.doFilter(req);      &#125;    &#125; <span class="hljs-keyword">catch</span>(RpcException e) &#123;      <span class="hljs-comment">// ...处理过滤结果...</span>    &#125;    <span class="hljs-comment">// ...省略其他处理逻辑...</span>  &#125;&#125;</code></pre><p>上面这段代码是一个比较典型的接口的使用场景。通过 <code>Java</code> 中的 <code>interface</code> 关键字定义了一个 <code>Filter</code> 接口。<code>AuthencationFilter</code> 和 <code>RateLimitFilter</code> 是接口的两个实现类，分别实现了对 <code>RPC</code> 请求鉴权和限流的过滤功能。</p><p>代码非常简洁。结合代码再来看一下，接口都有哪些特性。</p><ul><li><p>接口不能包含属性（也就是成员变量）。</p></li><li><p>接口只能声明方法，方法不能包含代码实现。</p></li><li><p>类实现接口的时候，必须实现接口中声明的所有方法。</p></li></ul><p>从语法特性上对比，这两者有比较大的区别，比如抽象类中可以定义属性、方法的实现，而接口中不能定义属性，方法也不能包含代码实现等等。除了语法特性，从设计的角度，两者也有比较大的区别。</p><p>抽象类实际上就是类，只不过是一种特殊的类，这种类不能被实例化为对象，只能被子类继承。我们知道，继承关系是一种 <code>is-a</code> 的关系，那抽象类既然属于类，也表示一种 <code>is-a</code> 的关系。相对于抽象类的 <code>is-a</code> 关系来说，接口表示一种 <code>has-a</code> 关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是协议（<code>contract</code>）。</p><h2 id="抽象类和接口能解决什么编程问题？"><a href="#抽象类和接口能解决什么编程问题？" class="headerlink" title="抽象类和接口能解决什么编程问题？"></a>抽象类和接口能解决什么编程问题？</h2><p><strong>为什么需要抽象类？它能够解决什么编程问题？</strong></p><p>抽象类也是为代码复用而生的。多个子类可以继承抽象类中定义的属性和方法，避免在子类中，重复编写相同的代码。</p><p>不过，既然继承本身就能达到代码复用的目的，而继承也并不要求父类一定是抽象类，那我们不使用抽象类，照样也可以实现继承和复用。从这个角度上来讲，我们貌似并不需要抽象类这种语法呀。那抽象类除了解决代码复用的问题，还有什么其他存在的意义吗？</p><p>还是拿之前那个打印日志的例子。我们先对上面的代码做下改造。在改造之后的代码中，<code>Logger</code> 不再是抽象类，只是一个普通的父类，删除了 <code>Logger</code> 中 <code>log()</code>、<code>doLog()</code> 方法，新增了 <code>isLoggable()</code> 方法。<code>FileLogger</code> 和 <code>MessageQueueLogger</code> 还是继承 <code>Logger</code> 父类，以达到代码复用的目的。具体的代码如下：</p><pre><code class="hljs java"><span class="hljs-comment">// 父类：非抽象类，就是普通的类. 删除了log(),doLog()，新增了isLoggable().</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span> </span>&#123;  <span class="hljs-keyword">private</span> String name;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> enabled;  <span class="hljs-keyword">private</span> Level minPermittedLevel;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Logger</span><span class="hljs-params">(String name, <span class="hljs-keyword">boolean</span> enabled, Level minPermittedLevel)</span> </span>&#123;    <span class="hljs-comment">//...构造函数不变，代码省略...</span>  &#125;  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLoggable</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">boolean</span> loggable = enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intValue());    <span class="hljs-keyword">return</span> loggable;  &#125;&#125;<span class="hljs-comment">// 子类：输出日志到文件</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileLogger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Logger</span> </span>&#123;  <span class="hljs-keyword">private</span> Writer fileWriter;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileLogger</span><span class="hljs-params">(String name, <span class="hljs-keyword">boolean</span> enabled,    Level minPermittedLevel, String filepath)</span> </span>&#123;    <span class="hljs-comment">//...构造函数不变，代码省略...</span>  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(Level level, String mesage)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!isLoggable()) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">// 格式化level和message,输出到日志文件</span>    fileWriter.write(...);  &#125;&#125;<span class="hljs-comment">// 子类: 输出日志到消息中间件(比如kafka)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageQueueLogger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Logger</span> </span>&#123;  <span class="hljs-keyword">private</span> MessageQueueClient msgQueueClient;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MessageQueueLogger</span><span class="hljs-params">(String name, <span class="hljs-keyword">boolean</span> enabled,    Level minPermittedLevel, MessageQueueClient msgQueueClient)</span> </span>&#123;    <span class="hljs-comment">//...构造函数不变，代码省略...</span>  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(Level level, String mesage)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!isLoggable()) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">// 格式化level和message,输出到消息中间件</span>    msgQueueClient.send(...);  &#125;&#125;</code></pre><p>这个设计思路虽然达到了代码复用的目的，但是无法使用多态特性了。像下面这样编写代码，就会出现编译错误，因为 <code>Logger</code> 中并没有定义 <code>log()</code> 方法。</p><pre><code class="hljs java">Logger logger = <span class="hljs-keyword">new</span> FileLogger(<span class="hljs-string">"access-log"</span>, <span class="hljs-keyword">true</span>, Level.WARN, <span class="hljs-string">"/users/muchen/access.log"</span>);logger.log(Level.ERROR, <span class="hljs-string">"This is a test log message."</span>);</code></pre><p>你可能会说，这个问题解决起来很简单啊。在 <code>Logger</code> 父类中，定义一个空的 <code>log()</code> 方法，让子类重写父类的 <code>log()</code> 方法，实现自己的记录日志的逻辑，不就可以了吗？</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span> </span>&#123;  <span class="hljs-comment">// ...省略部分代码...</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(Level level, String mesage)</span> </span>&#123; <span class="hljs-comment">// do nothing... &#125;</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileLogger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Logger</span> </span>&#123;  <span class="hljs-comment">// ...省略部分代码...</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(Level level, String mesage)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!isLoggable()) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">// 格式化level和message,输出到日志文件</span>    fileWriter.write(...);  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageQueueLogger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Logger</span> </span>&#123;  <span class="hljs-comment">// ...省略部分代码...</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(Level level, String mesage)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!isLoggable()) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">// 格式化level和message,输出到消息中间件</span>    msgQueueClient.send(...);  &#125;&#125;</code></pre><p>这个设计思路能用，但是，它显然没有之前通过抽象类的实现思路优雅。为什么这么说呢？主要有以下几点原因。</p><ul><li><p>在 <code>Logger</code> 中定义一个空的方法，会影响代码的可读性。如果我们不熟悉 <code>Logger</code> 背后的设计思想，代码注释又不怎么给力，我们在阅读 <code>Logger</code> 代码的时候，就可能对为什么定义一个空的 <code>log()</code> 方法而感到疑惑，需要查看 <code>Logger</code>、<code>FileLogger</code>、<code>MessageQueueLogger</code> 之间的继承关系，才能弄明白其设计意图。</p></li><li><p>当创建一个新的子类继承 <code>Logger</code> 父类的时候，我们有可能会忘记重新实现 <code>log()</code> 方法。之前基于抽象类的设计思路，编译器会强制要求子类重写 <code>log()</code> 方法，否则会报编译错误。你可能会说，我既然要定义一个新的 <code>Logger</code> 子类，怎么会忘记重新实现 <code>log()</code> 方法呢？我们举的例子比较简单，<code>Logger</code> 中的方法不多，代码行数也很少。但是，如果 <code>Logger</code> 有几百行，有 <code>n</code> 多方法，除非你对 <code>Logger</code> 的设计非常熟悉，否则忘记重新实现 <code>log()</code> 方法，也不是不可能的。</p></li><li><p><code>Logger</code> 可以被实例化，换句话说，我们可以 <code>new</code> 一个 <code>Logger</code> 出来，并且调用空的 <code>log()</code> 方法。这也增加了类被误用的风险。当然，这个问题可以通过设置私有的构造函数的方式来解决。不过，显然没有通过抽象类来的优雅。</p></li></ul><p><strong>为什么需要接口？它能够解决什么编程问题？</strong></p><p>抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约，你可以联想类比一下 <code>API</code> 接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。</p><p>实际上，接口是一个比抽象类应用更加广泛、更加重要的知识点。比如，经常提到的“基于接口而非实现编程”，就是一条几乎天天会用到，并且能极大地提高代码的灵活性、扩展性的设计思想。</p><h2 id="如何模拟抽象类和接口两个语法概念？"><a href="#如何模拟抽象类和接口两个语法概念？" class="headerlink" title="如何模拟抽象类和接口两个语法概念？"></a>如何模拟抽象类和接口两个语法概念？</h2><p>在前面举的例子中，使用 <code>Java</code> 的接口语法实现了一个 <code>Filter</code> 过滤器。不过，如果你熟悉的是 <code>C++</code> 这种编程语言，你可能会说，<code>C++</code> 只有抽象类，并没有接口，那从代码实现的角度上来说，是不是就无法实现 <code>Filter</code> 的设计思路了呢？</p><p>先来回忆一下接口的定义：接口中没有成员变量，只有方法声明，没有方法实现，实现接口的类必须实现接口中的所有方法。只要满足这样几点，从设计的角度上来说，我们就可以把它叫作接口。实际上，要满足接口的这些语法特性并不难。在下面这段 <code>C++</code> 代码中，就用抽象类模拟了一个接口（下面这段代码实际上是策略模式中的一段代码）。</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strategy</span> &#123;</span> <span class="hljs-comment">// 用抽象类模拟接口</span>  <span class="hljs-keyword">public</span>:    ~Strategy();    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithm</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;  <span class="hljs-keyword">protected</span>:    Strategy();&#125;;</code></pre><p>抽象类 <code>Strategy</code> 没有定义任何属性，并且所有的方法都声明为 <code>virtual</code> 类型（等同于 <code>Java</code> 中的 <code>abstract</code> 关键字），这样，所有的方法都不能有代码实现，并且所有继承这个抽象类的子类，都要实现这些方法。从语法特性上来看，这个抽象类就相当于一个接口。</p><p>在 <code>Python</code>、<code>Ruby</code> 这些动态语言中，不仅没有接口的概念，也没有类似 <code>abstract</code>、<code>virtual</code> 这样的关键字来定义抽象类，那该如何实现上面的讲到的 <code>Filter</code>、<code>Logger</code> 的设计思路呢？实际上，除了用抽象类来模拟接口之外，还可以用普通类来模拟接口。具体的 <code>Java</code> 代码实现如下所示。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockInteface</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">MockInteface</span><span class="hljs-params">()</span> </span>&#123;&#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">funcA</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MethodUnSupportedException();  &#125;&#125;</code></pre><p>类中的方法必须包含实现，这个不符合接口的定义。但是，我们可以让类中的方法抛出 <code>MethodUnSupportedException</code> 异常，来模拟不包含实现的接口，并且能强迫子类在继承这个父类的时候，都去主动实现父类的方法，否则就会在运行时抛出异常。那又如何避免这个类被实例化呢？实际上很简单，我们只需要将这个类的构造函数声明为 <code>protected</code> 访问权限就可以了。</p><h2 id="如何决定该用抽象类还是接口？"><a href="#如何决定该用抽象类还是接口？" class="headerlink" title="如何决定该用抽象类还是接口？"></a>如何决定该用抽象类还是接口？</h2><p>实际上，判断的标准很简单。如果我们要表示一种 <code>is-a</code> 的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示一种 <code>has-a</code> 关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。</p><p>从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p><strong>1. 抽象类和接口的语法特性</strong></p><p>抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。</p><p><strong>2. 抽象类和接口存在的意义</strong></p><p>抽象类是对成员变量和方法的抽象，是一种 <code>is-a</code> 关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种 <code>has-a</code> 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。</p><p><strong>3. 抽象类和接口的应用场景区别</strong></p><p>什么时候该用抽象类？什么时候该用接口？实际上，判断的标准很简单。如果要表示一种 <code>is-a</code> 的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示一种 <code>has-a</code> 关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>接口和抽象类是两个经常在面试中被问到的概念。如果面试官再让你聊聊接口和抽象类，你会如何回答呢？</li></ul><p>参考：<a href="https://time.geekbang.org/column/article/165103" target="_blank" rel="noopener">接口vs抽象类的区别？如何用普通的类模拟抽象类和接口？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(面向对象)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（五）</title>
    <link href="/passages/design-pattern-learn-5/"/>
    <url>/passages/design-pattern-learn-5/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>常见的编程范式或者说编程风格有三种，面向过程编程、面向对象编程、函数式编程，而面向对象编程又是这其中最主流的编程范式。现如今，大部分编程语言都是面向对象编程语言，大部分软件都是基于面向对象编程这种编程范式来开发的。</p><p>不过，在实际的开发工作中，总以为把所有代码都塞到类里，自然就是在进行面向对象编程了。实际上，这样的认识是不正确的。有时候，从表面上看似是面向对象编程风格的代码，从本质上看却是面向过程编程风格的。</p><h2 id="哪些代码设计看似是面向对象，实际是面向过程的？"><a href="#哪些代码设计看似是面向对象，实际是面向过程的？" class="headerlink" title="哪些代码设计看似是面向对象，实际是面向过程的？"></a>哪些代码设计看似是面向对象，实际是面向过程的？</h2><p>在用面向对象编程语言进行软件开发的时候，我们有时候会写出面向过程风格的代码。有些是有意为之，并无不妥；而有些是无意为之，会影响到代码的质量。</p><p><strong>1. 滥用 <code>getter</code>、<code>setter</code> 方法</strong></p><p>它违反了面向对象编程的封装特性，相当于将面向对象编程风格退化成了面向过程编程风格。通过下面这个例子来给你解释一下这句话。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShoppingCart</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> itemsCount;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> totalPrice;  <span class="hljs-keyword">private</span> List&lt;ShoppingCartItem&gt; items = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemsCount</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.itemsCount;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setItemsCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> itemsCount)</span> </span>&#123;    <span class="hljs-keyword">this</span>.itemsCount = itemsCount;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getTotalPrice</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.totalPrice;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTotalPrice</span><span class="hljs-params">(<span class="hljs-keyword">double</span> totalPrice)</span> </span>&#123;    <span class="hljs-keyword">this</span>.totalPrice = totalPrice;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;ShoppingCartItem&gt; <span class="hljs-title">getItems</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addItem</span><span class="hljs-params">(ShoppingCartItem item)</span> </span>&#123;    items.add(item);    itemsCount++;    totalPrice += item.getPrice();  &#125;  <span class="hljs-comment">// ...省略其他方法...</span>&#125;</code></pre><p>在这段代码中，<code>ShoppingCart</code> 是一个简化后的购物车类，有三个私有（<code>private</code>）属性：<code>itemsCount</code>、<code>totalPrice</code>、<code>items</code>。对于 <code>itemsCount</code>、<code>totalPrice</code> 两个属性，我们定义了它们的 <code>getter</code>、<code>setter</code> 方法。对于 <code>items</code> 属性，我们定义了它的 <code>getter</code> 方法和 <code>addItem()</code> 方法。代码很简单，理解起来不难。那你有没有发现，这段代码有什么问题呢？</p><p>我们先来看前两个属性，<code>itemsCount</code> 和 <code>totalPrice</code>。虽然我们将它们定义成 <code>private</code> 私有属性，但是提供了 <code>public</code> 的 <code>getter</code>、<code>setter</code> 方法，这就跟将这两个属性定义为 <code>public</code> 公有属性，没有什么两样了。外部可以通过 <code>setter</code> 方法随意地修改这两个属性的值。除此之外，任何代码都可以随意调用 <code>setter</code> 方法，来重新设置 <code>itemsCount</code>、<code>totalPrice</code> 属性的值，这也会导致其跟 <code>items</code> 属性的值不一致。</p><p>而面向对象封装的定义是：通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限的接口访问、修改内部数据。所以，暴露不应该暴露的 <code>setter</code> 方法，明显违反了面向对象的封装特性。数据没有访问权限控制，任何代码都可以随意修改它，代码就退化成了面向过程编程风格的了。</p><p>看完了前两个属性，我们再来看 <code>items</code> 这个属性。对于 <code>items</code> 这个属性，我们定义了它的 <code>getter</code> 方法和 <code>addItem()</code> 方法，并没有定义它的 <code>setter</code> 方法。这样的设计貌似看起来没有什么问题，但实际上并不是。</p><p>对于 <code>itemsCount</code> 和 <code>totalPrice</code> 这两个属性来说，定义一个 <code>public</code> 的 <code>getter</code> 方法，确实无伤大雅，毕竟 <code>getter</code> 方法不会修改数据。但是，对于 <code>items</code> 属性就不一样了，这是因为 <code>items</code> 属性的 <code>getter</code> 方法，返回的是一个 <code>List</code>集合容器。外部调用者在拿到这个容器之后，是可以操作容器内部数据的，也就是说，外部代码还是能修改 <code>items</code> 中的数据。比如像下面这样：</p><pre><code class="hljs java">ShoppingCart cart = <span class="hljs-keyword">new</span> ShoppCart();...cart.getItems().clear(); <span class="hljs-comment">// 清空购物车</span></code></pre><p>你可能会说，清空购物车这样的功能需求看起来合情合理啊，上面的代码没有什么不妥啊。你说得没错，需求是合理的，但是这样的代码写法，会导致 <code>itemsCount</code>、<code>totalPrice</code>、<code>items</code> 三者数据不一致。我们不应该将清空购物车的业务逻辑暴露给上层代码。正确的做法应该是，在 <code>ShoppingCart</code> 类中定义一个 <code>clear()</code> 方法，将清空购物车的业务逻辑封装在里面，透明地给调用者使用。<code>ShoppingCart</code> 类的 <code>clear()</code> 方法的具体代码实现如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShoppingCart</span> </span>&#123;  <span class="hljs-comment">// ...省略其他代码...</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;    items.clear();    itemsCount = <span class="hljs-number">0</span>;    totalPrice = <span class="hljs-number">0.0</span>;  &#125;&#125;</code></pre><p>你可能还会说，我有一个需求，需要查看购物车中都买了啥，那这个时候，<code>ShoppingCart</code> 类不得不提供 <code>items</code> 属性的 <code>getter</code> 方法了，那又该怎么办才好呢？</p><p>如果你熟悉 <code>Java</code> 语言，那解决这个问题的方法还是挺简单的。我们可以通过 <code>Java</code> 提供的 <code>Collections.unmodifiableList()</code> 方法，让 <code>getter</code> 方法返回一个不可被修改的 <code>UnmodifiableList</code> 集合容器，而这个容器类重写了 <code>List</code> 容器中跟修改数据相关的方法，比如 <code>add()</code>、<code>clear()</code> 等方法。一旦我们调用这些修改数据的方法，代码就会抛出 <code>UnsupportedOperationException</code> 异常，这样就避免了容器中的数据被修改。具体的代码实现如下所示。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShoppingCart</span> </span>&#123;  <span class="hljs-comment">// ...省略其他代码...</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;ShoppingCartItem&gt; <span class="hljs-title">getItems</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> Collections.unmodifiableList(<span class="hljs-keyword">this</span>.items);  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnmodifiableList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">UnmodifiableCollection</span>&lt;<span class="hljs-title">E</span>&gt;                          <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();  &#125;  <span class="hljs-comment">// ...省略其他代码...</span>&#125;ShoppingCart cart = <span class="hljs-keyword">new</span> ShoppingCart();List&lt;ShoppingCartItem&gt; items = cart.getItems();items.clear();<span class="hljs-comment">//抛出UnsupportedOperationException异常</span></code></pre><p>不过，这样的实现思路还是有点问题。因为当调用者通过 <code>ShoppingCart</code> 的 <code>getItems()</code> 获取到 <code>items</code> 之后，虽然我们没法修改容器中的数据，但我们仍然可以修改容器中每个对象（<code>ShoppingCartItem</code>）的数据。听起来有点绕，看看下面这几行代码你就明白了。</p><pre><code class="hljs java">ShoppingCart cart = <span class="hljs-keyword">new</span> ShoppingCart();cart.add(<span class="hljs-keyword">new</span> ShoppingCartItem(...));List&lt;ShoppingCartItem&gt; items = cart.getItems();ShoppingCartItem item = items.get(<span class="hljs-number">0</span>);item.setPrice(<span class="hljs-number">19.0</span>); <span class="hljs-comment">// 这里修改了item的价格属性</span></code></pre><p>总结一下，在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 <code>setter</code> 方法。除此之外，尽管 <code>getter</code> 方法相对 <code>setter</code> 方法要安全些，但是如果返回的是集合容器（比如例子中的 <code>List</code> 容器），也要防范集合内部数据被修改的危险。</p><p><strong>2. 滥用全局变量和全局方法</strong></p><p>在面向对象编程中，常见的全局变量有单例类对象、静态成员变量、常量等，常见的全局方法有静态方法。单例类对象在全局代码中只有一份，所以，它相当于一个全局变量。静态成员变量归属于类上的数据，被所有的实例化对象所共享，也相当于一定程度上的全局变量。而常量是一种非常常见的全局变量，比如一些代码中的配置参数，一般都设置为常量，放到一个 <code>Constants</code> 类中。静态方法一般用来操作静态变量或者外部数据。你可以联想一下我们常用的各种 <code>Utils</code> 类，里面的方法一般都会定义成静态方法，可以在不用创建对象的情况下，直接拿来使用。静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格。</p><p>在刚刚介绍的这些全局变量和全局方法中，<code>Constants</code> 类和 <code>Utils</code> 类最常用到。现在，我们就结合这两个几乎在每个软件开发中都会用到的类，来深入探讨一下全局变量和全局方法的利与弊。</p><p><strong>我们先来看一下，在我过去参与的项目中，一种常见的 <code>Constants</code> 类的定义方法。</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Constants</span> </span>&#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MYSQL_ADDR_KEY = <span class="hljs-string">"mysql_addr"</span>;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MYSQL_DB_NAME_KEY = <span class="hljs-string">"db_name"</span>;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MYSQL_USERNAME_KEY = <span class="hljs-string">"mysql_username"</span>;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MYSQL_PASSWORD_KEY = <span class="hljs-string">"mysql_password"</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REDIS_DEFAULT_ADDR = <span class="hljs-string">"192.168.7.2:7234"</span>;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> REDIS_DEFAULT_MAX_TOTAL = <span class="hljs-number">50</span>;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> REDIS_DEFAULT_MAX_IDLE = <span class="hljs-number">50</span>;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> REDIS_DEFAULT_MIN_IDLE = <span class="hljs-number">20</span>;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REDIS_DEFAULT_KEY_PREFIX = <span class="hljs-string">"rt:"</span>;    <span class="hljs-comment">// ...省略更多的常量定义...</span>&#125;</code></pre><p>在这段代码中，我们把程序中所有用到的常量，都集中地放到这个 <code>Constants</code> 类中。不过，定义一个如此大而全的 <code>Constants</code> 类，并不是一种很好的设计思路。为什么这么说呢？原因主要有以下几点。</p><p>首先，这样的设计会影响代码的可维护性。</p><p>如果参与开发同一个项目的工程师有很多，在开发过程中，可能都要涉及修改这个类，比如往这个类里添加常量，那这个类就会变得越来越大，成百上千行都有可能，查找修改某个常量也会变得比较费时，而且还会增加提交代码冲突的概率。</p><p>其次，这样的设计还会增加代码的编译时间。</p><p>当 <code>Constants</code> 类中包含很多常量定义的时候，依赖这个类的代码就会很多。那每次修改 <code>Constants</code> 类，都会导致依赖它的类文件重新编译，因此会浪费很多不必要的编译时间。不要小看编译花费的时间，对于一个非常大的工程项目来说，编译一次项目花费的时间可能是几分钟，甚至几十分钟。而我们在开发过程中，每次运行单元测试，都会触发一次编译的过程，这个编译时间就有可能会影响到我们的开发效率。</p><p>最后，这样的设计还会影响代码的复用性。</p><p>如果我们要在另一个项目中，复用本项目开发的某个类，而这个类又依赖 <code>Constants</code> 类。即便这个类只依赖 <code>Constants</code> 类中的一小部分常量，我们仍然需要把整个 <code>Constants</code> 类也一并引入，也就引入了很多无关的常量到新的项目中。</p><p>那如何改进 <code>Constants</code> 类的设计呢？这里有两种思路可以借鉴。</p><p>第一种是将 <code>Constants</code> 类拆解为功能更加单一的多个类，比如跟 <code>MySQL</code> 配置相关的常量，我们放到 <code>MysqlConstants</code> 类中；跟 <code>Redis</code> 配置相关的常量，我们放到 <code>RedisConstants</code> 类中。当然，还有一种觉得更好的设计思路，那就是并不单独地设计 <code>Constants</code> 常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中。比如，<code>RedisConfig</code> 类用到了 <code>Redis</code> 配置相关的常量，那我们就直接将这些常量定义在 <code>RedisConfig</code> 中，这样也提高了类设计的内聚性和代码的复用性。</p><p>讲完了 <code>Constants</code> 类，我们再来讨论一下 <code>Utils</code> 类。首先，想问你这样一个问题，我们为什么需要 <code>Utils</code> 类？<code>Utils</code> 类存在的意义是什么？</p><p>在讲面向对象特性的时候，讲过继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，<code>A</code> 类和 <code>B</code> 类并不一定具有继承关系，比如 <code>Crawler</code> 类和 <code>PageAnalyzer</code> 类，它们都用到了 <code>URL</code> 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 <code>Crawler</code> 类和 <code>PageAnalyzer</code> 类继承同一个父类，而父类中定义的却是 <code>URL</code> 相关的操作，会觉得这个代码写得莫名其妙，理解不了。</p><p>既然继承不能解决这个问题，我们可以定义一个新的类，实现 <code>URL</code> 拼接和分割的方法。而拼接和分割两个方法，不需要共享任何数据，所以新的类不需要定义任何属性，这个时候，我们就可以把它定义为只包含静态方法的 <code>Utils</code> 类了。</p><p>实际上，只包含静态方法不包含任何属性的 <code>Utils</code> 类，是彻彻底底的面向过程的编程风格。但这并不是说，我们就要杜绝使用 <code>Utils</code> 类了。实际上，从刚刚讲的 <code>Utils</code> 类存在的目的来看，它在软件开发中还是挺有用的，能解决代码复用问题。所以，这里并不是说完全不能用 <code>Utils</code> 类，而是说，要尽量避免滥用，不要不加思考地随意去定义 <code>Utils</code> 类。</p><p>在定义 <code>Utils</code> 类之前，你要问一下自己，你真的需要单独定义这样一个 <code>Utils</code> 类吗？是否可以把 <code>Utils</code> 类中的某些方法定义到其他类中呢？如果在回答完这些问题之后，你还是觉得确实有必要去定义这样一个 <code>Utils</code> 类，那就大胆地去定义它吧。因为即便在面向对象编程中，我们也并不是完全排斥面向过程风格的代码。只要它能为我们写出好的代码贡献力量，我们就可以适度地去使用。</p><p>除此之外，类比 <code>Constants</code> 类的设计，我们设计 <code>Utils</code> 类的时候，最好也能细化一下，针对不同的功能，设计不同的 <code>Utils</code> 类，比如 <code>FileUtils</code>、<code>IOUtils</code>、<code>StringUtils</code>、<code>UrlUtils</code> 等，不要设计一个过于大而全的 <code>Utils</code> 类。</p><p><strong>3. 定义数据和方法分离的类</strong></p><p>最后一种面向对象编程过程中，常见的面向过程风格的代码。那就是，数据定义在一个类中，方法定义在另一个类中。</p><p>传统的 <code>MVC</code> 结构分为 <code>Model</code> 层、<code>Controller</code> 层、<code>View</code> 层这三层。不过，在做前后端分离之后，三层结构在后端开发中，会稍微有些调整，被分为 <code>Controller</code> 层、<code>Service</code> 层、<code>Repository</code> 层。<code>Controller</code> 层负责暴露接口给前端调用，<code>Service</code> 层负责核心业务逻辑，<code>Repository</code> 层负责数据读写。而在每一层中，我们又会定义相应的 <code>VO</code>（<code>View Object</code>）、<code>BO</code>（<code>Business Object</code>）、<code>Entity</code>。一般情况下，<code>VO</code>、<code>BO</code>、<code>Entity</code> 中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 <code>Controller</code> 类、<code>Service</code> 类、<code>Repository</code> 类中。这就是典型的面向过程的编程风格。</p><p>实际上，这种开发模式叫作<strong>基于贫血模型的开发模式</strong>，也是我们现在非常常用的一种 <code>Web</code> 项目的开发模式。</p><h2 id="在面向对象编程中，为什么容易写出面向过程风格的代码？"><a href="#在面向对象编程中，为什么容易写出面向过程风格的代码？" class="headerlink" title="在面向对象编程中，为什么容易写出面向过程风格的代码？"></a>在面向对象编程中，为什么容易写出面向过程风格的代码？</h2><p>可以联想一下，在生活中，你去完成一个任务，你一般都会思考，应该先做什么、后做什么，如何一步一步地顺序执行一系列操作，最后完成整个任务。面向过程编程风格恰恰符合人的这种流程化思维方式。而面向对象编程风格正好相反。它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。我们在上一节课讲到了，这样的思考路径比较适合复杂程序的开发，但并不是特别符合人类的思考习惯。</p><p>除此之外，面向对象编程要比面向过程编程难一些。在面向对象编程中，类的设计还是挺需要技巧，挺需要一定设计经验的。你要去思考如何封装合适的数据和方法到一个类里，如何设计类之间的关系，如何设计类之间的交互等等诸多设计问题。</p><p>所以，基于这两点原因，很多工程师在开发的过程，更倾向于用不太需要动脑子的方式去实现需求，也就不由自主地就将代码写成面向过程风格的了。</p><h2 id="面向过程编程及面向过程编程语言就真的无用武之地了吗？"><a href="#面向过程编程及面向过程编程语言就真的无用武之地了吗？" class="headerlink" title="面向过程编程及面向过程编程语言就真的无用武之地了吗？"></a>面向过程编程及面向过程编程语言就真的无用武之地了吗？</h2><p>前面我们有讲到，如果我们开发的是微小程序，或者是一个数据处理相关的代码，以算法为主，数据为辅，那脚本式的面向过程的编程风格就更适合一些。当然，面向过程编程的用武之地还不止这些。实际上，面向过程编程是面向对象编程的基础，面向对象编程离不开基础的面向过程编程。为什么这么说？我们仔细想想，类中每个方法的实现逻辑，不就是面向过程风格的代码吗？</p><p>除此之外，面向对象和面向过程两种编程风格，也并不是非黑即白、完全对立的。在用面向对象编程语言开发的软件中，面向过程风格的代码并不少见，甚至在一些标准的开发库（比如 <code>JDK</code>、<code>Apache Commons</code>、<code>Google Guava</code>）中，也有很多面向过程风格的代码。</p><p>不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码。只要我们能避免面向过程编程风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用，我们就大可不用避讳在面向对象编程中写面向过程风格的代码。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p><strong>1. 滥用 <code>getter</code>、<code>setter</code> 方法</strong></p><p>在设计实现类的时候，除非真的需要，否则尽量不要给属性定义 <code>setter</code> 方法。除此之外，尽管 <code>getter</code> 方法相对 <code>setter</code> 方法要安全些，但是如果返回的是集合容器，那也要防范集合内部数据被修改的风险。</p><p><strong>2.<code>Constants</code> 类、<code>Utils</code> 类的设计问题</strong></p><p>对于这两种类的设计，我们尽量能做到职责单一，定义一些细化的小类，比如 <code>RedisConstants</code>、<code>FileUtils</code>，而不是定义一个大而全的 <code>Constants</code> 类、<code>Utils</code> 类。除此之外，如果能将这些类中的属性和方法，划分归并到其他业务类中，那是最好不过的了，能极大地提高类的内聚性和代码的可复用性。</p><ol start="3"><li>基于贫血模型的开发模式</li></ol><p>讲了为什么这种开发模式是彻彻底底的面向过程编程风格的。这是因为数据和操作是分开定义在 <code>VO/BO/Entity</code> 和 <code>Controler/Service/Repository</code> 中的。</p><p>参考：<a href="https://time.geekbang.org/column/article/164907" target="_blank" rel="noopener">哪些代码设计看似是面向对象，实际是面向过程的？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(面向对象)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（四）</title>
    <link href="/passages/design-pattern-learn-4/"/>
    <url>/passages/design-pattern-learn-4/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>除了面向对象之外，被大家熟知的编程范式还有另外两种，面向过程编程和函数式编程。面向过程这种编程范式随着面向对象的出现，已经慢慢退出了舞台，而函数式编程目前还没有被广泛接受。</p><p>在工作中，很多人搞不清楚面向对象和面向过程的区别，总以为使用面向对象编程语言来做开发，就是在进行面向对象编程了。而实际上，他们只是在用面向对象编程语言，编写面向过程风格的代码而已，并没有发挥面向对象编程的优势。这就相当于手握一把屠龙刀，却只是把它当作一把普通的刀剑来用，相当可惜。</p><h2 id="什么是面向过程编程与面向过程编程语言？"><a href="#什么是面向过程编程与面向过程编程语言？" class="headerlink" title="什么是面向过程编程与面向过程编程语言？"></a>什么是面向过程编程与面向过程编程语言？</h2><p>我们可以对比着面向对象编程和面向对象编程语言这两个概念，来理解面向过程编程和面向过程编程语言。还记得之前是如何定义面向对象编程和面向对象编程语言的吗？让我们一块再来回顾一下。</p><ul><li><p>面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。</p></li><li><p>面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</p></li></ul><p>类比面向对象编程与面向对象编程语言的定义，对于面向过程编程和面向过程编程语言这两个概念，给出下面这样的定义。</p><ul><li><p>面向过程编程也是一种编程范式或编程风格。它以过程（可以为理解方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。</p></li><li><p>面向过程编程语言首先是一种编程语言。它最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程。</p></li></ul><p>不过，这里必须声明一下，就像我们在之前讲到的，面向对象编程和面向对象编程语言并没有官方的定义一样，这里我给出的面向过程编程和面向过程编程语言的定义，也并不是严格的官方定义。之所以要给出这样的定义，只是为了跟面向对象编程及面向对象编程语言做个对比，以方便你理解它们的区别。</p><p>定义不是很严格，也比较抽象，所以，我再用一个例子进一步解释一下。假设我们有一个记录了用户信息的文本文件 <code>users.txt</code>，每行文本的格式是 <code>name&amp;age&amp;gender</code>（比如，<code>小王 &amp;28&amp; 男</code>）。我们希望写一个程序，从 <code>users.txt</code> 文件中逐行读取用户信息，然后格式化成 <code>name\tage\tgender</code>（其中，<code>\t</code> 是分隔符）这种文本格式，并且按照 <code>age</code> 从小到达排序之后，重新写入到另一个文本文件 <code>formatted_users.txt</code> 中。针对这样一个小程序的开发，我们一块来看看，用面向过程和面向对象两种编程风格，编写出来的代码有什么不同。</p><p>首先，我们先来看，用面向过程这种编程风格写出来的代码是什么样子的。注意，下面的代码是用 <code>C</code> 语言这种面向过程的编程语言来编写的。</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">User</span> &#123;</span>  <span class="hljs-keyword">char</span> name[<span class="hljs-number">64</span>];  <span class="hljs-keyword">int</span> age;  <span class="hljs-keyword">char</span> gender[<span class="hljs-number">16</span>];&#125;;<span class="hljs-function">struct User <span class="hljs-title">parse_to_user</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* text)</span> </span>&#123;  <span class="hljs-comment">// 将text(“小王&amp;28&amp;男”)解析成结构体struct User</span>&#125;<span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">format_to_text</span><span class="hljs-params">(struct User user)</span> </span>&#123;  <span class="hljs-comment">// 将结构体struct User格式化成文本（"小王\t28\t男"）</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort_users_by_age</span><span class="hljs-params">(struct User users[])</span> </span>&#123;  <span class="hljs-comment">// 按照年龄从小到大排序users</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">format_user_file</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* origin_file_path, <span class="hljs-keyword">char</span>* new_file_path)</span> </span>&#123;  <span class="hljs-comment">// open files...</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">User</span> <span class="hljs-title">users</span>[1024];</span> <span class="hljs-comment">// 假设最大1024个用户</span>  <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// read until the file is empty</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">User</span> <span class="hljs-title">user</span> = <span class="hljs-title">parse_to_user</span>(<span class="hljs-title">line</span>);</span>    users[count++] = user;  &#125;    sort_users_by_age(users);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; ++i) &#123;    <span class="hljs-keyword">char</span>* formatted_user_text = format_to_text(users[i]);    <span class="hljs-comment">// write to new file...</span>  &#125;  <span class="hljs-comment">// close files...</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">char</span>** args, <span class="hljs-keyword">int</span> argv)</span> </span>&#123;  format_user_file(<span class="hljs-string">"/home/zheng/user.txt"</span>, <span class="hljs-string">"/home/zheng/formatted_users.txt"</span>);&#125;</code></pre><p>然后，我们再来看，用面向对象这种编程风格写出来的代码是什么样子的。注意，下面的代码是用 <code>Java</code> 这种面向对象的编程语言来编写的。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;  <span class="hljs-keyword">private</span> String name;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;  <span class="hljs-keyword">private</span> String gender;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String gender)</span> </span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.age = age;    <span class="hljs-keyword">this</span>.gender = gender;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> User <span class="hljs-title">praseFrom</span><span class="hljs-params">(String userInfoText)</span> </span>&#123;    <span class="hljs-comment">// 将text(“小王&amp;28&amp;男”)解析成结构体struct User</span>  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">formatToText</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 将结构体struct User格式化成文本（"小王\t28\t男"）</span>  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFileFormatter</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">format</span><span class="hljs-params">(String userFile, String formattedUserFile)</span> </span>&#123;    <span class="hljs-comment">// Open files...</span>    List users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// read until file is empty </span>      <span class="hljs-comment">// read from file into userText...</span>      User user = User.parseFrom(userText);      users.add(user);    &#125;    <span class="hljs-comment">// sort users by age...</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; users.size(); ++i) &#123;      String formattedUserText = user.formatToText();      <span class="hljs-comment">// write to new file...</span>    &#125;    <span class="hljs-comment">// close files...</span>  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(Sring[] args)</span> </span>&#123;    UserFileFormatter userFileFormatter = <span class="hljs-keyword">new</span> UserFileFormatter();    userFileFormatter.format(<span class="hljs-string">"/home/zheng/users.txt"</span>, <span class="hljs-string">"/home/zheng/formatted_users.txt"</span>);  &#125;&#125;</code></pre><p>从上面的代码中，我们可以看出，面向过程和面向对象最基本的区别就是，代码的组织方式不同。面向过程风格的代码被组织成了一组方法集合及其数据结构（<code>struct User</code>），方法和数据结构的定义是分开的。面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。</p><h2 id="面向对象编程相比面向过程编程有哪些优势？"><a href="#面向对象编程相比面向过程编程有哪些优势？" class="headerlink" title="面向对象编程相比面向过程编程有哪些优势？"></a>面向对象编程相比面向过程编程有哪些优势？</h2><p>为什么面向对象编程晚于面向过程编程出现，却能取而代之，成为现在主流的编程范式？面向对象编程跟面向过程编程比起来，到底有哪些优势？</p><p><strong>1.<code>OOP</code> 更加能够应对大规模复杂程序的开发</strong></p><p>对于简单程序的开发来说，不管是用面向过程编程风格，还是用面向对象编程风格，差别确实不会很大，甚至有的时候，面向过程的编程风格反倒更有优势。因为需求足够简单，整个程序的处理流程只有一条主线，很容易被划分成顺序执行的几个步骤，然后逐句翻译成代码，这就非常适合采用面向过程这种面条式的编程风格来实现。</p><p>但对于大规模复杂程序的开发来说，整个程序的处理流程错综复杂，并非只有一条主线。如果把整个程序的处理流程画出来的话，会是一个网状结构。如果我们再用面向过程编程这种流程化、线性的思维方式，去翻译这个网状结构，去思考如何把程序拆解为一组顺序执行的方法，就会比较吃力。这个时候，面向对象的编程风格的优势就比较明显了。</p><p>面向对象编程是以类为思考对象。在进行面向对象编程的时候，我们并不是一上来就去思考，如何将复杂的流程拆解为一个一个方法，而是采用曲线救国的策略，先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。当我们有了类的设计之后，然后再像搭积木一样，按照处理流程，将类组装起来形成整个程序。这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候，思路更加清晰。</p><p>除此之外，面向对象编程还提供了一种更加清晰的、更加模块化的代码组织方式。比如，我们开发一个电商交易系统，业务逻辑复杂，代码量很大，可能要定义数百个函数、数百个数据结构，那如何分门别类地组织这些函数和数据结构，才能不至于看起来比较凌乱呢？类就是一种非常好的组织这些函数和数据结构的方式，是一种将代码模块化的有效手段。</p><p>实际上，利用面向过程的编程语言照样可以写出面向对象风格的代码，只不过可能会比用面向对象编程语言来写面向对象风格的代码，付出的代价要高一些。而且，面向过程编程和面向对象编程并非完全对立的。很多软件开发中，尽管利用的是面向过程的编程语言，也都有借鉴面向对象编程的一些优点。</p><p><strong>2.<code>OOP</code> 风格的代码更易复用、易扩展、易维护</strong></p><p>面向过程编程是一种非常简单的编程风格，并没有像面向对象编程那样提供丰富的特性。而面向对象编程提供的封装、抽象、继承、多态这些特性，能极大地满足复杂的编程需求，能方便我们写出更易复用、易扩展、易维护的代码。为什么这么说呢？</p><p>首先，我们先来看下封装特性。封装特性是面向对象编程相比于面向过程编程的一个最基本的区别，因为它基于的是面向对象编程中最基本的类的概念。面向对象编程通过类这种组织代码的方式，将数据和方法绑定在一起，通过访问权限控制，只允许外部调用者通过类暴露的有限方法访问数据，而不会像面向过程编程那样，数据可以被任意方法随意修改。因此，面向对象编程提供的封装特性更有利于提高代码的易维护性。</p><p>其次，我们再来看下抽象特性。我们知道，函数本身就是一种抽象，它隐藏了具体的实现。我们在使用函数的时候，只需要了解函数具有什么功能，而不需要了解它是怎么实现的。从这一点上，不管面向过程编程还是是面向对象编程，都支持抽象特性。不过，面向对象编程还提供了其他抽象特性的实现方式。这些实现方式是面向过程编程所不具备的，比如基于接口实现的抽象。基于接口的抽象，可以让我们在不改变原有实现的情况下，轻松替换新的实现逻辑，提高了代码的可扩展性。</p><p>再次，我们来看下继承特性。继承特性是面向对象编程相比于面向过程编程所特有的两个特性之一（另一个是多态）。如果两个类有一些相同的属性和方法，我们就可以将这些相同的代码，抽取到父类中，让两个子类继承父类。这样两个子类也就可以重用父类中的代码，避免了代码重复写多遍，提高了代码的复用性。</p><p>最后，我们来看下多态特性。基于这个特性，我们在需要修改一个功能实现的时候，可以通过实现一个新的子类的方式，在子类中重写原来的功能逻辑，用子类替换父类。在实际的代码运行过程中，调用子类新的功能逻辑，而不是在原有代码上做修改。这就遵从了“对修改关闭、对扩展开放”的设计原则，提高代码的扩展性。除此之外，利用多态特性，不同的类对象可以传递给相同的方法，执行不同的代码逻辑，提高了代码的复用性。</p><p>所以说，基于这四大特性，利用面向对象编程，我们可以更轻松地写出易复用、易扩展、易维护的代码。当然，我们不能说，利用面向过程风格就不可以写出易复用、易扩展、易维护的代码，但没有四大特性的帮助，付出的代价可能就要高一些。</p><p><strong>3.<code>OOP</code> 语言更加人性化、更加高级、更加智能</strong></p><p>人类最开始跟机器打交道是通过 <code>0</code>、<code>1</code> 这样的二进制指令，然后是汇编语言，再之后才出现了高级编程语言。在高级编程语言中，面向过程编程语言又早于面向对象编程语言出现。之所以先出现面向过程编程语言，那是因为跟机器交互的方式，从二进制指令、汇编语言到面向过程编程语言，是一个非常自然的过渡，都是一种流程化的、面条式的编程风格，用一组指令顺序操作数据，来完成一项任务。</p><p>从指令到汇编再到面向过程编程语言，跟机器打交道的方式在不停地演进，从中我们很容易发现这样一条规律，那就是编程语言越来越人性化，让人跟机器打交道越来越容易。笼统点讲，就是编程语言越来越高级。实际上，在面向过程编程语言之后，面向对象编程语言的出现，也顺应了这样的发展规律，也就是说，面向对象编程语言比面向过程编程语言更加高级！</p><p>跟二进制指令、汇编语言、面向过程编程语言相比，面向对象编程语言的编程套路、思考问题的方式，是完全不一样的。前三者是一种计算机思维方式，而面向对象是一种人类的思维方式。我们在用前面三种语言编程的时候，我们是在思考，如何设计一组指令，告诉机器去执行这组指令，操作某些数据，帮我们完成某个任务。而在进行面向对象编程时候，我们是在思考，如何给业务建模，如何将真实的世界映射为类或者对象，这让我们更加能聚焦到业务本身，而不是思考如何跟机器打交道。可以这么说，越高级的编程语言离机器越“远”，离我们人类越“近”，越“智能”。</p><blockquote><p>顺着刚刚这个编程语言的发展规律来想，如果一种新的突破性的编程语言出现，那它肯定是更加“智能”的。大胆想象一下，使用这种编程语言，我们可以无需对计算机知识有任何了解，无需像现在这样一行一行地敲很多代码，只需要把需求文档写清楚，就能自动生成我们想要的软件了。</p></blockquote><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p><strong>1. 什么面向过程编程？什么面向过程编程语言？</strong></p><p>实际上，面向过程编程和面向过程编程语言并没有严格的官方定义。理解这两个概念最好的方式是跟面向对象编程和面向对象编程语言进行对比。相较于面向对象编程以类为组织代码的基本单元，面向过程编程则是以过程（或方法）作为组织代码的基本单元。它最主要的特点就是数据和方法相分离。相较于面向对象编程语言，面向过程编程语言最大的特点就是不支持丰富的面向对象编程特性，比如继承、多态、封装。</p><p><strong>2. 面向对象编程相比面向过程编程有哪些优势？</strong></p><ul><li><p>面向对象编程相比起面向过程编程的优势主要有三个。<br>对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。</p></li><li><p>面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。</p></li><li><p>从编程语言跟机器打交道的方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。</p></li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>面向对象编程比面向过程编程，更加容易应对大规模复杂程序的开发。但像 <code>Unix</code>、<code>Linux</code> 这些复杂的系统，也都是基于 <code>C</code> 语言这种面向过程的编程语言开发的，怎么看待这个现象？</p><p>参考：<a href="https://time.geekbang.org/column/article/161587" target="_blank" rel="noopener">面向对象相比面向过程有哪些优势？面向过程真的过时了吗？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(面向对象)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（三）</title>
    <link href="/passages/design-pattern-learn-3/"/>
    <url>/passages/design-pattern-learn-3/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>理解面向对象编程及面向对象编程语言的关键就是理解其四大特性：封装、抽象、继承、多态。不过，对于这四大特性，光知道它们的定义是不够的，我们还要知道每个特性存在的意义和目的，以及它们能解决哪些编程问题。</p><h2 id="封装（Encapsulation）"><a href="#封装（Encapsulation）" class="headerlink" title="封装（Encapsulation）"></a>封装（Encapsulation）</h2><p>封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。</p><p>对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持。这个语法机制就是<strong>访问权限控制</strong>。<code>private</code>、<code>public</code> 等关键字就是 <code>Java</code> 语言中的访问权限控制语法。<code>private</code> 关键字修饰的属性只能类本身访问，可以保护其不被类之外的代码直接访问。如果 <code>Java</code> 语言没有提供访问权限控制语法，所有的属性默认都是 <code>public</code> 的，那任意外部代码都可以通过类似 <code>wallet.id=123</code>; 这样的方式直接访问、修改属性，也就没办法达到隐藏信息和保护数据的目的了，也就无法支持封装特性了。</p><p><strong>封装的意义是什么？它能解决什么编程问题？</strong></p><p>如果我们对类中属性的访问不做限制，那任何代码都可以访问、修改类中的属性，虽然这样看起来更加灵活，但从另一方面来说，过度灵活也意味着不可控，属性可以随意被以各种奇葩的方式修改，而且修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性。比如某个同事在不了解业务逻辑的情况下，在某段代码中“偷偷地”重设了 <code>wallet</code> 中的 <code>balanceLastModifiedTime</code> 属性，这就会导致 <code>balance</code> 和 <code>balanceLastModifiedTime</code> 两个数据不一致。</p><p>除此之外，类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。如果我们把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解。而这对于调用者来说也是一种负担。相反，如果我们将属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就减少很多。这就好比，如果一个冰箱有很多按钮，你就要研究很长时间，还不一定能操作正确。相反，如果只有几个必要的按钮，比如开、停、调节温度，你一眼就能知道该如何来操作，而且操作出错的概率也会降低很多。</p><h2 id="抽象（Abstraction）"><a href="#抽象（Abstraction）" class="headerlink" title="抽象（Abstraction）"></a>抽象（Abstraction）</h2><p>封装主要讲的是如何隐藏信息、保护数据，而抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。</p><p>在面向对象编程中，我们常借助编程语言提供的接口类（比如 <code>Java</code> 中的 <code>interface</code> 关键字语法）或者抽象类（比如 <code>Java</code> 中的 <code>abstract</code> 关键字语法）这两种语法机制，来实现抽象这一特性。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IPictureStorage</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">savePicture</span><span class="hljs-params">(Picture picture)</span></span>;  <span class="hljs-function">Image <span class="hljs-title">getPicture</span><span class="hljs-params">(String pictureId)</span></span>;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deletePicture</span><span class="hljs-params">(String pictureId)</span></span>;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modifyMetaInfo</span><span class="hljs-params">(String pictureId, PictureMetaInfo metaInfo)</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureStorage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IPictureStorage</span> </span>&#123;  <span class="hljs-comment">// ...省略其他属性...</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">savePicture</span><span class="hljs-params">(Picture picture)</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> Image <span class="hljs-title">getPicture</span><span class="hljs-params">(String pictureId)</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deletePicture</span><span class="hljs-params">(String pictureId)</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">modifyMetaInfo</span><span class="hljs-params">(String pictureId, PictureMetaInfo metaInfo)</span> </span>&#123; ... &#125;&#125;</code></pre><p>在上面的这段代码中，我们利用 <code>Java</code> 中的 <code>interface</code> 接口语法来实现抽象特性。调用者在使用图片存储功能的时候，只需要了解 <code>IPictureStorage</code> 这个接口类暴露了哪些方法就可以了，不需要去查看 <code>PictureStorage</code> 类里的具体实现逻辑。</p><p>实际上，抽象这个特性是非常容易实现的，并不需要非得依靠接口类或者抽象类这些特殊语法机制来支持。换句话说，并不是说一定要为实现类（<code>PictureStorage</code>）抽象出接口类（<code>IPictureStorage</code>），才叫作抽象。即便不编写 <code>IPictureStorage</code> 接口类，单纯的 <code>PictureStorage</code> 类本身就满足抽象特性。</p><p>之所以这么说，那是因为，类的方法是通过编程语言中的“函数”这一语法机制来实现的。通过函数包裹具体的实现逻辑，这本身就是一种抽象。调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档，了解其提供了什么功能，就可以直接使用了。比如，我们在使用 <code>C</code> 语言的 <code>malloc()</code> 函数的时候，并不需要了解它的底层代码是怎么实现的。</p><p>抽象有时候会被排除在面向对象的四大特性之外，为什么呢？</p><p>抽象这个概念是一个非常通用的设计思想，并不单单用在面向对象编程中，也可以用来指导架构设计等。而且这个特性也并不需要编程语言提供特殊的语法机制来支持，只需要提供“函数”这一非常基础的语法机制，就可以实现抽象特性、所以，它没有很强的“特异性”，有时候并不被看作面向对象编程的特性之一。</p><p><strong>抽象的意义是什么？它能解决什么编程问题</strong></p><p>如果上升一个思考层面的话，抽象及其前面讲到的封装都是人类处理复杂性的有效手段。在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们必须忽略掉一些非关键性的实现细节。而抽象作为一种只关注功能点不关注实现的设计思路，正好帮我们的大脑过滤掉许多非必要的信息。</p><p>除此之外，抽象作为一个非常宽泛的设计思想，在代码设计中，起到非常重要的指导作用。很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则（对扩展开放、对修改关闭）、代码解耦（降低代码的耦合性）等。我们在讲到后面的内容的时候，会具体来解释。</p><p>换一个角度来考虑，我们在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。举个简单例子，比如 <code>getAliyunPictureUrl()</code> 就不是一个具有抽象思维的命名，因为某一天如果我们不再把图片存储在阿里云上，而是存储在私有云上，那这个命名也要随之被修改。相反，如果我们定义一个比较抽象的函数，比如叫作 <code>getPictureUrl()</code>，那即便内部存储方式修改了，我们也不需要修改命名。</p><h2 id="继承（Inheritance）"><a href="#继承（Inheritance）" class="headerlink" title="继承（Inheritance）"></a>继承（Inheritance）</h2><p>继承是用来表示类之间的 <code>is-a</code> 关系，比如猫是一种哺乳动物。从继承关系上来讲，继承可以分为两种模式，单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类，比如猫既是哺乳动物，又是爬行动物。</p><p>为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持，比如 <code>Java</code> 使用 <code>extends</code> 关键字来实现继承，<code>C++</code> 使用冒号（<code>class B : public A</code>），<code>Python</code> 使用 <code>paraentheses()</code>，<code>Ruby</code> 使用 <code>&lt;</code>。不过，有些编程语言只支持单继承，不支持多重继承，比如 <code>Java</code>、<code>PHP</code>、<code>C#</code>、<code>Ruby</code> 等，而有些编程语言既支持单重继承，也支持多重继承，比如 <code>C++</code>、<code>Python</code>、<code>Perl</code> 等。</p><p>为什么 <code>Java</code> 不支持多重继承呢？</p><blockquote><p><strong><code>Java</code> 不支持多重继承的原因：<br>多重继承有副作用：钻石问题(菱形继承)。<br>假设类 <code>B</code> 和类 <code>C</code> 继承自类 <code>A</code>，且都重写了类 <code>A</code> 中的同一个方法，而类 <code>D</code> 同时继承了类 <code>B</code> 和类 <code>C</code>，那么此时类 <code>D</code> 会继承 <code>B</code>、<code>C</code> 的方法，那对于 <code>B</code>、<code>C</code> 重写的 <code>A</code> 中的方法，类 <code>D</code> 会继承哪一个呢？这里就会产生歧义。<br>考虑到这种二义性问题，<code>Java</code> 不支持多重继承。</strong></p></blockquote><p><strong>继承存在的意义是什么？它能解决什么编程问题？</strong></p><p>继承最大的一个好处就是代码复用。假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。这样，两个子类就可以重用父类中的代码，避免代码重复写多遍。不过，这一点也并不是继承所独有的，我们也可以通过其他方式来解决这个代码复用的问题，比如利用组合关系而不是继承关系。</p><p>如果我们再上升一个思维层面，去思考继承这一特性，可以这么理解：我们代码中有一个猫类，有一个哺乳动物类。猫属于哺乳动物，从人类认知的角度上来说，是一种 <code>is-a</code> 关系。我们通过继承来关联两个类，反应真实世界中的这种关系，非常符合人类的认知，而且，从设计的角度来说，也有一种结构美感。</p><p>继承的概念很好理解，也很容易使用。不过，过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。为了了解一个类的功能，我们不仅需要查看这个类的代码，还需要按照继承关系一层一层地往上查看“父类、父类的父类……”的代码。还有，子类和父类高度耦合，修改父类的代码，会直接影响到子类。</p><p>所以，继承这个特性也是一个非常有争议的特性。很多人觉得继承是一种反模式，我们应该尽量少用，甚至不用。</p><h2 id="多态（Polymorphism）"><a href="#多态（Polymorphism）" class="headerlink" title="多态（Polymorphism）"></a>多态（Polymorphism）</h2><p>多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。对于多态这种特性，纯文字解释不好理解，我们还是看一个具体的例子。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicArray</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity = DEFAULT_CAPACITY;  <span class="hljs-keyword">private</span> Integer[] elements = <span class="hljs-keyword">new</span> Integer[DEFAULT_CAPACITY];    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.size; &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123; <span class="hljs-keyword">return</span> elements[index];&#125;  <span class="hljs-comment">//...省略n多方法...</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Integer e)</span> </span>&#123;    ensureCapacity();    elements[size++] = e;  &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//...如果数组满了就扩容...代码省略...</span>  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortedDynamicArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DynamicArray</span> </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Integer e)</span> </span>&#123;    ensureCapacity();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; --i) &#123; <span class="hljs-comment">//保证数组中的数据有序</span>      <span class="hljs-keyword">if</span> (elements[i] &gt; e) &#123;        elements[i+<span class="hljs-number">1</span>] = elements[i];      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">break</span>;      &#125;    &#125;    elements[i+<span class="hljs-number">1</span>] = e;    ++size;  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(DynamicArray dynamicArray)</span> </span>&#123;    dynamicArray.add(<span class="hljs-number">5</span>);    dynamicArray.add(<span class="hljs-number">1</span>);    dynamicArray.add(<span class="hljs-number">3</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dynamicArray.size(); ++i) &#123;      System.out.println(dynamicArray[i]);    &#125;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;    DynamicArray dynamicArray = <span class="hljs-keyword">new</span> SortedDynamicArray();    test(dynamicArray); <span class="hljs-comment">// 打印结果：1、3、5</span>  &#125;&#125;</code></pre><p>多态这种特性也需要编程语言提供特殊的语法机制来实现。在上面的例子中，我们用到了三个语法机制来实现多态。</p><ul><li><p>第一个语法机制是编程语言要支持父类对象可以引用子类对象，也就是可以将 <code>SortedDynamicArray</code> 传递给 <code>DynamicArray</code>。</p></li><li><p>第二个语法机制是编程语言要支持继承，也就是 <code>SortedDynamicArray</code> 继承了 <code>DynamicArray</code>，才能将 <code>SortedDyamicArray</code> 传递给 <code>DynamicArray</code>。</p></li><li><p>第三个语法机制是编程语言要支持子类可以重写（<code>override</code>）父类中的方法，也就是 <code>SortedDyamicArray</code> 重写了 <code>DynamicArray</code> 中的 <code>add()</code> 方法。</p></li></ul><p>通过这三种语法机制配合在一起，我们就实现了在 <code>test()</code> 方法中，子类 <code>SortedDyamicArray</code> 替换父类 <code>DynamicArray</code>，执行子类 <code>SortedDyamicArray</code> 的 <code>add()</code> 方法，也就是实现了多态特性。</p><p>对于多态特性的实现方式，除了利用”继承加方法重写”这种实现方式之外，我们还有其他两种比较常见的的实现方式，一个是利用接口类语法，另一个是利用 <code>duck-typing</code> 语法。不过，并不是每种编程语言都支持接口类或者 <code>duck-typing</code> 这两种语法机制，比如 <code>C++</code> 就不支持接口类语法，而 <code>duck-typing</code> 只有一些动态语言才支持，比如 <code>Python</code>、<code>JavaScript</code> 等。</p><p><strong>接下来，先来看如何利用接口类来实现多态特性。</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span> </span>&#123;  <span class="hljs-function">String <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;  <span class="hljs-function">String <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;  <span class="hljs-function">String <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Array</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span> </span>&#123;  <span class="hljs-keyword">private</span> String[] data;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-comment">//...省略其他方法...</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span> </span>&#123;  <span class="hljs-keyword">private</span> LinkedListNode head;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-comment">//...省略其他方法... </span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Iterator iterator)</span> </span>&#123;    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;      System.out.println(iterator.next());    &#125;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Iterator arrayIterator = <span class="hljs-keyword">new</span> Array();    print(arrayIterator);        Iterator linkedListIterator = <span class="hljs-keyword">new</span> LinkedList();    print(linkedListIterator);  &#125;&#125;</code></pre><p>在这段代码中，<code>Iterator</code> 是一个接口类，定义了一个可以遍历集合数据的迭代器。<code>Array</code> 和 <code>LinkedList</code> 都实现了接口类 <code>Iterator</code>。我们通过传递不同类型的实现类（<code>Array</code>、<code>LinkedList</code>）到 <code>print(Iterator iterator)</code> 函数中，支持动态的调用不同的 <code>next()</code>、<code>hasNext()</code> 实现。</p><p>具体点讲就是，当我们往 <code>print(Iterator iterator)</code> 函数传递 <code>Array</code> 类型的对象的时候，<code>print(Iterator iterator)</code> 函数就会调用 <code>Array</code> 的 <code>next()</code>、<code>hasNext()</code> 的实现逻辑；当我们往 <code>print(Iterator iterator)</code> 函数传递 <code>LinkedList</code> 类型的对象的时候，<code>print(Iterator iterator)</code> 函数就会调用 <code>LinkedList</code> 的 <code>next()</code>、<code>hasNext()</code> 的实现逻辑。</p><p>刚刚讲的是用接口类来实现多态特性。再来看下，如何用 <code>duck-typing</code> 来实现多态特性。我们还是先来看一段代码。这是一段 <code>Python</code> 代码。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">record</span><span class="hljs-params">(self)</span>:</span>        print(“I write a log into file.”)        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DB</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">record</span><span class="hljs-params">(self)</span>:</span>        print(“I insert data into db. ”)        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span><span class="hljs-params">(recorder)</span>:</span>    recorder.record()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span><span class="hljs-params">()</span>:</span>    logger = Logger()    db = DB()    test(logger)    test(db)</code></pre><p>从这段代码中可以发现，<code>duck-typing</code> 实现多态的方式非常灵活。<code>Logger</code> 和 <code>DB</code> 两个类没有任何关系，既不是继承关系，也不是接口和实现的关系，但是只要它们都有定义了 <code>record()</code> 方法，就可以被传递到 <code>test()</code> 方法中，在实际运行的时候，执行对应的 <code>record()</code> 方法。</p><p>也就是说，只要两个类具有相同的方法，就可以实现多态，并不要求两个类之间有任何关系，这就是所谓的 <code>duck-typing</code>，是一些动态语言所特有的语法机制。而像 <code>Java</code> 这样的静态语言，通过继承实现多态特性，必须要求两个类之间有继承关系，通过接口实现多态特性，类必须实现对应的接口。</p><p><strong>多态特性存在的意义是什么？它能解决什么编程问题？</strong></p><p>多态特性能提高代码的可扩展性和复用性。为什么这么说呢？我们回过头去看讲解多态特性的时候，举的第二个代码实例（<code>Iterator</code> 的例子）。</p><p>在那个例子中，我们利用多态的特性，仅用一个 <code>print()</code> 函数就可以实现遍历打印不同类型（<code>Array</code>、<code>LinkedList</code>）集合的数据。当再增加一种要遍历打印的类型的时候，比如 <code>HashMap</code>，我们只需让 <code>HashMap</code> 实现 <code>Iterator</code> 接口，重新实现自己的 <code>hasNext()</code>、<code>next()</code> 等方法就可以了，完全不需要改动 <code>print()</code> 函数的代码。所以说，多态提高了代码的可扩展性。</p><p>如果我们不使用多态特性，我们就无法将不同的集合类型（<code>Array</code>、<code>LinkedList</code>）传递给相同的函数（<code>print(Iterator iterator)</code> 函数）。我们需要针对每种要遍历打印的集合，分别实现不同的 <code>print()</code> 函数，比如针对 <code>Array</code>，我们要实现 <code>print(Array array)</code> 函数，针对 <code>LinkedList</code>，我们要实现 <code>print(LinkedList linkedList)</code> 函数。而利用多态特性，我们只需要实现一个 <code>print()</code> 函数的打印逻辑，就能应对各种集合数据的打印操作，这显然提高了代码的复用性。</p><p>除此之外，多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 <code>if-else</code> 语句等等。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p><strong>1. 关于封装特性</strong></p><p>封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 <code>Java</code> 中的 <code>private</code>、<code>protected</code>、<code>public</code> 关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。</p><p><strong>2. 关于抽象特性</strong></p><p>封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现，但也并不需要特殊的语法机制来支持。抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</p><p><strong>3. 关于继承特性</strong></p><p>继承是用来表示类之间的 <code>is-a</code> 关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题。</p><p><strong>4. 关于多态特性</strong></p><p>多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、<code>duck-typing</code>。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。</p><p>参考：<a href="https://time.geekbang.org/column/article/161114" target="_blank" rel="noopener">理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(面向对象)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（二）</title>
    <link href="/passages/design-pattern-learn-2/"/>
    <url>/passages/design-pattern-learn-2/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>提到面向对象，相信很多人都不陌生，随口都可以说出面向对象的四大特性：封装、抽象、继承、多态。实际上，面向对象这个概念包含的内容还不止这些。</p><h2 id="什么是面向对象编程和面向对象编程语言？"><a href="#什么是面向对象编程和面向对象编程语言？" class="headerlink" title="什么是面向对象编程和面向对象编程语言？"></a>什么是面向对象编程和面向对象编程语言？</h2><p>面向对象编程的英文缩写是 <code>OOP</code>，全称是 <code>Object Oriented Programming</code>。对应地，面向对象编程语言的英文缩写是 <code>OOPL</code>，全称是 <code>Object Oriented Programming Language</code>。</p><p>面向对象编程中有两个非常重要、非常基础的概念，那就是类（<code>class</code>）和对象（<code>object</code>）。这两个概念最早出现在 <code>1960</code> 年，在 <code>Simula</code> 这种编程语言中第一次使用。而面向对象编程这个概念第一次被使用是在 <code>Smalltalk</code> 这种编程语言中。<code>Smalltalk</code> 被认为是第一个真正意义上的面向对象编程语言。</p><p>什么语言才算是面向对象编程语言呢？如果非得给出一个定义的话，可以用下面两句话来概括。</p><ul><li><p>面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石。</p></li><li><p>面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</p></li></ul><p>一般来讲，面向对象编程都是通过使用面向对象编程语言来进行的，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。</p><h2 id="如何判定某编程语言是否是面向对象编程语言？"><a href="#如何判定某编程语言是否是面向对象编程语言？" class="headerlink" title="如何判定某编程语言是否是面向对象编程语言？"></a>如何判定某编程语言是否是面向对象编程语言？</h2><p>实际上，对于什么是面向对象编程、什么是面向对象编程语言，并没有一个官方的、统一的定义。而且，从 <code>1960</code> 年，也就是 <code>60</code> 年前面向对象编程诞生开始，这两个概念就在不停地演化，所以，也无法给出一个明确的定义，也没有必要给出一个明确定义。</p><p>实际上，面向对象编程从字面上，按照最简单、最原始的方式来理解，就是将对象或类作为代码组织的基本单元，来进行编程的一种编程范式或者编程风格，并不一定需要封装、抽象、继承、多态这四大特性的支持。但是，在进行面向对象编程的过程中，人们不停地总结发现，有了这四大特性，我们就能更容易地实现各种面向对象的代码设计思路。</p><p>实际上，只要某种编程语言支持类或对象的语法概念，并且以此作为组织代码的基本单元，那就可以被粗略地认为它就是面向对象编程语言了。至于是否有现成的语法机制，完全地支持了面向对象编程的四大特性、是否对四大特性有所取舍和优化，可以不作为判定的标准。基于此，才有了前面的说法，<strong>按照严格的定义，很多语言都不能算得上面向对象编程语言，但按照不严格的定义来讲，现在流行的大部分编程语言都是面向对象编程语言。</strong></p><h2 id="什么是面向对象分析和面向对象设计？"><a href="#什么是面向对象分析和面向对象设计？" class="headerlink" title="什么是面向对象分析和面向对象设计？"></a>什么是面向对象分析和面向对象设计？</h2><p>实际上，跟面向对象编程经常放到一块儿来讲的还有另外两个概念，那就是面向对象分析（<code>OOA</code>）和面向对象设计（<code>OOD</code>）。面向对象分析英文缩写是 <code>OOA</code>，全称是 <code>Object Oriented Analysis</code>；面向对象设计的英文缩写是 <code>OOD</code>，全称是 <code>Object Oriented Design</code>。<code>OOA</code>、<code>OOD</code>、<code>OOP</code> 三个连在一起就是面向对象分析、设计、编程（实现），正好是面向对象软件开发要经历的三个阶段。</p><p>之所以在前面加“面向对象”这几个字，是因为我们是围绕着对象或类来做需求分析和设计的。分析和设计两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法，类与类之间如何交互等等。它们比其他的分析和设计更加具体、更加落地、更加贴近编码，更能够顺利地过渡到面向对象编程环节。这也是面向对象分析和设计，与其他分析和设计最大的不同点。</p><p>简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的的结果翻译成代码的过程。</p><h2 id="什么是-UML？我们是否需要-UML？"><a href="#什么是-UML？我们是否需要-UML？" class="headerlink" title="什么是 UML？我们是否需要 UML？"></a>什么是 UML？我们是否需要 UML？</h2><p>讲到面向对象分析、设计、编程，就不得不提到另外一个概念，那就是 <code>UML</code>（<code>Unified Model Language</code>），统一建模语言。很多讲解面向对象或设计模式的书籍，常用它来画图表达面向对象或设计模式的设计思路。</p><p><code>UML</code> 是一种非常复杂的东西。它不仅仅包含我们常提到类图，还有用例图、顺序图、活动图、状态图、组件图等。在我看来，即便仅仅使用类图，学习成本也是很高的。就单说类之间的关系，<code>UML</code> 就定义了很多种，比如泛化、实现、关联、聚合、组合、依赖等。</p><p><code>UML</code> 在互联网公司的项目开发中，用处可能并不大。为了文档化软件设计或者方便讨论软件设计，大部分情况下，随手画个不那么规范的草图，能够达意，方便沟通就够了，而完全按照 <code>UML</code> 规范来将草图标准化，所付出的代价是不值得的。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p><strong>1. 什么是面向对象编程？</strong></p><p>面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。</p><p><strong>2. 什么是面向对象编程语言？</strong></p><p>面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</p><p><strong>3. 如何判定一个编程语言是否是面向对象编程语言？</strong></p><p>如果按照严格的的定义，需要有现成的语法支持类、对象、四大特性才能叫作面向对象编程语言。如果放宽要求的话，只要某种编程语言支持类、对象语法机制，那基本上就可以说这种编程语言是面向对象编程语言了，不一定非得要求具有所有的四大特性。</p><p><strong>4. 面向对象编程和面向对象编程语言之间有何关系？</strong></p><p>面向对象编程一般使用面向对象编程语言来进行，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。</p><p><strong>5. 什么是面向对象分析和面向对象设计？</strong></p><p>简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做。两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法、类与类之间如何交互等等。</p><p>参考：<a href="https://time.geekbang.org/column/article/161575" target="_blank" rel="noopener">理论一：当谈论面向对象的时候，我们到底在谈论什么？</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(面向对象)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之美学习（一）</title>
    <link href="/passages/design-pattern-learn-1/"/>
    <url>/passages/design-pattern-learn-1/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>继数据结构与算法之美后，王争老师的专栏又开始更新了，这次是《设计模式之美》，希望学习之后会对自己有所提升。在此记录下自己的学习笔记，希望对自己或者看到的读者都有所裨益。</p><h2 id="为什么每个程序员都要尽早地学习并掌握设计模式相关知识？"><a href="#为什么每个程序员都要尽早地学习并掌握设计模式相关知识？" class="headerlink" title="为什么每个程序员都要尽早地学习并掌握设计模式相关知识？"></a><a href="https://time.geekbang.org/column/article/160981" target="_blank" rel="noopener">为什么每个程序员都要尽早地学习并掌握设计模式相关知识？</a></h2><p><strong>1. 应对面试中的设计模式相关问题</strong></p><p>学习设计模式和算法一样，最功利、最直接的目的，可能就是应对面试了。</p><p>不管你是前端工程师、后端工程师，还是全栈工程师，在求职面试中，设计模式问题是被问得频率比较高的一类问题。特别是一些像 <code>BAT</code>、<code>TMD</code> 这样的大公司，比较重视候选人的基本功，经常会拿算法、设计模式之类的问题来考察候选人。</p><p><strong>2. 告别写被人吐槽的烂代码</strong></p><p>我们经常说，<code>Talk is cheap，show me the code</code>。实际上，代码能力是一个程序员最基础的能力，是基本功，是展示一个程序员基础素养的最直接的衡量标准。你写的代码，实际上就是你名片。</p><p><strong>3. 提高复杂代码的设计和开发能力</strong></p><p>大部分工程师比较熟悉的都是编程语言、工具、框架这些东西，因为每天的工作就是在框架里根据业务需求，填充代码。实际上，这样的工作并不需要你具备很强的代码设计能力，只要单纯地能理解业务，翻译成代码就可以了。</p><p>但是，有一天，<code>leader</code> 让开发一个跟业务无关的比较通用的功能模块，面对这样稍微复杂的代码设计和开发，就发现会有点力不从心，不知从何下手了。因为只是完成功能、代码能用，可能并不复杂，但是要想写出易扩展、易用、易维护的代码，并不容易。</p><p>如何分层、分模块？应该怎么划分类？每个类应该具有哪些属性、方法？怎么设计类之间的交互？该用继承还是组合？该使用接口还是抽象类？怎样做到解耦、高内聚低耦合？该用单例模式还是静态方法？用工厂模式创建对象还是直接 <code>new</code> 出来？如何避免引入设计模式提高扩展性的同时带来的降低可读性问题？……各种问题，一下子挤到面前。</p><p><strong>4. 让读源码、学框架事半功倍</strong></p><p>对于一个有追求的程序员来说，对技术的积累，既要有广度，也要有深度。很多技术人早早就意识到了这一点，所以在学习框架、中间件的时候，都会抽空去研究研究原理，读一读源码，希望能在深度上有所积累，而不只是略知皮毛，会用而已。</p><p>有些人看源码的时候，经常会遇到看不懂、看不下去的问题。不知道你有没有遇到过这种情况？实际上，这个问题的原因很简单，那就是你积累的基本功还不够，你的能力还不足以看懂这些代码。</p><p><strong>5. 为你的职场发展做铺垫</strong></p><p>普通的、低级别的开发工程师，只需要把框架、开发工具、编程语言用熟练，再做几个项目练练手，基本上就能应付平时的开发工作了。但是，如果你不想一辈子做一个低级的码农，想成长为技术专家、大牛、技术 <code>leader</code>，希望在职场有更高的成就、更好的发展，那就要重视基本功的训练、基础知识的积累。</p><p>你去看大牛写的代码，或者优秀的开源项目，代码写得都非常的优美，质量都很高。如果你只是框架用得很溜，架构聊得头头是道，但写出来的代码很烂，让人一眼就能看出很多不合理的、可以改进的地方，那你永远都成不了别人心目中的“技术大牛”。</p><p><font size='4'><strong>总结</strong></font></p><p>总结一下的话，主要有这样五点：应对面试中的设计模式相关问题；告别写被人吐槽的烂代码；提高复杂代码的设计和开发能力；让读源码、学框架事半功倍；为你的职场发展做铺垫。</p><p>投资要趁早，这样我们才能尽早享受复利。同样，有些能力，要早点锻炼；有些东西，要早点知道；有些书，要早点读。这样在你后面的生活、工作、学习中，才能一直都发挥作用。不要等到好多年后，看到了，才恍然大悟，后悔没有早点去学、去看。</p><p>设计模式作为一门与编码、开发有着直接关系的基础知识，是你现在就要开始学习的。早点去学习，以后的项目就都可以拿来锻炼，每写一行代码都是对内功的利用和加深，是可以受益一整个职业生涯的事情。</p><h2 id="从哪些维度评判代码质量的好坏？如何具备写出高质量代码的能力？"><a href="#从哪些维度评判代码质量的好坏？如何具备写出高质量代码的能力？" class="headerlink" title="从哪些维度评判代码质量的好坏？如何具备写出高质量代码的能力？"></a><a href="https://time.geekbang.org/column/article/160985" target="_blank" rel="noopener">从哪些维度评判代码质量的好坏？如何具备写出高质量代码的能力？</a></h2><p>对于程序员来说，辨别代码写得“好”还是“烂”，是一个非常重要的能力。这也是我们写出好代码的前提。毕竟，如果我们连什么是好代码、什么是烂代码，都分辨不清，又谈何写出好代码呢？</p><p><font size='4'><strong>如何评价代码质量的高低？</strong></font></p><p>下面是描述代码质量的所有常用词汇：</p><blockquote><p>灵活性（flexibility）、可扩展性（extensibility）、可维护性（maintainability）、可读性（readability）、可理解性（understandability）、易修改性（changeability）、可复用（reusability）、可测试性（testability）、模块化（modularity）、高内聚低耦合（high cohesion loose coupling）、高效（high effciency）、高性能（high performance）、安全性（security）、兼容性（compatibility）、易用性（usability）、整洁（clean）、清晰（clarity）、简单（simple）、直接（straightforward）、少即是多（less code is more）、文档详尽（well-documented）、分层清晰（well-layered）、正确性（correctness、bug free）、健壮性（robustness）、鲁棒性（robustness）、可用性（reliability）、可伸缩性（scalability）、稳定性（stability）、优雅（elegant）、好（good）、坏（bad）……</p></blockquote><p>实际上，我们很难通过其中的某个或者某几个词汇来全面地评价代码质量。因为这些词汇都是从不同维度来说的。这就好比，对于一个人的评价，我们需要综合各个方面来给出，比如性格、相貌、能力、财富等等。代码质量高低也是一个综合各种因素得到的结论。我们并不能通过单一的维度去评价一段代码写的好坏。比如，即使一段代码的可扩展性很好，但可读性很差，那我们也不能说这段代码质量高。</p><p>除此之外，不同的评价维度也并不是完全独立的，有些是具有包含关系、重叠关系或者可以互相影响的。比如，代码的可读性好、可扩展性好，就意味着代码的可维护性好。不过，我们真的可以客观地量化一段代码质量的高低吗？答案是否定的。对一段代码的质量评价，常常有很强的主观性。</p><p>正是因为代码质量评价的主观性，使得这种主观评价的准确度，跟工程师自身经验有极大的关系。越是有经验的工程师，给出的评价也就越准确。所以，这也导致如果没有人指导的话，自己一个人闷头写代码，即便写再多的代码，代码能力也可能一直没有太大提高。</p><p><font size='4'><strong>最常用的评价标准有哪几个？</strong></font></p><p>其中几个最常用的、最重要的评价标准，来详细讲解，其中就包括：可维护性、可读性、可扩展性、灵活性、简洁性（简单、复杂）、可复用性、可测试性。</p><p><strong>1. 可维护性（<code>maintainability</code>）</strong></p><p>落实到编码开发，所谓的“维护”无外乎就是修改 <code>bug</code>、修改老的代码、添加新的代码之类的工作。所谓“代码易维护”就是指，在不破坏原有代码设计、不引入新的 <code>bug</code> 的情况下，能够快速地修改或者添加代码。所谓“代码不易维护”就是指，修改或者添加代码需要冒着极大的引入新 <code>bug</code> 的风险，并且需要花费很长的时间才能完成。</p><p>维护、易维护、不易维护这三个概念不难理解。不过，对于实际的软件开发来说，更重要的是搞清楚，如何来判断代码可维护性的好坏。从正面去分析一个代码是否易维护稍微有点难度。不过，我们可以从侧面上给出一个比较主观但又比较准确的感受。如果 <code>bug</code> 容易修复，修改、添加功能能够轻松完成，那我们就可以主观地认为代码对我们来说易维护。相反，如果修改一个 <code>bug</code>，修改、添加一个功能，需要花费很长的时间，那我们就可以主观地认为代码对我们来说不易维护。</p><p><strong>2. 可读性（<code>readability</code>）</strong></p><p>软件设计大师 <code>Martin Fowler</code> 曾经说过：<code>Any fool can write code that a computer can understand. Good programmers write code that humans can understand.</code>翻译成中文就是：“任何傻瓜都会编写计算机能理解的代码。好的程序员能够编写人能够理解的代码。”</p><p>代码的可读性应该是评价代码质量最重要的指标之一。我们在编写代码的时候，时刻要考虑到代码是否易读、易理解。除此之外，代码的可读性在非常大程度上会影响代码的可维护性。毕竟，不管是修改 <code>bug</code>，还是修改添加功能代码，我们首先要做的事情就是读懂代码。代码读不大懂，就很有可能因为考虑不周全，而引入新的 <code>bug</code>。</p><p>既然可读性如此重要，那我们又该如何评价一段代码的可读性呢？</p><p>实际上，code review 是一个很好的测验代码可读性的手段。如果你的同事可以轻松地读懂你写的代码，那说明你的代码可读性很好；如果同事在读你的代码时，有很多疑问，那就说明你的代码可读性有待提高了。</p><p><strong>3. 可扩展性（<code>extensibilty</code>）</strong></p><p>可扩展性也是一个评价代码质量非常重要的标准。它表示我们的代码应对未来需求变化的能力。跟可读性一样，代码是否易扩展也很大程度上决定代码是否易维护。那到底什么是代码的可扩展性呢？</p><p>代码的可扩展性表示，我们在不修改或少量修改原有代码的情况下，通过扩展的方式添加新的功能代码。说直白点就是，代码预留了一些功能扩展点，你可以把新功能代码，直接插到扩展点上，而不需要因为要添加一个功能而大动干戈，改动大量的原始代码。</p><p><strong>4. 灵活性（<code>flexibility</code>）</strong></p><p>灵活性是一个挺抽象的评价标准，要给灵活性下个定义也是挺难的。不过，我们可以想一下，什么情况下我们才会说代码写得好灵活呢？我这里罗列了几个场景，希望能引发你自己对什么是灵活性的思考。</p><ul><li>当我们添加一个新的功能代码的时候，原有的代码已经预留好了扩展点，我们不需要修改原有的代码，只要在扩展点上添加新的代码即可。这个时候，我们除了可以说代码易扩展，还可以说代码写得好灵活。</li><li>当我们要实现一个功能的时候，发现原有代码中，已经抽象出了很多底层可以复用的模块、类等代码，我们可以拿来直接使用。这个时候，我们除了可以说代码易复用之外，还可以说代码写得好灵活。</li><li>当我们使用某组接口的时候，如果这组接口可以应对各种使用场景，满足各种不同的需求，我们除了可以说接口易用之外，还可以说这个接口设计得好灵活或者代码写得好灵活。</li></ul><p>从刚刚举的场景来看，如果一段代码易扩展、易复用或者易用，我们都可以称这段代码写得比较灵活。所以，灵活这个词的含义非常宽泛，很多场景下都可以使用。</p><p><strong>5. 简洁性（<code>simplity</code>）</strong></p><p>有一条非常著名的设计原则，你一定听过，那就是 <code>KISS</code> 原则：<code>Keep It Simple，Stupid</code>。这个原则说的意思就是，尽量保持代码简单。代码简单、逻辑清晰，也就意味着易读、易维护。我们在编写代码的时候，往往也会把简单、清晰放到首位。</p><p>不过，很多编程经验不足的程序员会觉得，简单的代码没有技术含量，喜欢在项目中引入一些复杂的设计模式，觉得这样才能体现自己的技术水平。实际上，<font color='red'><strong>思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。这也是一个编程老手跟编程新手的本质区别之一。</strong></font></p><p><strong>6. 可复用性（<code>reusability</code>）</strong></p><p>代码的可复用性可以简单地理解为，尽量减少重复代码的编写，复用已有的代码。实际上，代码可复用性跟 <code>DRY</code>（<code>Don’t Repeat Yourself</code>）这条设计原则的关系挺紧密的.</p><p><strong>7. 可测试性（<code>testability</code>）</strong></p><p>相对于前面六个评价标准，代码的可测试性是一个相对较少被提及，但又非常重要的代码质量评价标准。代码可测试性的好坏，能从侧面上非常准确地反应代码质量的好坏。代码的可测试性差，比较难写单元测试，那基本上就能说明代码设计得有问题。</p><p><font size='4'><strong>如何才能写出高质量的代码？</strong></font></p><p>问如何写出高质量的代码，也就等同于在问，如何写出易维护、易读、易扩展、灵活、简洁、可复用、可测试的代码。</p><p>要写出满足这些评价标准的高质量代码，我们需要掌握一些更加细化、更加能落地的编程方法论，包括面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。而所有这些编程方法论的最终目的都是为了编写出高质量的代码。</p><p><font size='4'><strong>总结</strong></font></p><p><strong>1. 如何评价代码质量的高低？</strong></p><p>代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、灵活、优雅、简洁等，这些词汇是从不同的维度去评价代码质量的。它们之间有互相作用，并不是独立的，比如，代码的可读性好、可扩展性好就意味着代码的可维护性好。代码质量高低是一个综合各种因素得到的结论。我们并不能通过单一的维度去评价一段代码的好坏。</p><p><strong>2. 最常用的评价标准有哪几个？</strong></p><p>最常用到几个评判代码质量的标准是：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。</p><p><strong>3. 如何才能写出高质量的代码？</strong></p><p>要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等等。</p><h2 id="面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？"><a href="#面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？" class="headerlink" title="面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？"></a><a href="https://time.geekbang.org/column/article/160991" target="_blank" rel="noopener">面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？</a></h2><p><font size='4'><strong>面向对象</strong></font></p><p>主流的编程范式或者是编程风格有三种，它们分别是面向过程、面向对象和函数式编程。面向对象这种编程风格又是这其中最主流的。现在比较流行的编程语言大部分都是面向对象编程语言。大部分项目也都是基于面向对象编程风格开发的。面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。</p><p>需要掌握的7大知识点：</p><ul><li>面向对象的四大特性：封装、抽象、继承、多态</li><li>面向对象编程与面向过程编程的区别和联系</li><li>面向对象分析、面向对象设计、面向对象编程</li><li>接口和抽象类的区别以及各自的应用场景</li><li>基于接口而非实现编程的设计思想</li><li>多用组合少用继承的设计思想</li><li>面向过程的贫血模型和面向对象的充血模型</li></ul><p><font size='4'><strong>设计原则</strong></font></p><p>设计原则是指导我们代码设计的一些经验总结。设计原则这块儿的知识有一个非常大的特点，那就是这些原则听起来都比较抽象，定义描述都比较模糊，不同的人会有不同的解读。所以，如果单纯地去记忆定义，对于编程、设计能力的提高，意义并不大。对于每一种设计原则，我们需要掌握它的设计初衷，能解决哪些编程问题，有哪些应用场景。只有这样，我们才能在项目中灵活恰当地应用这些原则。</p><p>需要掌握的常用设计原则：</p><ul><li><code>SOLID</code> 原则 -<code>SRP</code> 单一职责原则</li><li><code>SOLID</code> 原则 -<code>OCP</code> 开闭原则</li><li><code>SOLID</code> 原则 -<code>LSP</code> 里式替换原则</li><li><code>SOLID</code> 原则 -<code>ISP</code> 接口隔离原则</li><li><code>SOLID</code> 原则 -<code>DIP</code> 依赖倒置原则</li><li><code>DRY</code> 原则、<code>KISS</code> 原则、<code>YAGNI</code> 原则、<code>LOD</code> 法则</li></ul><p><font size='4'><strong>设计模式</strong></font></p><p>设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。大部分设计模式要解决的都是代码的可扩展性问题。设计模式相对于设计原则来说，没有那么抽象，而且大部分都不难理解，代码实现也并不复杂。这一块的学习难点是了解它们都能解决哪些问题，掌握典型的应用场景，并且懂得不过度应用。</p><p>经典的设计模式可以分为三大类：创建型、结构型、行为型。</p><p><strong>1. 创建型</strong></p><p>常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。<br>不常用的有：原型模式。</p><p><strong>2. 结构型</strong></p><p>常用的有：代理模式、桥接模式、装饰者模式、适配器模式。<br>不常用的有：门面模式、组合模式、享元模式。</p><p><strong>3. 行为型</strong></p><p>常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。<br>不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</p><p><font size='4'><strong>编程规范</strong></font></p><p>编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节。即便你可能对设计原则不熟悉、对设计模式不了解，但你最起码要掌握基本的编码规范，比如，如何给变量、类、函数命名，如何写代码注释，函数不宜过长、参数不能过多等等。</p><p><font size='4'><strong>代码重构</strong></font></p><p>在软件开发中，只要软件在不停地迭代，就没有一劳永逸的设计。随着需求的变化，代码的不停堆砌，原有的设计必定会存在这样那样的问题。针对这些问题，我们就需要进行代码重构。重构是软件开发中非常重要的一个环节。持续重构是保持代码质量不下降的有效手段，能有效避免代码腐化到无可救药的地步。</p><p>而重构的工具就是我们前面罗列的那些面向对象设计思想、设计原则、设计模式、编码规范。</p><p>需要掌握的知识点有：</p><ul><li>重构的目的（<code>why</code>）、对象（<code>what</code>）、时机（<code>when</code>）、方法（<code>how</code>）；</li><li>保证重构不出错的技术手段：单元测试和代码的可测试性；</li><li>两种不同规模的重构：大重构（大规模高层次）和小重构（小规模低层次）。</li></ul><p><font size='4'><strong>五者之间的联系</strong></font></p><ul><li>面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。</li><li>设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义。比如，“开闭原则”是很多设计模式（策略、模板等）的指导原则。</li><li>设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度上来讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。</li><li>编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范。</li><li>重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。</li></ul><p>实际上，面向对象、设计原则、设计模式、编程规范、代码重构，这五者都是保持或者提高代码质量的方法论，本质上都是服务于编写高质量代码这一件事的。当我们追本逐源，看清这个本质之后，很多事情怎么做就清楚了，很多选择怎么选也清楚了。比如，在某个场景下，该不该用这个设计模式，那就看能不能提高代码的可扩展性；要不要重构，那就看重代码是否存在可读、可维护问题等。</p><p><font size='4'><strong>总结</strong></font><br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/11/06/07df8480-0064-11ea-a208-a725c5887990.png" srcset="/img/loading.gif" alt="image.png"></p><p>欢迎小伙伴们和我一起学习。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/11/06/257cffe0-0064-11ea-a208-a725c5887990.png" srcset="/img/loading.gif" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>设计模式(入门)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对Netty的一些理解</title>
    <link href="/passages/netty-understanding/"/>
    <url>/passages/netty-understanding/</url>
    
    <content type="html"><![CDATA[<!-- more --><p><code>Netty</code>是一个高性能、异步事件驱动的<code>NIO</code>框架，它提供了对<code>TCP</code>、<code>UDP</code>和文件传输的支持。作为当前最流行的<code>NIO</code>框架，<code>Netty</code>在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，一些业界著名的开源组件也是基于<code>Netty</code>的<code>NIO</code>框架构建。</p><p><code>Netty</code> 利用 <code>Java</code> 高级网络的能力，隐藏其背后的复杂性而提供一个易于使用的 <code>API</code> 构建一个客户端/服务端，其具有高并发、传输快、封装好等特点。</p><p><strong>高并发</strong><br><code>Netty</code>是一款基于<code>NIO</code>（<code>Nonblocking I/O</code>，非阻塞<code>IO</code>）开发的网络通信框架，对比于<code>BIO</code>（<code>Blocking I/O</code>，阻塞<code>IO</code>），它的并发性能得到了很大提高 。</p><p><strong>传输快</strong><br><code>Netty</code>的传输快其实也是依赖了<code>NIO</code>的一个特性——<strong>零拷贝</strong>。</p><p><strong>封装好</strong><br>Netty封装了NIO操作的很多细节，提供易于使用的API，还有心跳、重连机制、拆包粘包方案等特性，使开发者能能够快速高效的构建一个稳健的高并发应用。</p><h2 id="为什么要用-Netty-？"><a href="#为什么要用-Netty-？" class="headerlink" title="为什么要用 Netty ？"></a>为什么要用 Netty ？</h2><p><strong><code>JDK</code> 原生 <code>NIO</code> 程序的问题</strong></p><p><code>JDK</code> 原生也有一套网络应用程序 <code>API</code>，但是存在一系列问题，主要如下：</p><ul><li><code>NIO</code> 的类库和 <code>API</code> 繁杂，使用麻烦。你需要熟练掌握 <code>Selector</code>、<code>ServerSocketChannel</code>、<code>SocketChannel</code>、<code>ByteBuffer</code> 等。</li><li>需要具备其他的额外技能做铺垫。例如熟悉 <code>Java</code> 多线程编程，因为 <code>NIO</code> 编程涉及到 <code>Reactor</code> 模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的 <code>NIO</code> 程序。</li><li>可靠性能力补齐，开发工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等。<code>NIO</code> 编程的特点是功能开发相对容易，但是可靠性能力补齐工作量和难度都非常大。</li><li><code>JDK NIO</code> 的 <code>Bug</code>。例如臭名昭著的 <code>Epoll Bug</code>，它会导致 <code>Selector</code> 空轮询，最终导致 <code>CPU 100%</code>。 官方声称在 <code>JDK 1.6</code> 版本的 <code>update 18</code> 修复了该问题，但是直到 <code>JDK 1.7</code> 版本该问题仍旧存在，只不过该 <code>Bug</code> 发生概率降低了一些而已，它并没有被根本解决。</li></ul><p><strong><code>Netty</code> 的特点</strong></p><p><code>Netty</code> 对 <code>JDK</code> 自带的 <code>NIO</code> 的 <code>API</code> 进行封装，解决上述问题，主要特点有：</p><ul><li>设计优雅，适用于各种传输类型的统一 <code>API</code> 阻塞和非阻塞 <code>Socket</code>；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型 - 单线程，一个或多个线程池；真正的无连接数据报套接字支持（自 <code>3.1</code> 起）。</li><li>使用方便，详细记录的 <code>Javadoc</code>，用户指南和示例；没有其他依赖项，<code>JDK 5</code>（<code>Netty 3.x</code>）或 <code>6</code>（<code>Netty 4.x</code>）就足够了。</li><li>高性能，吞吐量更高，延迟更低；减少资源消耗；最小化不必要的内存复制。<br>安全，完整的 <code>SSL/TLS</code> 和 <code>StartTLS</code> 支持。</li><li>社区活跃，不断更新，社区活跃，版本迭代周期短，发现的 <code>Bug</code> 可以被及时修复，同时，更多的新功能会被加入。</li></ul><h2 id="Netty-内部执行流程"><a href="#Netty-内部执行流程" class="headerlink" title="Netty 内部执行流程"></a>Netty 内部执行流程</h2><p>服务端：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/10/29/d121cd40-fa28-11e9-aa0e-cb7fb94f2463.png" srcset="/img/loading.gif" alt="image.png"><br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/10/29/d7574f50-fa28-11e9-aa0e-cb7fb94f2463.png" srcset="/img/loading.gif" alt="image.png"></p><ol><li><p>创建<code>ServerBootStrap</code>实例</p></li><li><p>设置并绑定<code>Reactor</code>线程池：<code>EventLoopGroup</code>，<code>EventLoop</code>就是处理所有注册到本线程的<code>Selector</code>上面的<code>Channel</code></p></li><li><p>设置并绑定服务端的<code>Channel</code></p></li></ol><p>4.5. 创建处理网络事件的<code>ChannelPipeline</code>和<code>handler</code>，网络时间以流的形式在其中流转，<code>handler</code>完成多数的功能定制：比如编解码 <code>SSl</code>安全认证</p><ol start="6"><li><p>绑定并启动监听端口</p></li><li><p>当轮训到准备就绪的<code>channel</code>后，由<code>Reactor</code>线程：<code>NioEventLoop</code>执行<code>pipline</code>中的方法，最终调度并执行<code>channelHandler</code></p></li></ol><p>客户端：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/10/29/431634d0-fa2a-11e9-aa0e-cb7fb94f2463.png" srcset="/img/loading.gif" alt="Netty客户端创建时序图.png"><br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/10/29/65cd7e80-fa29-11e9-aa0e-cb7fb94f2463.png" srcset="/img/loading.gif" alt="image.png"></p><h2 id="Netty-架构设计"><a href="#Netty-架构设计" class="headerlink" title="Netty 架构设计"></a>Netty 架构设计</h2><p>主要功能特性如下图：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/10/29/3761fa60-fa26-11e9-aa0e-cb7fb94f2463.png" srcset="/img/loading.gif" alt="image.png"></p><p><code>Netty</code> 功能特性如下：</p><ul><li>传输服务，支持 <code>BIO</code> 和 <code>NIO</code>。</li><li>容器集成，支持 <code>OSGI</code>、<code>JBossMC</code>、<code>Spring</code>、<code>Guice</code> 容器。</li><li>协议支持，<code>HTTP</code>、<code>Protobuf</code>、二进制、文本、<code>WebSocket</code> 等一系列常见协议都支持。还支持通过实行编码解码逻辑来实现自定义协议。</li><li><code>Core</code> 核心，可扩展事件模型、通用通信 <code>API</code>、支持零拷贝的 <code>ByteBuf</code> 缓冲对象。</li></ul><p><strong>模块组件</strong></p><p><strong><code>Bootstrap</code>、<code>ServerBootstrap</code></strong></p><p><code>Bootstrap</code> 意思是引导，一个 <code>Netty</code> 应用通常由一个 <code>Bootstrap</code> 开始，主要作用是配置整个 <code>Netty</code> 程序，串联各个组件，<code>Netty</code> 中 <code>Bootstrap</code> 类是客户端程序的启动引导类，<code>ServerBootstrap</code> 是服务端启动引导类。</p><p><strong><code>Future</code>、<code>ChannelFuture</code></strong></p><p>正如前面介绍，在 <code>Netty</code> 中所有的 <code>IO</code> 操作都是异步的，不能立刻得知消息是否被正确处理。</p><p>但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 <code>Future</code> 和 <code>ChannelFutures</code>，它们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。</p><p><strong><code>Channel</code></strong></p><p><code>Netty</code> 网络通信的组件，能够用于执行网络 <code>I/O</code> 操作。<br><code>Channel</code> 为用户提供：</p><ul><li>当前网络连接的通道的状态（例如是否打开？是否已连接？）</li><li>网络连接的配置参数 （例如接收缓冲区大小）</li><li>提供异步的网络 <code>I/O</code> 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 <code>I/O</code> 调用都将立即返回，并且不保证在调用结束时所请求的 <code>I/O</code> 操作已完成。调用立即返回一个 <code>ChannelFuture</code> 实例，通过注册监听器到 <code>ChannelFuture</code> 上，可以在 <code>I/O</code> 操作成功、失败或取消时回调通知调用方。</li><li>支持关联 <code>I/O</code> 操作与对应的处理程序。</li></ul><p>不同协议、不同的阻塞类型的连接都有不同的 <code>Channel</code> 类型与之对应。下面是一些常用的 <code>Channel</code> 类型：</p><ul><li><code>NioSocketChannel</code>，异步的客户端 <code>TCP Socket</code> 连接。</li><li><code>NioServerSocketChannel</code>，异步的服务器端 <code>TCP Socket</code> 连接。</li><li><code>NioDatagramChannel</code>，异步的 <code>UDP</code> 连接。</li><li><code>NioSctpChannel</code>，异步的客户端 <code>Sctp</code> 连接。</li><li><code>NioSctpServerChannel</code>，异步的 <code>Sctp</code> 服务器端连接，这些通道涵盖了 <code>UDP</code> 和 <code>TCP</code> 网络 <code>IO</code> 以及文件 <code>IO</code>。</li></ul><p><strong><code>Selector</code></strong></p><p><code>Netty</code> 基于 <code>Selector</code> 对象实现 <code>I/O</code> 多路复用，通过 <code>Selector</code> 一个线程可以监听多个连接的 <code>Channel</code> 事件。</p><p>当向一个 <code>Selector</code> 中注册 <code>Channel</code> 后，<code>Selector</code> 内部的机制就可以自动不断地查询(<code>Select</code>) 这些注册的 <code>Channel</code> 是否有已就绪的 <code>I/O</code> 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 <code>Channel</code>。</p><p><strong><code>NioEventLoop</code></strong></p><p><code>NioEventLoop</code> 中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用 <code>NioEventLoop</code> 的 <code>run</code> 方法，执行 <code>I/O</code> 任务和非 <code>I/O</code> 任务：</p><ul><li><code>I/O</code> 任务，即 <code>selectionKey</code> 中 <code>ready</code> 的事件，如 <code>accept</code>、<code>connect</code>、<code>read</code>、<code>write</code> 等，由 <code>processSelectedKeys</code> 方法触发。</li><li>非 <code>IO</code> 任务，添加到 <code>taskQueue</code> 中的任务，如 <code>register0</code>、<code>bind0</code> 等任务，由 <code>runAllTasks</code> 方法触发。<br>两种任务的执行时间比由变量 <code>ioRatio</code> 控制，默认为 <code>50</code>，则表示允许非 <code>IO</code> 任务执行的时间与 <code>IO</code> 任务的执行时间相等。</li></ul><p><strong><code>NioEventLoopGroup</code></strong></p><p><code>NioEventLoopGroup</code>，主要管理 <code>eventLoop</code> 的生命周期，可以理解为一个线程池，内部维护了一组线程，每个线程(<code>NioEventLoop</code>)负责处理多个 <code>Channel</code> 上的事件，而一个 <code>Channel</code> 只对应于一个线程。</p><p><strong><code>ChannelHandler</code></strong></p><p><code>ChannelHandler</code> 是一个接口，处理 <code>I/O</code> 事件或拦截 <code>I/O</code> 操作，并将其转发到其 <code>ChannelPipeline</code>(业务处理链)中的下一个处理程序。</p><p><code>ChannelHandler</code> 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类：</p><ul><li><p><code>ChannelInboundHandler</code> 用于处理入站 <code>I/O</code> 事件。</p></li><li><p><code>ChannelOutboundHandler</code> 用于处理出站 <code>I/O</code> 操作。<br>或者使用以下适配器类：</p></li><li><p><code>ChannelInboundHandlerAdapter</code> 用于处理入站 <code>I/O</code> 事件。</p></li><li><p><code>ChannelOutboundHandlerAdapter</code> 用于处理出站 <code>I/O</code> 操作。</p></li><li><p><code>ChannelDuplexHandler</code> 用于处理入站和出站事件。</p></li><li><p><code>ChannelHandlerContext</code> 保存 <code>Channel</code> 相关的所有上下文信息，同时关联一个 <code>ChannelHandler</code> 对象。</p></li></ul><p><strong><code>ChannelPipline</code></strong></p><p>保存 <code>ChannelHandler</code> 的 <code>List</code>，用于处理或拦截 <code>Channel</code> 的入站事件和出站操作。</p><p><code>ChannelPipeline</code> 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 <code>Channel</code> 中各个的 <code>ChannelHandler</code> 如何相互交互。</p><h2 id="Netty-高性能设计"><a href="#Netty-高性能设计" class="headerlink" title="Netty 高性能设计"></a>Netty 高性能设计</h2><p><code>Netty</code> 作为异步事件驱动的网络，高性能之处主要来自于其 <code>I/O</code> 模型和线程处理模型，前者决定如何收发数据，后者决定如何处理数据。</p><p><strong>I/O 模型</strong></p><p>用什么样的通道将数据发送给对方，<code>BIO</code>、<code>NIO</code> 或者 <code>AIO</code>，<code>I/O</code> 模型在很大程度上决定了框架的性能。</p><p><strong>阻塞 I/O</strong></p><p>传统阻塞型 <code>I/O</code>(<code>BIO</code>)可以用下图表示：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/10/29/d5a1fb00-fa24-11e9-aa0e-cb7fb94f2463.png" srcset="/img/loading.gif" alt="image.png"></p><p>特点以及缺点如下：</p><ul><li>每个请求都需要独立的线程完成数据 <code>Read</code>，业务处理，数据 <code>Write</code> 的完整操作问题。</li><li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。</li><li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 <code>Read</code> 操作上，造成线程资源浪费。</li></ul><p><strong>I/O 复用模型</strong><br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/10/29/10a67870-fa25-11e9-aa0e-cb7fb94f2463.png" srcset="/img/loading.gif" alt="image.png"><br>在 <code>I/O</code> 复用模型中，会用到 <code>Select</code>，这个函数也会使进程阻塞，但是和阻塞 <code>I/O</code> 所不同的是这个函数可以同时阻塞多个 <code>I/O</code> 操作。</p><p>而且可以同时对多个读操作，多个写操作的 <code>I/O</code> 函数进行检测，直到有数据可读或可写时，才真正调用 <code>I/O</code> 操作函数。</p><p><code>Netty</code> 的非阻塞 <code>I/O</code> 的实现关键是<strong>基于 <code>I/O</code> 复用模型</strong>，这里用 <code>Selector</code> 对象表示：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/10/29/49e1cea0-fa25-11e9-aa0e-cb7fb94f2463.png" srcset="/img/loading.gif" alt="image.png"></p><p><code>Netty</code> 的 <code>IO</code> 线程 <code>NioEventLoop</code> 由于聚合了多路复用器 <code>Selector</code>，可以同时并发处理成百上千个客户端连接。</p><p>当线程从某客户端 <code>Socket</code> 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</p><p>线程通常将非阻塞 <code>IO</code> 的空闲时间用于在其他通道上执行 <code>IO</code> 操作，所以单独的线程可以管理多个输入和输出通道。</p><p>由于读写操作都是非阻塞的，这就可以充分提升 <code>IO</code> 线程的运行效率，避免由于频繁 <code>I/O</code> 阻塞导致的线程挂起。</p><p>一个 <code>I/O</code> 线程可以并发处理 <code>N</code> 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 <code>I/O</code> 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</p><p><strong><code>Netty</code> 线程模型</strong></p><p><code>Netty</code> 主要基于<strong>主从 <code>Reactors</code> 多线程模型</strong>（如下图）做了一定的修改，其中主从 <code>Reactor</code> 多线程模型有多个 <code>Reactor</code>：</p><p><code>MainReactor</code> 负责客户端的连接请求，并将请求转交给 <code>SubReactor</code>。<br><code>SubReactor</code> 负责相应通道的 <code>IO</code> 读写请求。<br>非 <code>IO</code> 请求（具体逻辑处理）的任务则会直接写入队列，等待 <code>worker threads</code> 进行处理。<br>这里引用 <code>Doug Lee</code> 大神的 <code>Reactor</code> 介绍：<code>Scalable IO in Java</code> 里面关于主从 <code>Reactor</code> 多线程模型的图：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/10/29/dc696760-fa25-11e9-aa0e-cb7fb94f2463.png" srcset="/img/loading.gif" alt="image.png"><br>特别说明的是：虽然 <code>Netty</code> 的线程模型基于主从 <code>Reactor</code> 多线程，借用了 <code>MainReactor</code> 和 <code>SubReactor</code> 的结构。但是实际实现上 <code>SubReactor</code> 和 <code>Worker</code> 线程在同一个线程池中。</p><p><strong><code>Netty</code> 的零拷贝</strong></p><p>是在发送数据的时候，传统的实现方式是：</p><pre><code class="hljs java">File.read(bytes);Socket.send(bytes);</code></pre><p>这种方式需要四次数据拷贝和四次上下文切换：</p><ul><li>数据从磁盘读取到内核的<code>read buffer</code></li><li>数据从内核缓冲区拷贝到用户缓冲区</li><li>数据从用户缓冲区拷贝到内核的<code>socket buffer</code></li><li>数据从内核的<code>socket buffer</code>拷贝到网卡接口（硬件）的缓冲区</li></ul><p><strong>零拷贝的概念</strong></p><p>明显上面的第二步和第三步是没有必要的，通过<code>java</code>的<code>FileChannel.transferTo</code>方法，可以避免上面两次多余的拷贝（当然这需要底层操作系统支持）</p><ul><li>调用<code>transferTo</code>,数据从文件由<code>DMA</code>引擎拷贝到内核<code>read buffer</code></li><li>接着<code>DMA</code>从内核<code>read buffer</code>将数据拷贝到网卡接口<code>buffer</code></li></ul><p>上面的两次操作都不需要<code>CPU</code>参与，所以就达到了零拷贝。</p><p><code>Netty</code>中的零拷贝主要体现在三个方面：</p><ul><li><p><code>bytebuffer</code></p><blockquote><p><code>Netty</code>发送和接收消息主要使用<code>bytebuffer</code>，<code>bytebuffer</code>使用对外内存（<code>DirectMemory</code>）直接进行<code>Socket</code>读写。</p><p>原因：如果使用传统的堆内存进行<code>Socket</code>读写，<code>JVM</code>会将堆内存<code>buffer</code>拷贝一份到直接内存中然后再写入<code>socket</code>，多了一次缓冲区的内存拷贝。<code>DirectMemory</code>中可以直接通过DMA发送到网卡接口。</p></blockquote></li><li><p><code>Composite Buffers</code></p><blockquote><p>传统的<code>ByteBuffer</code>，如果需要将两个<code>ByteBuffer</code>中的数据组合到一起，我们需要首先创建一个<code>size=size1+size2</code>大小的新的数组，然后将两个数组中的数据拷贝到新的数组中。<br>但是使用<code>Netty</code>提供的组合<code>ByteBuf</code>，就可以避免这样的操作，因为<code>CompositeByteBuf</code>并没有真正将多个<code>Buffer</code>组合起来，而是保存了它们的引用，从而避免了数据的拷贝，实现了零拷贝。</p></blockquote></li><li><p>对于<code>FileChannel.transferTo</code>的使用</p><blockquote><p><code>Netty</code>中使用了<code>FileChannel的transferTo</code>方法，该方法依赖于操作系统实现零拷贝。</p></blockquote></li></ul><p>参考博客<br><a href="https://www.sohu.com/a/272879207_463994" target="_blank" rel="noopener">这可能是目前最透彻的Netty原理架构解析</a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Optional</title>
    <link href="/passages/java-optional/"/>
    <url>/passages/java-optional/</url>
    
    <content type="html"><![CDATA[<!-- more --><p><code>Java 8</code> 引入的一个很有趣的特性是 <code>Optional</code> 类。<code>Optional</code> 类主要解决的问题是臭名昭著的空指针异常（<code>NullPointerException</code>） —— 每个 <code>Java</code> 程序员都非常了解的异常。<br>本质上，这是一个包含有可选值的包装类，这意味着 <code>Optional</code> 类既可以含有对象也可以为空。</p><p><code>Optional</code> 是 <code>Java</code> 实现函数式编程的强劲一步，并且帮助在范式中实现。但是 <code>Optional</code> 的意义显然不止于此。</p><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>从一个简单的用例开始。在 <code>Java 8</code> 之前，任何访问对象方法或属性的调用都可能导致<code>NullPointerException</code>：</p><pre><code class="hljs java">String isOcode = user.getAddress().getCountry().getIsOcode().toUpperCase();</code></pre><p>在这个示例中，如果我们需要确保不触发异常，就得在访问每一个值之前对其进行明确地检查：</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (user != <span class="hljs-keyword">null</span>) &#123;    Address address = user.getAddress();    <span class="hljs-keyword">if</span> (address != <span class="hljs-keyword">null</span>) &#123;        Country country = address.getCountry();        <span class="hljs-keyword">if</span> (country != <span class="hljs-keyword">null</span>) &#123;            String isOcode = country.getIsOcode();            <span class="hljs-keyword">if</span> (isOcode != <span class="hljs-keyword">null</span>) &#123;                isOcode = isOcode.toUpperCase();            &#125;        &#125;    &#125;&#125;</code></pre><p>这很容易就导致代码变得冗长，难以维护。</p><p>为了简化这个过程，下面来看看用 <code>Optional</code> 类是怎么做的。从创建和验证实例，到使用其不同的方法，并与其它返回相同类型的方法相结合，下面是见证 <code>Optional</code> 奇迹的时刻。</p><h2 id="创建-Optional-实例"><a href="#创建-Optional-实例" class="headerlink" title="创建 Optional 实例"></a>创建 Optional 实例</h2><p>先看下 <code>Optional</code> 类的部分源码：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="hljs-keyword">new</span> Optional&lt;&gt;();<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> T value;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Optional</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">null</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;    <span class="hljs-keyword">return</span> t;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Optional</span><span class="hljs-params">(T value)</span> </span>&#123;    <span class="hljs-keyword">this</span>.value = Objects.requireNonNull(value);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">of</span><span class="hljs-params">(T value)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Optional&lt;&gt;(value);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">ofNullable</span><span class="hljs-params">(T value)</span> </span>&#123;    <span class="hljs-keyword">return</span> value == <span class="hljs-keyword">null</span> ? empty() : of(value);&#125;</code></pre><p>可以看出，<code>Optional</code> 类的两个构造方法都是 <code>private</code> 型的，因此类外部不能显示的使用 <code>new Optional()</code> 的方式来创建 <code>Optional</code> 对象，但是 <code>Optional</code> 类提供了三个静态方法 <code>empty()</code>、<code>of(T value)</code>、<code>ofNullable(T value)</code>来创建 <code>Optinal</code> 对象。</p><p>使用同名方法创建一个空的 <code>Optional</code>：</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>(expected = NoSuchElementException.class)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenCreateEmptyOptional_thenNull</span><span class="hljs-params">()</span> </span>&#123;    Optional&lt;User&gt; emptyOpt = Optional.empty();    emptyOpt.get();&#125;</code></pre><p>毫无疑问，当调用 <code>get()</code> 方法获取 <code>emptyOpt</code> 的值时，会导致 <code>NoSuchElementException</code> 异常。</p><p>可以使用 <code>of()</code> 和 <code>ofNullable()</code> 方法创建包含值的 <code>Optional</code>。两个方法的不同之处在于如果你把 <code>null</code> 值作为参数传递进去，<code>of()</code> 方法会抛出 <code>NullPointerException</code>：</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span>(expected = NullPointerException.class)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenCreateOfEmptyOptional_thenNullPointerException</span><span class="hljs-params">()</span> </span>&#123;    Optional&lt;User&gt; opt = Optional.of(user);&#125;</code></pre><p>上面的代码并没有完全摆脱 <code>NullPointerException</code>。因此，你应该明确对象不为 <code>null</code> 的时候使用 <code>of()</code>。</p><p>如果对象即可能是 <code>null</code> 也可能是非 <code>null</code>，你就应该使用 <code>ofNullable()</code> 方法：</p><pre><code class="hljs java">Optional&lt;User&gt; opt = Optional.ofNullable(user);</code></pre><h2 id="访问-Optional-对象的值"><a href="#访问-Optional-对象的值" class="headerlink" title="访问 Optional 对象的值"></a>访问 Optional 对象的值</h2><p>从 <code>Optional</code> 实例中取回实际值对象的方法之一是使用 <code>get()</code> 方法：</p><pre><code class="hljs java"><span class="hljs-comment">//源码</span><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException(<span class="hljs-string">"No value present"</span>);    &#125;    <span class="hljs-keyword">return</span> value;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenCreateOfNullableOptional_thenOk</span><span class="hljs-params">()</span> </span>&#123;    String name = <span class="hljs-string">"John"</span>;    Optional&lt;String&gt; opt = Optional.ofNullable(name);    assertEquals(<span class="hljs-string">"John"</span>, opt.get());&#125;</code></pre><p>不过，从源码可以知道，这个方法会在值为 <code>null</code> 的时候抛出异常。要避免异常，你可以选择首先验证是否有值：</p><pre><code class="hljs java"><span class="hljs-comment">//源码</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPresent</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> value != <span class="hljs-keyword">null</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenCheckIfPresent_thenOk</span><span class="hljs-params">()</span> </span>&#123;    User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"john@gmail.com"</span>, <span class="hljs-string">"1234"</span>);    Optional&lt;User&gt; opt = Optional.ofNullable(user);    assertTrue(opt.isPresent());    assertEquals(user.getEmail(), opt.get().getEmail());&#125;</code></pre><p>检查是否有值的另一个选择是 <code>ifPresent()</code> 方法。该方法除了执行检查，还接受一个 <code>Consumer</code>(消费者) 参数，如果对象不是空的，就对执行传入的 <code>Lambda</code> 表达式：</p><pre><code class="hljs java"><span class="hljs-comment">//源码</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ifPresent</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; consumer)</span> </span>&#123;    <span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>)        consumer.accept(value);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenCheckIfPresent</span><span class="hljs-params">()</span> </span>&#123;    User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"john@gmail.com"</span>, <span class="hljs-string">"1234"</span>);    Optional&lt;User&gt; opt = Optional.ofNullable(user);    opt.ifPresent( u -&gt; assertEquals(user.getEmail(), u.getEmail()));&#125;</code></pre><p>这个例子中，只有 <code>user</code> 用户不为 <code>null</code> 的时候才会执行断言。</p><h2 id="返回默认值"><a href="#返回默认值" class="headerlink" title="返回默认值"></a>返回默认值</h2><p><code>Optional</code> 类提供了 <code>API</code> 用以返回对象值，或者在对象为空的时候返回默认值。</p><p>第一个方法是 <code>orElse()</code>，它的工作方式非常直接，如果有值则返回该值，否则返回传递给它的参数值：</p><pre><code class="hljs java"><span class="hljs-comment">//源码</span><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">orElse</span><span class="hljs-params">(T other)</span> </span>&#123;    <span class="hljs-keyword">return</span> value != <span class="hljs-keyword">null</span> ? value : other;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenEmptyValue_thenReturnDefault</span><span class="hljs-params">()</span> </span>&#123;    User user = <span class="hljs-keyword">null</span>;    User user2 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"anna@gmail.com"</span>, <span class="hljs-string">"1234"</span>);    User result = Optional.ofNullable(user).orElse(user2);    assertEquals(user2.getEmail(), result.getEmail());&#125;</code></pre><p>这里 <code>user</code> 对象是空的，所以返回了作为默认值的 <code>user2</code>。</p><p>如果对象的初始值不是 <code>null</code>，那么默认值会被忽略：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenValueNotNull_thenIgnoreDefault</span><span class="hljs-params">()</span> </span>&#123;    User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"john@gmail.com"</span>,<span class="hljs-string">"1234"</span>);    User user2 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"anna@gmail.com"</span>, <span class="hljs-string">"1234"</span>);    User result = Optional.ofNullable(user).orElse(user2);    assertEquals(<span class="hljs-string">"john@gmail.com"</span>, result.getEmail());&#125;</code></pre><p>第二个同类型的 <code>API</code> 是 <code>orElseGet()</code> —— 其行为略有不同。<br>这个方法会在有值的时候返回值，如果没有值，它会执行作为参数传入的 <code>Supplier</code>(供应者) 函数式接口，并将返回其执行结果：</p><pre><code class="hljs java"><span class="hljs-comment">//源码</span><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">orElseGet</span><span class="hljs-params">(Supplier&lt;? extends T&gt; other)</span> </span>&#123;    <span class="hljs-keyword">return</span> value != <span class="hljs-keyword">null</span> ? value : other.get();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenValueNotNull_thenIgnoreDefault</span><span class="hljs-params">()</span> </span>&#123;    User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"john@gmail.com"</span>,<span class="hljs-string">"1234"</span>);    User result = Optional.ofNullable(user).orElseGet( () -&gt; user2);&#125;</code></pre><p><strong><code>orElse()</code> 和 <code>orElseGet()</code> 的不同之处</strong></p><p>乍一看，这两种方法似乎起着同样的作用。然而事实并非如此。下面创建一些示例来突出二者行为上的异同。</p><p>我们先来看看对象为空时它们的行为：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">givenEmptyValue_whenCompare_thenOk</span><span class="hljs-params">()</span> </span>&#123;    User user = <span class="hljs-keyword">null</span>    logger.debug(<span class="hljs-string">"Using orElse"</span>);    User result = Optional.ofNullable(user).orElse(createNewUser());    logger.debug(<span class="hljs-string">"Using orElseGet"</span>);    User result2 = Optional.ofNullable(user).orElseGet(() -&gt; createNewUser());&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> User <span class="hljs-title">createNewUser</span><span class="hljs-params">()</span> </span>&#123;    logger.debug(<span class="hljs-string">"Creating New User"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-string">"extra@gmail.com"</span>, <span class="hljs-string">"1234"</span>);&#125;</code></pre><p>上面的代码中，两种方法都调用了 <code>createNewUser()</code> 方法，这个方法会记录一个消息并返回 <code>User</code> 对象。</p><p>代码输出如下：</p><pre><code class="hljs java">Using orElseCreating New UserUsing orElseGetCreating New User</code></pre><p>由此可见，当对象为空而返回默认对象时，行为并无差异。</p><p>接下来看一个类似的示例，但这里 <code>Optional</code> 不为空：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">givenPresentValue_whenCompare_thenOk</span><span class="hljs-params">()</span> </span>&#123;    User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"john@gmail.com"</span>, <span class="hljs-string">"1234"</span>);    logger.info(<span class="hljs-string">"Using orElse"</span>);    User result = Optional.ofNullable(user).orElse(createNewUser());    logger.info(<span class="hljs-string">"Using orElseGet"</span>);    User result2 = Optional.ofNullable(user).orElseGet(() -&gt; createNewUser());&#125;</code></pre><p>这次的输出就不同了：</p><pre><code class="hljs java">Using orElseCreating New UserUsing orElseGet</code></pre><p>这个示例中，两个 <code>Optional</code> 对象都包含非空值，两个方法都会返回对应的非空值。不过，<code>orElse()</code> 方法仍然创建了 <code>User</code> 对象。与之相反，<code>orElseGet()</code> 方法不创建 <code>User</code> 对象。</p><p>在执行较密集的调用时，比如调用 <code>Web</code> 服务或数据查询，<strong>这个差异会对性能产生重大影响</strong>。</p><h2 id="返回异常"><a href="#返回异常" class="headerlink" title="返回异常"></a>返回异常</h2><p>除了 <code>orElse()</code> 和 <code>orElseGet()</code> 方法，<code>Optional</code> 还定义了 <code>orElseThrow() API</code> —— 它会在对象为空的时候抛出异常，而不是返回备选的值：</p><pre><code class="hljs java"><span class="hljs-comment">//源码</span><span class="hljs-keyword">public</span> &lt;X extends Throwable&gt; <span class="hljs-function">T <span class="hljs-title">orElseThrow</span><span class="hljs-params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="hljs-keyword">throws</span> X </span>&#123;    <span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> value;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">throw</span> exceptionSupplier.get();    &#125;&#125;<span class="hljs-meta">@Test</span>(expected = IllegalArgumentException.class)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenThrowException_thenOk</span><span class="hljs-params">()</span> </span>&#123;    User result = Optional.ofNullable(user)      .orElseThrow( () -&gt; <span class="hljs-keyword">new</span> IllegalArgumentException());&#125;</code></pre><p>这里，如果 <code>user</code> 值为 <code>null</code>，会抛出 <code>IllegalArgumentException</code>。</p><p>这个方法让我们有更丰富的语义，可以决定抛出什么样的异常，而不总是抛出 <code>NullPointerException</code>。</p><p>现在我们已经很好地理解了如何使用 <code>Optional</code>，下面来看看其它可以对 <code>Optional</code> 值进行转换和过滤的方法。</p><h2 id="转换值"><a href="#转换值" class="headerlink" title="转换值"></a>转换值</h2><p>有很多种方法可以转换 <code>Optional</code> 的值。先从 <code>map()</code> 和 <code>flatMap()</code> 方法开始。</p><p>先来看一个使用 <code>map() API</code> 的例子：</p><pre><code class="hljs java"><span class="hljs-comment">//源码</span><span class="hljs-function"><span class="hljs-keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="hljs-title">map</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends U&gt; mapper)</span> </span>&#123;    Objects.requireNonNull(mapper);    <span class="hljs-keyword">if</span> (!isPresent())        <span class="hljs-keyword">return</span> empty();    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> Optional.ofNullable(mapper.apply(value));    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenMap_thenOk</span><span class="hljs-params">()</span> </span>&#123;    User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"anna@gmail.com"</span>, <span class="hljs-string">"1234"</span>);    String email = Optional.ofNullable(user)      .map(u -&gt; u.getEmail()).orElse(<span class="hljs-string">"default@gmail.com"</span>);    assertEquals(email, user.getEmail());&#125;</code></pre><p><strong><code>map()</code> 对值应用(调用)作为参数的函数，然后将返回的值包装在 <code>Optional</code> 中</strong>。这就使对返回值进行链试调用的操作成为可能 —— 这里的下一环就是 <code>orElse()</code>。</p><p>相比这下，<code>flatMap()</code> 也需要函数作为参数，并对值调用这个函数，然后直接返回结果。</p><p>下面的操作中，我们给 <code>User</code> 类添加了一个方法，用来返回 <code>Optional</code>：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;        <span class="hljs-keyword">private</span> String position;    <span class="hljs-function"><span class="hljs-keyword">public</span> Optional&lt;String&gt; <span class="hljs-title">getPosition</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> Optional.ofNullable(position);    &#125;    <span class="hljs-comment">//...</span>&#125;</code></pre><p>既然 <code>getter</code> 方法返回 <code>String</code> 值的 <code>Optional</code>，你可以在对 <code>User</code> 的 <code>Optional</code> 对象调用 <code>flatMap()</code> 时，用它作为参数。其返回的值是解除包装的 <code>String</code> 值：</p><pre><code class="hljs java"><span class="hljs-comment">//源码</span><span class="hljs-function"><span class="hljs-keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="hljs-title">flatMap</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> T, Optional&lt;U&gt;&gt; mapper)</span> </span>&#123;    Objects.requireNonNull(mapper);    <span class="hljs-keyword">if</span> (!isPresent())        <span class="hljs-keyword">return</span> empty();    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> Objects.requireNonNull(mapper.apply(value));    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenFlatMap_thenOk</span><span class="hljs-params">()</span> </span>&#123;    User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"anna@gmail.com"</span>, <span class="hljs-string">"1234"</span>);    user.setPosition(<span class="hljs-string">"Developer"</span>);    String position = Optional.ofNullable(user)      .flatMap(u -&gt; u.getPosition()).orElse(<span class="hljs-string">"default"</span>);    assertEquals(position, user.getPosition().get());&#125;</code></pre><h2 id="过滤值"><a href="#过滤值" class="headerlink" title="过滤值"></a>过滤值</h2><p>除了转换值之外，<code>Optional</code> 类也提供了按条件“过滤”值的方法。</p><p><strong><code>filter()</code> 接受一个 <code>Predicate</code> 参数，返回测试结果为 <code>true</code> 的值</strong>。如果测试结果为 <code>false</code>，会返回一个空的 <code>Optional</code>。</p><p>来看一个根据基本的电子邮箱验证来决定接受或拒绝 <code>User</code>(用户) 的示例：</p><pre><code class="hljs java"><span class="hljs-comment">//源码</span><span class="hljs-function"><span class="hljs-keyword">public</span> Optional&lt;T&gt; <span class="hljs-title">filter</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span> </span>&#123;    Objects.requireNonNull(predicate);    <span class="hljs-keyword">if</span> (!isPresent())        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> predicate.test(value) ? <span class="hljs-keyword">this</span> : empty();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenFilter_thenOk</span><span class="hljs-params">()</span> </span>&#123;    User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"anna@gmail.com"</span>, <span class="hljs-string">"1234"</span>);    Optional&lt;User&gt; result = Optional.ofNullable(user)      .filter(u -&gt; u.getEmail() != <span class="hljs-keyword">null</span> &amp;&amp; u.getEmail().contains(<span class="hljs-string">"@"</span>));    assertTrue(result.isPresent());&#125;</code></pre><p>如果通过过滤器测试，<code>result</code> 对象会包含非空值。</p><h2 id="Optional-类的链式方法"><a href="#Optional-类的链式方法" class="headerlink" title="Optional 类的链式方法"></a>Optional 类的链式方法</h2><p>为了更充分的使用 <code>Optional</code>，你可以链接组合其大部分方法，因为它们都返回相同类似的对象。</p><p>我们使用 <code>Optional</code> 重写最早介绍的示例。</p><p>首先，重构类，使其 <code>getter</code> 方法返回 <code>Optional</code> 引用：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> Address address;    <span class="hljs-function"><span class="hljs-keyword">public</span> Optional&lt;Address&gt; <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> Optional.ofNullable(address);    &#125;    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span> </span>&#123;    <span class="hljs-keyword">private</span> Country country;    <span class="hljs-function"><span class="hljs-keyword">public</span> Optional&lt;Country&gt; <span class="hljs-title">getCountry</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> Optional.ofNullable(country);    &#125;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p>现在可以删除 <code>null</code> 检查，替换为 <code>Optional</code> 的方法：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenChaining_thenOk</span><span class="hljs-params">()</span> </span>&#123;    User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"anna@gmail.com"</span>, <span class="hljs-string">"1234"</span>);    String result = Optional.ofNullable(user)      .flatMap(u -&gt; u.getAddress())      .flatMap(a -&gt; a.getCountry())      .map(c -&gt; c.getIsocode())      .orElse(<span class="hljs-string">"default"</span>);    assertEquals(result, <span class="hljs-string">"default"</span>);&#125;</code></pre><p>上面的代码还可以通过方法引用进一步缩减：</p><pre><code class="hljs java">String result = Optional.ofNullable(user)  .flatMap(User::getAddress)  .flatMap(Address::getCountry)  .map(Country::getIsocode)  .orElse(<span class="hljs-string">"default"</span>);</code></pre><p>现在的代码看起来比之前采用条件分支的冗长代码就简洁多了。</p><h2 id="Optional-应该怎样用？"><a href="#Optional-应该怎样用？" class="headerlink" title="Optional 应该怎样用？"></a>Optional 应该怎样用？</h2><p>在使用 <code>Optional</code> 的时候需要考虑一些事情，以决定什么时候怎样使用它。</p><p>重要的一点是 <code>Optional</code> 不是 <code>Serializable</code>。因此，它不应该用作类的字段。</p><p>如果你需要序列化的对象包含 <code>Optional</code> 值，<code>Jackson</code> 库支持把 <code>Optional</code> 当作普通对象。也就是说，<code>Jackson</code> 会把空对象看作 <code>null</code>，而有值的对象则把其值看作对应域的值。这个功能在 <a href="https://github.com/FasterXML/jackson-modules-java8" target="_blank" rel="noopener">jackson-modules-java8</a> 项目中。</p><p>它在另一种情况下也并不怎么有用，就是在将其类型用作方法或构建方法的参数时。这样做会让代码变得复杂，完全没有必要：</p><pre><code class="hljs java">User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"john@gmail.com"</span>, <span class="hljs-string">"1234"</span>, Optional.empty());</code></pre><p>使用重载方法来处理非要的参数要容易得多。</p><p><code>Optional</code> 主要用作返回类型。在获取到这个类型的实例后，如果它有值，你可以取得这个值，否则可以进行一些替代行为。</p><p><code>Optional</code> 类有一个非常有用的用例，就是将其与流或其它返回 <code>Optional</code> 的方法结合，以构建流畅的<code>API</code>。</p><p>下面来看一个示例，使用 <code>Stream</code> 返回 <code>Optional</code> 对象的 <code>findFirst()</code> 方法：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenEmptyStream_thenReturnDefaultOptional</span><span class="hljs-params">()</span> </span>&#123;    List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    User user = users.stream().findFirst().orElse(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"default"</span>, <span class="hljs-string">"1234"</span>));    assertEquals(user.getEmail(), <span class="hljs-string">"default"</span>);&#125;</code></pre><h2 id="Java-9-增强"><a href="#Java-9-增强" class="headerlink" title="Java 9 增强"></a>Java 9 增强</h2><p><code>Java 9</code> 为 <code>Optional</code> 类添加了三个方法：<code>or()</code>、<code>ifPresentOrElse()</code> 和 <code>stream()</code>。</p><p><code>or()</code> 方法与 <code>orElse()</code> 和 <code>orElseGet()</code> 类似，它们都在对象为空的时候提供了替代情况。<code>or()</code> 的返回值是由 <code>Supplier</code> 参数产生的另一个 <code>Optional</code> 对象。</p><p>具体的这里不再介绍，读者可自行查找。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Optional</code> 是 <code>Java</code> 语言的有益补充 —— 它旨在减少代码中的 <code>NullPointerExceptions</code>，虽然还不能完全消除这些异常。</p><p>它也是精心设计，自然融入 <code>Java 8</code> 函数式支持的功能。</p><p>总的来说，这个简单而强大的类有助于创建简单、可读性更强、比对应程序错误更少的程序。</p><p>参考：<br><a href="https://www.oschina.net/translate/understanding-accepting-and-leveraging-optional-in?lang=chs&p=2" target="_blank" rel="noopener">理解、学习与使用 Java 中的 Optional</a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java Optional</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Atomic简介</title>
    <link href="/passages/java-atomic-introduction/"/>
    <url>/passages/java-atomic-introduction/</url>
    
    <content type="html"><![CDATA[<!-- more --><!-- more --><p>所谓 <code>Atomic</code>，翻译过来就是原子。原子被认为是操作中最小的单位，一段代码如果是原子的，则表示这段代码在执行过程中，要么执行成功，要么执行失败。原子操作一般都是底层通过 <code>CPU</code> 的指令来实现。而 <code>atomic</code> 包下的这些类，则可以让我们在多线程环境下，通过一种无锁的原子操作来实现线程安全。</p><p><code>atomic</code> 包下的类基本上都是借助 <code>Unsafe</code> 类，通过 <code>CAS</code> 操作来封装实现的。<code>Unsafe</code> 这个类不属于 <code>Java</code> 标准，或者说这个类是 <code>Java</code> 预留的一个后门类，<code>JDK</code> 中，有关提升性能的 <code>concurrent</code> 或者 <code>NIO</code> 等操作，大部分都是借助于这个类来封装操作的。<br><code>Java</code> 是种编译型语言，不像 <code>C</code> 语言能支持操作内存，正常情况下都是由 <code>JVM</code> 进行内存的创建回收等操作，但这个类提供了一些直接操作内存相关的底层操作，使得我们也可以手动操作内存，但从类的名字就可以看出，这个类不是安全的，官方也是不建议我们使用的。</p><h2 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h2><p><code>CAS</code> 包含 <code>3</code> 个参数 <code>CAS(V,E,N)</code>. <code>V</code> 表示要更新的变量, <code>E</code> 表示预期值, <code>N</code> 表示新值.</p><p>仅当<code>V</code>值等于<code>E</code>值时, 才会将<code>V</code>的值设为<code>N</code>, 如果<code>V</code>值和<code>E</code>值不同, 则说明已经有其他线程做了更新, 则当前线程什么都不做. 最后, <code>CAS</code>返回当前<code>V</code>的真实值. <code>CAS</code>操作是抱着乐观的态度进行的, 它总是认为自己可以成功完成操作.</p><p>当多个线程同时使用<code>CAS</code>操作一个变量时, 只有一个会胜出, 并成功更新, 其余均会失败.失败的线程不会被挂起,仅是被告知失败, 并且允许再次尝试, 当然也允许失败的线程放弃操作.基于这样的原理, <code>CAS</code>操作即时没有锁,也可以发现其他线程对当前线程的干扰, 并进行恰当的处理.</p><p>在 <code>JDK8</code> 的 <code>atomic</code> 包下，大概有 <code>16</code> 个类，按照原子的更新方式，大概可以分为 <code>4</code> 类：<strong>原子更新普通类型</strong>，<strong>原子更新数组</strong>，<strong>原子更新引用</strong>，<strong>原子更新字段</strong>。</p><h2 id="原子更新普通类型"><a href="#原子更新普通类型" class="headerlink" title="原子更新普通类型"></a>原子更新普通类型</h2><p><code>atomic</code> 包下提供了三种基本类型的原子更新，分别是 <code>AtomicBoolean</code>，<code>AtomicInteger</code>，<code>AtomicLong</code>，这几个原子类对应于基础类型的布尔，整形，长整形，至于 <code>Java</code> 中其他的基本类型，如 <code>float</code> 等，如果需要，可以参考这几个类的源码自行实现。</p><h3 id="AtomicBoolean"><a href="#AtomicBoolean" class="headerlink" title="AtomicBoolean"></a>AtomicBoolean</h3><p><strong>主要接口</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> expect, <span class="hljs-keyword">boolean</span> update)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">weakCompareAndSet</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> expect, <span class="hljs-keyword">boolean</span> update)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> newValue)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lazySet</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> newValue)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">getAndSet</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> newValue)</span></span>;</code></pre><p>这里面的操作都很正常，主要都是用到了 <code>CAS</code>。这个类中的方法不多，基本上上面都介绍了，而内部的计算则是先将布尔转换为数字<code>0/1</code>，然后再进行后续计算。</p><h3 id="AtomicLong"><a href="#AtomicLong" class="headerlink" title="AtomicLong"></a>AtomicLong</h3><p><strong>主要接口</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">long</span> newValue)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lazySet</span><span class="hljs-params">(<span class="hljs-keyword">long</span> newValue)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getAndSet</span><span class="hljs-params">(<span class="hljs-keyword">long</span> newValue)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(<span class="hljs-keyword">long</span> expect, <span class="hljs-keyword">long</span> update)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">weakCompareAndSet</span><span class="hljs-params">(<span class="hljs-keyword">long</span> expect, <span class="hljs-keyword">long</span> update)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getAndIncrement</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getAndDecrement</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getAndAdd</span><span class="hljs-params">(<span class="hljs-keyword">long</span> delta)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">incrementAndGet</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">decrementAndGet</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">addAndGet</span><span class="hljs-params">(<span class="hljs-keyword">long</span> delta)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getAndUpdate</span><span class="hljs-params">(LongUnaryOperator updateFunction)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">updateAndGet</span><span class="hljs-params">(LongUnaryOperator updateFunction)</span></span>;</code></pre><p>这个和下面要讲的 <code>AtomicInteger</code> 类似，下面具体说下。</p><h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p><strong>主要接口</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 取得当前值</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 设置当前值</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newValue)</span></span>;<span class="hljs-comment">// 设置新值，并返回旧值</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newValue)</span></span>;<span class="hljs-comment">// 如果当前值为expect，则设置为u</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expect, <span class="hljs-keyword">int</span> u)</span></span>;<span class="hljs-comment">// 当前值加1，返回旧值</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndIncrement</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 当前值减1，返回旧值</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndDecrement</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 当前值增加delta，返回旧值</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAdd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> delta)</span></span>;<span class="hljs-comment">// 当前值加1，返回新值</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">incrementAndGet</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 当前值减1，返回新值</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">decrementAndGet</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 当前值增加delta，返回新值</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addAndGet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> delta)</span></span>;</code></pre><p><strong>实现</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 封装了一个int对其加减</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> value;.......<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expect, <span class="hljs-keyword">int</span> update)</span> </span>&#123;<span class="hljs-comment">// 通过unsafe 基于CPU的CAS指令来实现, 可以认为无阻塞.</span>    <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-keyword">this</span>, valueOffset, expect, update);&#125;.......<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndIncrement</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (;;) &#123;    <span class="hljs-comment">// 当前值</span>        <span class="hljs-keyword">int</span> current = get();    <span class="hljs-comment">// 预期值</span>        <span class="hljs-keyword">int</span> next = current + <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (compareAndSet(current, next)) &#123;    <span class="hljs-comment">// 如果加成功了, 则返回当前值</span>            <span class="hljs-keyword">return</span> current;    &#125;    <span class="hljs-comment">// 如果加失败了, 说明其他线程已经修改了数据, 与期望不相符,</span>    <span class="hljs-comment">// 则继续无限循环, 直到成功. 这种乐观锁, 理论上只要等两三个时钟周期就可以设值成功</span>    <span class="hljs-comment">// 相比于直接通过synchronized独占锁的方式操作int, 要大大节约等待时间.</span>    &#125;&#125;</code></pre><p>用一个简单的例子测试下：</p><pre><code class="hljs java">AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);System.out.println(atomicInteger.incrementAndGet());                       <span class="hljs-comment">// 2</span>System.out.println(atomicInteger.getAndIncrement());                       <span class="hljs-comment">// 2</span>System.out.println(atomicInteger.getAndAccumulate(<span class="hljs-number">2</span>, (i, j) -&gt; i + j));    <span class="hljs-comment">// 3</span>System.out.println(atomicInteger.get());                                   <span class="hljs-comment">// 5</span>System.out.println(atomicInteger.addAndGet(<span class="hljs-number">5</span>));</code></pre><h2 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h2><p><code>atomic</code> 包下提供了三种数组相关类型的原子更新，分别是 <code>AtomicIntegerArray</code>，<code>AtomicLongArray</code>，<code>AtomicReferenceArray</code>，对应于整型，长整形，引用类型，要说明的一点是，这里说的更新是指更新数组中的某一个元素的操作。</p><p>由于方法和更新基本类型方法相同，这里只简单看下 <code>AtomicIntegerArray</code> 这个类的几个方法，其他的方法类似。</p><h3 id="AtomicIntegerArray"><a href="#AtomicIntegerArray" class="headerlink" title="AtomicIntegerArray"></a>AtomicIntegerArray</h3><p><strong>主要接口</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 获得数组第i个下标的元素</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;<span class="hljs-comment">// 获得数组的长度</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 将数组第i个下标设置为newValue，并返回旧的值</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> newValue)</span></span>;<span class="hljs-comment">// 进行CAS操作，如果第i个下标的元素等于expect，则设置为update，设置成功返回true</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> expect, <span class="hljs-keyword">int</span> update)</span></span>;<span class="hljs-comment">// 将第i个下标的元素加1</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndIncrement</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;<span class="hljs-comment">// 将第i个下标的元素减1</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndDecrement</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;<span class="hljs-comment">// 将第i个下标的元素增加delta（delta可以是负数）</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAdd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> delta)</span></span>;</code></pre><p><strong>实现</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 数组本身基地址</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> base = unsafe.arrayBaseOffset(<span class="hljs-keyword">int</span>[].class);<span class="hljs-comment">// 封装了一个数组</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] array;<span class="hljs-keyword">static</span> &#123;    <span class="hljs-comment">// 数组中对象的宽度, int类型, 4个字节, scale = 4;</span>    <span class="hljs-keyword">int</span> scale = unsafe.arrayIndexScale(<span class="hljs-keyword">int</span>[].class);    <span class="hljs-keyword">if</span> ((scale &amp; (scale - <span class="hljs-number">1</span>)) != <span class="hljs-number">0</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"data type scale not a power of two"</span>);    <span class="hljs-comment">// 前导0 : 一个数字转为二进制后, 他前面0的个数</span>    <span class="hljs-comment">// 对于4来讲, 他就是00000000 00000000 00000000 00000100, 他的前导0 就是29</span>    <span class="hljs-comment">// 所以shift = 2</span>    shift = <span class="hljs-number">31</span> - Integer.numberOfLeadingZeros(scale);&#125;<span class="hljs-comment">// 获取第i个元素</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;    <span class="hljs-keyword">return</span> getRaw(checkedByteOffset(i));&#125;<span class="hljs-comment">// 第i个元素, 在数组中的偏移量是多少</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> <span class="hljs-title">checkedByteOffset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= array.length)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"index "</span> + i);    <span class="hljs-keyword">return</span> byteOffset(i);&#125;<span class="hljs-comment">// base : 数组基地址, i &lt;&lt; shift, 其实就是i * 4, 因为这边是int array.</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">byteOffset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;    <span class="hljs-comment">// i * 4 + base</span>    <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">long</span>) i &lt;&lt; shift) + base;&#125;<span class="hljs-comment">// 根据偏移量从数组中获取数据</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRaw</span><span class="hljs-params">(<span class="hljs-keyword">long</span> offset)</span> </span>&#123;    <span class="hljs-keyword">return</span> unsafe.getIntVolatile(array, offset);&#125;</code></pre><p>用一个简单的例子测试一下：</p><pre><code class="hljs java">AtomicIntegerArray array = <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-number">5</span>);array.set(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);                                        <span class="hljs-comment">// 设置数组第一个值为1</span>System.out.println(array.getAndDecrement(<span class="hljs-number">0</span>));         <span class="hljs-comment">// 1</span>System.out.println(array.addAndGet(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>));      <span class="hljs-comment">// 5</span></code></pre><h2 id="原子更新引用"><a href="#原子更新引用" class="headerlink" title="原子更新引用"></a>原子更新引用</h2><p>更新引用类型的原子类包含了<code>AtomicReference</code>（更新引用类型），<code>AtomicReferenceFieldUpdater</code>（抽象类，更新引用类型里的字段），<code>AtomicMarkableReference</code>（更新带有标记的引用类型）这三个类，这几个类能同时更新多个变量。</p><h3 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h3><p>与 <code>AtomicInteger</code> 类似, 只是里面封装了一个对象, 而不是 <code>int</code>, 对引用进行修改。</p><p><strong>主要接口</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(V newValue)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(V expect, V update)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">getAndSet</span><span class="hljs-params">(V newValue)</span></span>;</code></pre><p><strong>测试</strong><br>使用 <code>10</code> 个线程, 同时尝试修改 <code>AtomicReference</code> 中的 <code>String</code>, 最终只有一个线程可以成功。</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicReference;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicReferenceTest</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; attxnicStr = <span class="hljs-keyword">new</span> AtomicReference&lt;String&gt;(<span class="hljs-string">"abc"</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread() &#123;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-keyword">try</span> &#123;                        Thread.sleep(Math.abs((<span class="hljs-keyword">int</span>) (Math.random() * <span class="hljs-number">100</span>)));                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    <span class="hljs-keyword">if</span> (attxnicStr.compareAndSet(<span class="hljs-string">"abc"</span>, <span class="hljs-string">"def"</span>)) &#123;                        System.out.println(<span class="hljs-string">"Thread:"</span> + Thread.currentThread().getId() + <span class="hljs-string">" change value to "</span> + attxnicStr.get());                    &#125; <span class="hljs-keyword">else</span> &#123;                        System.out.println(<span class="hljs-string">"Thread:"</span> + Thread.currentThread().getId() + <span class="hljs-string">" change failed!"</span>);                    &#125;                &#125;            &#125;.start();        &#125;    &#125;&#125;</code></pre><h2 id="原子更新字段"><a href="#原子更新字段" class="headerlink" title="原子更新字段"></a>原子更新字段</h2><p>如果更新的时候只更新对象中的某一个字段，则可以使用 <code>atomic</code> 包提供的更新字段类型：<code>AtomicIntegerFieldUpdater</code>，<code>AtomicLongFieldUpdater</code> 和 <code>AtomicStampedReference</code>，前两个顾名思义，就是更新 <code>int</code> 和 <code>long</code> 类型，最后一个是更新引用类型，该类提供了版本号，用于解决通过 <code>CAS</code> 进行原子更新过程中，可能出现的 <code>ABA</code> 问题。<br>前面这两个类和上面介绍的 <code>AtomicReferenceFieldUpdater</code> 有些相似，都是抽象类，都需要通过 <code>newUpdater</code> 方法进行实例化，并且对字段的要求也是一样的。</p><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><p><strong>ABA问题</strong></p><p>线程一准备用 <code>CAS</code> 将变量的值由 <code>A</code> 替换为 <code>B</code>, 在此之前线程二将变量的值由 <code>A</code> 替换为 <code>C</code>, 线程三又将 <code>C</code> 替换为<code>A</code>, 然后线程一执行 <code>CAS</code> 时发现变量的值仍然为 <code>A</code>, 所以线程一 <code>CAS</code> 成功.</p><p><strong>主要接口</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 比较设置 参数依次为：期望值 写入新值 期望时间戳 新时间戳</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(V expectedReference,V newReference,<span class="hljs-keyword">int</span> expectedStamp,<span class="hljs-keyword">int</span> newStamp)</span><span class="hljs-comment">// 获得当前对象引用</span><span class="hljs-keyword">public</span> V <span class="hljs-title">getReference</span><span class="hljs-params">()</span><span class="hljs-comment">// 获得当前时间戳</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getStamp</span><span class="hljs-params">()</span><span class="hljs-comment">// 设置当前对象引用和时间戳</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(V newReference, <span class="hljs-keyword">int</span> newStamp)</span></span></code></pre><p><strong>分析</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 内部封装了一个Pair对象, 每次对对象操作的时候, stamp + 1</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">final</span> T reference;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> stamp;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T reference, <span class="hljs-keyword">int</span> stamp)</span> </span>&#123;        <span class="hljs-keyword">this</span>.reference = reference;        <span class="hljs-keyword">this</span>.stamp = stamp;    &#125;    <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Pair&lt;T&gt; <span class="hljs-title">of</span><span class="hljs-params">(T reference, <span class="hljs-keyword">int</span> stamp)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pair&lt;T&gt;(reference, stamp);    &#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Pair&lt;V&gt; pair;<span class="hljs-comment">// 进行cas操作的时候, 会对比stamp的值</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(V   expectedReference,                             V   newReference,                             <span class="hljs-keyword">int</span> expectedStamp,                             <span class="hljs-keyword">int</span> newStamp)</span> </span>&#123;    Pair&lt;V&gt; current = pair;    <span class="hljs-keyword">return</span>        expectedReference == current.reference &amp;&amp;        expectedStamp == current.stamp &amp;&amp;        ((newReference == current.reference &amp;&amp;          newStamp == current.stamp) ||         casPair(current, Pair.of(newReference, newStamp)));&#125;</code></pre><p><strong>测试</strong></p><p>要求：后台使用多个线程对用户充值, 要求只能充值一次.</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicStampedReferenceDemo</span> </span>&#123; <span class="hljs-keyword">static</span> AtomicStampedReference&lt;Integer&gt; money=<span class="hljs-keyword">new</span> AtomicStampedReference&lt;Integer&gt;(<span class="hljs-number">19</span>,<span class="hljs-number">0</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> staticvoid <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//模拟多个线程同时更新后台数据库，为用户充值</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">3</span> ; i++) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> timestamp=money.getStamp();            newThread() &#123;                  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                     <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;                       <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;                           Integerm=money.getReference();                            <span class="hljs-keyword">if</span>(m&lt;<span class="hljs-number">20</span>)&#123;                         <span class="hljs-keyword">if</span>(money.compareAndSet(m,m+<span class="hljs-number">20</span>,timestamp,timestamp+<span class="hljs-number">1</span>))&#123;          　　　　　　　　　　　　　　　 System.out.println(<span class="hljs-string">"余额小于20元，充值成功，余额:"</span>+money.getReference()+<span class="hljs-string">"元"</span>);                                    <span class="hljs-keyword">break</span>;                                &#125;                            &#125;<span class="hljs-keyword">else</span>&#123;                               <span class="hljs-comment">//System.out.println("余额大于20元，无需充值");</span>                                <span class="hljs-keyword">break</span> ;                             &#125;                       &#125;                    &#125;                &#125;             &#125;.start();         &#125;               <span class="hljs-comment">//用户消费线程，模拟消费行为</span>        <span class="hljs-keyword">new</span> Thread() &#123;              <span class="hljs-function">publicvoid <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                 <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)&#123;                   <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;                        <span class="hljs-keyword">int</span> timestamp=money.getStamp();                        Integer m=money.getReference();                        <span class="hljs-keyword">if</span>(m&gt;<span class="hljs-number">10</span>)&#123;                             System.out.println(<span class="hljs-string">"大于10元"</span>);                          　　<span class="hljs-keyword">if</span>(money.compareAndSet(m, m-<span class="hljs-number">10</span>,timestamp,timestamp+<span class="hljs-number">1</span>))&#123;                      　　　　　　 System.out.println(<span class="hljs-string">"成功消费10元，余额:"</span>+money.getReference());                                 <span class="hljs-keyword">break</span>;                             &#125;                        &#125;<span class="hljs-keyword">else</span>&#123;                           System.out.println(<span class="hljs-string">"没有足够的金额"</span>);                             <span class="hljs-keyword">break</span>;                        &#125;                    &#125;                    <span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">100</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;                 &#125;            &#125;         &#125;.start();     &#125; &#125;</code></pre><h3 id="AtomicIntegerFieldUpdater"><a href="#AtomicIntegerFieldUpdater" class="headerlink" title="AtomicIntegerFieldUpdater"></a>AtomicIntegerFieldUpdater</h3><p>能够让普通变量也能够进行原子操作。</p><p><strong>主要接口</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; <span class="hljs-function">AtomicIntegerFieldUpdater&lt;U&gt; <span class="hljs-title">newUpdater</span><span class="hljs-params">(Class&lt;U&gt; tclass,                                                              String fieldName)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">incrementAndGet</span><span class="hljs-params">(T obj)</span></span>;</code></pre><ul><li><p><code>Updater</code>只能修改它可见范围内的变量。因为<code>Updater</code>使用反射得到这个变量。如果变量不可见，就会出错。比如如果<code>score</code>申明为<code>private</code>，就是不可行的。</p></li><li><p>为了确保变量被正确的读取，它必须是<code>volatile</code>类型的。如果我们原有代码中未申明这个类型，那么简单得申明一下就行。</p></li><li><p>由于<code>CAS</code>操作会通过对象实例中的偏移量直接进行赋值，因此，它不支持<code>static</code>字段（<code>Unsafe.objectFieldOffset()</code>不支持静态变量）。</p></li></ul><p><strong>测试</strong></p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicIntegerFieldUpdaterDemo</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candidate</span> </span>&#123;        <span class="hljs-keyword">int</span> id;        <span class="hljs-comment">// 如果直接把int改成atomicinteger, 可能对代码破坏比较大</span>        <span class="hljs-comment">// 因此使用AtomicIntegerFieldUpdater对score进行封装</span>        <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> score;    &#125;    <span class="hljs-comment">// 通过反射实现</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> AtomicIntegerFieldUpdater&lt;Candidate&gt; scoreUpdater = AtomicIntegerFieldUpdater.newUpdater(Candidate.class, <span class="hljs-string">"score"</span>);    <span class="hljs-comment">// 检查Updater是否工作正确, allScore的结果应该跟score一致</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AtomicInteger allScore = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">final</span> Candidate stu = <span class="hljs-keyword">new</span> Candidate();        Thread[] t = <span class="hljs-keyword">new</span> Thread[<span class="hljs-number">10000</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;            t[i] = <span class="hljs-keyword">new</span> Thread() &#123;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-keyword">if</span> (Math.random() &gt; <span class="hljs-number">0.4</span>) &#123;                        scoreUpdater.incrementAndGet(stu);                        allScore.incrementAndGet();                    &#125;                &#125;            &#125;;            t[i].start();        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;            t[i].join();        &#125;        System.out.println(<span class="hljs-string">"score="</span> + stu.score);        System.out.println(<span class="hljs-string">"allScore="</span> + allScore);    &#125;&#125;</code></pre><h2 id="JDK8之后引入的类型"><a href="#JDK8之后引入的类型" class="headerlink" title="JDK8之后引入的类型"></a>JDK8之后引入的类型</h2><p>在<code>JDK8</code>之前，针对原子操作，我们基本上可以通过上面提供的这些类来完成我们的多线程下的原子操作，不过在并发高的情况下，上面这些单一的 <code>CAS</code> + 自旋操作的性能将会是一个问题，所以上述这些类一般用于低并发操作。<br>而针对这个问题，<code>JDK8</code>又引入了下面几个类：<code>DoubleAdder</code>，<code>LongAdder</code>，<code>DoubleAccumulator</code>，<code>LongAccumulator</code>，这些类是对<code>AtomicLong</code>这些类的改进与增强，这些类都继承自<code>Striped64</code>这个类。</p><p><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/10/16/67ad3b70-efeb-11e9-8a30-f58a35fb4bc0.png" srcset="/img/loading.gif" alt="Java Atomic.png"></p><p>参考博客：<br><a href="https://www.cnblogs.com/xdecode/p/9022525.html" target="_blank" rel="noopener">Java高并发之无锁与Atomic源码分析</a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java Atomic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java锁机制</title>
    <link href="/passages/java-lock/"/>
    <url>/passages/java-lock/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>锁机制是用来保证对象的一致性以及操作的原子性，另一方面也是实现线程安全的重要手段。</p><h2 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁/非公平锁"></a>公平锁/非公平锁</h2><p>公平锁是指多个线程按照申请锁的顺序来获取锁。</p><p>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，有可能会造成优先级反转或者饥饿现象。</p><p><code>ReentrantReadWriteLock</code> 实现了公平锁和非公平锁两种模式。<br>在公平锁模式下线程按照请求的顺序来获得锁，而非公平模式下则可以插队。我们的期望是所有的锁都是公平的，毕竟插队是一种不好的行为。但实际上非公平锁比公平锁有着更高的并发效率。假设线程 <code>A</code> 持有一个锁，并且线程 <code>B</code> 也请求这个锁，由于该锁被线程 <code>A</code> 占有，所以 <code>B</code>线 程挂起，当 <code>A</code> 使用结束时释放锁，此时唤醒 <code>B</code>，<code>B</code> 需要重新申请获得锁。如果同时线程 <code>C</code> 也请求这个锁，并且 <code>C</code> 很可能在 <code>B</code> 获得锁之前已经获得、使用并释放了锁。这样就实现了双赢，<code>B</code> 线程获得的锁没有延迟同时线程 <code>C</code> 也得到了执行，这提高了程序的吞吐率。</p><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p><code>ReentrantLock</code> 是一个可重入的互斥锁，继承自 <code>Lock</code> 接口。如果说 <code>synchronized</code> 是隐式锁的话，那么 <code>ReentrentLock</code> 就是显式锁。锁的申请、使用、释放都必须显式的申明。<code>Lock</code>接口提供了以下方法：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Lock</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time,TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unLock</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，并提供了与 <code>synchronized</code> 相同的互斥性和内存可见性。<br>那既然如此，为什么还要创建一个类似的锁机制呢？<br>内置锁虽然好用，但是缺乏一些灵活性，而<code>ReentrantLock</code>则可以弥补这些不足。</p><ul><li><p>第一，轮询锁与定时锁。<code>tryLock</code> 方法实现了可定时的与可轮询的锁实现。<br>与 <code>synchronized</code> 相比它有更完善的错误恢复机制。内置锁中死锁是一类严重的错误，只能重启程序。而 <code>ReentrantLock</code> 可以使用可定时或者轮询的锁，它会释放已获得的锁，然后再尝试获得所有的锁。在实现具有时间限制的操作时，定时锁也非常也用。如果操作在给定时间内不能给出结果那么就会使程序提前结束。</p></li><li><p>第二，可中断锁获取操作。<br><code>lockInterruptibly</code> 方法能够在获得锁的同时保持对中断的响应。而且由于它包含在 <code>Lock</code> 中，因此无需创建其他类型的不可中断阻塞机制。</p></li></ul><h2 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁/共享锁"></a>独享锁/共享锁</h2><p>独享锁是指该锁一次只能被一个线程所持有。</p><p>共享锁是指该锁可被多个线程所持有。</p><h2 id="互斥锁-读写锁"><a href="#互斥锁-读写锁" class="headerlink" title="互斥锁/读写锁"></a>互斥锁/读写锁</h2><p>独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。</p><h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><p><code>ReentrantReadWriteLock</code> 实现了一种标准的互斥读写锁，继承自 <code>ReadWriteLock</code>。<code>ReadWriteLock</code> 接口包含以下方法：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ReadWriteLock</span></span>&#123;    <span class="hljs-function">Lock <span class="hljs-title">readLock</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">Lock <span class="hljs-title">WriteLock</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><code>ReentrantReadWriteLock</code> 可以这样理解：当执行读操作的时候可以多个线程并发访问；当执行写操作的时候，只可以同时被一个线程访问。所以它使用的场景是<strong>读操作多而写操作少的并发场景</strong>。<br>此外，<code>ReentrantReadWriteLock</code> 还可以设置是否为公平锁，是公平锁的话则可以按照排队的顺序获取锁，非公平锁的话则是随机获得。</p><h2 id="偏向锁-轻量级锁-重量级锁"><a href="#偏向锁-轻量级锁-重量级锁" class="headerlink" title="偏向锁/轻量级锁/重量级锁"></a>偏向锁/轻量级锁/重量级锁</h2><p><strong>偏向锁的适用场景</strong></p><p>始终只有一个线程在执行同步块，在它没有执行完释放锁之前，没有其它线程去执行同步块，在锁无竞争的情况下使用，一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致 <code>stop the word(stw)</code>操作；</p><p>在有锁的竞争时，偏向锁会多做很多额外操作，尤其是撤销偏向所的时候会导致进入安全点，安全点会导致 <code>stw</code>，导致性能下降，这种情况下应当禁用；</p><p>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p><p>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><code>synchronized</code>用来形容方法或者代码块，是 <code>Java</code> 提供的最早的锁机制，支持重入锁。</p><p>列举几个注意事项：</p><ul><li><p>第一，使用 <code>synchronized</code> 关键字时一定要尽可能的缩小范围，尽可能的在方法块里需要锁的地方使用，而不是直接用来修饰整个方法。<br>这需要对方法里面的操作进行分析，哪些需要加锁，哪些不需要加锁，只在需要锁的地方加锁，这样即可以提高程序的效率，同时开放调用方法也减少了线程安全的隐患。</p></li><li><p>第二，<code>synchronized</code> 提供的锁机制是粗粒度的，当有线程访问当前对象的 <code>synchronized</code> 方法或代码块时，其他线程只能等待当前操作结束才可以访问。<br>这听上去似乎存在一定的性能问题，但 <code>java 1.6</code> 以后 <code>synchronized</code> 在并发环境下性能得到了大幅提升，因此建议尽可能的使用<code>synchronized</code>，除非 <code>synchronized</code> 满足不了业务需求。<br>而且 <code>synchronized</code> 使用时无需释放锁，而且 <code>JVM</code> 还提供了专门的优化支持，因此即使 <code>synchronized</code> 是古老的锁，但是它依然适用于绝大多数场景。</p></li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p><code>volatile</code> 用来修饰变量保证其可见性。可见性是一种复杂的属性，<code>volatile</code> 变量不会被缓存在寄存器或者其他处理器不可见的地方，在读取<code>volatile</code> 变量时返回的一定是最新写入的值。<br><code>volatile</code> <strong>不是线程安全的</strong>，不能替代锁，它只在特定的场景下使用，使用时要非常小心。</p><p>以下场景可以使用 <code>volatile</code>：</p><ul><li><p>第一，对变量的写入不依赖于变量当前的值，或者你能确保只有单个线程更新变量的值；</p></li><li><p>第二，该变量不会与其它状态变量一起纳入不变性条件中；</p></li><li><p>第三，在访问变量时不需要加锁。</p></li></ul><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>在 <code>Java</code> 中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗 <code>CPU</code>。</p><p>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p><p>自旋锁尽可能的减少线程的阻塞，适用于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗</p><p>但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 <code>cpu</code> 做无用功，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要<code>cpu</code> 的线程又不能获取到 <code>cpu</code> ，造成 <code>cpu</code> 的浪费。</p><h2 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h2><p>分段锁是一种锁的设计，并不是具体的一种锁，对于 <code>ConcurrentHashMap</code> 而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</p><p>以 <code>ConcurrentHashMap</code> 来说一下分段锁的含义以及设计思想，<code>ConcurrentHashMap</code> 中的分段锁称为 <code>Segment</code>，它即类似于<code>HashMap</code>（ <code>JDK7</code> 与 <code>JDK8</code> 中 <code>HashMap</code> 的实现）的结构，即内部拥有一个 <code>Entry</code> 数组，数组中的每个元素又是一个链表；同时又是一个 <code>ReentrantLock</code>（ <code>Segment</code> 继承了 <code>ReentrantLock</code>)。</p><p>当需要 <code>put</code> 元素的时候，并不是对整个 <code>hashmap</code> 进行加锁，而是先通过 <code>hashcode</code> 来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程 <code>put</code> 的时候，只要不是放在一个分段中，就实现了真正的并行的插入。<br>但是，在统计 <code>size</code> 的时候，可就是获取 <code>hashmap</code> 全局信息的时候，就需要获取所有的分段锁才能统计。</p><p>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</p><h2 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁/悲观锁"></a>乐观锁/悲观锁</h2><p>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。</p><p>悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。<br>因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。</p><p>乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。<br>在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。</p><p>从上面的描述可以看出，<strong>悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景</strong>，不加锁会带来大量的性能提升。</p><p>悲观锁在 <code>Java</code> 中的使用，就是利用各种锁。<br>乐观锁在 <code>Java</code> 中的使用，是无锁编程，常常采用的是 <code>CAS</code> 算法，典型的例子就是原子类，通过 <code>CAS</code> 自旋实现原子操作的更新。</p><p>重量级锁是悲观锁的一种，自旋锁、轻量级锁与偏向锁属于乐观锁。</p><p><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/10/15/a5ef69b0-ef25-11e9-9152-99732114d9f7.png" srcset="/img/loading.gif" alt="Java锁机制.png"></p><p>参考博客：<br><a href="https://blog.csdn.net/qq_41181619/article/details/81407289" target="_blank" rel="noopener">浅谈Java锁机制</a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java锁机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9月面试总结</title>
    <link href="/passages/201909Interview-summary/"/>
    <url>/passages/201909Interview-summary/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>面试的问题都记录在下面，以及问题的一些解答。</p><h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><p><strong>谈谈你对 <code>HashMap</code> 的理解</strong></p><ul><li><p><code>HashMap</code> 是以数组+链表的方式存储的;</p></li><li><p><code>HashMap</code> 存储的是键值对映射，即 <code>key-value</code>;</p></li><li><p><code>HashMap</code> 可以接受 <code>null</code> 键和 <code>null</code> 值;</p></li><li><p><code>HashMap</code> 的键如果出现冲突，会以链表的方式链接到后面;</p></li><li><p><code>HashMap</code> 的链表会一直增长，在 <code>JDK 1.8</code> 中，当链表的长度大于 <code>8</code> 时，将使用红黑树代替。</p></li></ul><p><strong><code>JVM</code> 有哪些数据区</strong></p><ul><li>主要有五个区域: 堆、方法区、虚拟机栈、本地方法栈、程序计数器</li></ul><p><strong>说说<code>JVM</code> 运行过程</strong></p><ul><li><p>向操作系统申请空闲内存。系统查找内存分配表，然后把内存段的起始地址和终止地址给<code>JVM</code>，<code>JVM</code>准备加载类文件。</p></li><li><p>给堆、栈分配内存。</p></li><li><p>文件检查和分析 <code>class</code> 文件。</p></li><li><p>加载类。（类加载机制，如双亲委派机制）</p></li><li><p>执行方法。</p></li><li><p>释放内存。</p></li></ul><p><strong><code>Java</code> 中的锁机制有哪些</strong></p><p>常见的锁有 <code>synchronized</code>、<code>volatile</code> 等</p><blockquote><p><code>synchronized</code></p></blockquote><ul><li><p>当使用 <code>synchronized</code> 修饰类普通方法时，那么当前加锁的级别就是实例对象，当多个线程并发访问该对象的同步方法、同步代码块时，会进行同步。</p></li><li><p>当使用 <code>synchronized</code> 修饰类静态方法时，那么当前加锁的级别就是类，当多个线程并发访问该类（所有实例对象）的同步方法以及同步代码块时，会进行同步。</p></li><li><p>当使用 <code>synchronized</code> 修饰代码块时，那么当前加锁的级别就是 <code>synchronized(X)</code> 中配置的 <code>x</code> 对象实例，当多个线程并发访问该对象的同步方法、同步代码块以及当前的代码块时，会进行同步。</p></li><li><p>使用同步代码块时要注意的是不要使用 <code>String</code> 类型对象，因为 <code>String</code> 常量池的存在，所以很容易导致出问题。</p></li></ul><blockquote><p><code>volatile</code></p></blockquote><ul><li><code>volatile</code> 可以看做是一种 <code>synchronized</code> 的轻量级锁，它能够保证并发时，被它修饰的共享变量的可见性，从 <code>jmm</code> 的角度来看一下，每个线程拥有自己的工作内存，实际上线程所修改的共享变量是从主内存中拷贝的副本，当一个共享变量被 <code>volatile</code> 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</li></ul><p><strong>说说你知道的设计模式</strong></p><p>常用的设计模式有单例模式、工厂模式、代理模式、观察者模式、装饰模式、享元模式等</p><blockquote><p>单例模式</p></blockquote><ul><li><p>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p></li><li><p>实现方式通常有两种，分别是 <strong>饿汉式单例模式</strong> 和 <strong>懒汉式单例模式</strong></p></li></ul><blockquote><p>工厂模式</p></blockquote><ul><li><p>为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。</p></li><li><p>一个调用者想创建一个对象，只要知道其名称就可以了。 </p></li><li><p>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 </p></li><li><p>屏蔽产品的具体实现，调用者只关心产品的接口。</p></li></ul><blockquote><p>代理模式</p></blockquote><ul><li><p>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是生活中常见的中介。</p></li><li><p>代理模式主要有两个作用：中介隔离，开闭原则</p></li><li><p>主要有两种代理模式，分别是静态代理和动态代理</p></li></ul><blockquote><p>观察者模式</p></blockquote><ul><li><p>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p></li><li><p>观察者模式是一个比较特殊的设计模式，它定义了触发机制，观察者只要订阅了被观察者，就可以第一时间得到被观察者传递的信息。</p></li><li><p>在工作中，使用观察者模式的场景也比较多，比如消息队列消费等等。</p></li></ul><blockquote><p>装饰模式</p></blockquote><ul><li>装饰模式在一些类与类之间有叠加效应（也就是给一个类增加附加功能）的场景中非常好用，它可以说是继承的替代品，有更好的扩展性，也比较灵活。在 <code>Java JDK</code> 源码中也大面积用到了装饰模式，比如：<code>java.io.BufferedInputStream(InputStream)</code>。</li></ul><blockquote><p>享元模式</p></blockquote><ul><li>享元模式合理提高了对象的复用性，减少了程序的内存占用，还有一个提高性能的地方就是减少了对象创建的过程。</li></ul><h2 id="Spring-框架"><a href="#Spring-框架" class="headerlink" title="Spring 框架"></a>Spring 框架</h2><p><strong><code>Spring</code> 的 <code>IOC</code> 理解</strong></p><ul><li><p><code>IOC</code> 就是控制反转，是指创建对象的控制权的转移，以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到 <code>Spring</code> 容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。<code>DI</code> 依赖注入，和控制反转是同一个概念的不同角度的描述，即应用程序在运行时依赖 <code>IoC</code> 容器来动态注入对象需要的外部资源。</p></li><li><p>最直观的表达就是，<code>IOC</code> 让对象的创建不用去 <code>new</code> 了，可以由 <code>spring</code> 自动生产，使用 <code>java</code> 的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。</p></li></ul><p><strong><code>Spring</code> 的 <code>AOP</code> 理解</strong></p><ul><li><p>一般称为面向切面，作为面向对象的一种补充，<strong>用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块</strong>，这个模块被命名为“切面”（ <code>Aspect</code> ），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。</p></li><li><p><code>AOP</code> 实现的关键在于代理模式，<code>AOP</code>代理主要分为静态代理和动态代理。静态代理与动态代理区别在于生成 <code>AOP</code> 代理对象的时机不同。</p></li><li><p><code>AOP</code> 中的动态代理主要有两种方式，<code>JDK</code>动态代理和<code>CGLIB</code>动态代理</p></li></ul><p><strong><code>Spring</code> 框架中都用到了哪些设计模式？</strong></p><ul><li><p>工厂模式：<code>BeanFactory</code> 就是简单工厂模式的体现，用来创建对象的实例；</p></li><li><p>单例模式：<code>Bean</code> 默认为单例模式；</p></li><li><p>代理模式：<code>Spring</code> 的 <code>AOP</code> 功能用到了 <code>JDK</code> 的动态代理和 <code>CGLIB</code> 字节码生成技术；</p></li><li><p>模板方法：用来解决代码重复的问题。比如 <code>RestTemplate</code>, <code>JmsTemplate</code>, <code>JpaTemplate</code>。</p></li><li><p>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</p></li></ul><p><strong><code>Spring</code> 事务的实现方式和实现原理</strong></p><ul><li><p><code>Spring</code> 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，<code>spring</code> 是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过 <code>bin log</code> 或者 <code>redo log</code> 实现的。</p></li><li><p><code>Spring</code> 支持编程式事务管理和声明式事务管理两种方式：编程式事务管理使用 <code>TransactionTemplate</code> ；声明式事务管理建立在 <code>AOP</code> 之上的。其本质是通过 <code>AOP</code> 功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p></li></ul><h2 id="Spring-Boot-框架"><a href="#Spring-Boot-框架" class="headerlink" title="Spring Boot 框架"></a>Spring Boot 框架</h2><p><strong>为什么要用 <code>Spring Boot</code>？</strong></p><ul><li>Spring Boot 可以做到独立运行、简化配置、自动配置、无代码生成和 <code>XML</code> 配置、应用监控、上手容易等优点。</li></ul><h2 id="Mybatis-框架"><a href="#Mybatis-框架" class="headerlink" title="Mybatis 框架"></a>Mybatis 框架</h2><p><strong><code>#{}</code> 和 <code>${}</code> 的区别是什么？</strong></p><ul><li><p><code>#{}</code> 是预编译处理，<code>${}</code> 是字符串替换。</p></li><li><p><code>Mybatis</code> 在处理 <code>#{}</code> 时，会将 <code>sql</code> 中的 <code>#{}</code> 替换为 <code>?</code> 号，调用 <code>PreparedStatement</code> 的 <code>set</code> 方法来赋值；</p></li><li><p><code>Mybatis</code> 在处理 <code>${}</code> 时，就是把 <code>${}</code> 替换成变量的值。</p></li><li><p>使用 <code>#{}</code> 可以有效的防止 <code>SQL</code> 注入，提高系统安全性。</p></li></ul><p><strong><code>Mybatis</code> 的常用标签有哪些？</strong></p><ul><li>常用的有 <code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>、<code>&lt;resultMap&gt;</code></li></ul><p><strong>通常一个 <code>Xml</code> 映射文件，都会写一个 <code>Dao</code> 接口与之对应，请问，这个 <code>Dao</code> 接口的工作原理是什么？<code>Dao</code> 接口里的方法，参数不同时，方法能重载吗？</strong></p><ul><li><p>接口的全名，就是映射文件中的 <code>namespace</code> 的值；</p></li><li><p>接口的方法名，就是映射文件中 <code>Mapper</code> 的 <code>Statement</code> 的 <code>id</code> 值；</p></li><li><p>接口方法内的参数，就是传递给 <code>sql</code> 的参数。</p></li><li><p><code>Mapper</code>接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 <code>key</code> 值，可唯一定位一个 <code>MapperStatement</code>。在 <code>Mybatis</code> 中，每一个 <code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code> 标签，都会被解析为一个 <code>MapperStatement</code> 对象。</p></li><li><p><code>Mapper</code> 接口里的方法，是不能重载的，因为是使用<strong>全限名+方法名</strong>的保存和寻找策略；</p></li><li><p><code>Mapper</code> 接口的工作原理是 <code>JDK</code> 动态代理，<code>Mybatis</code>运行时会使用 <code>JDK</code> 动态代理为 <code>Mapper</code> 接口生成代理对象 <code>proxy</code>，代理对象会拦截接口方法，转而执行<code>MapperStatement</code>所代表的<code>sql</code>，然后将<code>sql</code>执行结果返回。</p></li></ul><p><strong><code>Mybatis</code> 是如何将 <code>sql</code> 执行结果封装为目标对象并返回的？都有哪些映射形式？</strong></p><ul><li><p>第一种是使用 <code>&lt;resultMap&gt;</code> 标签，逐一定义数据库列名和对象属性名之间的映射关系。</p></li><li><p>第二种是使用 <code>sql</code> 列的别名功能，将列的别名书写为对象属性名。</p></li><li><p>有了列名与属性名的映射关系后，<code>Mybatis</code> 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p></li></ul><p><strong>如何获取自动生成的(主)键值?</strong></p><ul><li>可以在 <code>&lt;insert&gt;</code> 内加上 <code>usegeneratedkeys=”true” keyproperty=”id”(假设主键名称为id)</code></li></ul><p><strong><code>Mybatis</code>一对一、一对多的关联查询是用什么标签实现的？</strong></p><ul><li>主要是通过 <code>&lt;association&gt;</code>, <code>&lt;collection&gt;</code> 来实现的</li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><strong><code>Redis</code> 支持哪些数据类型？</strong></p><ul><li>支持的有 <code>String</code>, <code>Hash</code>, <code>List</code>, <code>Set</code>, <code>zset</code>, 压缩列表等</li></ul><p><strong>什么是 <code>Redis</code> 持久化？<code>Redis</code>有哪几种持久化方式？优缺点是什么？</strong></p><ul><li><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p></li><li><p><code>Redis</code> 提供了两种持久化方式: <code>RDB</code>（默认）和 <code>AOF</code></p></li><li><p><code>RDB</code> 持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是 <code>fork</code> 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p></li><li><p><code>RDB</code> 持久化会清除原有的存储结构，只将数据存储到磁盘中。当需要从磁盘还原数据到内存的时候，再重新将数据组织成原来的数据结构。</p></li><li><p><code>AOF</code> 持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</p></li><li><p><code>AOF</code> 持久化会保留原来的存储格式，将数据按照原有的格式存储在磁盘中。拿散列表这样的数据结构来举例。可以将散列表的大小、每个数据被散列到的槽的编号等信息，都保存在磁盘中。有了这些信息，从磁盘中将数据还原到内存中的时候，就可以避免重新计算哈希值。</p></li><li><p><code>AOF</code>文件比<code>RDB</code>更新频率高，优先使用<code>AOF</code>还原数据。</p></li><li><p><code>AOF</code>比<code>RDB</code>更安全也更大</p></li><li><p><code>RDB</code>性能比<code>AOF</code>好</p></li><li><p>如果两个都配了优先加载<code>AOF</code></p></li></ul><p><strong>什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？</strong></p><ul><li><p>一般的缓存系统，都是按照 <code>key</code> 去缓存查询，如果不存在对应的 <code>value</code>，就应该去后端系统查找（比如<code>DB</code>）。一些恶意的请求会故意查询不存在的 <code>key</code>,请求量很大，就会对后端系统造成很大的压力。这就叫做<strong>缓存穿透</strong>。</p></li><li><p>避免的方法：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该 <code>key</code> 对应的数据 <code>insert</code> 了之后清理缓存。对一定不存在的 <code>key</code> 进行过滤；可以把所有的可能存在的 <code>key</code>放到一个大的<code>Bitmap</code>中，查询时通过该<code>Bitmap</code>过滤。</p></li><li><p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。这就叫做<strong>缓存雪崩</strong>。</p></li><li><p>避免的方法：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 <code>key</code> 只允许一个线程查询数据和写缓存，其他线程等待；做二级缓存，<code>A1</code>为原始缓存，<code>A2</code>为拷贝缓存，<code>A1</code>失效时，可以访问<code>A2</code>，<code>A1</code>缓存失效时间设置为短期，<code>A2</code>设置为长期；不同的 <code>key</code>，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p></li></ul><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p><strong>数据库事务的四个特性</strong></p><ul><li><p><code>ACID</code></p></li><li><p>原子性(<code>Atomicity</code>)：指的是事务中所有操作，要么全做，要么全不做。事务在执行过程中如果出现差错会全部回滚到最初的状态</p></li><li><p>一致性(<code>Correspondence</code>)：在事务开始之前以及结束之后，数据库的完整性约束不会被破坏</p></li><li><p>隔离性(<code>Isolation</code>)：隔离状态下执行事务，使他们好像是系统在给定时间内执行的唯一操作</p></li><li><p>持久性(<code>Durability</code>)：在事务完成后，该事务对数据库所做的操作都会全部持久的保存在数据库中，不会被回滚</p></li></ul><p><strong><code>MySQL</code>中 <code>MyISAM</code> 与 <code>InnoDB</code> 的区别</strong></p><ul><li><p><code>InnoDB</code>支持事务，而<code>MyISAM</code>不支持事务</p></li><li><p><code>InnoDB</code>支持行级锁，而<code>MyISAM</code>支持表级锁</p></li><li><p><code>InnoDB</code>支持<code>MVCC</code>, 而<code>MyISAM</code>不支持</p></li><li><p><code>InnoDB</code>支持外键，而<code>MyISAM</code>不支持</p></li><li><p><code>InnoDB</code>不支持全文索引，而<code>MyISAM</code>支持。</p></li><li><p><code>InnoDB</code>不能通过直接拷贝表文件的方法拷贝表到另外一台机器，<code>MyISAM</code> 支持</p></li><li><p><code>InnoDB</code>表支持多种行格式，<code>MyISAM</code>不支持</p></li><li><p><code>InnoDB</code>是索引组织表，<code>MyISAM</code> 是堆表</p></li></ul><p><strong><code>InnoDB</code>引擎的4大特性</strong></p><ul><li><p>插入缓冲（<code>insert buffer</code>)</p></li><li><p>二次写(<code>double write</code>)</p></li><li><p>自适应哈希索引(<code>ahi</code>)</p></li><li><p>预读(<code>read ahead</code>)</p></li></ul><p><strong><code>MyISAM</code> 与 <code>InnoDB</code>两者<code>select count(*)</code>哪个更快，为什么</strong></p><ul><li><code>MyISAM</code>更快，因为<code>MyISAM</code>内部维护了一个计数器，可以直接调取</li></ul><p><strong><code>InnoDB</code>的事务与日志的存放形式</strong></p><ul><li><p><code>redo</code>：在页修改的时候，先写到 <code>redo log buffer</code> 里面，然后写到 <code>redo log</code> 的文件系统缓存里面(<code>fwrite</code>)，然后再同步到磁盘文件（<code>fsync</code>）</p></li><li><p><code>undo</code>：在 <code>MySQL5.5</code> 之前，<code>undo</code> 只能存放在 <code>ibdata*</code> 文件里面，<code>5.6</code> 之后，可以通过设置 <code>innodb_undo_tablespaces</code> 参数把 <code>undo log</code> 存放在 <code>ibdata*</code> 之外</p></li></ul><p><strong><code>InnoDB</code>的事务是如何通过日志来实现的</strong></p><ul><li><p>事务在修改页时，要先记 <code>undo</code>，在记 <code>undo</code> 之前要记 <code>undo</code> 的 <code>redo</code>，然后修改数据页，再记数据页修改的 <code>redo</code>。</p></li><li><p><code>redo</code>（里面包括 <code>undo</code> 的修改） 一定要比数据页先持久化到磁盘。</p></li><li><p>当事务需要回滚时，因为有 <code>undo</code>，可以把数据页回滚到前镜像的状态，崩溃恢复时，如果 <code>redo log</code> 中事务没有对应的 <code>commit</code> 记录，那么需要用 <code>undo</code> 把该事务的修改回滚到事务开始之前。</p></li><li><p>如果有 <code>commit</code> 记录，就用 <code>redo</code> 前滚到该事务完成时并提交掉。</p></li></ul><p><strong><code>explain</code> 中的索引问题</strong></p><ul><li><p><code>explain</code> 结果中，一般来说，要看到尽量用 <code>index</code>(<code>type</code> 为 <code>const</code>、<code>ref</code> 等，<code>key</code> 列有值)，避免使用全表扫描(<code>type</code> 显式为 <code>ALL</code>)。</p></li><li><p>比如说有 <code>where</code> 条件且选择性不错的列，需要建立索引。</p></li><li><p>被驱动表的连接列，也需要建立索引。被驱动表的连接列也可能会跟 <code>where</code> 条件列一起建立联合索引。</p></li><li><p>当有排序或者 <code>group by</code> 的需求时，也可以考虑建立索引来达到直接排序和汇总的需求。</p></li></ul><p><strong><code>MySQL</code>中<code>InnoDB</code>引擎的行锁是通过加在什么上完成(或称实现)的？</strong></p><ul><li><p><code>InnoDB</code>是基于索引来完成行锁</p></li><li><p>例如，<code>select * from tab_with_index where id = 1 for update;</code><br><code>for update</code> 可以根据条件来完成行锁锁定,并且 <code>id</code> 是有索引键的列, 如果 <code>id</code> 不是索引键那么<code>InnoDB</code>将加上表锁</p></li></ul><p><strong>描述下 <code>MySQL</code> 中 <code>InnoDB</code> 支持的四种事务隔离级别名称，以及逐级之间的区别？</strong></p><ul><li><p>读未提交(<code>read uncommitted</code>)<br>读已提交(<code>read committed</code>)<br>可重复读(<code>repeatable read</code>)<br>串行(<code>serializable</code>)</p></li><li><p><code>Read Uncommitted</code>:可以读取其他 <code>session</code> 未提交的脏数据。<br><code>Read Committed</code>:允许不可重复读取，但不允许脏读取。提交后，其他会话可以看到提交的数据。<br><code>Repeatable Read</code>: 禁止不可重复读取和脏读取、以及幻读(<code>innodb</code> 独有)。<br><code>Serializable</code>: 事务只能一个接着一个地执行，但不能并发执行。事务隔离级别最高。<br>不同的隔离级别有不同的现象，并有不同的锁定/并发机制，隔离级别越高，数据库的并发性就越差。</p></li></ul><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p><strong>为什么要使用 <code>kafka</code>，为什么要使用消息队列</strong></p><ul><li><p>缓冲和削峰：上游数据时有突发流量，下游可能扛不住，或者下游没有足够多的机器来保证冗余，<code>kafka</code> 在中间可以起到一个缓冲的作用，把消息暂存在 <code>kafka</code> 中，下游服务就可以按照自己的节奏进行慢慢处理。</p></li><li><p>解耦和扩展性：项目开始的时候，并不能确定具体需求。消息队列可以作为一个接口层，解耦重要的业务流程。只需要遵守约定，针对数据编程即可获取扩展能力。</p></li><li><p>冗余：可以采用一对多的方式，一个生产者发布消息，可以被多个订阅<code>topic</code>的服务消费到，供多个毫无关联的业务使用。</p></li><li><p>健壮性：消息队列可以堆积请求，所以消费端业务即使短时间死掉，也不会影响主要业务的正常进行。</p></li><li><p>异步通信：很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p></li></ul><p><strong><code>Kafka</code>中的 <code>broker</code> 是干什么的</strong></p><ul><li><code>broker</code> 是消息的代理，<code>Producers</code> 往 <code>Brokers</code> 里面的指定 <code>Topic</code> 中写消息，<code>Consumers</code> 从 <code>Brokers</code> 里面拉取指定 <code>Topic</code> 的消息，然后进行业务处理，<code>broker</code> 在中间起到一个代理保存消息的中转站。</li></ul><p><strong>Kafka中是怎么体现消息顺序性的？</strong></p><ul><li><code>kafka</code>每个 <code>partition</code> 中的消息在写入时都是有序的，消费时，每个<code>partition</code>只能被每一个<code>group</code>中的一个消费者消费，保证了消费时也是有序的。整个<code>topic</code>不保证有序。如果为了保证<code>topic</code>整个有序，那么将<code>partition</code>调整为<code>1</code>.</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LEETCODE：数组（一）</title>
    <link href="/passages/leetcode-day190911/"/>
    <url>/passages/leetcode-day190911/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>数组是最常见最基础的数据结构了，由于它在内存中是顺序存储的，因此按下标查询的效率很高。</p><p>下面是一些我刷的数组题目的一些思路和代码。</p><h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">盛最多水的容器</a></h2><p><strong>思路</strong><br>首先想到了可以利用暴力法直接遍历出所有的容器大小，时间复杂度为$O(n^2)$</p><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;    <span class="hljs-keyword">if</span> (height.length == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> maxArea = Integer.MIN_VALUE;    <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> tail;    <span class="hljs-keyword">while</span> (head &lt; height.length - <span class="hljs-number">1</span>) &#123;        tail = height.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (tail &gt; head) &#123;            <span class="hljs-keyword">int</span> minSide = Math.min(height[head], height[tail]);            maxArea = Math.max(maxArea, (tail - head) * minSide);            tail --;        &#125;        head ++;    &#125;    <span class="hljs-keyword">return</span> maxArea;&#125;</code></pre><p>提交结果<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/11/a5e84780-d47b-11e9-8ff2-7340a5031e46.png" srcset="/img/loading.gif" alt="image.png"><br>时间复杂度过于高了，该怎么优化下呢？</p><p>最初我们考虑由最外围两条线段构成的区域。现在，为了使面积最大化，我们需要考虑更长的两条线段之间的区域。如果我们试图将指向较长线段的指针向内侧移动，矩形区域的面积将受限于较短的线段而不会获得任何增加。但是，在同样的条件下，移动指向较短线段的指针尽管造成了矩形宽度的减小，但却可能会有助于面积的增大。因为移动较短线段的指针会得到一条相对较长的线段，这可以克服由宽度减小而引起的面积减小。</p><p>优化后的代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;    <span class="hljs-keyword">if</span> (height.length == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> maxArea = Integer.MIN_VALUE;    <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> tail = height.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (head &lt; height.length - <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">int</span> minSide = Math.min(height[head], height[tail]);        maxArea = Math.max(maxArea, (tail - head) * minSide);        <span class="hljs-keyword">if</span> (height[head] &gt; height[tail]) &#123;            tail --;        &#125; <span class="hljs-keyword">else</span> &#123;            head ++;        &#125;    &#125;    <span class="hljs-keyword">return</span> maxArea;&#125;</code></pre><p>提交结果<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/11/5d7a08b0-d47d-11e9-8ff2-7340a5031e46.png" srcset="/img/loading.gif" alt="image.png"><br>瞬间快了好多，美滋滋😎</p><h2 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/submissions/" target="_blank" rel="noopener">最接近的三数之和</a></h2><p><strong>思路</strong><br>由于要计算三个数的和，如果用暴力法，会用$O(n^3)$的时间复杂度，对于这道题目会太慢了，那应该如何降低时间复杂度呢？<br>首先可以对数组进行排序，快速排序的时间复杂度是$O(nlogn)$，这个对速度的影响不是很大。<br>遍历<code>nums</code>数组，在使用双指针，第一个指针指向 <code>l = i + 1</code> 处，第二个指针指向末尾处，即 <code>r = nums.length - 1</code>处<br>再根据当前三个数字的和 <code>thisSum = nums[l] + nums[r] + nums[i]</code> 的结果，判断与目标 <code>target</code> 的距离，更新当前最近距离。<br>然后判断 <code>thisSum</code> 与 <code>target</code> 的大小关系，由于数组已经是有序的，若 <code>thisSum &gt; target</code> 则 <code>r--</code>，若 <code>thisSum &lt; target</code> 则 <code>l++</code>，否则说明已经找到 <code>target</code> ，直接返回结果即可<br>整个遍历过程的时间复杂度是$O(n^2)$，则总时间复杂度为 $O(nlogn) + O(n^2) = O(n^2)$</p><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;    <span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">3</span>) &#123;        <span class="hljs-keyword">return</span> target;    &#125;    Arrays.sort(nums);    <span class="hljs-keyword">int</span> closetNum = nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;        <span class="hljs-keyword">int</span> l = i + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> r = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (l &lt; r) &#123;            <span class="hljs-keyword">int</span> thisSum = nums[l] + nums[r] + nums[i];            <span class="hljs-keyword">if</span> (Math.abs(thisSum - target) &lt; Math.abs(closetNum - target)) &#123;                closetNum = thisSum;            &#125;            <span class="hljs-keyword">if</span> (thisSum &gt; target) &#123;                r--;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (thisSum &lt; target) &#123;                l++;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> thisSum;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> closetNum;&#125;</code></pre><p>提交结果<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/12/d71d14a0-d509-11e9-98af-f301859595e1.png" srcset="/img/loading.gif" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>LEETCODE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题：贪心、分治、回溯和动态规划</title>
    <link href="/passages/leetcode-greedy-partition-backtracking-dynamic/"/>
    <url>/passages/leetcode-greedy-partition-backtracking-dynamic/</url>
    
    <content type="html"><![CDATA[<!-- more --><h2 id="几种算法思想必知必会的代码实现"><a href="#几种算法思想必知必会的代码实现" class="headerlink" title="几种算法思想必知必会的代码实现"></a>几种算法思想必知必会的代码实现</h2><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><ul><li><p>利用回溯算法求解八皇后问题</p></li><li><p>利用回溯算法求解 <code>0-1</code> 背包问题</p></li></ul><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><ul><li>利用分治算法求一组数据的逆序对个数</li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ul><li><p><code>0-1</code> 背包问题</p></li><li><p>最小路径和</p></li><li><p>编程实现莱文斯坦最短编辑距离</p></li><li><p>编程实现查找两个字符串的最长公共子序列</p></li><li><p>编程实现一个数据序列的最长递增子序列</p></li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="Regular-Expression-Matching（正则表达式匹配）"><a href="#Regular-Expression-Matching（正则表达式匹配）" class="headerlink" title="Regular Expression Matching（正则表达式匹配）"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">Regular Expression Matching（正则表达式匹配）</a></h3><p>思路</p><blockquote><p>不容易想到，直接看<a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-by-leetcode/" target="_blank" rel="noopener">官方题解</a></p></blockquote><p>代码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String text, String pattern)</span> </span>&#123;    <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[text.length() + <span class="hljs-number">1</span>][pattern.length() + <span class="hljs-number">1</span>];    dp[text.length()][pattern.length()] = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = text.length(); i &gt;= <span class="hljs-number">0</span>; i--)&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = pattern.length() - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;            <span class="hljs-keyword">boolean</span> first_match = (i &lt; text.length() &amp;&amp; (pattern.charAt(j) == text.charAt(i) || pattern.charAt(j) == <span class="hljs-string">'.'</span>));            <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; pattern.length() &amp;&amp; pattern.charAt(j+<span class="hljs-number">1</span>) == <span class="hljs-string">'*'</span>)&#123;                dp[i][j] = dp[i][j+<span class="hljs-number">2</span>] || first_match &amp;&amp; dp[i+<span class="hljs-number">1</span>][j];            &#125; <span class="hljs-keyword">else</span> &#123;                dp[i][j] = first_match &amp;&amp; dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>];            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];&#125;</code></pre><h3 id="Minimum-Path-Sum（最小路径和）"><a href="#Minimum-Path-Sum（最小路径和）" class="headerlink" title="Minimum Path Sum（最小路径和）"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">Minimum Path Sum（最小路径和）</a></h3><p>思路</p><blockquote><p>动态规划问题，往左往下选择最小即可</p></blockquote><p>代码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;    <span class="hljs-keyword">int</span> m = grid.length, n = grid[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;                dp[j] = j == <span class="hljs-number">0</span>? grid[i][j] : grid[i][j] + dp[j - <span class="hljs-number">1</span>];            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;                dp[j] = grid[i][j] + dp[j];            &#125; <span class="hljs-keyword">else</span> &#123;                dp[j] = grid[i][j] + Math.min(dp[j], dp[j - <span class="hljs-number">1</span>]);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];&#125;</code></pre><h3 id="Coin-Change（零钱兑换）"><a href="#Coin-Change（零钱兑换）" class="headerlink" title="Coin Change（零钱兑换）"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">Coin Change（零钱兑换）</a></h3><p>思路</p><blockquote><p>找出动态转移方程 <code>dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1)</code>，具体可参考<a href="https://leetcode-cn.com/problems/coin-change/solution/ling-qian-dui-huan-by-leetcode/" target="_blank" rel="noopener">官方题解</a></p></blockquote><p>代码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;    <span class="hljs-keyword">int</span> max = amount + <span class="hljs-number">1</span>;                 <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];      Arrays.fill(dp, max);      dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= amount; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; coins.length; j++) &#123;            <span class="hljs-keyword">if</span> (coins[j] &lt;= i) &#123;                dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="hljs-number">1</span>);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[amount] &gt; amount ? -<span class="hljs-number">1</span> : dp[amount];&#125;</code></pre><h3 id="Best-Time-to-Buy-and-Sell-Stock（买卖股票的最佳时机）"><a href="#Best-Time-to-Buy-and-Sell-Stock（买卖股票的最佳时机）" class="headerlink" title="Best Time to Buy and Sell Stock（买卖股票的最佳时机）"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock（买卖股票的最佳时机）</a></h3><p>思路</p><blockquote><p>由于只能交易一次，则从前到后找出最小值，并计算最大利润</p></blockquote><p>代码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-keyword">if</span> (prices.length == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> maxProfit = <span class="hljs-number">0</span>, minValue = prices[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; i++)&#123;        <span class="hljs-keyword">if</span> (minValue &gt; prices[i])            minValue = prices[i];        <span class="hljs-keyword">else</span>            maxProfit = Math.max(maxProfit, prices[i] - minValue);    &#125;    <span class="hljs-keyword">return</span> maxProfit;&#125;</code></pre><h3 id="Maximum-Product-Subarray（乘积最大子序列）"><a href="#Maximum-Product-Subarray（乘积最大子序列）" class="headerlink" title="Maximum Product Subarray（乘积最大子序列）"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">Maximum Product Subarray（乘积最大子序列）</a></h3><p>思路</p><blockquote><ul><li>遍历数组时计算当前最大值，不断更新</li><li>令<code>imax</code>为当前最大值，则当前最大值为 <code>imax = max(imax * nums[i], nums[i])</code></li><li>由于存在负数，那么会导致最大的变最小的，最小的变最大的。因此还需要维护当前最小值<code>imin</code>，<code>imin = min(imin * nums[i], nums[i])</code></li><li>当负数出现时则<code>imax</code>与<code>imin</code>进行交换再进行下一步计算</li><li>参考<a href="https://leetcode-cn.com/problems/maximum-product-subarray/solution/hua-jie-suan-fa-152-cheng-ji-zui-da-zi-xu-lie-by-g/" target="_blank" rel="noopener">链接</a></li></ul></blockquote><p>代码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE, imax = <span class="hljs-number">1</span>, imin = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;nums.length; i++)&#123;        <span class="hljs-keyword">if</span>(nums[i] &lt; <span class="hljs-number">0</span>)&#123;           <span class="hljs-keyword">int</span> tmp = imax;          imax = imin;          imin = tmp;        &#125;        imax = Math.max(imax*nums[i], nums[i]);        imin = Math.min(imin*nums[i], nums[i]);                max = Math.max(max, imax);    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre><h3 id="Triangle（三角形最小路径和）"><a href="#Triangle（三角形最小路径和）" class="headerlink" title="Triangle（三角形最小路径和）"></a><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">Triangle（三角形最小路径和）</a></h3><p>思路</p><blockquote><p>动态规划，自底向上进行， <code>dp[j] = nums[i][j] + Math.min(dp[j], dp[j + 1])</code></p></blockquote><p>代码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;   <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[triangle.get(triangle.size() - <span class="hljs-number">1</span>).size() + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = triangle.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; triangle.get(i).size(); j++) &#123;            dp[j] = triangle.get(i).get(j) + Math.min(dp[j], dp[j + <span class="hljs-number">1</span>]);        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LEETCODE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>分治</tag>
      
      <tag>回溯</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题：图</title>
    <link href="/passages/leetcode-graph/"/>
    <url>/passages/leetcode-graph/</url>
    
    <content type="html"><![CDATA[<!-- more --><h2 id="关于图的几个必知必会的代码实现"><a href="#关于图的几个必知必会的代码实现" class="headerlink" title="关于图的几个必知必会的代码实现"></a>关于图的几个必知必会的代码实现</h2><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><ul><li><p>实现有向图、无向图、有权图、无权图的邻接矩阵和邻接表表示方法</p></li><li><p>实现图的深度优先搜索、广度优先搜索</p></li><li><p>实现 <code>Dijkstra</code> 算法、<code>A*</code> 算法</p></li><li><p>实现拓扑排序的 <code>Kahn</code> 算法、<code>DFS</code> 算法</p></li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="Number-of-Islands（岛屿的个数）"><a href="#Number-of-Islands（岛屿的个数）" class="headerlink" title="Number of Islands（岛屿的个数）"></a><a href="https://leetcode-cn.com/problems/number-of-islands/description/" target="_blank" rel="noopener">Number of Islands（岛屿的个数）</a></h3><p>思路</p><blockquote><p>想到了深度优先搜素，先遍历找到是 <code>1</code> 的，岛屿数量加 <code>1</code> ，然后递归的把周围的 <code>1</code> 都标记为已访问，代码如下</p></blockquote><p>代码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;    <span class="hljs-keyword">int</span> island = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; grid.length; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; grid[i].length; j++) &#123;            <span class="hljs-comment">//是陆地</span>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">'1'</span>) &#123;                marked(grid, i ,j);                island ++;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> island;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">marked</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= grid.length || j &lt; <span class="hljs-number">0</span> || j &gt;= grid[<span class="hljs-number">0</span>].length || grid[i][j] != <span class="hljs-string">'1'</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    grid[i][j] = <span class="hljs-string">'2'</span>;    <span class="hljs-comment">//分别往 上 下 左 右 递归</span>    marked(grid, i + <span class="hljs-number">1</span>, j);    marked(grid, i - <span class="hljs-number">1</span>, j);    marked(grid, i, j - <span class="hljs-number">1</span>);    marked(grid, i, j + <span class="hljs-number">1</span>);&#125;</code></pre><h3 id="Valid-Sudoku（有效的数独）"><a href="#Valid-Sudoku（有效的数独）" class="headerlink" title="Valid Sudoku（有效的数独）"></a><a href="https://leetcode-cn.com/problems/valid-sudoku/" target="_blank" rel="noopener">Valid Sudoku（有效的数独）</a></h3><p>思路</p><blockquote><p>暴力法解决问题</p></blockquote><p>代码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; board.length; i++) &#123;        <span class="hljs-keyword">int</span>[] numMapCol = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>];        <span class="hljs-keyword">int</span>[] numMapRow = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; board[i].length; j++) &#123;            <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">'.'</span>) &#123;                numMapRow[board[i][j] - <span class="hljs-string">'1'</span>]++;                <span class="hljs-keyword">if</span> (numMapRow[board[i][j] - <span class="hljs-string">'1'</span>] &gt; <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (board[j][i] != <span class="hljs-string">'.'</span>) &#123;                numMapCol[board[j][i] - <span class="hljs-string">'1'</span>]++;                <span class="hljs-keyword">if</span> (numMapCol[board[j][i] - <span class="hljs-string">'1'</span>] &gt; <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">9</span>; i += <span class="hljs-number">3</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">9</span>; j += <span class="hljs-number">3</span>) &#123;            <span class="hljs-keyword">int</span>[] numMapRow = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>];            <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">'.'</span>) &#123;                numMapRow[board[i][j] - <span class="hljs-string">'1'</span>]++;                <span class="hljs-keyword">if</span> (numMapRow[board[i][j] - <span class="hljs-string">'1'</span>] &gt; <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (board[i + <span class="hljs-number">1</span>][j] != <span class="hljs-string">'.'</span>) &#123;                numMapRow[board[i + <span class="hljs-number">1</span>][j] - <span class="hljs-string">'1'</span>]++;                <span class="hljs-keyword">if</span> (numMapRow[board[i + <span class="hljs-number">1</span>][j] - <span class="hljs-string">'1'</span>] &gt; <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (board[i - <span class="hljs-number">1</span>][j] != <span class="hljs-string">'.'</span>) &#123;                numMapRow[board[i - <span class="hljs-number">1</span>][j] - <span class="hljs-string">'1'</span>]++;                <span class="hljs-keyword">if</span> (numMapRow[board[i - <span class="hljs-number">1</span>][j] - <span class="hljs-string">'1'</span>] &gt; <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (board[i][j - <span class="hljs-number">1</span>] != <span class="hljs-string">'.'</span>) &#123;                numMapRow[board[i][j - <span class="hljs-number">1</span>] - <span class="hljs-string">'1'</span>]++;                <span class="hljs-keyword">if</span> (numMapRow[board[i][j - <span class="hljs-number">1</span>] - <span class="hljs-string">'1'</span>] &gt; <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (board[i][j + <span class="hljs-number">1</span>] != <span class="hljs-string">'.'</span>) &#123;                numMapRow[board[i][j + <span class="hljs-number">1</span>] - <span class="hljs-string">'1'</span>]++;                <span class="hljs-keyword">if</span> (numMapRow[board[i][j + <span class="hljs-number">1</span>] - <span class="hljs-string">'1'</span>] &gt; <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (board[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] != <span class="hljs-string">'.'</span>) &#123;                numMapRow[board[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] - <span class="hljs-string">'1'</span>]++;                <span class="hljs-keyword">if</span> (numMapRow[board[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] - <span class="hljs-string">'1'</span>] &gt; <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (board[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] != <span class="hljs-string">'.'</span>) &#123;                numMapRow[board[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] - <span class="hljs-string">'1'</span>]++;                <span class="hljs-keyword">if</span> (numMapRow[board[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] - <span class="hljs-string">'1'</span>] &gt; <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (board[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] != <span class="hljs-string">'.'</span>) &#123;                numMapRow[board[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] - <span class="hljs-string">'1'</span>]++;                <span class="hljs-keyword">if</span> (numMapRow[board[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] - <span class="hljs-string">'1'</span>] &gt; <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (board[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] != <span class="hljs-string">'.'</span>) &#123;                numMapRow[board[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] - <span class="hljs-string">'1'</span>]++;                <span class="hljs-keyword">if</span> (numMapRow[board[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] - <span class="hljs-string">'1'</span>] &gt; <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><p>优化后的代码如下</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;    <span class="hljs-comment">// 记录某行，某位数字是否已经被摆放</span>    <span class="hljs-keyword">boolean</span>[][] row = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];    <span class="hljs-comment">// 记录某列，某位数字是否已经被摆放</span>    <span class="hljs-keyword">boolean</span>[][] col = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];    <span class="hljs-comment">// 记录某 3x3 宫格内，某位数字是否已经被摆放</span>    <span class="hljs-keyword">boolean</span>[][] block = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;            <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">'.'</span>) &#123;                <span class="hljs-keyword">int</span> num = board[i][j] - <span class="hljs-string">'1'</span>;                <span class="hljs-keyword">int</span> blockIndex = i / <span class="hljs-number">3</span> * <span class="hljs-number">3</span> + j / <span class="hljs-number">3</span>;                <span class="hljs-keyword">if</span> (row[i][num] || col[j][num] || block[blockIndex][num]) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    row[i][num] = <span class="hljs-keyword">true</span>;                    col[j][num] = <span class="hljs-keyword">true</span>;                    block[blockIndex][num] = <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LEETCODE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题：二叉树和堆</title>
    <link href="/passages/leetcode-binarytree-heap/"/>
    <url>/passages/leetcode-binarytree-heap/</url>
    
    <content type="html"><![CDATA[<!-- more --><h2 id="关于二叉树和堆的-7-个必知必会的代码实现"><a href="#关于二叉树和堆的-7-个必知必会的代码实现" class="headerlink" title="关于二叉树和堆的 7 个必知必会的代码实现"></a>关于二叉树和堆的 7 个必知必会的代码实现</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul><li><p>实现一个二叉查找树，并且支持插入、删除、查找操作</p></li><li><p>实现查找二叉查找树中某个节点的后继、前驱节点</p></li><li><p>实现二叉树前、中、后序以及按层遍历</p></li></ul><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul><li><p>实现一个小顶堆、大顶堆、优先级队列</p></li><li><p>实现堆排序</p></li><li><p>利用优先级队列合并 <code>K</code> 个有序数组</p></li><li><p>求一组动态数据集合的最大 <code>Top K</code></p></li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="Invert-Binary-Tree（翻转二叉树）"><a href="#Invert-Binary-Tree（翻转二叉树）" class="headerlink" title="Invert Binary Tree（翻转二叉树）"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">Invert Binary Tree（翻转二叉树）</a></h3><p>思路</p><blockquote><p>后序遍历，交换左右结点即可</p></blockquote><p>代码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    invertTree(root.left);    invertTree(root.right);    TreeNode temp = root.left;    root.left = root.right;    root.right = temp;    <span class="hljs-keyword">return</span> root;&#125;</code></pre><h3 id="Maximum-Depth-of-Binary-Tree（二叉树的最大深度）"><a href="#Maximum-Depth-of-Binary-Tree（二叉树的最大深度）" class="headerlink" title="Maximum Depth of Binary Tree（二叉树的最大深度）"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">Maximum Depth of Binary Tree（二叉树的最大深度）</a></h3><p>思路</p><blockquote><p>深度优先遍历就可以得出树的深度</p></blockquote><p>代码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.max(maxDepth(root.left), maxDepth(root.right));    &#125; &#125;</code></pre><h3 id="Validate-Binary-Search-Tree（验证二叉查找树）"><a href="#Validate-Binary-Search-Tree（验证二叉查找树）" class="headerlink" title="Validate Binary Search Tree（验证二叉查找树）"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">Validate Binary Search Tree（验证二叉查找树）</a></h3><p>思路</p><blockquote><p>可以用递归法实现。首先将结点的值与上界和下界（如果有）比较。然后，对左子树和右子树递归进行该过程。</p></blockquote><p>代码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">return</span> help(root, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">help</span><span class="hljs-params">(TreeNode root, Integer lower, Integer upper)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">if</span> (lower != <span class="hljs-keyword">null</span> &amp;&amp; root.val &lt;= lower) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">if</span> (upper != <span class="hljs-keyword">null</span> &amp;&amp; root.val &gt;= upper) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">if</span> (!help(root.left, lower, root.val)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">if</span> (!help(root.right, root.val, upper)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><h3 id="Path-Sum（路径总和）"><a href="#Path-Sum（路径总和）" class="headerlink" title="Path Sum（路径总和）"></a><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">Path Sum（路径总和）</a></h3><p>思路</p><blockquote><p>如果当前节点不是叶子，对它的所有孩子节点，递归调用 <code>hasPathSum</code> 函数，其中 <code>sum</code> 值减去当前节点的权值；如果当前节点是叶子，检查 <code>sum</code> 值是否为 <code>0</code>，也就是是否找到了给定的目标和。</p></blockquote><p>代码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    sum -= root.val;    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> sum == <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">return</span> hasPathSum(root.left, sum) || hasPathSum(root.right, sum);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LEETCODE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题：散列表和字符串</title>
    <link href="/passages/leetcode-hashtable-string/"/>
    <url>/passages/leetcode-hashtable-string/</url>
    
    <content type="html"><![CDATA[<!-- more --><h2 id="关于散列表和字符串的-4-个必知必会的代码实现"><a href="#关于散列表和字符串的-4-个必知必会的代码实现" class="headerlink" title="关于散列表和字符串的 4 个必知必会的代码实现"></a>关于散列表和字符串的 4 个必知必会的代码实现</h2><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><ul><li><p>实现一个基于链表法解决冲突问题的散列表</p></li><li><p>实现一个 <code>LRU</code> 缓存淘汰算法</p></li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li><p>实现一个字符集，只包含 <code>a～z</code> 这 <code>26</code> 个英文字母的 <code>Trie</code> 树</p></li><li><p>实现朴素的字符串匹配算法</p></li></ul><h2 id="字符串题目"><a href="#字符串题目" class="headerlink" title="字符串题目"></a>字符串题目</h2><h3 id="Reverse-String-（反转字符串）"><a href="#Reverse-String-（反转字符串）" class="headerlink" title="Reverse String （反转字符串）"></a><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">Reverse String （反转字符串）</a></h3><p>思路 </p><blockquote><p>看到题目后首先想到的是双指针法，创建两个指针 <code>head</code> 和 <code>tail</code> 分别指向字符串头部和尾部，交换两个指针所指元素，然后 <code>head</code> 往后 <code>tail</code> 往前，直到两指针相遇。</p></blockquote><p>代码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] s)</span> </span>&#123;    <span class="hljs-keyword">if</span> (s.length == <span class="hljs-number">0</span> || s.length == <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> tail = s.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (head &lt; tail) &#123;        <span class="hljs-keyword">char</span> temp = s[head];        s[head] = s[tail];        s[tail] = temp;        head++;        tail--;    &#125;&#125;</code></pre><h3 id="Reverse-Words-in-a-String（翻转字符串里的单词）"><a href="#Reverse-Words-in-a-String（翻转字符串里的单词）" class="headerlink" title="Reverse Words in a String（翻转字符串里的单词）"></a><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">Reverse Words in a String（翻转字符串里的单词）</a></h3><p>思路</p><blockquote><p>从后往前遍历，遇到空格跳过，否则就记录下不是空格的位置，然后截取字串，放到临时字符串中</p></blockquote><p>代码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseWords</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> s;    &#125;    StringBuilder result = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = s.length() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>;) &#123;        <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">' '</span>) &#123;            i --;            <span class="hljs-keyword">continue</span>;        &#125;        end = i + <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> ((i &gt;= <span class="hljs-number">0</span>) &amp;&amp; s.charAt(i) != <span class="hljs-string">' '</span>) &#123;            i --;        &#125;        result.append(s, i + <span class="hljs-number">1</span>, end);        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;            result.append(<span class="hljs-string">" "</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> result.toString().trim();&#125;</code></pre><h3 id="String-to-Integer-atoi-（字符串转换整数-atoi-）"><a href="#String-to-Integer-atoi-（字符串转换整数-atoi-）" class="headerlink" title="String to Integer (atoi)（字符串转换整数 (atoi)）"></a><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">String to Integer (atoi)（字符串转换整数 (atoi)）</a></h3><p>思路</p><blockquote><p>题目说明上已经给出限制条件，但是还有很多条件没有给出，最后一步步提交踩着坑终于踩出来了。。。</p></blockquote><p>代码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(String str)</span> </span>&#123;    <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span> || <span class="hljs-string">""</span>.equals(str)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    StringBuilder resultS = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">boolean</span> isNegative = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">boolean</span> isPositive = <span class="hljs-keyword">false</span>;    String newStr = str.trim();    <span class="hljs-keyword">if</span> (<span class="hljs-string">""</span>.equals(newStr)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">if</span> ((newStr.charAt(<span class="hljs-number">0</span>) &lt; <span class="hljs-string">'0'</span>) || (newStr.charAt(<span class="hljs-number">0</span>) &gt; <span class="hljs-string">'9'</span>)) &#123;        <span class="hljs-keyword">if</span> (newStr.charAt(<span class="hljs-number">0</span>) != <span class="hljs-string">'+'</span> &amp;&amp; newStr.charAt(<span class="hljs-number">0</span>) != <span class="hljs-string">'-'</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (newStr.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">'-'</span>) &#123;                isNegative = <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-keyword">if</span> (newStr.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">'+'</span>) &#123;                isPositive = <span class="hljs-keyword">true</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">char</span>[] chars = newStr.toCharArray();    <span class="hljs-keyword">int</span> i = isNegative | isPositive ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (; i &lt; chars.length; i++) &#123;        <span class="hljs-keyword">char</span> c = chars[i];        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'0'</span>) &#123;            chars[i] = <span class="hljs-string">'`'</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    i = isNegative | isPositive ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (; i &lt; chars.length; i++) &#123;        <span class="hljs-keyword">char</span> c = chars[i];        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'`'</span>) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">if</span> (resultS.length() &gt; <span class="hljs-number">10</span>) &#123;            <span class="hljs-keyword">return</span> isNegative ? Integer.MIN_VALUE : Integer.MAX_VALUE;        &#125;        <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">'0'</span> &amp;&amp; c &lt;= <span class="hljs-string">'9'</span>) &#123;            resultS.append(c);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span> (resultS.length() == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">long</span> aLong = Long.parseLong(resultS.toString());    <span class="hljs-keyword">if</span> (isNegative) &#123;        aLong = - aLong;    &#125;    <span class="hljs-keyword">if</span> (aLong &gt; Integer.MAX_VALUE) &#123;        <span class="hljs-keyword">return</span> Integer.MAX_VALUE;    &#125;    <span class="hljs-keyword">if</span> (aLong &lt; Integer.MIN_VALUE) &#123;        <span class="hljs-keyword">return</span> Integer.MIN_VALUE;    &#125;    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) aLong;&#125;</code></pre><p>精简版代码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">myAtoi2</span><span class="hljs-params">(String str)</span> </span>&#123;    str = str.trim();    <span class="hljs-keyword">if</span> (str.length() == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> first = <span class="hljs-number">0</span>, n = str.length();    <span class="hljs-keyword">int</span> flag = <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (str.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">'+'</span>) &#123;        first++;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">'-'</span>) &#123;        first++;        flag = -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = first; i &lt; n; i++) &#123;        <span class="hljs-keyword">if</span> (!Character.isDigit(str.charAt(i))) &#123;            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) sum * flag;        &#125;        sum = <span class="hljs-number">10</span> * sum + str.charAt(i) - <span class="hljs-string">'0'</span>;        <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span> &amp;&amp; sum &gt; Integer.MAX_VALUE) &#123;            <span class="hljs-keyword">return</span> Integer.MAX_VALUE;        &#125;        <span class="hljs-keyword">if</span> (flag == -<span class="hljs-number">1</span> &amp;&amp; (-<span class="hljs-number">1</span>) * sum &lt; Integer.MIN_VALUE) &#123;            <span class="hljs-keyword">return</span> Integer.MIN_VALUE;        &#125;    &#125;    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) sum * flag;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LEETCODE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>散列表</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题：排序和二分查找</title>
    <link href="/passages/leetcode-sort-binary-search/"/>
    <url>/passages/leetcode-sort-binary-search/</url>
    
    <content type="html"><![CDATA[<!-- more --><h2 id="关于排序和二分查找的几个必知必会的代码实现"><a href="#关于排序和二分查找的几个必知必会的代码实现" class="headerlink" title="关于排序和二分查找的几个必知必会的代码实现"></a>关于排序和二分查找的几个必知必会的代码实现</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li><p>实现归并排序、快速排序、插入排序、冒泡排序、选择排序</p></li><li><p>编程实现 $O(n)$ 时间复杂度内找到一组数据的第 <code>K</code> 大元素</p></li></ul><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ul><li><p>实现一个有序数组的二分查找算法</p></li><li><p>实现模糊二分查找算法（比如大于等于给定值的第一个元素）</p></li></ul><h2 id="排序题目"><a href="#排序题目" class="headerlink" title="排序题目"></a>排序题目</h2><h3 id="Relative-Sort-Array-数组的相对排序"><a href="#Relative-Sort-Array-数组的相对排序" class="headerlink" title="Relative Sort Array(数组的相对排序)"></a><a href="https://leetcode-cn.com/problems/relative-sort-array/" target="_blank" rel="noopener">Relative Sort Array(数组的相对排序)</a></h3><p>题目：</p><blockquote><p>给你两个数组，<code>arr1</code> 和 <code>arr2</code>，</p><ul><li><code>arr2</code> 中的元素各不相同</li><li><code>arr2</code> 中的每个元素都出现在 <code>arr1</code> 中<br>对 <code>arr1</code> 中的元素进行排序，使 <code>arr1</code> 中项的相对顺序和 <code>arr2</code> 中的相对顺序相同。未在 <code>arr2</code> 中出现过的元素需要按照升序放在 <code>arr1</code> 的末尾。</li></ul><p>示例：</p><p>输入：<code>arr1 = [2,3,1,3,2,4,6,7,9,2,19]</code>, <code>arr2 = [2,1,4,3,9,6]</code><br>输出：<code>[2,2,2,1,4,3,3,9,6,7,19]</code></p><p>提示：</p><ul><li><code>arr1.length</code>, <code>arr2.length &lt;= 1000</code></li><li><code>0 &lt;= arr1[i]</code>, <code>arr2[i] &lt;= 1000</code></li><li><code>arr2</code> 中的元素 <code>arr2[i]</code> 各不相同</li><li><code>arr2</code> 中的每个元素 <code>arr2[i]</code> 都出现在 <code>arr1</code> 中</li></ul></blockquote><p>思路：</p><blockquote><p>先对 <code>arr1</code> 进行排序，然后按照 <code>arr2</code> 的顺序放置 <code>arr1</code> 的元素，最后剩下的元素放在末尾即可。</p></blockquote><p>代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] relativeSortArray(<span class="hljs-keyword">int</span>[] arr1, <span class="hljs-keyword">int</span>[] arr2) &#123;    <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr1.length];    Arrays.sort(arr1);    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr2.length; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr1.length; j++) &#123;            <span class="hljs-keyword">if</span> ((arr1[j] != -<span class="hljs-number">1</span>) &amp;&amp; (arr1[j] == arr2[i])) &#123;                result[k ++] = arr1[j];                arr1[j] = -<span class="hljs-number">1</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;        <span class="hljs-keyword">if</span> (arr1[i] != -<span class="hljs-number">1</span>) &#123;            result[k ++] = arr1[i];        &#125;    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre><h2 id="二分查找题目"><a href="#二分查找题目" class="headerlink" title="二分查找题目"></a>二分查找题目</h2><h3 id="Sqrt-x-（x-的平方根）"><a href="#Sqrt-x-（x-的平方根）" class="headerlink" title="Sqrt(x) （x 的平方根）"></a><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">Sqrt(x) （x 的平方根）</a></h3><p>题目：</p><blockquote><p>实现 <code>int sqrt(int x)</code> 函数。</p><p>计算并返回 <code>x</code> 的平方根，其中 <code>x</code> 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例 1:</p><p>输入: <code>4</code><br>输出: <code>2</code></p><p>示例 2:</p><p>输入: <code>8</code><br>输出: <code>2</code><br>说明: <code>8</code> 的平方根是 <code>2.82842...</code>, 由于返回类型是整数，小数部分将被舍去。</p></blockquote><p>思路：</p><blockquote><p>这里提供了两种方法，分别是二分法和牛顿法，<a href="https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/" target="_blank" rel="noopener">点击查看</a><br>二分查找法应用于搜索平方根的思想很简单，其实就是“猜”，但是是有策略的“猜”，用“排除法”在有限的区间里，一次排除一半的区间元素，最后只剩下一个数，这个数就是题目要求的向下取整的平方根整数。</p><p>牛顿法最初提出的时候，是用于求解方程的根，它的基本思想是“以直代曲”，在迭代中搜索得到方程的近似解。</p></blockquote><p>代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">long</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">long</span> right = Integer.MAX_VALUE;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-comment">// 这种取中位数的方法又快又好</span>        <span class="hljs-comment">// 注意：这里得用无符号右移</span>        <span class="hljs-keyword">long</span> mid = (left + right + <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">long</span> square = mid * mid;        <span class="hljs-keyword">if</span> (square &gt; x) &#123;            right = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            left = mid;        &#125;    &#125;    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) left;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LEETCODE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题：栈、队列和递归</title>
    <link href="/passages/leetcode-stack-queue-recur/"/>
    <url>/passages/leetcode-stack-queue-recur/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="关于栈、队列和递归的几个必知必会的代码实现"><a href="#关于栈、队列和递归的几个必知必会的代码实现" class="headerlink" title="关于栈、队列和递归的几个必知必会的代码实现"></a>关于栈、队列和递归的几个必知必会的代码实现</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li><p>用数组实现一个顺序栈</p></li><li><p>用链表实现一个链式栈</p></li><li><p>编程模拟实现一个浏览器的前进、后退功能</p></li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li><p>用数组实现一个顺序队列</p></li><li><p>用链表实现一个链式队列</p></li><li><p>实现一个循环队列</p></li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li><p>编程实现斐波那契数列求值 <code>f(n)=f(n-1)+f(n-2)</code></p></li><li><p>编程实现求阶乘 <code>n!</code></p></li><li><p>编程实现一组数据集合的全排列</p></li></ul><h2 id="栈题目"><a href="#栈题目" class="headerlink" title="栈题目"></a>栈题目</h2><h3 id="Valid-Parentheses（有效的括号）"><a href="#Valid-Parentheses（有效的括号）" class="headerlink" title="Valid Parentheses（有效的括号）"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">Valid Parentheses（有效的括号）</a></h3><p>题目：</p><blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p><p>示例 1:</p><p>输入: “()”<br>输出: <code>true</code></p></blockquote><p>思路：</p><blockquote><p>初始化栈 <code>S</code>。<br>依次处理表达式的每个括号。<br>如果遇到开括号，入栈上即可。<br>如果遇到一个闭括号，那么检查栈顶的元素。如果栈顶的元素是一个<em>相同类型</em>的左括号，那么将它从栈中弹出并继续处理。<br>如果到最后剩下的栈中仍然有元素，那么这意味着表达式无效。</p></blockquote><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] sChar = s.toCharArray();    Stack&lt;Character&gt; s1 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt; sChar.length)&#123;        <span class="hljs-keyword">if</span> (!s1.isEmpty()) &#123;            <span class="hljs-keyword">if</span> (sChar[i] == <span class="hljs-string">')'</span>) &#123;                <span class="hljs-keyword">if</span> (s1.peek() == <span class="hljs-string">'('</span>)                    s1.pop();                <span class="hljs-keyword">else</span>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sChar[i] == <span class="hljs-string">'&#125;'</span>) &#123;                <span class="hljs-keyword">if</span> (s1.peek() == <span class="hljs-string">'&#123;'</span>)                    s1.pop();                <span class="hljs-keyword">else</span>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sChar[i] == <span class="hljs-string">']'</span>) &#123;                <span class="hljs-keyword">if</span> (s1.peek() == <span class="hljs-string">'['</span>)                    s1.pop();                <span class="hljs-keyword">else</span>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-keyword">else</span>                s1.push(sChar[i]);        &#125;        <span class="hljs-keyword">else</span>            s1.push(sChar[i]);        i++;    &#125;    <span class="hljs-keyword">return</span> s1.isEmpty();&#125;</code></pre><h3 id="Longest-Valid-Parentheses（最长有效的括号）"><a href="#Longest-Valid-Parentheses（最长有效的括号）" class="headerlink" title="Longest Valid Parentheses（最长有效的括号）"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">Longest Valid Parentheses（最长有效的括号）</a></h3><p>题目：</p><blockquote><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p><p>示例 1:</p><p>输入: “(()”<br>输出: <code>2</code><br>解释: 最长有效括号子串为 “()”</p></blockquote><p>思路：</p><blockquote><p>本人没有太好的思路，就去偷瞄官方题解了。。。<a href="https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode/" target="_blank" rel="noopener">官方题解</a></p></blockquote><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">int</span> maxans = <span class="hljs-number">0</span>;    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();    stack.push(-<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;        <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">'('</span>) &#123;            stack.push(i);        &#125; <span class="hljs-keyword">else</span> &#123;            stack.pop();            <span class="hljs-keyword">if</span> (stack.empty()) &#123;                stack.push(i);            &#125; <span class="hljs-keyword">else</span> &#123;                maxans = Math.max(maxans, i - stack.peek());            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> maxans;&#125;</code></pre><h3 id="Evaluate-Reverse-Polish-Notatio（逆波兰表达式求值）"><a href="#Evaluate-Reverse-Polish-Notatio（逆波兰表达式求值）" class="headerlink" title="Evaluate Reverse Polish Notatio（逆波兰表达式求值）"></a><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">Evaluate Reverse Polish Notatio（逆波兰表达式求值）</a></h3><p>题目：</p><blockquote><p>根据逆波兰表示法，求表达式的值。</p><p>有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>说明：</p><p>整数除法只保留整数部分。<br>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。<br>示例 1：</p><p>输入: <code>[&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</code><br>输出: <code>9</code><br>解释: <code>((2 + 1) * 3) = 9</code></p></blockquote><p>思路：</p><blockquote><p>定义一个栈辅助计算;<br>当遇到运算符”+”、”-“、”*”、”/“时,从栈中 <code>pop</code> 出两个数字计算，否则将数字入栈;</p></blockquote><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(String[] tokens)</span> </span>&#123;    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();    <span class="hljs-keyword">for</span> (String s : tokens) &#123;        <span class="hljs-keyword">if</span> (s.equals(<span class="hljs-string">"+"</span>)) &#123;            stack.push(stack.pop() + stack.pop());        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.equals(<span class="hljs-string">"-"</span>)) &#123;            stack.push(-stack.pop() + stack.pop());        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.equals(<span class="hljs-string">"*"</span>)) &#123;            stack.push(stack.pop() * stack.pop());        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.equals(<span class="hljs-string">"/"</span>)) &#123;            <span class="hljs-keyword">int</span> num1 = stack.pop();            stack.push(stack.pop() / num1);        &#125; <span class="hljs-keyword">else</span> &#123;            stack.push(Integer.parseInt(s));        &#125;    &#125;    <span class="hljs-keyword">return</span> stack.pop();&#125;</code></pre><h2 id="队列题目"><a href="#队列题目" class="headerlink" title="队列题目"></a>队列题目</h2><h3 id="Design-Circular-Deque（设计一个双端队列）"><a href="#Design-Circular-Deque（设计一个双端队列）" class="headerlink" title="Design Circular Deque（设计一个双端队列）"></a><a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">Design Circular Deque（设计一个双端队列）</a></h3><p>题目：</p><blockquote><p>设计实现双端队列。<br>你的实现需要支持以下操作：</p><ul><li><code>MyCircularDeque(k)</code>：构造函数,双端队列的大小为 <code>k</code>。</li><li><code>insertFront()</code>：将一个元素添加到双端队列头部。 如果操作成功返回 <code>true</code>。</li><li><code>insertLast()</code>：将一个元素添加到双端队列尾部。如果操作成功返回 <code>true</code>。</li><li><code>deleteFront()</code>：从双端队列头部删除一个元素。 如果操作成功返回 <code>true</code>。</li><li><code>deleteLast()</code>：从双端队列尾部删除一个元素。如果操作成功返回 <code>true</code>。</li><li><code>getFront()</code>：从双端队列头部获得一个元素。如果双端队列为空，返回 <code>-1</code>。</li><li><code>getRear()</code>：获得双端队列的最后一个元素。 如果双端队列为空，返回 <code>-1</code>。</li><li><code>isEmpty()</code>：检查双端队列是否为空。</li><li><code>isFull()</code>：检查双端队列是否满了。</li></ul></blockquote><p>思路：</p><blockquote><p>使用循环数组来实现避免数据迁移，这里直接记录size来做判断队列空还是满，需要注意的是在插入头部时，头部指针回退一位的处理；和删除尾部时，尾部指针回退一位的处理</p></blockquote><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] elementData;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> head;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tail;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyCircularDeque</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">if</span> (k &lt;= <span class="hljs-number">0</span>) &#123;            k = DEFAULT_CAPACITY;        &#125;        elementData = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];        capacity = k;        head = <span class="hljs-number">0</span>;        tail = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">insertFront</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">if</span> (isFull()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">if</span> (head - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>) &#123;            head = capacity - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            head--;        &#125;        elementData[head] = value;        size++;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">// 插入到队列尾部</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">insertLast</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">if</span> (isFull()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        elementData[tail] = value;        tail = (tail + <span class="hljs-number">1</span>) % capacity;        size++;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">deleteFront</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        head = (head + <span class="hljs-number">1</span>) % capacity;        size--;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">deleteLast</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">if</span> (tail - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>) &#123;            tail = capacity - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            tail--;        &#125;        size--;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFront</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> elementData[head];    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRear</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">// 特别注意！！！！</span>        <span class="hljs-keyword">if</span> (tail - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> elementData[capacity - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">return</span> elementData[tail - <span class="hljs-number">1</span>];    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> size == capacity;    &#125;</code></pre><h3 id="Sliding-Window-Maximum（滑动窗口最大值）"><a href="#Sliding-Window-Maximum（滑动窗口最大值）" class="headerlink" title="Sliding Window Maximum（滑动窗口最大值）"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">Sliding Window Maximum（滑动窗口最大值）</a></h3><p>题目：</p><blockquote><p>给定一个数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。<br>提示：</p><p>你可以假设 <code>k</code> 总是有效的，在输入数组不为空的情况下，<code>1 ≤ k ≤ 输入数组的大小</code>。</p><p>进阶：</p><p>你能在线性时间复杂度内解决此题吗？</p></blockquote><p>思路：</p><blockquote><p>暴力法可以做，但是太慢了，给上<a href="https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetcode-3/" target="_blank" rel="noopener">官方题解</a></p></blockquote><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;  <span class="hljs-keyword">int</span> n = nums.length;  <span class="hljs-keyword">if</span> (n * k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];  <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums;  <span class="hljs-keyword">int</span> [] left = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];  left[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];  <span class="hljs-keyword">int</span> [] right = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];  right[n - <span class="hljs-number">1</span>] = nums[n - <span class="hljs-number">1</span>];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;    <span class="hljs-comment">// from left to right</span>    <span class="hljs-keyword">if</span> (i % k == <span class="hljs-number">0</span>) left[i] = nums[i];  <span class="hljs-comment">// block_start</span>    <span class="hljs-keyword">else</span> left[i] = Math.max(left[i - <span class="hljs-number">1</span>], nums[i]);    <span class="hljs-comment">// from right to left</span>    <span class="hljs-keyword">int</span> j = n - i - <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> ((j + <span class="hljs-number">1</span>) % k == <span class="hljs-number">0</span>) right[j] = nums[j];  <span class="hljs-comment">// block_end</span>    <span class="hljs-keyword">else</span> right[j] = Math.max(right[j + <span class="hljs-number">1</span>], nums[j]);  &#125;  <span class="hljs-keyword">int</span> [] output = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n - k + <span class="hljs-number">1</span>];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - k + <span class="hljs-number">1</span>; i++)    output[i] = Math.max(left[i + k - <span class="hljs-number">1</span>], right[i]);  <span class="hljs-keyword">return</span> output;&#125;</code></pre><h2 id="递归题目"><a href="#递归题目" class="headerlink" title="递归题目"></a>递归题目</h2><h3 id="Climbing-Stairs（爬楼梯）"><a href="#Climbing-Stairs（爬楼梯）" class="headerlink" title="Climbing Stairs（爬楼梯）"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">Climbing Stairs（爬楼梯）</a></h3><p>题目：</p><blockquote><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 <code>n</code> 是一个正整数。</p><p>示例 1：</p><p>输入： <code>2</code><br>输出： <code>2</code><br>解释： 有两种方法可以爬到楼顶。</p><ol><li><code>1</code> 阶 + <code>1</code> 阶</li><li><code>2</code> 阶</li></ol></blockquote><p>思路：</p><blockquote><p>暴力递归可以通过，但是有没有更好的方案呢，思考一下发现其实就是斐波那契数列 $Fib(n) = Fib(n−1) + Fib(n−2)$</p></blockquote><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">int</span> first = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> second = <span class="hljs-number">2</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;        <span class="hljs-keyword">int</span> third = first + second;        first = second;        second = third;    &#125;    <span class="hljs-keyword">return</span> second;&#125;</code></pre><p>好了，就刷到这里了，有问题欢迎和我留言😉。</p>]]></content>
    
    
    <categories>
      
      <category>LEETCODE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题：数组和链表</title>
    <link href="/passages/leetcode-array-and-list/"/>
    <url>/passages/leetcode-array-and-list/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>学习了那么多的数据结构和算法，到了检验学习成果的时刻了！！😎</p><h2 id="关于数组和链表的几个必知必会的代码实现"><a href="#关于数组和链表的几个必知必会的代码实现" class="headerlink" title="关于数组和链表的几个必知必会的代码实现"></a>关于数组和链表的几个必知必会的代码实现</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li><p>实现一个支持动态扩容的数组</p></li><li><p>实现一个大小固定的有序数组，支持动态增删改操作</p></li><li><p>实现两个有序数组合并为一个有序数组</p></li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li><p>实现单链表、循环链表、双向链表，支持增删操作</p></li><li><p>实现单链表反转</p></li><li><p>实现两个有序的链表合并为一个有序链表</p></li><li><p>实现求链表的中间结点</p></li></ul><h2 id="数组题目"><a href="#数组题目" class="headerlink" title="数组题目"></a>数组题目</h2><h3 id="Three-Sum（求三数之和）"><a href="#Three-Sum（求三数之和）" class="headerlink" title="Three Sum（求三数之和）"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">Three Sum（求三数之和）</a></h3><p>题目：</p><blockquote><p>给定一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <code>a</code>，<code>b</code>，<code>c</code> ，使得 <code>a + b + c = 0</code> ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>例如, 给定数组 <code>nums = [-1, 0, 1, 2, -1, -4]</code>，</p><p>满足要求的三元组集合为：</p></blockquote><pre><code class="hljs plain">[  [-1, 0, 1],  [-1, -1, 2]]</code></pre><p>思路：</p><blockquote><p>最外层控制一个元素的循环，内层用双指针，一个从头到尾扫描，另一个从尾到头扫描，判断三个元素的值之和是否为零。</p><p>注意：相同的元素需要跳过</p></blockquote><p>代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;    <span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">3</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    &#125;    <span class="hljs-comment">//排序</span>    Arrays.sort(nums);    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;        <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 如果当前数字大于0，则三数之和一定大于0，所以结束循环（没有0或负数怎么加也不会等于0）</span>        &#125;        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;            <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 去重</span>        &#125;        <span class="hljs-keyword">int</span> left = i + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> sum = nums[i] + nums[left] + nums[right];            <span class="hljs-keyword">if</span>(sum == <span class="hljs-number">0</span>)&#123;                result.add(Arrays.asList(nums[i], nums[left], nums[right]));                <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left+<span class="hljs-number">1</span>]) &#123;                    left++; <span class="hljs-comment">// 去重</span>                &#125;                <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right-<span class="hljs-number">1</span>]) &#123;                    right--; <span class="hljs-comment">// 去重</span>                &#125;                left++;                right--;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;                left++;            &#125; <span class="hljs-keyword">else</span> &#123;                right --;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre><h3 id="Majority-Element（求众数）"><a href="#Majority-Element（求众数）" class="headerlink" title="Majority Element（求众数）"></a><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">Majority Element（求众数）</a></h3><p>题目：</p><blockquote><p>给定一个大小为 <code>n</code> 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ $\frac n 2$ ⌋ 的元素。</p><p>你可以假设数组是非空的，<strong>并且给定的数组总是存在众数</strong>。<br>示例 1:</p><p>输入: <code>[3,2,3]</code><br>输出: <code>3</code><br>示例 2:</p><p>输入: <code>[2,2,1,1,1,2,2]</code><br>输出: <code>2</code></p></blockquote><p>思路：</p><blockquote><p>根据题意，众数是指在数组中出现次数大于 ⌊ $\frac n 2$ ⌋ 的元素，因此可以先把数组排序，数组$\frac n 2$下标处就是众数。</p></blockquote><p>代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    Arrays.sort(nums);    <span class="hljs-keyword">return</span> nums[nums.length/<span class="hljs-number">2</span>];&#125;</code></pre><p>然而你以为这样就完了吗？通过官方题解，还看到了一种更厉害的解法，那就是 <code>Boyer-Moore</code> 投票算法，思路如下：</p><blockquote><p>如果我们把众数记为 $+1$ ，把其他数记为 $−1$ ，将它们全部加起来，显然和大于 <code>0</code> ，从结果本身我们可以看出众数比其他数多。</p><p>本质上，<code>Boyer-Moore</code> 算法就是找 <code>nums</code> 的一个后缀 $suf$ ，其中 $suf[0]$ 就是后缀中的众数。我们维护一个计数器，如果遇到一个我们目前的候选众数，就将计数器加一，否则减一。只要计数器等于 <code>0</code> &gt; &gt; ，我们就将 <code>nums</code> 中之前访问的数字全部忘记 ，并把下一个数字当做候选的众数。直观上这个算法不是特别明显为何是对的，我们先看下面这个例子（竖线用来划分每次计数器归零的情况）</p><p><code>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</code></p><p>首先，下标为 <code>0</code> 的 <code>7</code> 被当做众数的第一个候选。在下标为 <code>5</code> 处，计数器会变回 <code>0</code>。所以下标为 <code>6</code> 的 <code>5</code> 是下一个众数的候选者。由于这个例子中 <code>7</code> 是真正的众数，所以通过忽略掉前面的数字，我们忽略掉了同样多数目的众数和非众数。因此，<code>7</code> 仍然是剩下数字中的众数。</p><p><code>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 5, 5, 5, 5]</code></p><p>现在，众数是 <code>5</code> （在计数器归零的时候我们把候选从 <code>7</code> 变成了 <code>5</code>）。此时，我们的候选者并不是真正的众数，但是我们在<em>遗忘</em>前面的数字的时候，要去掉相同数目的众数和非众数（如果遗忘更多的非众数，会导致计数器变成负数）。</p><p>因此，上面的过程说明了我们可以放心地遗忘前面的数字，并继续求解剩下数字中的众数。最后，总有一个后缀满足计数器是大于 0 的，此时这个后缀的众数就是整个数组的众数。</p></blockquote><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    Integer candidate = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;            candidate = num;        &#125;        count += (num == candidate) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> candidate;&#125;</code></pre><h3 id="Missing-Positive（求缺失的第一个正数）"><a href="#Missing-Positive（求缺失的第一个正数）" class="headerlink" title="Missing Positive（求缺失的第一个正数）"></a><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">Missing Positive（求缺失的第一个正数）</a></h3><p>题目：</p><blockquote><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</p><p>示例 1:</p><p>输入: <code>[1,2,0]</code><br>输出: <code>3</code></p><p>示例 2:</p><p>输入: <code>[7,8,9,11,12]</code><br>输出: <code>1</code></p><p>说明:</p><p>你的算法的时间复杂度应为$O(n)$，并且只能使用常数级别的空间。</p></blockquote><p>思路：看到说明后就知道不能用哈希表来解决了，所以要换个思路，想了半天想不明白，咱也不敢说，咱也不敢问，只好去偷瞄一眼官方题解，看了后才觉得还是大佬们🐂🏆。<a href="https://leetcode-cn.com/problems/first-missing-positive/solution/que-shi-de-di-yi-ge-zheng-shu-by-leetcode/" target="_blank" rel="noopener">点击此处链接</a></p><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;  <span class="hljs-keyword">int</span> n = nums.length;  <span class="hljs-comment">// 基本情况</span>  <span class="hljs-keyword">int</span> contains = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">1</span>) &#123;      contains++;      <span class="hljs-keyword">break</span>;    &#125;  <span class="hljs-keyword">if</span> (contains == <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// nums = [1]</span>  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">// 用 1 替换负数，0，</span>  <span class="hljs-comment">// 和大于 n 的数</span>  <span class="hljs-comment">// 在转换以后，nums 只会包含</span>  <span class="hljs-comment">// 正数</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    <span class="hljs-keyword">if</span> ((nums[i] &lt;= <span class="hljs-number">0</span>) || (nums[i] &gt; n))      nums[i] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 使用索引和数字符号作为检查器</span>  <span class="hljs-comment">// 例如，如果 nums[1] 是负数表示在数组中出现了数字 `1`</span>  <span class="hljs-comment">// 如果 nums[2] 是正数 表示数字 2 没有出现</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;    <span class="hljs-keyword">int</span> a = Math.abs(nums[i]);    <span class="hljs-comment">// 如果发现了一个数字 a - 改变第 a 个元素的符号</span>    <span class="hljs-comment">// 注意重复元素只需操作一次</span>    <span class="hljs-keyword">if</span> (a == n)      nums[<span class="hljs-number">0</span>] = - Math.abs(nums[<span class="hljs-number">0</span>]);    <span class="hljs-keyword">else</span>      nums[a] = - Math.abs(nums[a]);  &#125;  <span class="hljs-comment">// 现在第一个正数的下标</span>  <span class="hljs-comment">// 就是第一个缺失的数</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;    <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>)      <span class="hljs-keyword">return</span> i;  &#125;  <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> n;  <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;&#125;</code></pre><h2 id="链表题目"><a href="#链表题目" class="headerlink" title="链表题目"></a>链表题目</h2><h3 id="Linked-List-Cycle-I（环形链表）"><a href="#Linked-List-Cycle-I（环形链表）" class="headerlink" title="Linked List Cycle I（环形链表）"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">Linked List Cycle I（环形链表）</a></h3><p>题目：</p><blockquote><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>示例 1：</p><p>输入：head = <code>[3,2,0,-4]</code>, pos = <code>1</code><br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/30/0419e3a0-caf3-11e9-942f-1b7eddebc63d.png" srcset="/img/loading.gif" alt="image.png"></p></blockquote><p>思路：此题即是<a href="../the-common-oper-of-single-list/">单向链表的常见操作</a>中链表环的检测，可以直接点击点链接跳转去看看。</p><p>这里直接给出代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    ListNode slow = head;    ListNode fast = head.next;    <span class="hljs-keyword">while</span> (slow != fast) &#123;        <span class="hljs-keyword">if</span> (fast == <span class="hljs-keyword">null</span> || fast.next == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        slow = slow.next;        fast = fast.next.next;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><h3 id="Merge-k-Sorted-Lists（合并-k-个排序链表）"><a href="#Merge-k-Sorted-Lists（合并-k-个排序链表）" class="headerlink" title="Merge k Sorted Lists（合并 k 个排序链表）"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">Merge k Sorted Lists（合并 k 个排序链表）</a></h3><p>题目：</p><blockquote><p>合并 <code>k</code> 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p>示例:</p><p>输入:</p></blockquote><pre><code class="hljs plain">[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]</code></pre><blockquote><p>输出: <code>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></p></blockquote><p>思路：这里直接给出官方题解的链接，因为有很多种方法可以解决这个问题，详见<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/he-bing-kge-pai-xu-lian-biao-by-leetcode/" target="_blank" rel="noopener">官方题解</a></p><p>代码如下：这里给出利用优先队列实现的代码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;    PriorityQueue&lt;ListNode&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(Comparator.comparingInt(node -&gt; node.val));    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);    ListNode p = dummy;    queue.addAll(Stream.of(lists).filter(Objects::nonNull).collect(Collectors.toList()));    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        ListNode node = queue.poll();        p.next = node;        p = p.next;        <span class="hljs-keyword">if</span> (node.next != <span class="hljs-keyword">null</span>)            queue.add(node.next);    &#125;    <span class="hljs-keyword">return</span> dummy.next;&#125;</code></pre><p>做完题目之后，你可以点击左侧的分享，把测试题分享给你的朋友，说不定就帮他解决了一个难题。也可以给我留言，和我一起分享。</p>]]></content>
    
    
    <categories>
      
      <category>LEETCODE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>53.算法实战（五）</title>
    <link href="/passages/53/"/>
    <url>/passages/53/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>短网址服务你用过吗？如果在微博里发布一条带网址的信息，微博会把里面的网址转化成一个更短的网址。只要访问这个短网址，就相当于访问原始的网址。比如下面这两个网址，尽管长度不同，但是都可以跳转到我的 <code>GitHub</code> 里。其中，第二个网址就是通过新浪提供的短网址服务生成的。</p><pre><code class="hljs java">原始网址：https:<span class="hljs-comment">//github.com/FancierCoder</span>短网址：http:<span class="hljs-comment">//t.cn/Ai8EY5h7</span></code></pre><p>从功能上讲，短网址服务其实非常简单，就是把一个长的网址转化成一个短的网址。作为一名软件工程师，你是否思考过，这样一个简单的功能，是如何实现的呢？底层都依赖了哪些数据结构和算法呢？</p><h2 id="短网址服务整体介绍"><a href="#短网址服务整体介绍" class="headerlink" title="短网址服务整体介绍"></a>短网址服务整体介绍</h2><p>刚刚讲了短网址服务的一个核心功能，就是把原始的长网址转化成短网址。除了这个功能之外，短网址服务还有另外一个必不可少的功能。那就是，当用户点击短网址的时候，短网址服务会将浏览器重定向为原始网址。这个过程是如何实现的呢？</p><p>为了方便理解，下面有一张对比图，你可以看下。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/29/1ebff400-ca0e-11e9-9613-1df66a9dd690.png" srcset="/img/loading.gif" alt="image.png"><br>从图中可以看出，浏览器会先访问短网址服务，通过短网址获取到原始网址，再通过原始网址访问到页面。不过这部分功能并不是要讲的重点。重点来看，如何将长网址转化成短网址？</p><h2 id="如何通过哈希算法生成短网址？"><a href="#如何通过哈希算法生成短网址？" class="headerlink" title="如何通过哈希算法生成短网址？"></a>如何通过哈希算法生成短网址？</h2><p>哈希算法可以将一个不管多长的字符串，转化成一个长度固定的哈希值。可以利用哈希算法，来生成短网址。</p><p>前面已经提过一些哈希算法了，比如 <code>MD5</code>、<code>SHA</code> 等。但是，实际上，并不需要这些复杂的哈希算法。在生成短网址这个问题上，毕竟不需要考虑反向解密的难度，所以只需要关心哈希算法的计算速度和冲突概率。</p><p>能够满足这样要求的哈希算法有很多，其中比较著名并且应用广泛的一个哈希算法，那就是 <code>MurmurHash</code> 算法。尽管这个哈希算法在 <code>2008</code> 年才被发明出来，但现在它已经广泛应用到 <code>Redis</code>、<code>MemCache</code>、<code>Cassandra</code>、<code>HBase</code>、<code>Lucene</code> 等众多著名的软件中。</p><p><code>MurmurHash</code> 算法提供了两种长度的哈希值，一种是 <code>32bits</code>，一种是 <code>128bits</code>。为了让最终生成的短网址尽可能短，可以选择 <code>32bits</code> 的哈希值。对于开头那个 <code>GitHub</code> 网址，假设经过 <code>MurmurHash</code> 计算后，得到的哈希值就是 <code>181338494</code>。再拼上短网址服务的域名，就变成了最终的短网址 <code>http://t.cn/181338494</code>（其中，<code>http://t.cn</code> 是短网址服务的域名）。</p><h3 id="1-如何让短网址更短？"><a href="#1-如何让短网址更短？" class="headerlink" title="1. 如何让短网址更短？"></a>1. 如何让短网址更短？</h3><p>不过，你可能已经看出来了，通过 <code>MurmurHash</code> 算法得到的短网址还是很长啊，而且跟开头那个网址的格式好像也不一样。别着急，只需要稍微改变一个哈希值的表示方法，就可以轻松把短网址变得更短些。</p><p>可以将 <code>10</code> 进制的哈希值，转化成更高进制的哈希值，这样哈希值就变短了。<code>16</code> 进制中，用 <code>A～F</code>，来表示 <code>10～15</code>。在网址 <code>URL</code> 中，常用的合法字符有 <code>0～9</code>、<code>a～z</code>、<code>A～Z</code> 这样 <code>62</code> 个字符。为了让哈希值表示起来尽可能短，可以将 <code>10</code> 进制的哈希值转化成 <code>62</code> 进制。具体的计算过程，写在下面了。最终用 <code>62</code> 进制表示的短网址就是 <code>http://t.cn/cgSqq</code>。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/29/fee4c830-ca0e-11e9-9613-1df66a9dd690.png" srcset="/img/loading.gif" alt="image.png"></p><h3 id="2-如何解决哈希冲突问题？"><a href="#2-如何解决哈希冲突问题？" class="headerlink" title="2. 如何解决哈希冲突问题？"></a>2. 如何解决哈希冲突问题？</h3><p>不过，前面讲过，哈希算法无法避免的一个问题，就是哈希冲突。尽管 <code>MurmurHash</code> 算法冲突的概率非常低。但是，一旦冲突，就会导致两个原始网址被转化成同一个短网址。当用户访问短网址的时候，就无从判断，用户想要访问的是哪一个原始网址了。这个问题该如何解决呢？</p><p>一般情况下，会保存短网址跟原始网址之间的对应关系，以便后续用户在访问短网址的时候，可以根据对应关系，查找到原始网址。存储这种对应关系的方式有很多，比如自己设计存储系统或者利用现成的数据库。前面讲到的数据库有 <code>MySQL</code>、<code>Redis</code>。就拿 <code>MySQL</code> 来举例。假设短网址与原始网址之间的对应关系，就存储在 <code>MySQL</code> 数据库中。</p><p>当有一个新的原始网址需要生成短网址的时候，先利用 <code>MurmurHash</code> 算法，生成短网址。然后，拿这个新生成的短网址，在 <code>MySQL</code> 数据库中查找。</p><p>如果没有找到相同的短网址，这也就表明，这个新生成的短网址没有冲突。于是就将这个短网址返回给用户（请求生成短网址的用户），然后将这个短网址与原始网址之间的对应关系，存储到 <code>MySQL</code> 数据库中。</p><p>如果在数据库中，找到了相同的短网址，那也并不一定说明就冲突了。从数据库中，将这个短网址对应的原始网址也取出来。如果数据库中的原始网址，跟现在正在处理的原始网址是一样的，这就说明已经有人请求过这个原始网址的短网址了。就可以拿这个短网址直接用。如果数据库中记录的原始网址，跟正在处理的原始网址不一样，那就说明哈希算法发生了冲突。不同的原始网址，经过计算，得到的短网址重复了。这个时候，该怎么办呢？</p><p>可以给原始网址拼接一串特殊字符，比如“[DUPLICATED]”，然后跟再重新计算哈希值，两次哈希计算都冲突的概率，显然是非常低的。假设出现非常极端的情况，又发生冲突了，可以再换一个拼接字符串，比如“[OHMYGOD]”，再计算哈希值。然后把计算得到的哈希值，跟原始网址拼接了特殊字符串之后的文本，一并存储在 <code>MySQL</code> 数据库中。</p><p>当用户访问短网址的时候，短网址服务先通过短网址，在数据库中查找到对应的原始网址。如果原始网址有拼接特殊字符（这个很容易通过字符串匹配算法找到），就先将特殊字符去掉，然后再将不包含特殊字符的原始网址返回给浏览器。</p><h3 id="3-如何优化哈希算法生成短网址的性能？"><a href="#3-如何优化哈希算法生成短网址的性能？" class="headerlink" title="3. 如何优化哈希算法生成短网址的性能？"></a>3. 如何优化哈希算法生成短网址的性能？</h3><p>为了判断生成的短网址是否冲突，需要拿生成的短网址，在数据库中查找。如果数据库中存储的数据非常多，那查找起来就会非常慢，势必影响短网址服务的性能。那有没有什么优化的手段呢？</p><p>还记得之前讲的 <code>MySQL</code> 数据库索引吗？可以给短网址字段添加 <code>B+</code> 树索引。这样通过短网址查询原始网址的速度就提高了很多。实际上，在真实的软件开发中，还可以通过一个小技巧，来进一步提高速度。</p><p>在短网址生成的过程中，会跟数据库打两次交道，也就是会执行两条 <code>SQL</code> 语句。第一个 <code>SQL</code> 语句是通过短网址查询短网址与原始网址的对应关系，第二个 <code>SQL</code> 语句是将新生成的短网址和原始网址之间的对应关系存储到数据库。</p><p>一般情况下，数据库和应用服务（只做计算不存储数据的业务逻辑部分）会部署在两个独立的服务器或者虚拟服务器上。那两条 <code>SQL</code> 语句的执行就需要两次网络通信。这种 <code>IO</code> 通信耗时以及 <code>SQL</code> 语句的执行，才是整个短网址服务的性能瓶颈所在。所以，为了提高性能，需要尽量减少 <code>SQL</code> 语句。那又该如何减少 <code>SQL</code> 语句呢？</p><p>可以给数据库中的短网址字段，添加一个唯一索引（不止是索引，还要求表中不能有重复的数据）。当有新的原始网址需要生成短网址的时候，并不会先拿生成的短网址，在数据库中查找判重，而是直接将生成的短网址与对应的原始网址，尝试存储到数据库中。如果数据库能够将数据正常写入，那说明并没有违反唯一索引，也就是说，这个新生成的短网址并没有冲突。</p><p>当然，如果数据库反馈违反唯一性索引异常，那还得重新执行刚刚讲过的“查询、写入”过程，<code>SQL</code> 语句执行的次数不减反增。但是，在大部分情况下，把新生成的短网址和对应的原始网址，插入到数据库的时候，并不会出现冲突。所以，大部分情况下，只需要执行一条写入的 <code>SQL</code> 语句就可以了。所以，从整体上看，总的 <code>SQL</code> 语句执行次数会大大减少。</p><p>实际上，还有另外一个优化 <code>SQL</code> 语句次数的方法，那就是借助布隆过滤器。</p><p>把已经生成的短网址，构建成布隆过滤器。布隆过滤器是比较节省内存的一种存储结构，长度是 <code>10</code> 亿的布隆过滤器，也只需要 <code>125MB</code> 左右的内存空间。</p><p>当有新的短网址生成的时候，先拿这个新生成的短网址，在布隆过滤器中查找。如果查找的结果是不存在，那就说明这个新生成的短网址并没有冲突。这个时候，只需要再执行写入短网址和对应原始网页的 <code>SQL</code> 语句就可以了。通过先查询布隆过滤器，总的 <code>SQL</code> 语句的执行次数减少了。</p><p>到此，利用哈希算法来生成短网址的思路，就讲完了。实际上，这种解决思路已经完全满足需求了，已经可以直接用到真实的软件开发中。不过，还有另外一种短网址的生成算法，那就是利用自增的 <code>ID</code> 生成器来生成短网址。接下来就看一下，这种算法是如何工作的？对于哈希算法生成短网址来说，它又有什么优势和劣势？</p><h2 id="如何通过-ID-生成器生成短网址？"><a href="#如何通过-ID-生成器生成短网址？" class="headerlink" title="如何通过 ID 生成器生成短网址？"></a>如何通过 ID 生成器生成短网址？</h2><p>可以维护一个 <code>ID</code> 自增生成器。它可以生成 <code>1</code>、<code>2</code>、<code>3</code>…这样自增的整数 <code>ID</code>。当短网址服务接收到一个原始网址转化成短网址的请求之后，它先从 <code>ID</code> 生成器中取一个号码，然后将其转化成 <code>62</code> 进制表示法，拼接到短网址服务的域名（比如<code>http://t.cn/</code>）后面，就形成了最终的短网址。最后，还是会把生成的短网址和对应的原始网址存储到数据库中。</p><p>理论非常简单好理解。不过，这里有几个细节问题需要处理。</p><h3 id="1-相同的原始网址可能会对应不同的短网址"><a href="#1-相同的原始网址可能会对应不同的短网址" class="headerlink" title="1. 相同的原始网址可能会对应不同的短网址"></a>1. 相同的原始网址可能会对应不同的短网址</h3><p>每次新来一个原始网址，就生成一个新的短网址，这种做法就会导致两个相同的原始网址生成了不同的短网址。这个该如何处理呢？实际上，有两种处理思路。</p><p>第一种处理思路是<strong>不做处理</strong>。听起来有点无厘头，稍微解释下就明白了。实际上，相同的原始网址对应不同的短网址，用户是可以接受的。在大部分短网址的应用场景里，用户只关心短网址能否正确地跳转到原始网址。至于短网址长什么样子，其实根本就不关心。所以，即便是同一个原始网址，两次生成的短网址不一样，也并不会影响到用户的使用。</p><p>第二种处理思路是<strong>借助哈希算法生成短网址的处理思想</strong>，当要给一个原始网址生成短网址的时候，要先拿原始网址在数据库中查找，看数据库中是否已经存在相同的原始网址了。如果数据库中存在，那就取出对应的短网址，直接返回给用户。</p><p>不过，这种处理思路有个问题，需要给数据库中的短网址和原始网址这两个字段，都添加索引。短网址上加索引是为了提高用户查询短网址对应的原始网页的速度，原始网址上加索引是为了加快刚刚讲的通过原始网址查询短网址的速度。这种解决思路虽然能满足“相同原始网址对应相同短网址”这样一个需求，但是是有代价的：一方面两个索引会占用更多的存储空间，另一方面索引还会导致插入、删除等操作性能的下降。</p><h3 id="2-如何实现高性能的-ID-生成器？"><a href="#2-如何实现高性能的-ID-生成器？" class="headerlink" title="2. 如何实现高性能的 ID 生成器？"></a>2. 如何实现高性能的 ID 生成器？</h3><p>实现 <code>ID</code> 生成器的方法有很多，比如利用数据库自增字段。当然也可以自己维护一个计数器，不停地加一加一。但是，一个计数器来应对频繁的短网址生成请求，显然是有点吃力的（因为计数器必须保证生成的 <code>ID</code> 不重复，笼统概念上讲，就是需要加锁）。如何提高 <code>ID</code> 生成器的性能呢？关于这个问题，实际上，有很多解决思路。这里给出两种思路。</p><p>第一种思路是借助<a href="../52/">第 52 篇</a>中讲的方法。可以给 <code>ID</code> 生成器装多个前置发号器。批量地给每个前置发号器发送 <code>ID</code> 号码。当接受到短网址生成请求的时候，就选择一个前置发号器来取号码。这样通过多个前置发号器，明显提高了并发发号的能力。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/29/0c55d430-ca1b-11e9-9613-1df66a9dd690.png" srcset="/img/loading.gif" alt="image.png"><br>第二种思路跟第一种差不多。不过，不再使用一个 <code>ID</code> 生成器和多个前置发号器这样的架构，而是，直接实现多个 <code>ID</code> 生成器同时服务。为了保证每个 <code>ID</code> 生成器生成的 <code>ID</code> 不重复。要求每个 <code>ID</code> 生成器按照一定的规则，来生成 <code>ID</code> 号码。比如，第一个 <code>ID</code> 生成器只能生成尾号为 <code>0</code> 的，第二个只能生成尾号为 <code>1</code> 的，以此类推。这样通过多个 <code>ID</code> 生成器同时工作，也提高了 <code>ID</code> 生成的效率。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/29/2f6ed070-ca1b-11e9-9613-1df66a9dd690.png" srcset="/img/loading.gif" alt="image.png"></p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>上面讲了短网址服务的两种实现方法。现在来稍微总结一下。</p><p>第一种实现思路是通过哈希算法生成短网址。采用计算速度快、冲突概率小的 <code>MurmurHash</code> 算法，并将计算得到的 <code>10</code> 进制数，转化成 <code>62</code> 进制表示法，进一步缩短短网址的长度。对于哈希算法的哈希冲突问题，通过给原始网址添加特殊前缀字符，重新计算哈希值的方法来解决。</p><p>第二种实现思路是通过 <code>ID</code> 生成器来生成短网址。维护一个 <code>ID</code> 自增的 <code>ID</code> 生成器，给每个原始网址分配一个 <code>ID</code> 号码，并且同样转成 <code>62</code> 进制表示法，拼接到短网址服务的域名之后，形成最终的短网址。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>如果还要额外支持用户自定义短网址功能（<code>http//t.cn/{用户自定部分}</code>），又该如何改造刚刚的算法呢?</p></li><li><p>在讲通过 <code>ID</code> 生成器生成短网址这种实现思路的时候，讲到相同的原始网址可能会对应不同的短网址。针对这个问题，其中一个解决思路就是，不做处理。但是，如果每个请求都生成一个短网址，并且存储在数据库中，那这样会不会撑爆数据库呢？又该如何解决呢？</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单向链表的常见操作</title>
    <link href="/passages/the-common-oper-of-single-list/"/>
    <url>/passages/the-common-oper-of-single-list/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>在<a href="../reverse-single-list/">单向链表的反转</a>后，再补充几个其他的常见操作，包括：</p><ul><li><p>链表中环的检测</p></li><li><p>两个有序的链表合并</p></li><li><p>删除链表倒数第 n 个结点</p></li><li><p>求链表的中间结点</p></li></ul><p>在往下看之前，建议先自己动手写一写这个操作的代码，你只要把这几个操作都能写熟练，不熟就多写几遍，保证你之后再也不会害怕写链表代码。</p><p>链表中每个结点的定义在<a href="../reverse-single-list/">单向链表的反转</a>中已经定义过了，为了方便查看，这里直接把它拉过来：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;    <span class="hljs-comment">// 结点的val</span>    <span class="hljs-keyword">int</span> val;    <span class="hljs-comment">// 下一个结点</span>    ListNode next;    ListNode(<span class="hljs-keyword">int</span> x) &#123;        val = x;    &#125;&#125;</code></pre><h2 id="链表中环的检测"><a href="#链表中环的检测" class="headerlink" title="链表中环的检测"></a>链表中环的检测</h2><p>链表中有环时，如果一直向下遍历链表，则会出现死循环，下图是一个带环的链表：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/28/0029a7b0-c974-11e9-97eb-b7bb8ac6eced.png" srcset="/img/loading.gif" alt="image.png"><br>下面就介绍两种检测环的方法，分别是<strong>快慢指针法</strong>和<strong>足迹法</strong>。</p><h3 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h3><p>首先定义两个指针 <code>slow</code> 和 <code>fast</code> , <code>slow</code> 每次走一步，<code>fast</code> 每次走两步，如果链表中没有环，<code>fast</code> 和 <code>slow</code> 会先后遍历完所有的节点。</p><p>如果链表中有环，<code>fast</code> 和 <code>slow</code> 则会先后进入环中，一直循环，并一定会在在某一次遍历中相遇。</p><p>因此，只要发现 <code>fast</code> 和 <code>slow</code> 相遇了，就可以判定链表中存在环。代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasLoop</span><span class="hljs-params">(ListNode head)</span> </span>&#123;    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    ListNode slow = head.next;    ListNode fast = head.next.next;    <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 每次走一步</span>        slow = slow.next; <span class="hljs-comment">// 每次走两步</span>        fast = fast.next.next; <span class="hljs-comment">// fast 走到末尾了，表示没有环</span>        <span class="hljs-keyword">if</span> (fast == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125; <span class="hljs-comment">// fast 和 slow 相遇了，就可以判定链表中存在环</span>        <span class="hljs-keyword">if</span> (slow == fast) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre><h3 id="足迹法"><a href="#足迹法" class="headerlink" title="足迹法"></a>足迹法</h3><p>顾名思义，足迹法就是每次记录下遍历的结点，当遍历到重复结点时就表明链表中有环。不过记录结点需要额外的一个散列表来实现。</p><p>实现足迹法有两种方式，<code>while</code> 循环和递归。</p><p><code>while</code> 循环版本代码如下：</p><pre><code class="hljs java">   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasLoopForWhile</span><span class="hljs-params">(ListNode head)</span> </span>&#123;       <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;           <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;       &#125;<span class="hljs-comment">// 记录结点</span>       HashSet&lt;ListNode&gt; hashSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();       <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-comment">// 有重复结点表示链表有环</span>           <span class="hljs-keyword">if</span> (hashSet.contains(head)) &#123;               <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;           &#125;    <span class="hljs-comment">// 继续往下遍历</span>           hashSet.add(head);           head = head.next;       &#125;       <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   &#125;</code></pre><p>递归版本代码如下：</p><pre><code class="hljs java">   <span class="hljs-comment">// 记录结点</span>   HashSet&lt;ListNode&gt; hashSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasLoopForRecur</span><span class="hljs-params">(ListNode head)</span> </span>&#123;       <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;           <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;       &#125;<span class="hljs-comment">// 有重复结点表示链表有环</span>       <span class="hljs-keyword">if</span> (hashSet.contains(head)) &#123;           <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;       &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 否则继续往下遍历</span>           hashSet.add(head);           <span class="hljs-keyword">return</span> hasLoopForRecur(head.next);       &#125;   &#125;</code></pre><p>从面试的角度看，快慢指针法更符合面试的意图。而从实际工作的角度看，快慢指针法难理解，代码也不好写，所以更推荐用足迹法。而且足迹法可以加上链表的 <code>index</code> ，可以找出是哪里开始出现了环。</p><h2 id="两个有序的链表合并"><a href="#两个有序的链表合并" class="headerlink" title="两个有序的链表合并"></a>两个有序的链表合并</h2><p>有序链表即已经排好顺序的链表，如 <code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</code>。</p><p>基本思路可以概括为以下几点：</p><ul><li><p>定义两个指针 <code>cur</code>, <code>cur2</code> 分别指向两个有序链表 <code>list1</code>,<code>list2</code> 的头结点；</p></li><li><p>定义一个新链表 <code>result</code> 来存放合并后的新链表；</p></li><li><p>比较 <code>cur1</code> 和 <code>cur2</code> 指向的结点;</p></li><li><p>如果 <code>cur1 &gt; cur2</code> ，将 <code>cur2</code> 所指的当前结点插入到 <code>result</code> ，然后 <code>cur2</code> 移动到下一个结点，再与 <code>cur1</code> 比较，依次循环这个过程；</p></li><li><p>如果 <code>cur1 &lt; cur2</code> ，将 <code>cur1</code> 所指的当前结点插入到 <code>result</code> ，然后 <code>cur1</code> 移动到下一个结点，再与 <code>cur2</code> 比较，依次循环这个过程；</p></li><li><p>如果 <code>cur1 = cur2</code> ，先插入 <code>cur1</code> ，在插入 <code>cur2</code> ，接着 <code>cur1</code> 和 <code>cur2</code> 分别向后移动，继续比较；</p></li><li><p>如果 <code>list1</code> 链表已经遍历完，那么将 <code>list2</code> 剩余的链表插入到链表 <code>result</code> 中，反之将 <code>list1</code> 剩余的链表插入到链表 <code>result</code> 中；</p></li></ul><p>具体实现代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoList2</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> </span>&#123;    <span class="hljs-keyword">if</span> (list1 == <span class="hljs-keyword">null</span> || list2 == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> list1 != <span class="hljs-keyword">null</span> ? list1 : list2;    &#125;    <span class="hljs-comment">// 合并后单链表头结点</span>    ListNode head = list1.val &lt; list2.val ? list1 : list2;    ListNode cur1 = head == list1 ? list1 : list2;    ListNode cur2 = head == list1 ? list2 : list1;    <span class="hljs-comment">// cur1前一个元素</span>    ListNode pre = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// cur2的后一个元素</span>    ListNode next = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">while</span> (cur1 != <span class="hljs-keyword">null</span> &amp;&amp; cur2 != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 第一次进来肯定走这里 上面已经比较过</span>        <span class="hljs-keyword">if</span> (cur1.val &lt;= cur2.val) &#123;            pre = cur1;            cur1 = cur1.next;        &#125; <span class="hljs-keyword">else</span> &#123;            next = cur2.next;            pre.next = cur2;            cur2.next = cur1;            pre = cur2;            cur2 = next;        &#125;    &#125;    pre.next = cur1 == <span class="hljs-keyword">null</span> ? cur2 : cur1;    <span class="hljs-keyword">return</span> head;&#125;</code></pre><p>递归版实现如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoList</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> </span>&#123;    <span class="hljs-comment">// 递归结束条件</span>    <span class="hljs-keyword">if</span> (list1 == <span class="hljs-keyword">null</span> &amp;&amp; list2 == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-keyword">if</span> (list1 == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> list2;    &#125;    <span class="hljs-keyword">if</span> (list2 == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> list1;    &#125;    <span class="hljs-comment">// 合并后的链表</span>    ListNode head = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">if</span> (list1.val &gt; list2.val) &#123;        <span class="hljs-comment">// 把较小的结点给头结点</span>        head = list2;        <span class="hljs-comment">// 继续递归head2</span>        head.next = mergeTwoList(list1, list2.next);    &#125; <span class="hljs-keyword">else</span> &#123;        head = list1;        head.next = mergeTwoList(list1.next, list2);    &#125;    <span class="hljs-keyword">return</span> head;&#125;</code></pre><h2 id="删除链表倒数第-n-个结点"><a href="#删除链表倒数第-n-个结点" class="headerlink" title="删除链表倒数第 n 个结点"></a>删除链表倒数第 n 个结点</h2><p>最简单和直接的方法就是先遍历一次链表取得链表长度 <code>len</code>，然后再次从表头开始遍历至第 <code>len - n</code> 个结点并将该结点删除即可，这种方法是可行的，不过效率不高（遍历了两次），因此应当考虑可否遍历一次即完成任务。</p><p>遍历是需要从表头开始遍历的，要想遍历一次就完成任务，就是说在遍历一次的时候就能找到倒数第 <code>n</code> 个结点，换句话说，当遍历到倒数第 <code>n</code> 个结点时就应当停止遍历了，那么该怎么知道我遍历到了倒数第 <code>n</code> 个结点呢？</p><p>此时就可以用快慢指针法。倒数即是从表尾(<code>NULL</code>)往前数，倒数第 <code>n</code> 个即是从表尾往前数第 <code>n</code> 个，换句话说，如果从某个结点往后数 <code>n</code> 个结点就达到表尾(<code>NULL</code>), 那么这个结点就显然是倒数第 <code>n</code> 个结点了，因此，算法思路也就有了：用慢指针指向遍历的当前结点，用快指针指向当前结点往后数的第 <code>n</code> 个结点，如果快指针指向了表尾(<code>NULL</code>)，则在链表中删除慢指针指向的结点。</p><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">// 慢指针</span>    ListNode slow = head;    <span class="hljs-comment">//快指针</span>    ListNode fast = head;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        fast = fast.next;        <span class="hljs-keyword">if</span> (fast == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span> (fast == <span class="hljs-keyword">null</span>) &#123;        head = head.next;        <span class="hljs-keyword">return</span> head;    &#125;    <span class="hljs-comment">// 快指针没有到最后 继续向下遍历</span>    <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-keyword">null</span>) &#123;        fast = fast.next;        slow = slow.next;    &#125;    <span class="hljs-comment">// 删除 slow 的下一个结点</span>    slow.next = slow.next.next;    <span class="hljs-keyword">return</span> head;&#125;</code></pre><h2 id="求链表的中间结点"><a href="#求链表的中间结点" class="headerlink" title="求链表的中间结点"></a>求链表的中间结点</h2><p>中间结点有两种情况：</p><ul><li><p>奇数长度的链表，例如：<code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</code><br>返回节点 <code>3</code></p></li><li><p>偶长度的链表，例如：<code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6</code><br>返回节点 <code>4</code></p></li></ul><p>与链表中环的检测一样，同样可以使用快慢指针法来解决。</p><p>定义两个指针 <code>fast</code> 指向链表的头结点的下一个结点，<code>slow</code> 指向链表的头结点。<code>slow</code> 一次遍历一个节点，<code>fast</code> 一次遍历两个节点，由于 <code>fast</code> 的速度是 <code>slow</code> 的两倍，所以当 <code>fast</code> 遍历完链表时，<code>slow</code> 所处的节点就是链表的中间节点。</p><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode head)</span> </span>&#123;    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> head;    &#125;    <span class="hljs-comment">// 指向链表的头结点</span>    ListNode slow = head;    <span class="hljs-comment">// 指向链表的头结点的下一个结点</span>    ListNode fast = head.next;    <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;        slow = slow.next;        fast = fast.next.next;    &#125;    <span class="hljs-keyword">return</span> fast == <span class="hljs-keyword">null</span> ? slow : slow.next;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>链表的操作最重要的是理解指针或引用的含义、警惕指针丢失和内存泄漏、重点留意边界条件处理，以及举例画图、辅助思考，还有多写多练。</p>]]></content>
    
    
    <categories>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>52.算法实战（四）</title>
    <link href="/passages/52/"/>
    <url>/passages/52/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>微服务是最近几年才兴起的概念。简单点讲，就是把复杂的大应用，解耦拆分成几个小的应用。这样做的好处有很多。比如，这样有利于团队组织架构的拆分，毕竟团队越大协作的难度越大；再比如，每个应用都可以独立运维，独立扩容，独立上线，各个应用之间互不影响。不用像原来那样，一个小功能上线，整个大应用都要重新发布。</p><p>不过，有利就有弊。大应用拆分成微服务之后，服务之间的调用关系变得更复杂，平台的整体复杂度升高，出错的概率、<code>debug</code> 问题的难度都高了好几个数量级。所以，为了解决这些问题，服务治理便成了微服务的一个技术重点。</p><p>所谓服务治理，简单点讲，就是管理微服务，保证平台整体正常、平稳地运行。服务治理涉及的内容比较多，比如鉴权、限流、降级、熔断、监控告警等等。这些服务治理功能的实现，底层依赖大量的数据结构和算法。下面就拿其中的鉴权和限流这两个功能，一起来看看，它们的实现过程中都要用到哪些数据结构和算法。</p><h2 id="鉴权背景介绍"><a href="#鉴权背景介绍" class="headerlink" title="鉴权背景介绍"></a>鉴权背景介绍</h2><p>以防读者之前可能对微服务没有太多了解，所以这里对鉴权的背景做了简化。</p><p>假设有一个微服务叫用户服务（<code>User Service</code>）。它提供很多用户相关的接口，比如获取用户信息、注册、登录等，给公司内部的其他应用使用。但是，并不是公司内部所有应用，都可以访问这个用户服务，也并不是每个有访问权限的应用，都可以访问用户服务的所有接口。</p><p>举了一个例子讲解一下，你可以看下面的这幅图。这里面，只有 <code>A</code>、<code>B</code>、<code>C</code>、<code>D</code> 四个应用可以访问用户服务，并且，每个应用只能访问用户服务的部分接口。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/28/4cb771f0-c953-11e9-97eb-b7bb8ac6eced.png" srcset="/img/loading.gif" alt="image.png"><br>要实现接口鉴权功能，需要事先将应用对接口的访问权限规则设置好。当某个应用访问其中一个接口的时候，就可以拿应用的请求 <code>URL</code>，在规则中进行匹配。如果匹配成功，就说明允许访问；如果没有可以匹配的规则，那就说明这个应用没有这个接口的访问权限，就拒绝服务。</p><h2 id="如何实现快速鉴权？"><a href="#如何实现快速鉴权？" class="headerlink" title="如何实现快速鉴权？"></a>如何实现快速鉴权？</h2><p>接口的格式有很多，有类似 <code>Dubbo</code> 这样的 <code>RPC</code> 接口，也有类似 <code>Spring Cloud</code> 这样的 <code>HTTP</code> 接口。不同接口的鉴权实现方式是类似的，这里主要拿 <code>HTTP</code> 接口讲解。</p><p>鉴权的原理比较简单、好理解。那具体到实现层面，该用什么数据结构来存储规则呢？用户请求 <code>URL</code> 在规则中快速匹配，又该用什么样的算法呢？</p><p>实际上，不同的规则和匹配模式，对应的数据结构和匹配算法也是不一样的。所以，关于这个问题，继续细化为三个更加详细的需求讲解。</p><h3 id="1-如何实现精确匹配规则？"><a href="#1-如何实现精确匹配规则？" class="headerlink" title="1. 如何实现精确匹配规则？"></a>1. 如何实现精确匹配规则？</h3><p>先来看最简单的一种匹配模式。只有当请求 <code>URL</code> 跟规则中配置的某个接口精确匹配时，这个请求才会被接受、处理。为了方便理解，下面举了一个例子，你可以看一下。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/28/bc86a500-c953-11e9-97eb-b7bb8ac6eced.png" srcset="/img/loading.gif" alt="image.png"><br>不同的应用对应不同的规则集合。可以采用散列表来存储这种对应关系。这里着重讲下，每个应用对应的规则集合，该如何存储和匹配。</p><p>针对这种匹配模式，可以将每个应用对应的权限规则，存储在一个字符串数组中。当用户请求到来时，拿用户的请求 <code>URL</code>，在这个字符串数组中逐一匹配，匹配的算法就是之前学过的字符串匹配算法（比如 <code>KMP</code>、<code>BM</code>、<code>BF</code> 等）。</p><p>规则不会经常变动，所以，为了加快匹配速度，可以按照字符串的大小给规则排序，把它组织成有序数组这种数据结构。当要查找某个 <code>URL</code> 能否匹配其中某条规则的时候，可以采用二分查找算法，在有序数组中进行匹配。</p><p>而二分查找算法的时间复杂度是 $O(logn)$（<code>n</code> 表示规则的个数），这比起时间复杂度是 $O(n)$ 的顺序遍历快了很多。对于规则中接口长度比较长，并且鉴权功能调用量非常大的情况，这种优化方法带来的性能提升还是非常可观的 。</p><h3 id="2-如何实现前缀匹配规则？"><a href="#2-如何实现前缀匹配规则？" class="headerlink" title="2. 如何实现前缀匹配规则？"></a>2. 如何实现前缀匹配规则？</h3><p>再来看一种稍微复杂的匹配模式。只要某条规则可以匹配请求 <code>URL</code> 的前缀，就说这条规则能够跟这个请求 <code>URL</code> 匹配。同样，为了方便你理解这种匹配模式，还是举一个例子说明一下。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/28/0bcc6050-c954-11e9-97eb-b7bb8ac6eced.png" srcset="/img/loading.gif" alt="image.png"><br>不同的应用对应不同的规则集合。采用散列表来存储这种对应关系。这里着重讲一下，每个应用的规则集合，最适合用什么样的数据结构来存储。</p><p>在 <code>Trie</code> 树那节讲到，<code>Trie</code> 树非常适合用来做前缀匹配。所以，针对这个需求，可以将每个用户的规则集合，组织成 <code>Trie</code> 树这种数据结构。</p><p>不过，<code>Trie</code> 树中的每个节点不是存储单个字符，而是存储接口被“/”分割之后的子目录（比如“/user/name”被分割为“user”“name”两个子目录）。因为规则并不会经常变动，所以，在 <code>Trie</code> 树中，可以把每个节点的子节点们，组织成有序数组这种数据结构。当在匹配的过程中，可以利用二分查找算法，决定从一个节点应该跳到哪一个子节点。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/28/41d429d0-c954-11e9-97eb-b7bb8ac6eced.png" srcset="/img/loading.gif" alt="image.png"></p><h3 id="3-如何实现模糊匹配规则？"><a href="#3-如何实现模糊匹配规则？" class="headerlink" title="3. 如何实现模糊匹配规则？"></a>3. 如何实现模糊匹配规则？</h3><p>如果规则更加复杂，规则中包含通配符，比如<code>**</code>表示匹配任意多个子目录，<code>*</code>表示匹配任意一个子目录。只要用户请求 <code>URL</code> 可以跟某条规则模糊匹配，就说这条规则适用于这个请求。为了方便理解，下面举一个例子来解释一下。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/28/5a6c3eb0-c954-11e9-97eb-b7bb8ac6eced.png" srcset="/img/loading.gif" alt="image.png"><br>不同的应用对应不同的规则集合。还是采用散列表来存储这种对应关系。这点刚才讲过了，这里不再重复说了。着重看下，每个用户对应的规则集合，该用什么数据结构来存储？针对这种包含通配符的模糊匹配，又该使用什么算法来实现呢？</p><p>还记得在回溯算法那节讲的正则表达式的例子吗？可以借助正则表达式那个例子的解决思路，来解决这个问题。采用回溯算法，拿请求 <code>URL</code> 跟每条规则逐一进行模糊匹配。如何用回溯算法进行模糊匹配，这部分就不重复讲了。如果忘记了，可以回到相应章节复习一下。</p><p>不过，这个解决思路的时间复杂度是非常高的。需要拿每一个规则，跟请求 <code>URL</code> 匹配一遍。那有没有办法可以继续优化一下呢？</p><p>实际上，可以结合实际情况，挖掘出这样一个隐形的条件，那就是，并不是每条规则都包含通配符，包含通配符的只是少数。于是，可以把不包含通配符的规则和包含通配符的规则分开处理。</p><p>把不包含通配符的规则，组织成有序数组或者 <code>Trie</code> 树（具体组织成什么结构，视具体的需求而定，是精确匹配，就组织成有序数组，是前缀匹配，就组织成 <code>Trie</code> 树），而这一部分匹配就会非常高效。剩下的是少数包含通配符的规则，只要把它们简单存储在一个数组中就可以了。尽管匹配起来会比较慢，但是毕竟这种规则比较少，所以这种方法也是可以接受的。</p><p>当接收到一个请求 <code>URL</code> 之后，可以先在不包含通配符的有序数组或者 <code>Trie</code> 树中查找。如果能够匹配，就不需要继续在通配符规则中匹配了；如果不能匹配，就继续在通配符规则中查找匹配。</p><h2 id="限流背景介绍"><a href="#限流背景介绍" class="headerlink" title="限流背景介绍"></a>限流背景介绍</h2><p>所谓限流，顾名思义，就是对接口调用的频率进行限制。比如每秒钟不能超过 <code>100</code> 次调用，超过之后，就拒绝服务。限流的原理听起来非常简单，但它在很多场景中，发挥着重要的作用。比如在秒杀、大促、双 <code>11</code>、<code>618</code> 等场景中，限流已经成为了保证系统平稳运行的一种标配的技术解决方案。</p><p>按照不同的限流粒度，限流可以分为很多种类型。比如给每个接口限制不同的访问频率，或者给所有接口限制总的访问频率，又或者更细粒度地限制某个应用对某个接口的访问频率等等。</p><p>不同粒度的限流功能的实现思路都差不多，所以，下面主要针对限制所有接口总的访问频率这样一个限流需求来讲解。其他粒度限流需求的实现思路，你可以自己思考。</p><h2 id="如何实现精准限流？"><a href="#如何实现精准限流？" class="headerlink" title="如何实现精准限流？"></a>如何实现精准限流？</h2><p>最简单的限流算法叫<strong>固定时间窗口限流算法</strong>。这种算法是如何工作的呢？首先需要选定一个时间起点，之后每当有接口请求到来，就将计数器加一。如果在当前时间窗口内，根据限流规则（比如每秒钟最大允许 <code>100</code> 次访问请求），出现累加访问次数超过限流值的情况时，就拒绝后续的访问请求。当进入下一个时间窗口之后，计数器就清零重新计数。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/28/1ad32880-c955-11e9-97eb-b7bb8ac6eced.png" srcset="/img/loading.gif" alt="image.png"><br>这种基于固定时间窗口的限流算法的缺点是，限流策略过于粗略，无法应对两个时间窗口临界时间内的突发流量。这是怎么回事呢？下面举一个例子解释一下。</p><p>假设限流规则是，每秒钟不能超过 <code>100</code> 次接口请求。第一个 <code>1s</code> 时间窗口内，<code>100</code> 次接口请求都集中在最后 <code>10ms</code> 内。在第二个 <code>1s</code> 的时间窗口内，<code>100</code> 次接口请求都集中在最开始的 <code>10ms</code> 内。虽然两个时间窗口内流量都符合限流要求（<code>≤ 100</code> 个请求），但在两个时间窗口临界的 <code>20ms</code> 内，会集中有 <code>200</code> 次接口请求。固定时间窗口限流算法并不能对这种情况做限制，所以，集中在这 <code>20ms</code> 内的 <code>200</code> 次请求就有可能压垮系统。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/28/59028010-c955-11e9-97eb-b7bb8ac6eced.png" srcset="/img/loading.gif" alt="image.png"><br>为了解决这个问题，可以对固定时间窗口限流算法稍加改造。可以限制任意时间窗口（比如 <code>1s</code>）内，接口请求数都不能超过某个阈值（ 比如 <code>100</code> 次）。因此，相对于固定时间窗口限流算法，这个算法叫滑动时间窗口限流算法。</p><p>流量经过滑动时间窗口限流算法整形之后，可以保证任意一个 <code>1s</code> 的时间窗口内，都不会超过最大允许的限流值，从流量曲线上来看会更加平滑。那具体到实现层面，该如何来做呢？</p><p>假设限流的规则是，在任意 <code>1s</code> 内，接口的请求次数都不能大于 <code>K</code> 次。就维护一个大小为 <code>K+1</code> 的循环队列，用来记录 <code>1s</code> 内到来的请求。注意，这里循环队列的大小等于限流次数加一，因为循环队列存储数据时会浪费一个存储单元。</p><p>当有新的请求到来时，将与这个新请求的时间间隔超过 <code>1s</code> 的请求，从队列中删除。然后，再来看循环队列中是否有空闲位置。如果有，则把新请求存储在队列尾部（<code>tail</code> 指针所指的位置）；如果没有，则说明这 <code>1</code> 秒内的请求次数已经超过了限流值 <code>K</code>，所以这个请求被拒绝服务。</p><p>为了方便理解，下面举一个例子解释一下。在这个例子中，假设限流的规则是，任意 <code>1s</code> 内，接口的请求次数都不能大于 <code>6</code> 次。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/28/aa6994c0-c955-11e9-97eb-b7bb8ac6eced.png" srcset="/img/loading.gif" alt="image.png"><br>即便滑动时间窗口限流算法可以保证任意时间窗口内，接口请求次数都不会超过最大限流值，但是仍然不能防止，在细时间粒度上访问过于集中的问题。</p><p>比如刚刚举的那个例子，第一个 <code>1s</code> 的时间窗口内，<code>100</code> 次请求都集中在最后 <code>10ms</code> 中，也就是说，基于时间窗口的限流算法，不管是固定时间窗口还是滑动时间窗口，只能在选定的时间粒度上限流，对选定时间粒度内的更加细粒度的访问频率不做限制。</p><p>实际上，针对这个问题，还有很多更加平滑的限流算法，比如令牌桶算法、漏桶算法等。如果感兴趣，你可以自己去研究一下。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>上面讲解了跟微服务相关的接口鉴权和限流功能的实现思路。现在，稍微总结一下。</p><p>关于鉴权，讲了三种不同的规则匹配模式。不管是哪种匹配模式，都可以用散列表来存储不同应用对应的不同规则集合。对于每个应用的规则集合的存储，三种匹配模式使用不同的数据结构。</p><p>对于第一种精确匹配模式，利用有序数组来存储每个应用的规则集合，并且通过二分查找和字符串匹配算法，来匹配请求 <code>URL</code> 与规则。对于第二种前缀匹配模式，利用 <code>Trie</code> 树来存储每个应用的规则集合。对于第三种模糊匹配模式，采用普通的数组来存储包含通配符的规则，通过回溯算法，来进行请求 <code>URL</code> 与规则的匹配。</p><p>关于限流，讲了两种限流算法，第一种是固定时间窗口限流算法，第二种是滑动时间窗口限流算法。对于滑动时间窗口限流算法，用了之前学习过的循环队列来实现。比起固定时间窗口限流算法，它对流量的整形效果更好，流量更加平滑。</p><p>从上面的学习中也可以看出，对于基础架构工程师来说，如果不精通数据结构和算法，就很难开发出性能卓越的基础架构、中间件。这其实就体现了数据结构和算法的重要性。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>除了用循环队列来实现滑动时间窗口限流算法之外，是否还可以用其他数据结构来实现呢？请对比一下这些数据结构跟循环队列在解决这个问题时的优劣之处。</p></li><li><p>分析一下鉴权那部分内容中，前缀匹配算法的时间复杂度和空间复杂度。欢迎留言和我分享。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51.算法实战（三）</title>
    <link href="/passages/51/"/>
    <url>/passages/51/</url>
    
    <content type="html"><![CDATA[<!-- more --><p><code>Disruptor</code> 你是否听说过呢？它是一种内存消息队列。从功能上讲，它其实有点儿类似 <code>Kafka</code>。不过，和 <code>Kafka</code> 不同的是，<code>Disruptor</code> 是线程之间用于消息传递的队列。它在 <code>Apache Storm</code>、<code>Camel</code>、<code>Log4j 2</code> 等很多知名项目中都有广泛应用。</p><p>之所以如此受青睐，主要还是因为它的性能表现非常优秀。它比 <code>Java</code> 中另外一个非常常用的内存消息队列 <code>ArrayBlockingQueue</code>（<code>ABS</code>）的性能，要高一个数量级，可以算得上是最快的内存消息队列了。它还因此获得过 <code>Oracle</code> 官方的 <code>Duke</code> 大奖。</p><p>如此高性能的内存消息队列，在设计和实现上，必然有它独到的地方。下面来看下 <strong><code>Disruptor</code> 是如何做到如此高性能的？其底层依赖了哪些数据结构和算法？</strong></p><h2 id="基于循环队列的“生产者-消费者模型”"><a href="#基于循环队列的“生产者-消费者模型”" class="headerlink" title="基于循环队列的“生产者 - 消费者模型”"></a>基于循环队列的“生产者 - 消费者模型”</h2><p>什么是内存消息队列？对很多业务工程师或者前端工程师来说，可能会比较陌生。不过，如果说“生产者 - 消费者模型”，估计大部分人都知道。在这个模型中，“生产者”生产数据，并且将数据放到一个中心存储容器中。之后，“消费者”从中心存储容器中，取出数据消费。</p><p>这个模型非常简单、好理解，那你有没有思考过，这里面存储数据的中心存储容器，是用什么样的数据结构来实现的呢？</p><p>实际上，实现中心存储容器最常用的一种数据结构，就是在<a href="../7/">第 7 篇</a>讲的<strong>队列</strong>。队列支持数据的先进先出。正是这个特性，使得数据被消费的顺序性可以得到保证，也就是说，早被生产的数据就会早被消费。</p><p><a href="../7/">第 7 篇</a>讲过，队列有两种实现思路。一种是基于链表实现的<strong>链式队列</strong>，另一种是基于数组实现的<strong>顺序队列</strong>。不同的需求背景下，会选择不同的实现方式。</p><p>如果要实现一个无界队列，也就是说，队列的大小事先不确定，理论上可以支持无限大。这种情况下，适合选用链表来实现队列。因为链表支持快速地动态扩容。如果要实现一个有界队列，也就是说，队列的大小事先确定，当队列中数据满了之后，生产者就需要等待。直到消费者消费了数据，队列有空闲位置的时候，生产者才能将数据放入。这种情况下，适合选用数组来实现队列。</p><p>实际上，相较于无界队列，有界队列的应用场景更加广泛。毕竟，机器内存是有限的。而无界队列占用的内存数量是不可控的。对于实际的软件开发来说，这种不可控的因素，就会有潜在的风险。在某些极端情况下，无界队列就有可能因为内存持续增长，而导致 <code>OOM</code>（<code>Out of Memory</code>）错误。</p><p>在<a href="../7/">第 7 篇</a>中，还讲过一种特殊的顺序队列，<strong>循环队列</strong>。非循环的顺序队列在添加、删除数据的工程中，会涉及数据的搬移操作，导致性能变差。而循环队列正好可以解决这个数据搬移的问题，所以性能更加好。所以，大部分用到顺序队列的场景中，都选择用顺序队列中的循环队列。</p><p>实际上，<strong>循环队列这种数据结构，就是内存消息队列的雏形</strong>。借助循环队列，可以实现一个最简单的“生产者 - 消费者模型”。对应的代码贴到下面，你可以看看。</p><p>为了方便理解，对于生产者和消费者之间操作的同步，并没有用到线程相关的操作。而是采用了“当队列满了之后，生产者就轮训等待；当队列空了之后，消费者就轮训等待”这样的措施。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span> </span>&#123;  <span class="hljs-keyword">private</span> Long[] data;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>, head = <span class="hljs-number">0</span>, tail = <span class="hljs-number">0</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Queue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;    <span class="hljs-keyword">this</span>.data = <span class="hljs-keyword">new</span> Long[size];    <span class="hljs-keyword">this</span>.size = size;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(Long element)</span> </span>&#123;    <span class="hljs-keyword">if</span> ((tail + <span class="hljs-number">1</span>) % size == head) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    data[tail] = element;    tail = (tail + <span class="hljs-number">1</span>) % size;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (head == tail) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">long</span> ret = data[head];    head = (head + <span class="hljs-number">1</span>) % size;    <span class="hljs-keyword">return</span> ret;  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> </span>&#123;  <span class="hljs-keyword">private</span> Queue queue;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Producer</span><span class="hljs-params">(Queue queue)</span> </span>&#123;    <span class="hljs-keyword">this</span>.queue = queue;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">(Long data)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">while</span> (!queue.add(data)) &#123;      Thread.sleep(<span class="hljs-number">100</span>);    &#125;  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> </span>&#123;  <span class="hljs-keyword">private</span> Queue queue;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">(Queue queue)</span> </span>&#123;    <span class="hljs-keyword">this</span>.queue = queue;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">comsume</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;      Long data = queue.poll();      <span class="hljs-keyword">if</span> (data == <span class="hljs-keyword">null</span>) &#123;        Thread.sleep(<span class="hljs-number">100</span>);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span>... 消费数据的业务逻辑...</span>      &#125;    &#125;  &#125;&#125;</code></pre><h2 id="基于加锁的并发“生产者-消费者模型”"><a href="#基于加锁的并发“生产者-消费者模型”" class="headerlink" title="基于加锁的并发“生产者 - 消费者模型”"></a>基于加锁的并发“生产者 - 消费者模型”</h2><p>实际上，刚刚的“生产者 - 消费者模型”实现代码，是不完善的。为什么这么说呢？</p><p>如果只有一个生产者往队列中写数据，一个消费者从队列中读取数据，那上面的代码是没有问题的。但是，如果有多个生产者在并发地往队列中写入数据，或者多个消费者并发地从队列中消费数据，那上面的代码就不能正确工作了。为什么呢？</p><p>在多个生产者或者多个消费者并发操作队列的情况下，刚刚的代码主要会有下面两个问题：</p><ul><li><p>多个生产者写入的数据可能会互相覆盖；</p></li><li><p>多个消费者可能会读取重复的数据。</p></li></ul><p>因为第一个问题和第二个问题产生的原理是类似的。所以，着重讲解第一个问题是如何产生的以及该如何解决。对于第二个问题，你可以类比对第一个问题的解决思路自己来想一想。</p><p>两个线程同时往队列中添加数据，也就相当于两个线程同时执行类 <code>Queue</code> 中的 <code>add()</code> 函数。假设队列的大小 <code>size</code> 是 <code>10</code>，当前的 <code>tail</code> 指向下标 <code>7</code>，<code>head</code> 指向下标 <code>3</code>，也就是说，队列中还有空闲空间。这个时候，线程 <code>1</code> 调用 <code>add()</code> 函数，往队列中添加一个值为 <code>12</code> 的数据；线程 <code>2</code> 调用 <code>add()</code> 函数，往队列中添加一个值为 <code>15</code> 的数据。在极端情况下，本来是往队列中添加了两个数据（<code>12</code> 和 <code>15</code>），最终可能只有一个数据添加成功，另一个数据会被覆盖。这是为什么呢？<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/27/3d641d00-c879-11e9-bbe3-f1168c942eb3.png" srcset="/img/loading.gif" alt="image.png"><br>为了方便你查看队列 <code>Queue</code> 中的 <code>add()</code> 函数，这里把它从上面的代码中摘录出来，贴在这里。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(Long element)</span> </span>&#123;  <span class="hljs-keyword">if</span> ((tail + <span class="hljs-number">1</span>) % size == head) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  data[tail] = element;  tail = (tail + <span class="hljs-number">1</span>) % size;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><p>从这段代码中，可以看到，第 <code>3</code> 行给 <code>data[tail]</code> 赋值，然后第 <code>4</code> 行才给 <code>tail</code> 的值加一。赋值和 <code>tail</code> 加一两个操作，并非原子操作。这就会导致这样的情况发生：当线程 <code>1</code> 和线程 <code>2</code> 同时执行 <code>add()</code> 函数的时候，线程 <code>1</code> 先执行完了第 <code>3</code> 行语句，将 <code>data[7]</code>（<code>tail</code> 等于 <code>7</code>）的值设置为 <code>12</code>。在线程 <code>1</code> 还未执行到第 <code>4</code> 行语句之前，也就是还未将 <code>tail</code> 加一之前，线程 <code>2</code> 执行了第 <code>3</code> 行语句，又将 <code>data[7]</code> 的值设置为 <code>15</code>，也就是说，那线程 <code>2</code> 插入的数据覆盖了线程 <code>1</code> 插入的数据。原本应该插入两个数据（<code>12</code> 和 <code>15</code>）的，现在只插入了一个数据（<code>15</code>）。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/27/bda6bd10-c879-11e9-bbe3-f1168c942eb3.png" srcset="/img/loading.gif" alt="image.png"><br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/27/c0361a80-c879-11e9-bbe3-f1168c942eb3.png" srcset="/img/loading.gif" alt="image.png"><br>那如何解决这种线程并发往队列中添加数据时，导致的数据覆盖、运行不正确问题呢？</p><p>最简单的处理方法就是给这段代码加锁，同一时间只允许一个线程执行 <code>add()</code> 函数。这就相当于将这段代码的执行，由并行改成了串行，也就不存在刚刚说的问题了。</p><p>不过，天下没有免费的午餐，加锁将并行改成串行，必然导致多个生产者同时生产数据的时候，执行效率的下降。当然，可以继续优化代码，用 <code>CAS</code>（<code>compare and swap</code>，比较并交换）操作等减少加锁的粒度，但是，这不是这里的重点。直接看 <code>Disruptor</code> 的处理方法。</p><h2 id="基于无锁的并发“生产者-消费者模型”"><a href="#基于无锁的并发“生产者-消费者模型”" class="headerlink" title="基于无锁的并发“生产者 - 消费者模型”"></a>基于无锁的并发“生产者 - 消费者模型”</h2><p>尽管 <code>Disruptor</code> 的源码读起来很复杂，但是基本思想其实非常简单。实际上，它是换了一种队列和“生产者 - 消费者模型”的实现思路。</p><p>之前的实现思路中，队列只支持两个操作，添加数据和读取并移除数据，分别对应代码中的 <code>add()</code> 函数和 <code>poll()</code> 函数，而 <code>Disruptor</code> 采用了另一种实现思路。</p><p>对于生产者来说，它往队列中添加数据之前，先申请可用空闲存储单元，并且是批量地申请连续的 <code>n</code> 个（<code>n ≥ 1</code>）存储单元。当申请到这组连续的存储单元之后，后续往队列中添加元素，就可以不用加锁了，因为这组存储单元是这个线程独享的。不过，从刚刚的描述中，可以看出，申请存储单元的过程是需要加锁的。</p><p>对于消费者来说，处理的过程跟生产者是类似的。它先去申请一批连续可读的存储单元（这个申请的过程也是需要加锁的），当申请到这批存储单元之后，后续的读取操作就可以不用加锁了。</p><p>不过，还有一个需要特别注意的地方，那就是，如果生产者 <code>A</code> 申请到了一组连续的存储单元，假设是下标为 <code>3</code> 到 <code>6</code> 的存储单元，生产者 <code>B</code> 紧跟着申请到了下标是 <code>7</code> 到 <code>9</code> 的存储单元，那在 <code>3</code> 到 <code>6</code> 没有完全写入数据之前，<code>7</code> 到 <code>9</code> 的数据是无法读取的。这个也是 <code>Disruptor</code> 实现思路的一个弊端。</p><p>文字描述不好理解，下面有一幅图可以展示一下这个操作过程。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/27/6055c5b0-c87a-11e9-bbe3-f1168c942eb3.png" srcset="/img/loading.gif" alt="image.png"><br>实际上，<code>Disruptor</code> 采用的是 <code>RingBuffer</code> 和 <code>AvailableBuffer</code> 这两个结构，来实现刚刚提到的功能。不过，因为这里主要聚焦在数据结构和算法上，所以这里对这两种结构做了简化，但是基本思想是一致的。如果你对 <code>Disruptor</code> 感兴趣，可以去阅读一下它的<a href="https://github.com/LMAX-Exchange/disruptor" target="_blank" rel="noopener">源码</a>。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>上面讲了如何实现一个高性能的并发队列。这里的“并发”两个字，实际上就是<strong>多线程安全</strong>的意思。</p><p>常见的内存队列往往采用循环队列来实现。这种实现方法，对于只有一个生产者和一个消费者的场景，已经足够了。但是，当存在多个生产者或者多个消费者的时候，单纯的循环队列的实现方式，就无法正确工作了。</p><p>这主要是因为，多个生产者在同时往队列中写入数据的时候，在某些情况下，会存在数据覆盖的问题。而多个消费者同时消费数据，在某些情况下，会存在消费重复数据的问题。</p><p>针对这个问题，最简单、暴力的解决方法就是，对写入和读取过程加锁。这种处理方法，相当于将原来可以并行执行的操作，强制串行执行，相应地就会导致操作性能的下降。</p><p>为了在保证逻辑正确的前提下，尽可能地提高队列在并发情况下的性能，<code>Disruptor</code> 采用了“两阶段写入”的方法。在写入数据之前，先加锁申请批量的空闲存储单元，之后往队列中写入数据的操作就不需要加锁了，写入的性能因此就提高了。<code>Disruptor</code> 对消费过程的改造，跟对生产过程的改造是类似的。它先加锁申请批量的可读取的存储单元，之后从队列中读取数据的操作也就不需要加锁了，读取的性能因此也就提高了。</p><p>你可能会觉得这个优化思路非常简单。实际上，不管架构设计还是产品设计，<strong>往往越简单的设计思路，越能更好地解决问题</strong>。正所谓“大道至简”，就是这个意思。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>为了提高存储性能，往往通过分库分表的方式设计数据库表。假设有 <code>8</code> 张表用来存储用户信息。这个时候，每张用户表中的 <code>ID</code> 字段就不能通过自增的方式来产生了。因为这样的话，就会导致不同表之间的用户 <code>ID</code> 值重复。<br>为了解决这个问题，需要实现一个 <code>ID</code> 生成器，可以为所有的用户表生成唯一的 <code>ID</code> 号。那现在问题是，如何设计一个高性能、支持并发的、能够生成全局唯一 <code>ID</code> 的 <code>ID</code> 生成器呢？欢迎留言和我分享。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单向链表的反转</title>
    <link href="/passages/reverse-single-list/"/>
    <url>/passages/reverse-single-list/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>单向链表的反转很考验逻辑思维，在面试中经常会被用到，因此是一个必须掌握的知识点。单向链表的反转有很多方法可以处理，这里介绍两种方法：<strong>遍历反转法</strong>和<strong>递归反转法</strong>。</p><h2 id="单向链表结构"><a href="#单向链表结构" class="headerlink" title="单向链表结构"></a>单向链表结构</h2><p>首先定义结构</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;    <span class="hljs-comment">//结点的val</span>    <span class="hljs-keyword">int</span> val;    <span class="hljs-comment">//下一个结点</span>    ListNode next;    ListNode(<span class="hljs-keyword">int</span> x) &#123;        val = x;    &#125;&#125;</code></pre><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>将单链表数据：<code>1, 2, 3, 4, 5</code> 反转为：<code>5, 4, 3, 2, 1</code></p><h3 id="遍历反转法"><a href="#遍历反转法" class="headerlink" title="遍历反转法"></a>遍历反转法</h3><ul><li><p>从前往后反转各个结点的指针域的指向。</p></li><li><p>将当前结点<code>curNode</code>的下一个结点 <code>curNode.next</code> 缓存到 <code>temp</code> 后，然后，使当前结点指针指向上一结点 <code>pre</code>。</p></li><li><p>也就是说在反转当前结点指针指向前，先把当前结点的指针域用 <code>tmp</code> 临时保存，以便下一次使用，代码如下：</p></li></ul><pre><code class="hljs java"><span class="hljs-comment">/** * 遍历反转法：从前往后反转各个结点的指针域的指向。 * <span class="hljs-doctag">@param</span> head * <span class="hljs-doctag">@return</span> preNode */</span><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">// 上一结点</span>    ListNode preNode = head;    <span class="hljs-comment">// 当前结点</span>    ListNode curNode = head.next;    <span class="hljs-comment">// 临时结点，用于保存当前结点的指针域（即下一结点）</span>    ListNode tmp;    <span class="hljs-keyword">while</span> (curNode != <span class="hljs-keyword">null</span>) &#123;        tmp = curNode.next;        <span class="hljs-comment">// 反转指向</span>        curNode.next = preNode;        <span class="hljs-comment">// 向下移动</span>        preNode= curNode;        curNode = tmp;    &#125;    head.next = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">return</span> preNode;&#125;</code></pre><h3 id="递归反转法"><a href="#递归反转法" class="headerlink" title="递归反转法"></a>递归反转法</h3><ul><li><p>在反转当前结点之前先反转后续结点。这样从头结点开始，层层深入直到尾结点才开始反转指针域的指向。</p></li><li><p>就是从尾结点开始，逆向反转各个结点的指针域指向。代码如下：</p></li></ul><pre><code class="hljs java"><span class="hljs-comment">/** * 递归反转法：从尾结点开始，逆向反转各个结点的指针域指向。 * <span class="hljs-doctag">@param</span> head * <span class="hljs-doctag">@return</span> reverseHead */</span><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseListRecur</span><span class="hljs-params">(ListNode head)</span> </span>&#123;    <span class="hljs-comment">// head看作是前一结点，head.next 是当前结点，reverseHead是反转后新链表的头结点</span>    <span class="hljs-comment">// 若为空链或者当前结点在尾结点，则直接还回</span>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> head;    &#125;    <span class="hljs-comment">// 先反转后续结点 head.next</span>    ListNode reverseHead = reverseListRecur(head.next);    <span class="hljs-comment">// 将当前结点的指针域指向前一结点</span>    head.next.next = head;    <span class="hljs-comment">// 前一结点的指针域设为null;</span>    head.next = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 反转后新链表的头结点</span>    <span class="hljs-keyword">return</span> reverseHead;&#125;</code></pre><p>代码看起来很简单，实际理解起来却十分烧脑，因此建议你自己在编译器上写一写，打断点去深入理解下。</p>]]></content>
    
    
    <categories>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>50.算法实战（二）</title>
    <link href="/passages/50/"/>
    <url>/passages/50/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>像百度、<code>Google</code> 这样的搜索引擎，在平时的工作、生活中，几乎天天都会用到。如果把搜索引擎也当作一个互联网产品的话，那它跟社交、电商这些类型的产品相比，有一个非常大的区别，那就是，它是一个技术驱动的产品。所谓技术驱动是指，搜索引擎实现起来，技术难度非常大，技术的好坏直接决定了这个产品的核心竞争力。</p><h2 id="整体系统介绍"><a href="#整体系统介绍" class="headerlink" title="整体系统介绍"></a>整体系统介绍</h2><p>搜索引擎大致可以分为四个部分：<strong>搜集</strong>、<strong>分析</strong>、<strong>索引</strong>、<strong>查询</strong>。其中，搜集，就是常说的利用爬虫爬取网页。分析，主要负责网页内容抽取、分词，构建临时索引，计算 <code>PageRank</code> 值这几部分工作。索引，主要负责通过分析阶段得到的临时索引，构建倒排索引。查询，主要负责响应用户的请求，根据倒排索引获取相关网页，计算网页排名，返回查询结果给用户。</p><h2 id="搜集"><a href="#搜集" class="headerlink" title="搜集"></a>搜集</h2><p>现在，互联网越来越发达，网站越来越多，对应的网页也就越来越多。对于搜索引擎来说，它事先并不知道网页都在哪里。打个比方来说就是，只知道海里面有很多鱼，但却并不知道鱼在哪里。那搜索引擎是如何爬取网页的呢？</p><p>搜索引擎把整个互联网看作数据结构中的有向图，把每个页面看作一个顶点。如果某个页面中包含另外一个页面的链接，那就在两个顶点之间连一条有向边。可以利用图的遍历搜索算法，来遍历整个互联网中的网页。</p><p>前面介绍过两种图的遍历方法，深度优先和广度优先。搜索引擎采用的是广度优先搜索策略。具体点的话，那就是，先找一些比较知名的网页（专业的叫法是权重比较高）的链接（比如新浪主页网址、腾讯主页网址等），作为种子网页链接，放入到队列中。爬虫按照广度优先的策略，不停地从队列中取出链接，然后取爬取对应的网页，解析出网页里包含的其他网页链接，再将解析出来的链接添加到队列中。</p><p>基本的原理就是这么简单。但落实到实现层面，还有很多技术细节。下面借助搜集阶段涉及的几个重要文件，来解释一下搜集工程都有哪些关键技术细节。</p><h3 id="1-待爬取网页链接文件：links-bin"><a href="#1-待爬取网页链接文件：links-bin" class="headerlink" title="1. 待爬取网页链接文件：links.bin"></a>1. 待爬取网页链接文件：links.bin</h3><p>在广度优先搜索爬取页面的过程中，爬虫会不停地解析页面链接，将其放到队列中。于是，队列中的链接就会越来越多，可能会多到内存放不下。所以，用一个存储在磁盘中的文件（<code>links.bin</code>）来作为广度优先搜索中的队列。爬虫从 <code>links.bin</code> 文件中，取出链接去爬取对应的页面。等爬取到网页之后，将解析出来的链接，直接存储到 <code>links.bin</code> 文件中。</p><p>这样用文件来存储网页链接的方式，还有其他好处。比如，支持断点续爬。也就是说，当机器断电之后，网页链接不会丢失；当机器重启之后，还可以从之前爬取到的位置继续爬取。</p><p>关于如何解析页面获取链接，额外多说几句。可以把整个页面看作一个大的字符串，可以利用字符串匹配算法，在这个大字符串中，搜索这样一个网页标签，然后顺序读取之间的字符串。这其实就是网页链接。</p><h3 id="2-网页判重文件：bloom-filter-bin"><a href="#2-网页判重文件：bloom-filter-bin" class="headerlink" title="2. 网页判重文件：bloom_filter.bin"></a>2. 网页判重文件：bloom_filter.bin</h3><p>如何避免重复爬取相同的网页呢？这个问题在位图那一篇已经讲过了。使用<strong>布隆过滤器</strong>，就可以快速并且非常节省内存地实现网页的判重。</p><p>不过，还是刚刚那个问题，如果把布隆过滤器存储在内存中，那机器宕机重启之后，布隆过滤器就被清空了。这样就可能导致大量已经爬取的网页会被重复爬取。</p><p>这个问题该怎么解决呢？可以定期地（比如每隔半小时）将布隆过滤器持久化到磁盘中，存储在 <code>bloom_filter.bin</code> 文件中。这样，即便出现机器宕机，也只会丢失布隆过滤器中的部分数据。当机器重启之后，就可以重新读取磁盘中的 <code>bloom_filter.bin</code> 文件，将其恢复到内存中。</p><h3 id="3-原始网页存储文件：doc-raw-bin"><a href="#3-原始网页存储文件：doc-raw-bin" class="headerlink" title="3. 原始网页存储文件：doc_raw.bin"></a>3. 原始网页存储文件：doc_raw.bin</h3><p>爬取到网页之后，需要将其存储下来，以备后面离线分析、索引之用。那如何存储海量的原始网页数据呢？</p><p>如果把每个网页都存储为一个独立的文件，那磁盘中的文件就会非常多，数量可能会有几千万，甚至上亿。常用的文件系统显然不适合存储如此多的文件。所以，可以把多个网页存储在一个文件中。每个网页之间，通过一定的标识进行分隔，方便后续读取。具体的存储格式，如下图所示。其中，<code>doc_id</code> 这个字段是网页的编号，待会儿再解释。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/26/d7ee21f0-c7b0-11e9-bd0a-57cc00d1a72f.png" srcset="/img/loading.gif" alt="image.png"><br>当然，这样的一个文件也不能太大，因为文件系统对文件的大小也有一定的限制。所以，可以设置每个文件的大小不能超过一定的值（比如 <code>1GB</code>）。随着越来越多的网页被添加到文件中，文件的大小就会越来越大，当超过 <code>1GB</code> 的时候，就创建一个新的文件，用来存储新爬取的网页。</p><p>假设一台机器的硬盘大小是 <code>100GB</code> 左右，一个网页的平均大小是 <code>64KB</code>。那在一台机器上，可以存储 <code>100</code> 万到 <code>200</code> 万左右的网页。假设机器的带宽是 <code>10MB</code>，那下载 <code>100GB</code> 的网页，大约需要 <code>10000</code> 秒。也就是说，爬取 <code>100</code> 多万的网页，也就是只需要花费几小时的时间。</p><h3 id="4-网页链接及其编号的对应文件：doc-id-bin"><a href="#4-网页链接及其编号的对应文件：doc-id-bin" class="headerlink" title="4. 网页链接及其编号的对应文件：doc_id.bin"></a>4. 网页链接及其编号的对应文件：doc_id.bin</h3><p>刚刚提到了网页编号这个概念，现在解释一下。网页编号实际上就是给每个网页分配一个唯一的 <code>ID</code>，方便后续对网页进行分析、索引。那如何给网页编号呢？</p><p>可以按照网页被爬取的先后顺序，从小到大依次编号。具体是这样做的：维护一个中心的计数器，每爬取到一个网页之后，就从计数器中拿一个号码，分配给这个网页，然后计数器加一。在存储网页的同时，将网页链接跟编号之间的对应关系，存储在另一个 <code>doc_id.bin</code> 文件中。</p><p><strong>爬虫在爬取网页的过程中，涉及的四个重要的文件，就介绍完了。其中，<code>links.bin</code> 和 <code>bloom_filter.bin</code> 这两个文件是爬虫自身所用的。另外的两个（<code>doc_raw.bin</code>、<code>doc_id.bin</code>）是作为搜集阶段的成果，供后面的分析、索引、查询用的。</strong></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>网页爬取下来之后，需要对网页进行离线分析。分析阶段主要包括两个步骤，第一个是抽取网页文本信息，第二个是分词并创建临时索引。</p><h3 id="1-抽取网页文本信息"><a href="#1-抽取网页文本信息" class="headerlink" title="1. 抽取网页文本信息"></a>1. 抽取网页文本信息</h3><p>网页是半结构化数据，里面夹杂着各种标签、<code>JavaScript</code> 代码、<code>CSS</code> 样式。对于搜索引擎来说，它只关心网页中的文本信息，也就是，网页显示在浏览器中时，能被用户肉眼看到的那部分信息。如何从半结构化的网页中，抽取出搜索引擎关系的文本信息呢？</p><p>之所以把网页叫作半结构化数据，是因为它本身是按照一定的规则来书写的。这个规则就是<strong><code>HTML</code> 语法规范</strong>。依靠 <code>HTML</code> 标签来抽取网页中的文本信息。这个抽取的过程，大体可以分为两步。</p><p>第一步是去掉 <code>JavaScript</code> 代码、<code>CSS</code> 格式以及下拉框中的内容（因为下拉框在用户不操作的情况下，也是看不到的）。也就是<code>&lt;style&gt;&lt;/style&gt;，&lt;script&gt;&lt;/script&gt;，&lt;option&gt;&lt;/option&gt;</code>这三组标签之间的内容。可以利用 <code>AC</code> 自动机这种多模式串匹配算法，在网页这个大字符串中，一次性查找<code>&lt;style&gt;, &lt;script&gt;, &lt;option&gt;</code>这三个关键词。当找到某个关键词出现的位置之后，只需要依次往后遍历，直到对应结束标签<code>&lt;/style&gt;, &lt;/script&gt;, &lt;/option&gt;</code> 为止。而这期间遍历到的字符串连带着标签就应该从网页中删除。</p><p>第二步是去掉所有 <code>HTML</code> 标签。这一步也是通过字符串匹配算法来实现的。过程跟第一步类似。</p><h3 id="2-分词并创建临时索引"><a href="#2-分词并创建临时索引" class="headerlink" title="2. 分词并创建临时索引"></a>2. 分词并创建临时索引</h3><p>经过上面的处理之后，就从网页中抽取出了我们关心的文本信息。接下来，要对文本信息进行分词，并且创建临时索引。</p><p>对于英文网页来说，分词非常简单。只需要通过空格、标点符号等分隔符，将每个单词分割开来就可以了。但是，对于中文来说，分词就复杂太多了。这里介绍一种比较简单的思路，基于字典和规则的分词方法。</p><p>其中，字典也叫词库，里面包含大量常用的词语（可以直接从网上下载别人整理好的）。借助词库并采用<strong>最长匹配规则</strong>，来对文本进行分词。所谓最长匹配，也就是匹配尽可能长的词语。举个例子解释一下。</p><p>比如要分词的文本是“中国人民解放了”，词库中有“中国”“中国人”“中国人民”“中国人民解放军”这几个词，那就取最长匹配，也就是“中国人民”划为一个词，而不是把“中国”、“中国人“划为一个词。具体到实现层面，可以将词库中的单词，构建成 <code>Trie</code> 树结构，然后拿网页文本在 <code>Trie</code> 树中匹配。</p><p>每个网页的文本信息在分词完成之后，都得到一组单词列表。把单词与网页之间的对应关系，写入到一个临时索引文件中（<code>tmp_Index.bin</code>），这个临时索引文件用来构建倒排索引文件。临时索引文件的格式如下：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/26/23295c10-c7b2-11e9-bd0a-57cc00d1a72f.png" srcset="/img/loading.gif" alt="image.png"><br>在临时索引文件中，存储的是单词编号，也就是图中的 <code>term_id</code>，而非单词本身。这样做的目的主要是为了节省存储的空间。那这些单词的编号是怎么来的呢？</p><p>给单词编号的方式，跟给网页编号类似。维护一个计数器，每当从网页文本信息中分割出一个新的单词的时候，就从计数器中取一个编号，分配给它，然后计数器加一。</p><p>在这个过程中，还需要使用散列表，记录已经编过号的单词。在对网页文本信息分词的过程中，拿分割出来的单词，先到散列表中查找，如果找到，那就直接使用已有的编号；如果没有找到，再去计数器中拿号码，并且将这个新单词以及编号添加到散列表中。</p><p>当所有的网页处理（分词及写入临时索引）完成之后，再将这个单词跟编号之间的对应关系，写入到磁盘文件中，并命名为 <code>term_id.bin</code>。</p><p><strong>经过分析阶段，得到了两个重要的文件。它们分别是临时索引文件（<code>tmp_index.bin</code>）和单词编号文件（<code>term_id.bin</code>）。</strong></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引阶段主要负责将分析阶段产生的临时索引，构建成倒排索引。倒排索引（<code>Inverted index</code>）中记录了每个单词以及包含它的网页列表。文字描述比较难理解，下面有一张倒排索引的结构图。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/26/adda9e90-c7b3-11e9-bd0a-57cc00d1a72f.png" srcset="/img/loading.gif" alt="image.png"><br>刚刚讲到，在临时索引文件中，记录的是单词跟每个包含它的文档之间的对应关系。那如何通过临时索引文件，构建出倒排索引文件呢？这是一个非常典型的算法问题，你可以先自己思考一下，再看下面的讲解。</p><p>解决这个问题的方法有很多。考虑到临时索引文件很大，无法一次性加载到内存中，搜索引擎一般会选择使用<strong>多路归并排序</strong>的方法来实现。</p><p>先对临时索引文件，按照单词编号的大小进行排序。因为临时索引很大，所以一般基于内存的排序算法就没法处理这个问题了。可以用之前讲到的归并排序的处理思想，将其分割成多个小文件，先对每个小文件独立排序，最后再合并在一起。当然，实际的软件开发中，其实可以直接利用 <code>MapReduce</code> 来处理。</p><p>临时索引文件排序完成之后，相同的单词就被排列到了一起。只需要顺序地遍历排好序的临时索引文件，就能将每个单词对应的网页编号列表找出来，然后把它们存储在倒排索引文件中。具体的处理过程，下面有一张图。通过图，你应该更容易理解。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/26/f5be3eb0-c7b3-11e9-bd0a-57cc00d1a72f.png" srcset="/img/loading.gif" alt="image.png"><br>除了倒排文件之外，还需要一个文件，来记录每个单词编号在倒排索引文件中的偏移位置。把这个文件命名为 <code>term_offset.bin</code>。这个文件的作用是，帮助快速地查找某个单词编号在倒排索引中存储的位置，进而快速地从倒排索引中读取单词编号对应的网页编号列表。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/26/1a4b1640-c7b4-11e9-bd0a-57cc00d1a72f.png" srcset="/img/loading.gif" alt="image.png"><br><strong>经过索引阶段的处理，得到了两个有价值的文件，它们分别是倒排索引文件（<code>index.bin</code>）和记录单词编号在索引文件中的偏移位置的文件（<code>term_offset.bin</code>）。</strong></p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>前面三个阶段的处理，只是为了最后的查询做铺垫。因此，现在就要利用之前产生的几个文件，来实现最终的用户搜索功能。</p><ul><li><p><code>doc_id.bin</code>：记录网页链接和编号之间的对应关系。</p></li><li><p><code>term_id.bin</code>：记录单词和编号之间的对应关系。</p></li><li><p><code>index.bin</code>：倒排索引文件，记录每个单词编号以及对应包含它的网页编号列表。</p></li><li><p><code>term_offsert.bin</code>：记录每个单词编号在倒排索引文件中的偏移位置。</p></li></ul><p>这四个文件中，除了倒排索引文件（<code>index.bin</code>）比较大之外，其他的都比较小。为了方便快速查找数据，将其他三个文件都加载到内存中，并且组织成散列表这种数据结构。</p><p>当用户在搜索框中，输入某个查询文本的时候，先对用户输入的文本进行分词处理。假设分分词之后，得到 <code>k</code> 个单词。</p><p>拿这 <code>k</code> 个单词，去 <code>term_id.bin</code> 对应的散列表中，查找对应的单词编号。经过这个查询之后，得到了这 <code>k</code> 个单词对应的单词编号。</p><p>拿这 <code>k</code> 个单词编号，去 <code>term_offset.bin</code> 对应的散列表中，查找每个单词编号在倒排索引文件中的偏移位置。经过这个查询之后，得到了 <code>k</code> 个偏移位置。</p><p>拿这 <code>k</code> 个偏移位置，去倒排索引（<code>index.bin</code>）中，查找 <code>k</code> 个单词对应的包含它的网页编号列表。经过这一步查询之后，得到了 <code>k</code> 个网页编号列表。</p><p>针对这 <code>k</code> 个网页编号列表，统计每个网页编号出现的次数。具体到实现层面，可以借助散列表来进行统计。统计得到的结果，按照出现次数的多少，从小到大排序。出现次数越多，说明包含越多的用户查询单词（用户输入的搜索文本，经过分词之后的单词）。</p><p>经过这一系列查询，就得到了一组排好序的网页编号。拿着网页编号，去 <code>doc_id.bin</code> 文件中查找对应的网页链接，分页显示给用户就可以了。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>上面展示了一个小型搜索引擎的设计思路。这只是一个搜索引擎设计的基本原理，有很多优化、细节并未涉及，比如计算网页权重的 <code>PageRank</code> 算法、计算查询结果排名的 <code>tf-idf</code> 模型等等。</p><p>在讲解的过程中，涉及的数据结构和算法有：图、散列表、<code>Trie</code> 树、布隆过滤器、单模式字符串匹配算法、<code>AC</code> 自动机、广度优先遍历、归并排序等。如果对其中哪些内容不清楚，你可以回到对应的章节进行复习。</p><p>最后，如果有时间的话，强烈建议你，按照上面的思路，自己写代码实现一个简单的搜索引擎。这样写出来的，即便只是一个 <code>demo</code>，但对于你深入理解数据结构和算法，也是很有帮助的。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>图的遍历方法有两种，深度优先和广度优先。搜索引擎中的爬虫是通过广度优先策略来爬取网页的。搜索引擎为什么选择广度优先策略，而不是深度优先策略呢？</p></li><li><p>大部分搜索引擎在结果显示的时候，都支持摘要信息和网页快照。实际上，只需要对上面的设计思路，稍加改造，就可以支持这两项功能。你知道如何改造吗？欢迎留言和我分享。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>49.算法实战（一）</title>
    <link href="/passages/49/"/>
    <url>/passages/49/</url>
    
    <content type="html"><![CDATA[<p><strong>经典数据库 <code>Redis</code> 中的常用数据类型，底层都是用哪种数据结构实现的？</strong></p><h2 id="Redis-数据库介绍"><a href="#Redis-数据库介绍" class="headerlink" title="Redis 数据库介绍"></a>Redis 数据库介绍</h2><p><code>Redis</code> 是一种键值（<code>Key-Value</code>）数据库。相对于关系型数据库（比如 <code>MySQL</code>），<code>Redis</code> 也被叫作<strong>非关系型数据库</strong>。</p><p>像 <code>MySQL</code> 这样的关系型数据库，表的结构比较复杂，会包含很多字段，可以通过 <code>SQL</code> 语句，来实现非常复杂的查询需求。而 <code>Redis</code> 中只包含“键”和“值”两部分，只能通过“键”来查询“值”。正是因为这样简单的存储结构，也让 <code>Redis</code> 的读写效率非常高。</p><p>除此之外，<code>Redis</code> 主要是作为内存数据库来使用，也就是说，数据是存储在内存中的。尽管它经常被用作内存数据库，但是，它也支持将数据存储在硬盘中。</p><p><code>Redis</code> 中，键的数据类型是字符串，但是为了丰富数据存储的方式，方便开发者使用，值的数据类型有很多，常用的数据类型有这样几种，它们分别是字符串、列表、字典、集合、有序集合。</p><p>“字符串（<code>string</code>）”这种数据类型非常简单，对应到数据结构里，就是字符串。你应该非常熟悉，这里就不多介绍了。着重看下，其他四种比较复杂点的数据类型，看看它们底层都依赖了哪些数据结构。</p><h2 id="列表（list）"><a href="#列表（list）" class="headerlink" title="列表（list）"></a>列表（list）</h2><p>先来看列表。列表这种数据类型支持存储一组数据。这种数据类型对应两种实现方法，一种是压缩列表（<code>ziplist</code>），另一种是双向循环链表。</p><p>当列表中存储的数据量比较小的时候，列表就可以采用压缩列表的方式实现。具体需要同时满足下面两个条件：</p><ul><li><p>列表中保存的单个数据（有可能是字符串类型的）小于 <code>64</code> 字节；</p></li><li><p>列表中数据个数少于 <code>512</code> 个。</p></li></ul><p>关于压缩列表，这里稍微解释一下。它并不是基础数据结构，而是 <code>Redis</code> 自己设计的一种数据存储结构。它有点儿类似数组，通过一片连续的内存空间，来存储数据。不过，它跟数组不同的一点是，它允许存储的数据大小不同。具体的存储结构也非常简单，可以看下面的这幅图。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/25/52db0a20-c718-11e9-913d-adef82c9ecf4.png" srcset="/img/loading.gif" alt="image.png"><br>现在来看看，压缩列表中的“压缩”两个字该如何理解？</p><p>听到“压缩”两个字，直观的反应就是节省内存。之所以说这种存储结构节省内存，是相较于数组的存储思路而言的。数组要求每个元素的大小相同，如果要存储不同长度的字符串，那就需要用最大长度的字符串大小作为元素的大小（假设是 <code>20</code> 个字节）。那当存储小于 <code>20</code> 个字节长度的字符串的时候，便会浪费部分存储空间。听起来有点儿拗口，下面有一幅图解释一下。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/25/73899b70-c72b-11e9-913d-adef82c9ecf4.png" srcset="/img/loading.gif" alt="image.png"><br>压缩列表这种存储结构，一方面比较节省内存，另一方面可以支持不同类型数据的存储。而且，因为数据存储在一片连续的内存空间，通过键来获取值为列表类型的数据，读取的效率也非常高。</p><p>当列表中存储的数据量比较大的时候，也就是不能同时满足刚刚讲的两个条件的时候，列表就要通过双向循环链表来实现了。</p><p>在链表里，已经讲过双向循环链表这种数据结构了，如果不记得了，你可以先去复习一下。这里着重看一下 <code>Redis</code> 中双向链表的编码实现方式。</p><p><code>Redis</code> 的这种双向链表的实现方式，非常值得借鉴。它额外定义一个 <code>list</code> 结构体，来组织链表的首、尾指针，还有长度等信息。这样，在使用的时候就会非常方便。</p><pre><code class="hljs c"><span class="hljs-comment">// 以下是 C 语言代码，因为 Redis 是用 C 语言实现的。</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listnode</span> &#123;</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">prev</span>;</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-keyword">void</span> *value;&#125; listNode;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> &#123;</span>  listNode *head;  listNode *tail;  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> len;  <span class="hljs-comment">// .... 省略其他定义</span>&#125; <span class="hljs-built_in">list</span>;</code></pre><h2 id="字典（hash）"><a href="#字典（hash）" class="headerlink" title="字典（hash）"></a>字典（hash）</h2><p>字典类型用来存储一组数据对。每个数据对又包含键值两部分。字典类型也有两种实现方式。一种是刚刚讲到的<strong>压缩列表</strong>，另一种是<strong>散列表</strong>。</p><p>同样，只有当存储的数据量比较小的情况下，<code>Redis</code> 才使用压缩列表来实现字典类型。具体需要满足两个条件：</p><ul><li><p>字典中保存的键和值的大小都要小于 <code>64</code> 字节；</p></li><li><p>字典中键值对的个数要小于 <code>512</code> 个。</p></li></ul><p>当不能同时满足上面两个条件的时候，<code>Redis</code> 就使用散列表来实现字典类型。<code>Redis</code> 使用 <code>MurmurHash2</code> 这种运行速度快、随机性好的哈希算法作为哈希函数。对于哈希冲突问题，<code>Redis</code> 使用链表法来解决。除此之外，<code>Redis</code> 还支持散列表的动态扩容、缩容。</p><p>当数据动态增加之后，散列表的装载因子会不停地变大。为了避免散列表性能的下降，当装载因子大于 <code>1</code> 的时候，<code>Redis</code> 会触发扩容，将散列表扩大为原来大小的 <code>2</code> 倍左右（具体值需要计算才能得到，如果感兴趣，你可以去阅读<a href="https://github.com/antirez/redis/blob/unstable/src/dict.c" target="_blank" rel="noopener">源码</a>）。</p><p>当数据动态减少之后，为了节省内存，当装载因子小于 <code>0.1</code> 的时候，<code>Redis</code> 就会触发缩容，缩小为字典中数据个数的大约 <code>2</code> 倍大小（这个值也是计算得到的，如果感兴趣，你也可以去阅读<a href="https://github.com/antirez/redis/blob/unstable/src/dict.c" target="_blank" rel="noopener">源码</a>）。</p><p>前面讲过，扩容缩容要做大量的数据搬移和哈希值的重新计算，所以比较耗时。针对这个问题，<code>Redis</code> 使用在<a href="../16/">散列表（中）</a>讲的渐进式扩容缩容策略，将数据的搬移分批进行，避免了大量数据一次性搬移导致的服务停顿。</p><h2 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h2><p>集合这种数据类型用来存储一组不重复的数据。这种数据类型也有两种实现方法，一种是基于<strong>有序数组</strong>，另一种是基于<strong>散列表</strong>。</p><p>当要存储的数据，同时满足下面这样两个条件的时候，<code>Redis</code> 就采用有序数组，来实现集合这种数据类型。</p><ul><li><p>存储的数据都是整数；</p></li><li><p>存储的数据元素个数不超过 <code>512</code> 个。</p></li></ul><p>当不能同时满足这两个条件的时候，<code>Redis</code> 就使用散列表来存储集合中的数据。</p><h2 id="有序集合（sortedset）"><a href="#有序集合（sortedset）" class="headerlink" title="有序集合（sortedset）"></a>有序集合（sortedset）</h2><p>有序集合这种数据类型，在跳表里已经详细讲过了。它用来存储一组数据，并且每个数据会附带一个得分。通过得分的大小，将数据组织成跳表这样的数据结构，以支持快速地按照得分值、得分区间获取数据。</p><p>实际上，跟 <code>Redis</code> 的其他数据类型一样，有序集合也并不仅仅只有跳表这一种实现方式。当数据量比较小的时候，<code>Redis</code> 会用压缩列表来实现有序集合。具体点说就是，使用压缩列表来实现有序集合的前提，有这样两个：</p><ul><li><p>所有数据的大小都要小于 <code>64</code> 字节；</p></li><li><p>元素个数要小于 <code>128</code> 个。</p></li></ul><h2 id="数据结构持久化"><a href="#数据结构持久化" class="headerlink" title="数据结构持久化"></a>数据结构持久化</h2><p>尽管 <code>Redis</code> 经常会被用作内存数据库，但是，它也支持数据落盘，也就是将内存中的数据存储到硬盘中。这样，当机器断电的时候，存储在 <code>Redis</code> 中的数据也不会丢失。在机器重新启动之后，<code>Redis</code> 只需要再将存储在硬盘中的数据，重新读取到内存，就可以继续工作了。</p><p>刚刚讲到，<code>Redis</code> 的数据格式由“键”和“值”两部分组成。而“值”又支持很多数据类型，比如字符串、列表、字典、集合、有序集合。像字典、集合等类型，底层用到了散列表，散列表中有指针的概念，而指针指向的是内存中的存储地址。 那 <code>Redis</code> 是如何将这样一个跟具体内存地址有关的数据结构存储到磁盘中的呢？</p><p>实际上，<code>Redis</code> 遇到的这个问题并不特殊，很多场景中都会遇到。它叫作<strong>数据结构的持久化问题</strong>，或者<strong>对象的持久化问题</strong>。这里的“持久化”，你可以笼统地可以理解为“存储到磁盘”。</p><p>如何将数据结构持久化到硬盘？主要有两种解决思路。</p><p>第一种是清除原有的存储结构，只将数据存储到磁盘中。当需要从磁盘还原数据到内存的时候，再重新将数据组织成原来的数据结构。实际上，<code>Redis</code> 采用的就是这种持久化思路。</p><p>不过，这种方式也有一定的弊端。那就是数据从硬盘还原到内存的过程，会耗用比较多的时间。比如，现在要将散列表中的数据存储到磁盘。当从磁盘中，取出数据重新构建散列表的时候，需要重新计算每个数据的哈希值。如果磁盘中存储的是几 <code>GB</code> 的数据，那重构数据结构的耗时就不可忽视了。</p><p>第二种方式是保留原来的存储格式，将数据按照原有的格式存储在磁盘中。拿散列表这样的数据结构来举例。可以将散列表的大小、每个数据被散列到的槽的编号等信息，都保存在磁盘中。有了这些信息，从磁盘中将数据还原到内存中的时候，就可以避免重新计算哈希值。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>上面讲了 <code>Redis</code> 中常用数据类型底层依赖的数据结构，总结一下大概有这五种：压缩列表（可以看作一种特殊的数组）、有序数组、链表、散列表、跳表。实际上，<code>Redis</code> 就是这些常用数据结构的封装。</p><p>你有没有发现，有了数据结构和算法的基础之后，再去阅读 <code>Redis</code> 的源码，理解起来就容易多了？很多原来觉得很深奥的设计思想，是不是就都会觉得顺理成章了呢？</p><p>还是那句话，<strong>夯实基础很重要</strong>。同样是看源码，有些人只能看个热闹，了解一些皮毛，无法形成自己的知识结构，不能化为己用，过不几天就忘了。而有些人基础很好，不但能知其然，还能知其所以然，从而真正理解作者设计的动机。这样不但能有助于理解所用的开源软件，还能为自己创新添砖加瓦。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>你有没有发现，在数据量比较小的情况下，<code>Redis</code> 中的很多数据类型，比如字典、有序集合等，都是通过多种数据结构来实现的，为什么会这样设计呢？用一种固定的数据结构来实现，不是更加简单吗？</p></li><li><p>讲到数据结构持久化有两种方法。对于二叉查找树这种数据结构，如何将它持久化到磁盘中呢？欢迎留言和我分享。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>48.并行算法</title>
    <link href="/passages/48/"/>
    <url>/passages/48/</url>
    
    <content type="html"><![CDATA[<p>时间复杂度是衡量算法执行效率的一种标准。但是，时间复杂度并不能跟性能划等号。在真实的软件开发中，即便在不降低时间复杂度的情况下，也可以通过一些优化手段，提升代码的执行效率。毕竟，对于实际的软件开发来说，即便是像 <code>10%</code>、<code>20%</code> 这样微小的性能提升，也是非常可观的。</p><p>算法的目的就是为了提高代码执行的效率。那当算法无法再继续优化的情况下，该如何来进一步提高执行效率呢？下面就讲一种非常简单但又非常好用的优化方法，那就是并行计算。通过几个例子展示一下，<strong>如何借助并行计算的处理思想对算法进行改造？</strong></p><h2 id="并行排序"><a href="#并行排序" class="headerlink" title="并行排序"></a>并行排序</h2><p>假设要给大小为 <code>8GB</code> 的数据进行排序，并且，机器的内存可以一次性容纳这么多数据。对于排序来说，最常用的就是时间复杂度为 $O(nlogn)$ 的三种排序算法，归并排序、快速排序、堆排序。从理论上讲，这个排序问题，已经很难再从算法层面优化了。而利用并行的处理思想，可以很轻松地将这个给 <code>8GB</code> 数据排序问题的执行效率提高很多倍。具体的实现思路有下面两种。</p><p><strong>第一种是对归并排序并行化处理。</strong>可以将这 <code>8GB</code> 的数据划分成 <code>16</code> 个小的数据集合，每个集合包含 <code>500MB</code> 的数据。用 <code>16</code> 个线程，并行地对这 <code>16</code> 个 <code>500MB</code> 的数据集合进行排序。这 <code>16</code> 个小集合分别排序完成之后，再将这 <code>16</code> 个有序集合合并。</p><p><strong>第二种是对快速排序并行化处理。</strong>通过扫描一遍数据，找到数据所处的范围区间。把这个区间从小到大划分成 <code>16</code> 个小区间。将 <code>8GB</code> 的数据划分到对应的区间中。针对这 <code>16</code> 个小区间的数据，启动 <code>16</code> 个线程，并行地进行排序。等到 <code>16</code> 个线程都执行结束之后，得到的数据就是有序数据了。</p><p>对比这两种处理思路，它们利用的都是分治的思想，对数据进行分片，然后并行处理。它们的区别在于，第一种处理思路是，先随意地对数据分片，排序之后再合并。第二种处理思路是，先对数据按照大小划分区间，然后再排序，排完序就不需要再处理了。这个跟归并和快排的区别如出一辙。</p><p>这里还要多说几句，如果要排序的数据规模不是 <code>8GB</code>，而是 <code>1TB</code>，那问题的重点就不是算法的执行效率了，而是数据的读取效率。因为 <code>1TB</code> 的数据肯定是存在硬盘中，无法一次性读取到内存中，这样在排序的过程中，就会有频繁地磁盘数据的读取和写入。如何减少磁盘的 <code>IO</code> 操作，减少磁盘数据读取和写入的总量，就变成了优化的重点。不过这个不是这里要讨论的重点，你可以自己思考下。</p><h2 id="并行查找"><a href="#并行查找" class="headerlink" title="并行查找"></a>并行查找</h2><p><strong>散列表</strong>是一种非常适合快速查找的数据结构。</p><p>如果是给动态数据构建索引，在数据不断加入的时候，散列表的装载因子就会越来越大。为了保证散列表性能不下降，就需要对散列表进行动态扩容。对如此大的散列表进行动态扩容，一方面比较耗时，另一方面比较消耗内存。比如，给一个 <code>2GB</code> 大小的散列表进行扩容，扩展到原来的 <code>1.5</code> 倍，也就是 <code>3GB</code> 大小。这个时候，实际存储在散列表中的数据只有不到 <code>2GB</code>，所以内存的利用率只有 <code>60%</code>，有 <code>1GB</code> 的内存是空闲的。</p><p>实际上，可以将数据随机分割成 <code>k</code> 份（比如 <code>16</code> 份），每份中的数据只有原来的 $\frac 1 k$，然后针对这 <code>k</code> 个小数据集合分别构建散列表。这样，散列表的维护成本就变低了。当某个小散列表的装载因子过大的时候，可以单独对这个散列表进行扩容，而其他散列表不需要进行扩容。</p><p>还是刚才那个例子，假设现在有 <code>2GB</code> 的数据，放到 <code>16</code> 个散列表中，每个散列表中的数据大约是 <code>150MB</code>。当某个散列表需要扩容的时候，只需要额外增加 <code>150 * 0.5 = 75MB</code> 的内存（假设还是扩容到原来的 <code>1.5</code> 倍）。不管从扩容的执行效率还是内存的利用率上，这种多个小散列表的处理方法，都要比大散列表高效。</p><p>当要查找某个数据的时候，只需要通过 <code>16</code> 个线程，并行地在这 <code>16</code> 个散列表中查找数据。这样的查找性能，比起一个大散列表的做法，也并不会下降，反倒有可能提高。</p><p>当往散列表中添加数据的时候，可以选择将这个新数据放入装载因子最小的那个散列表中，这样也有助于减少散列冲突。</p><h2 id="并行字符串匹配"><a href="#并行字符串匹配" class="headerlink" title="并行字符串匹配"></a>并行字符串匹配</h2><p>前面提到过，在文本中查找某个关键词这样一个功能，可以通过<strong>字符串匹配算法</strong>来实现。之前的字符串匹配算法有 <code>KMP</code>、<code>BM</code>、<code>RK</code>、<code>BF</code> 等。当在一个不是很长的文本中查找关键词的时候，这些字符串匹配算法中的任何一个，都可以表现得非常高效。但是，如果处理的是超级大的文本，那处理的时间可能就会变得很长，那有没有办法加快匹配速度呢？</p><p>可以把大的文本，分割成 <code>k</code> 个小文本。假设 <code>k</code> 是 <code>16</code>，就启动 <code>16</code> 个线程，并行地在这 <code>16</code> 个小文本中查找关键词，这样整个查找的性能就提高了 <code>16</code> 倍。<code>16</code> 倍效率的提升，从理论的角度来说并不多。但是，对于真实的软件开发来说，这显然是一个非常可观的优化。</p><p>不过，这里还有一个细节要处理，那就是原本包含在大文本中的关键词，被一分为二，分割到两个小文本中，这就会导致尽管大文本中包含这个关键词，但在这 <code>16</code> 个小文本中查找不到它。实际上，这个问题也不难解决，只需要针对这种特殊情况，做一些特殊处理就可以了。</p><p>假设关键词的长度是 <code>m</code>。在每个小文本的结尾和开始各取 <code>m</code> 个字符串。前一个小文本的末尾 <code>m</code> 个字符和后一个小文本的开头 <code>m</code> 个字符，组成一个长度是 <code>2m</code> 的字符串。再拿关键词在这个长度为 <code>2m</code> 的字符串中再重新查找一遍，就可以补上刚才的漏洞了。</p><h2 id="并行搜索"><a href="#并行搜索" class="headerlink" title="并行搜索"></a>并行搜索</h2><p>前面学习过好几种搜索算法，它们分别是广度优先搜索、深度优先搜索、<code>Dijkstra</code> 最短路径算法、<code>A*</code> 启发式搜索算法。对于广度优先搜索算法，也可以将其改造成并行算法。</p><p>广度优先搜索是一种逐层搜索的搜索策略。基于当前这一层顶点，可以启动多个线程，并行地搜索下一层的顶点。在代码实现方面，原来广度优先搜索的代码实现，是通过一个队列来记录已经遍历到但还没有扩展的顶点。现在，经过改造之后的并行广度优先搜索算法，需要利用两个队列来完成扩展顶点的工作。</p><p>假设这两个队列分别是队列 <code>A</code> 和队列 <code>B</code>。多线程并行处理队列 <code>A</code> 中的顶点，并将扩展得到的顶点存储在队列 <code>B</code> 中。等队列 <code>A</code> 中的顶点都扩展完成之后，队列 <code>A</code> 被清空，再并行地扩展队列 <code>B</code> 中的顶点，并将扩展出来的顶点存储在队列 <code>A</code>。这样两个队列循环使用，就可以实现并行广度优先搜索算法。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>上一篇通过实际软件开发中的“索引”这一技术点，回顾了之前的一些支持动态数据集合的数据结构。本篇又通过“并行算法”这个话题，回顾了之前学过的一些算法。</p><p>本篇内容比较简单，没有太复杂的知识点。通过一些例子，比如并行排序、查找、搜索、字符串匹配，展示了并行处理的实现思路，也就是对数据进行分片，对没有依赖关系的任务，并行地执行。</p><p>并行计算是一个工程上的实现思路，尽管跟算法关系不大，但是，在实际的软件开发中，它确实可以非常巧妙地提高程序的运行效率，是一种非常好用的性能优化手段。</p><p>特别是，当要处理的数据规模达到一定程度之后，无法通过继续优化算法，来提高执行效率的时候，就需要在实现的思路上做文章，利用更多的硬件资源，来加快执行的效率。所以，在很多超大规模数据处理中，并行处理的思想，应用非常广泛，比如 <code>MapReduce</code> 实际上就是一种并行计算框架。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>假设有 <code>n</code> 个任务，为了提高执行的效率，希望能并行执行任务，但是各个任务之间又有一定的依赖关系，如何根据依赖关系找出可以并行执行的任务？欢迎留言和我分享。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(高级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>47.索引</title>
    <link href="/passages/47/"/>
    <url>/passages/47/</url>
    
    <content type="html"><![CDATA[<p><code>MySQL</code> 底层依赖的是 <code>B+</code> 树这种数据结构。那类似 <code>Redis</code> 这样的 <code>Key-Value</code> 数据库中的索引，又是怎么实现的呢？底层依赖的又是什么数据结构呢？</p><h2 id="为什么需要索引？"><a href="#为什么需要索引？" class="headerlink" title="为什么需要索引？"></a>为什么需要索引？</h2><p>在实际的软件开发中，业务纷繁复杂，功能千变万化，但是，万变不离其宗。如果抛开这些业务和功能的外壳，其实它们的本质都可以抽象为“对数据的存储和计算”。对应到数据结构和算法中，那“存储”需要的就是数据结构，“计算”需要的就是算法。</p><p>对于存储的需求，功能上无外乎增删改查。这其实并不复杂。但是，一旦存储的数据很多，那性能就成了这些系统要关注的重点，特别是在一些跟存储相关的基础系统（比如 <code>MySQL</code> 数据库、分布式文件系统等）、中间件（比如消息中间件 <code>RocketMQ</code> 等）中。</p><p>“如何节省存储空间、如何提高数据增删改查的执行效率”，这样的问题就成了设计的重点。而这些系统的实现，都离不开一个东西，那就是索引。不夸张地说，索引设计得好坏，直接决定了这些系统是否优秀。</p><p>索引这个概念，非常好理解。你可以类比书籍的目录来理解。如果没有目录，想要查找某个知识点的时候，就要一页一页翻。通过目录，就可以快速定位相关知识点的页数，查找的速度也会有质的提高。</p><h2 id="索引的需求定义"><a href="#索引的需求定义" class="headerlink" title="索引的需求定义"></a>索引的需求定义</h2><p>索引的概念不难理解，你应该已经搞明白。接下来就分析一下，在设计索引的过程中，需要考虑到的一些因素，换句话说就是，该如何定义清楚需求呢？</p><p>对于系统设计需求，一般可以从<strong>功能性需求</strong>和<strong>非功能性需求</strong>两方面来分析。</p><h3 id="1-功能性需求"><a href="#1-功能性需求" class="headerlink" title="1. 功能性需求"></a>1. 功能性需求</h3><p>对于功能性需求需要考虑的点，它们大致可以概括成下面这几点。</p><p><strong>数据是格式化数据还是非格式化数据？</strong>要构建索引的原始数据，类型有很多。这里把它分为两类，一类是结构化数据，比如，<code>MySQL</code> 中的数据；另一类是非结构化数据，比如搜索引擎中网页。对于非结构化数据，一般需要做预处理，提取出查询关键词，对关键词构建索引。</p><p><strong>数据是静态数据还是动态数据？</strong>如果原始数据是一组静态数据，也就是说，不会有数据的增加、删除、更新操作，所以，在构建索引的时候，只需要考虑查询效率就可以了。这样，索引的构建就相对简单些。不过，大部分情况下，都是对动态数据构建索引，也就是说，不仅要考虑到索引的查询效率，在原始数据更新的同时，还需要动态地更新索引。支持动态数据集合的索引，设计起来相对也要更加复杂些。</p><p><strong>索引存储在内存还是硬盘？</strong>如果索引存储在内存中，那查询的速度肯定要比存储在磁盘中的高。但是，如果原始数据量很大的情况下，对应的索引可能也会很大。这个时候，因为内存有限，可能就不得不将索引存储在磁盘中了。实际上，还有第三种情况，那就是一部分存储在内存，一部分存储在磁盘，这样就可以兼顾内存消耗和查询效率。</p><p><strong>单值查找还是区间查找？</strong>所谓单值查找，也就是根据查询关键词等于某个值的数据。这种查询需求最常见。所谓区间查找，就是查找关键词处于某个区间值的所有数据。你可以类比 <code>MySQL</code> 数据库的查询需求，自己想象一下。实际上，不同的应用场景，查询的需求会多种多样。</p><p><strong>单关键词查找还是多关键词组合查找？</strong>比如，搜索引擎中构建的索引，既要支持一个关键词的查找，比如“数据结构”，也要支持组合关键词查找，比如“数据结构 <code>AND</code> 算法”。对于单关键词的查找，索引构建起来相对简单些。对于多关键词查询来说，要分多种情况。像 <code>MySQL</code> 这种结构化数据的查询需求，可以实现针对多个关键词的组合，建立索引；对于像搜索引擎这样的非结构数据的查询需求，可以针对单个关键词构建索引，然后通过集合操作，比如求并集、求交集等，计算出多个关键词组合的查询结果。</p><p>实际上，不同的场景，不同的原始数据，对于索引的需求也会千差万别。这里只列举了一些比较有共性的需求。</p><h3 id="2-非功能性需求"><a href="#2-非功能性需求" class="headerlink" title="2. 非功能性需求"></a>2. 非功能性需求</h3><p>看完了功能性需求，再来看看，索引设计的非功能性需求。</p><p><strong>不管是存储在内存中还是磁盘中，索引对存储空间的消耗不能过大。</strong>如果存储在内存中，索引对占用存储空间的限制就会非常苛刻。毕竟内存空间非常有限，一个中间件启动后就占用几个 <code>GB</code> 的内存，开发者显然是无法接受的。如果存储在硬盘中，那索引对占用存储空间的限制，稍微会放宽一些。但是，也不能掉以轻心。因为，有时候，索引对存储空间的消耗会超过原始数据。</p><p><strong>在考虑索引查询效率的同时，我们还要考虑索引的维护成本。</strong>索引的目的是提高查询效率，但是，基于动态数据集合构建的索引，还要考虑到索引的维护成本。因为在原始数据动态增删改的同时，也需要动态的更新索引。而索引的更新势必会影响到增删改操作的性能。</p><h2 id="构建索引常用的数据结构有哪些？"><a href="#构建索引常用的数据结构有哪些？" class="headerlink" title="构建索引常用的数据结构有哪些？"></a>构建索引常用的数据结构有哪些？</h2><p>刚刚从很宏观的角度，总结了在索引设计的过程中，需要考虑的一些共性因素。现在，就来看看，对于不同需求的索引结构，底层一般使用哪种数据结构。</p><p>实际上，常用来构建索引的数据结构，就是之前讲过的几种支持动态数据集合的数据结构。比如，散列表、红黑树、跳表、<code>B+</code> 树。除此之外，位图、布隆过滤器可以作为辅助索引，有序数组可以用来对静态数据构建索引。</p><p><strong>散列表</strong>增删改查操作的性能非常好，时间复杂度是 $O(1)$。一些键值数据库，比如 <code>Redis</code>、<code>Memcache</code>，就是使用散列表来构建索引的。这类索引，一般都构建在内存中。</p><p><strong>红黑树</strong>作为一种常用的平衡二叉查找树，数据插入、删除、查找的时间复杂度是 $O(logn)$，也非常适合用来构建内存索引。<code>Ext</code> 文件系统中，对磁盘块的索引，用的就是红黑树。</p><p><strong><code>B+</code> 树</strong>比起红黑树来说，更加适合构建存储在磁盘中的索引。<code>B+</code> 树是一个多叉树，所以，对相同个数的数据构建索引，<code>B+</code> 树的高度要低于红黑树。当借助索引查询数据的时候，读取 <code>B+</code> 树索引，需要的磁盘 <code>IO</code> 次数非常更少。所以，大部分关系型数据库的索引，比如 <code>MySQL</code>、<code>Oracle</code>，都是用 <code>B+</code> 树来实现的。</p><p><strong>跳表</strong>也支持快速添加、删除、查找数据。而且，通过灵活调整索引结点个数和数据个数之间的比例，可以很好地平衡索引对内存的消耗及其查询效率。<code>Redis</code> 中的有序集合，就是用跳表来构建的。</p><p>除了散列表、红黑树、<code>B+</code> 树、跳表之外，位图和布隆过滤器这两个数据结构，也可以用于索引中，辅助存储在磁盘中的索引，加速数据查找的效率。下面来看下，具体是怎么做的？</p><p><strong>布隆过滤器</strong>有一定的判错率。但是，可以规避它的短处，发挥它的长处。尽管对于判定存在的数据，有可能并不存在，但是对于判定不存在的数据，那肯定就不存在。而且，布隆过滤器还有一个更大的特点，那就是内存占用非常少。可以针对数据，构建一个布隆过滤器，并且存储在内存中。当要查询数据的时候，可以先通过布隆过滤器，判定是否存在。如果通过布隆过滤器判定数据不存在，那就没有必要读取磁盘中的索引了。对于数据不存在的情况，数据查询就更加快速了。</p><p>实际上，有序数组也可以被作为索引。如果数据是静态的，也就是不会有插入、删除、更新操作，那可以把数据的关键词（查询用的）抽取出来，组织成有序数组，然后利用二分查找算法来快速查找数据。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>上面的内容从索引这个非常常用的技术方案，展示了散列表、红黑树、跳表、位图、布隆过滤器、有序数组这些数据结构的应用场景。学习完之后，不知道你对这些数据结构以及索引，有没有更加清晰的认识呢？</p><p>你应该可以看出，架构设计离不开数据结构和算法。要想成长为一个优秀的业务架构师、基础架构师，数据结构和算法的根基一定要打稳。因为，那些看似很惊艳的架构设计思路，实际上，都是来自最常用的数据结构和算法。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>你知道基础系统、中间件、开源软件等系统中，有哪些用到了索引吗？这些系统的索引是如何实现的呢？欢迎留言和我分享。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(高级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>46.搜索</title>
    <link href="/passages/46/"/>
    <url>/passages/46/</url>
    
    <content type="html"><![CDATA[<p>魔兽世界、仙剑奇侠传这类 <code>MMRPG</code> 游戏，不知道你有没有玩过？在这些游戏中，有一个非常重要的功能，那就是人物角色自动寻路。<strong>当人物处于游戏地图中的某个位置的时候，用鼠标点击另外一个相对较远的位置，人物就会自动地绕过障碍物走过去。玩过这么多游戏，不知你是否思考过，这个功能是怎么实现的呢？</strong></p><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><p>实际上，这是一个非常典型的搜索问题。人物的起点就是他当下所在的位置，终点就是鼠标点击的位置。我们需要在地图中，找一条从起点到终点的路径。这条路径要绕过地图中所有障碍物，并且看起来要是一种非常聪明的走法。所谓“聪明”，笼统地解释就是，走的路不能太绕。理论上讲，最短路径显然是最聪明的走法，是这个问题的最优解。</p><p>不过，在<a href="../41/">第 41 篇</a>最优出行路线规划问题中，提到过，如果图非常大，那 <code>Dijkstra</code> 最短路径算法的执行耗时会很多。在真实的软件开发中，面对的是超级大的地图和海量的寻路请求，算法的执行效率太低，这显然是无法接受的。</p><p>实际上，像出行路线规划、游戏寻路，这些真实软件开发中的问题，一般情况下，都不需要非得求最优解（也就是最短路径）。在权衡路线规划质量和执行效率的情况下，只需要寻求一个次优解就足够了。那<strong>如何快速找出一条接近于最短路线的次优路线呢？</strong></p><p>这个快速的路径规划算法，就是 <code>A*</code> 算法。实际上，<code>A*</code> 算法是对 <code>Dijkstra</code> 算法的优化和改造。如何将 <code>Dijkstra</code> 算法改造成 <code>A*</code> 算法呢？为了更好地理解接下来要讲的内容，建议你先温习下<a href="../41/">第 41 篇</a>中的 <code>Dijkstra</code> 算法的实现原理。</p><p><code>Dijkstra</code> 算法有点儿类似 <code>BFS</code> 算法，它每次找到跟起点最近的顶点，往外扩展。这种往外扩展的思路，其实有些盲目。为什么这么说呢？举一个例子来解释一下。下面这个图对应一个真实的地图，每个顶点在地图中的位置，用一个二维坐标<code>(x,y)</code>来表示，其中，<code>x</code> 表示横坐标，<code>y</code> 表示纵坐标。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/22/f1f902f0-c48a-11e9-808b-1970743a43bb.png" srcset="/img/loading.gif" alt="image.png"><br>在 <code>Dijkstra</code> 算法的实现思路中，用一个优先级队列，来记录已经遍历到的顶点以及这个顶点与起点的路径长度。顶点与起点路径长度越小，就越先被从优先级队列中取出来扩展，从图中举的例子可以看出，尽管找的是从 <code>s</code> 到 <code>t</code> 的路线，但是最先被搜索到的顶点依次是 <code>1</code>，<code>2</code>，<code>3</code>。通过肉眼来观察，这个搜索方向跟期望的路线方向（<code>s</code> 到 <code>t</code> 是从西向东）是反着的，路线搜索的方向明显“跑偏”了。</p><p>之所以会“跑偏”，那是因为按照顶点与起点的路径长度的大小，来安排出队列顺序的。与起点越近的顶点，就会越早出队列。并没有考虑到这个顶点到终点的距离，所以，在地图中，尽管 <code>1</code>，<code>2</code>，<code>3</code> 三个顶点离起始顶点最近，但离终点却越来越远。</p><p>如果综合更多的因素，把这个顶点到终点可能还要走多远，也考虑进去，综合来判断哪个顶点该先出队列，那是不是就可以避免“跑偏”呢？</p><p>当遍历到某个顶点的时候，从起点走到这个顶点的路径长度是确定的，记作 <code>g(i)</code>（<code>i</code> 表示顶点编号）。但是，从这个顶点到终点的路径长度是未知的。虽然确切的值无法提前知道，但是可以用其他估计值来代替。</p><p>这里可以通过这个顶点跟终点之间的直线距离，也就是<strong>欧几里得距离</strong>，来近似地估计这个顶点跟终点的路径长度（注意：路径长度跟直线距离是两个概念）。把这个距离记作 <code>h(i)</code>（<code>i</code> 表示这个顶点的编号），专业的叫法是<strong>启发函数</strong>（<code>heuristic function</code>）。因为欧几里得距离的计算公式，会涉及比较耗时的开根号计算，所以，一般通过另外一个更加简单的距离计算公式，那就是<strong>曼哈顿距离</strong>（<code>Manhattan distance</code>）。曼哈顿距离是两点之间横纵坐标的距离之和。计算的过程只涉及加减法、符号位反转，所以比欧几里得距离更加高效。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hManhattan</span><span class="hljs-params">(Vertex v1, Vertex v2)</span> </span>&#123; <span class="hljs-comment">// Vertex 表示顶点，后面有定义</span>  <span class="hljs-keyword">return</span> Math.abs(v1.x - v2.x) + Math.abs(v1.y - v2.y);&#125;</code></pre><p>原来只是单纯地通过顶点与起点之间的路径长度 <code>g(i)</code>，来判断谁先出队列，现在有了顶点到终点的路径长度估计值，通过两者之和 <code>f(i)=g(i)+h(i)</code>，来判断哪个顶点该最先出队列。综合两部分，就能有效避免刚刚讲的“跑偏”。这里 <code>f(i)</code> 的专业叫法是<strong>估价函数</strong>（<code>evaluation function</code>）。    </p><p>从刚刚的描述，可以发现，<code>A*</code> 算法就是对 <code>Dijkstra</code> 算法的简单改造。实际上，代码实现方面，也只需要稍微改动几行代码，就能把 <code>Dijkstra</code> 算法的代码实现，改成 <code>A*</code> 算法的代码实现。</p><p>在 <code>A*</code> 算法的代码实现中，顶点 <code>Vertex</code> 类的定义，跟 <code>Dijkstra</code> 算法中的定义，稍微有点儿区别，多了 <code>x</code>，<code>y</code> 坐标，以及刚刚提到的 <code>f(i)</code> 值。图 <code>Graph</code> 类的定义跟 <code>Dijkstra</code> 算法中的定义一样。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vertex</span> </span>&#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id; <span class="hljs-comment">// 顶点编号 ID</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> dist; <span class="hljs-comment">// 从起始顶点，到这个顶点的距离，也就是 g(i)</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> f; <span class="hljs-comment">// 新增：f(i)=g(i)+h(i)</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> x, y; <span class="hljs-comment">// 新增：顶点在地图中的坐标（x, y）</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vertex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;    <span class="hljs-keyword">this</span>.id = id;    <span class="hljs-keyword">this</span>.x = x;    <span class="hljs-keyword">this</span>.y = y;    <span class="hljs-keyword">this</span>.f = Integer.MAX_VALUE;    <span class="hljs-keyword">this</span>.dist = Integer.MAX_VALUE;  &#125;&#125;<span class="hljs-comment">// Graph 类的成员变量，在构造函数中初始化</span>Vertex[] vertexes = <span class="hljs-keyword">new</span> Vertex[<span class="hljs-keyword">this</span>.v];<span class="hljs-comment">// 新增一个方法，添加顶点的坐标</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addVetex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;  vertexes[id] = <span class="hljs-keyword">new</span> Vertex(id, x, y)&#125;</code></pre><p><code>A*</code> 算法的代码实现的主要逻辑是下面这段代码。它跟 <code>Dijkstra</code> 算法的代码实现，主要有 <code>3</code> 点区别：</p><ul><li><p>优先级队列构建的方式不同。<code>A*</code> 算法是根据 <code>f</code> 值（也就是刚刚讲到的 <code>f(i)=g(i)+h(i)</code>）来构建优先级队列，而 <code>Dijkstra</code> 算法是根据 <code>dist</code> 值（也就是刚刚讲到的 <code>g(i)</code>）来构建优先级队列；</p></li><li><p><code>A*</code> 算法在更新顶点 <code>dist</code> 值的时候，会同步更新 <code>f</code> 值；</p></li><li><p>循环结束的条件也不一样。<code>Dijkstra</code> 算法是在终点出队列的时候才结束，<code>A*</code> 算法是一旦遍历到终点就结束。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">astar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123; <span class="hljs-comment">// 从顶点 s 到顶点 t 的路径</span>  <span class="hljs-keyword">int</span>[] predecessor = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">this</span>.v]; <span class="hljs-comment">// 用来还原路径</span>  <span class="hljs-comment">// 按照 vertex 的 f 值构建的小顶堆，而不是按照 dist</span>  PriorityQueue queue = <span class="hljs-keyword">new</span> PriorityQueue(<span class="hljs-keyword">this</span>.v);  <span class="hljs-keyword">boolean</span>[] inqueue = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-keyword">this</span>.v]; <span class="hljs-comment">// 标记是否进入过队列</span>  vertexes[s].dist = <span class="hljs-number">0</span>;  vertexes[s].f = <span class="hljs-number">0</span>;  queue.add(vertexes[s]);  inqueue[s] = <span class="hljs-keyword">true</span>;  <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;    Vertex minVertex = queue.poll(); <span class="hljs-comment">// 取堆顶元素并删除</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; adj[minVertex.id].size(); ++i) &#123;      Edge e = adj[minVertex.id].get(i); <span class="hljs-comment">// 取出一条 minVetex 相连的边</span>      Vertex nextVertex = vertexes[e.tid]; <span class="hljs-comment">// minVertex--&gt;nextVertex</span>      <span class="hljs-keyword">if</span> (minVertex.dist + e.w &lt; nextVertex.dist) &#123; <span class="hljs-comment">// 更新 next 的 dist,f</span>        nextVertex.dist = minVertex.dist + e.w;        nextVertex.f            = nextVertex.dist+hManhattan(nextVertex, vertexes[t]);        predecessor[nextVertex.id] = minVertex.id;        <span class="hljs-keyword">if</span> (inqueue[nextVertex.id] == <span class="hljs-keyword">true</span>) &#123;          queue.update(nextVertex);        &#125; <span class="hljs-keyword">else</span> &#123;          queue.add(nextVertex);          inqueue[nextVertex.id] = <span class="hljs-keyword">true</span>;        &#125;      &#125;      <span class="hljs-keyword">if</span> (nextVertex.id == t) &#123; <span class="hljs-comment">// 只要到达 t 就可以结束 while 了</span>        queue.clear(); <span class="hljs-comment">// 清空 queue，才能退出 while 循环</span>        <span class="hljs-keyword">break</span>;       &#125;    &#125;  &#125;  <span class="hljs-comment">// 输出路径</span>  System.out.print(s);  print(s, t, predecessor); <span class="hljs-comment">// print 函数请参看 Dijkstra 算法的实现</span>&#125;</code></pre></li></ul><p><strong>尽管 <code>A*</code> 算法可以更加快速的找到从起点到终点的路线，但是它并不能像 <code>Dijkstra</code> 算法那样，找到最短路线。这是为什么呢？</strong></p><p>要找出起点 <code>s</code> 到终点 <code>t</code> 的最短路径，最简单的方法是，通过回溯穷举所有从 <code>s</code> 到达 <code>t</code> 的不同路径，然后对比找出最短的那个。不过很显然，回溯算法的执行效率非常低，是指数级的。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/22/486d8280-c48d-11e9-808b-1970743a43bb.png" srcset="/img/loading.gif" alt="image.png"><br><code>Dijkstra</code> 算法在此基础之上，利用动态规划的思想，对回溯搜索进行了剪枝，只保留起点到某个顶点的最短路径，继续往外扩展搜索。动态规划相较于回溯搜索，只是换了一个实现思路，但它实际上也考察到了所有从起点到终点的路线，所以才能得到最优解。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/22/60f829e0-c48d-11e9-808b-1970743a43bb.png" srcset="/img/loading.gif" alt="image.png"><br><code>A*</code> 算法之所以不能像 <code>Dijkstra</code> 算法那样，找到最短路径，主要原因是两者的 <code>while</code> 循环结束条件不一样。刚刚提到，<code>Dijkstra</code> 算法是在终点出队列的时候才结束，<code>A*</code> 算法是一旦遍历到终点就结束。对于 <code>Dijkstra</code> 算法来说，当终点出队列的时候，终点的 <code>dist</code> 值是优先级队列中所有顶点的最小值，即便再运行下去，终点的 <code>dist</code> 值也不会再被更新了。对于 <code>A*</code> 算法来说，一旦遍历到终点，就结束 <code>while</code> 循环，这个时候，终点的 <code>dist</code> 值未必是最小值。</p><p><code>A*</code> 算法利用贪心算法的思路，每次都找 <code>f</code> 值最小的顶点出队列，一旦搜索到终点就不在继续考察其他顶点和路线了。所以，它并没有考察所有的路线，也就不可能找出最短路径了。</p><p>搞懂了 <code>A*</code> 算法，再来看下，<strong>如何借助 A* 算法解决游戏寻路问题？</strong></p><p>要利用 <code>A*</code> 算法解决这个问题，只需要把地图，抽象成图就可以了。不过，游戏中的地图跟<a href="../41/">第 41 篇</a>中讲的平常用的地图是不一样的。因为游戏中的地图并不像现实生活中那样，存在规划非常清晰的道路，更多的是宽阔的荒野、草坪等。所以，没法利用 41 篇中讲到的抽象方法，把岔路口抽象成顶点，把道路抽象成边。</p><p>实际上，可以换一种抽象的思路，把整个地图分割成一个一个的小方块。在某一个方块上的人物，只能往上下左右四个方向的方块上移动。可以把每个方块看作一个顶点。两个方块相邻，就在它们之间，连两条有向边，并且边的权值都是 <code>1</code>。所以，这个问题就转化成了，在一个有向有权图中，找某个顶点到另一个顶点的路径问题。将地图抽象成边权值为 <code>1</code> 的有向图之后，就可以套用 <code>A*</code> 算法，来实现游戏中人物的自动寻路功能了。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p><code>A*</code> 算法属于一种<strong>启发式搜索算法</strong>（<code>Heuristically Search Algorithm</code>）。实际上，启发式搜索算法并不仅仅只有 <code>A*</code> 算法，还有很多其他算法，比如 <code>IDA*</code> 算法、蚁群算法、遗传算法、模拟退火算法等。</p><p>启发式搜索算法利用估价函数，避免“跑偏”，贪心地朝着最有可能到达终点的方向前进。这种算法找出的路线，并不是最短路线。但是，实际的软件开发中的路线规划问题，往往并不需要非得找最短路线。所以，鉴于启发式搜索算法能很好地平衡路线质量和执行效率，它在实际的软件开发中的应用更加广泛。实际上，在<a href="https://muchen.fun/passages/41/">第 41 篇</a>中，讲到的地图 <code>App</code> 中的出行路线规划问题，也可以利用启发式搜索算法来实现。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>之前讲的“迷宫问题”是否可以借助 <code>A*</code> 算法来更快速地找到一个走出去的路线呢？如果可以，请具体讲讲该怎么来做；如果不可以，请说说原因。欢迎留言和我分享。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(高级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>45. B+树</title>
    <link href="/passages/45/"/>
    <url>/passages/45/</url>
    
    <content type="html"><![CDATA[<p>数据库作为主流的数据存储系统，它在业务开发中，有着举足轻重的地位。在工作中，为了加速数据库中数据的查找速度，常用的处理思路是，对表中数据创建索引。那你是否思考过，数据库索引是如何实现的呢？底层使用的是什么数据结构和算法呢？</p><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><h3 id="1-解决问题的前提是定义清楚问题"><a href="#1-解决问题的前提是定义清楚问题" class="headerlink" title="1. 解决问题的前提是定义清楚问题"></a>1. 解决问题的前提是定义清楚问题</h3><p>如何定义清楚问题呢？除了对问题进行详细的调研，还有一个办法，那就是，通过<strong>对一些模糊的需求进行假设，来限定要解决的问题的范围。</strong></p><p>如果你对数据库的操作非常了解，针对现在这个问题，你就能把索引的需求定义得非常清楚。但是，对于大部分软件工程师来说，可能只了解一小部分常用的 <code>SQL</code> 语句，所以，这里假设要解决的问题，只包含这样两个常用的需求：</p><ul><li><p>根据某个值查找数据，比如 <code>SELECT * FROM user WHRER id=1234</code>；</p></li><li><p>根据区间值来查找某些数据，比如 <code>SELECT * FROM user WHRER id &gt; 1234 AND id &lt; 2345</code>。</p></li></ul><p>除了这些功能性需求之外，这种问题往往还会涉及一些非功能性需求，比如安全、性能、用户体验等等。性能方面的需求主要考察时间和空间两方面，也就是<strong>执行效率和存储空间</strong>。</p><p>在执行效率方面，希望通过索引，查询数据的效率尽可能的高；在存储空间方面，希望索引不要消耗太多的内存空间。</p><h3 id="2-尝试用学过的数据结构解决这个问题"><a href="#2-尝试用学过的数据结构解决这个问题" class="headerlink" title="2. 尝试用学过的数据结构解决这个问题"></a>2. 尝试用学过的数据结构解决这个问题</h3><p>问题的需求大致定义清楚了，现在回想一下，能否利用已经学习过的数据结构解决这个问题呢？支持快速查询、插入等操作的动态数据结构，已经学习过散列表、平衡二叉查找树、跳表。</p><p>先来看<strong>散列表</strong>。散列表的查询性能很好，时间复杂度是 $O(1)$。但是，散列表不能支持按照区间快速查找数据。所以，散列表不能满足我们的需求。</p><p>再来看<strong>平衡二叉查找树</strong>。尽管平衡二叉查找树查询的性能也很高，时间复杂度是 $O(logn)$。而且，对树进行中序遍历，还可以得到一个从小到大有序的数据序列，但这仍然不足以支持按照区间快速查找数据。</p><p>再来看<strong>跳表</strong>。跳表是在链表之上加上多层索引构成的。它支持快速地插入、查找、删除数据，对应的时间复杂度是 $O(logn)$。并且，跳表也支持按照区间快速地查找数据。只需要定位到区间起点值对应在链表中的结点，然后从这个结点开始，顺序遍历链表，直到区间终点对应的结点为止，这期间遍历得到的数据就是满足区间值的数据。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/21/92dc2ca0-c3c4-11e9-a9c0-05ac7c3e725c.png" srcset="/img/loading.gif" alt="image.png"><br>这样看来，跳表是可以解决这个问题。实际上，数据库索引所用到的数据结构跟跳表非常相似，叫作 <code>B+</code> 树。不过，它是通过二叉查找树演化过来的，而非跳表。为了还原发明 <code>B+</code> 树的整个思考过程，所以，接下来，还再从二叉查找树讲起，看它是如何一步一步被改造成 <code>B+</code> 树的。</p><h3 id="3-改造二叉查找树来解决这个问题"><a href="#3-改造二叉查找树来解决这个问题" class="headerlink" title="3. 改造二叉查找树来解决这个问题"></a>3. 改造二叉查找树来解决这个问题</h3><p>为了让二叉查找树支持按照区间来查找数据，可以对它进行这样的改造：树中的节点并不存储数据本身，而是只是作为索引。除此之外，把每个叶子节点串在一条链表上，链表中的数据是从小到大有序的。经过改造之后的二叉树，就像图中这样，看起来是不是很像跳表呢？<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/21/331b6dc0-c3c5-11e9-a9c0-05ac7c3e725c.png" srcset="/img/loading.gif" alt="image.png"><br>改造之后，如果要求某个区间的数据。只需要拿区间的起始值，在树中进行查找，当查找到某个叶子节点之后，再顺着链表往后遍历，直到链表中的结点数据值大于区间的终止值为止。所有遍历到的数据，就是符合区间值的所有数据。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/21/4fa640a0-c3c5-11e9-a9c0-05ac7c3e725c.png" srcset="/img/loading.gif" alt="image.png"><br>但是，要为几千万、上亿的数据构建索引，如果将索引存储在内存中，尽管内存访问的速度非常快，查询的效率非常高，但是，占用的内存会非常多。</p><p>比如，给一亿个数据构建二叉查找树索引，那索引中会包含大约 <code>1</code> 亿个节点，每个节点假设占用 <code>16</code> 个字节，那就需要大约 <code>1GB</code> 的内存空间。给一张表建立索引，需要 <code>1GB</code> 的内存空间。如果要给 <code>10</code> 张表建立索引，那对内存的需求是无法满足的。如何解决这个索引占用太多内存的问题呢？</p><p>可以借助时间换空间的思路，把索引存储在硬盘中，而非内存中。硬盘是一个非常慢速的存储设备。通常内存的访问速度是纳秒级别的，而磁盘访问的速度是毫秒级别的。读取同样大小的数据，从磁盘中读取花费的时间，是从内存中读取所花费时间的上万倍，甚至几十万倍。</p><p>这种将索引存储在硬盘中的方案，尽管减少了内存消耗，但是在数据查找的过程中，需要读取磁盘中的索引，因此数据查询效率就相应降低很多。</p><p>二叉查找树，经过改造之后，支持区间查找的功能就实现了。不过，为了节省内存，如果把树存储在硬盘中，那么每个节点的读取（或者访问），都对应一次磁盘 <code>IO</code> 操作。树的高度就等于每次查询数据时磁盘 <code>IO</code> 操作的次数。</p><p>前面讲到，比起内存读写操作，磁盘 <code>IO</code> 操作非常耗时，所以优化的重点就是尽量减少磁盘 <code>IO</code> 操作，也就是，尽量降低树的高度。那如何降低树的高度呢？</p><p>来看下，如果把索引构建成 <code>m</code> 叉树，高度是不是比二叉树要小呢？如图所示，给 <code>16</code> 个数据构建二叉树索引，树的高度是 <code>4</code>，查找一个数据，就需要 <code>4</code> 个磁盘 <code>IO</code> 操作（如果根节点存储在内存中，其他结点存储在磁盘中），如果对 <code>16</code> 个数据构建五叉树索引，那高度只有 <code>2</code>，查找一个数据，对应只需要 <code>2</code> 次磁盘操作。如果 <code>m</code> 叉树中的 <code>m</code> 是 <code>100</code>，那对一亿个数据构建索引，树的高度也只是 <code>3</code>，最多只要 <code>3</code> 次磁盘 <code>IO</code> 就能获取到数据。磁盘 <code>IO</code> 变少了，查找数据的效率也就提高了。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/21/17aa79e0-c3c6-11e9-a9c0-05ac7c3e725c.png" srcset="/img/loading.gif" alt="image.png"><br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/21/19e4d980-c3c6-11e9-a9c0-05ac7c3e725c.png" srcset="/img/loading.gif" alt="image.png"><br>如果将 <code>m</code> 叉树实现 <code>B+</code> 树索引，用代码实现出来，就是下面这个样子（假设给 <code>int</code> 类型的数据库字段添加索引，所以代码中的 <code>keywords</code> 是 <code>int</code> 类型的）：</p><pre><code class="hljs java"><span class="hljs-comment">/** * 这是 B+ 树非叶子节点的定义。 * * 假设 keywords=[3, 5, 8, 10] * 4 个键值将数据分为 5 个区间：(-INF,3), [3,5), [5,8), [8,10), [10,INF) * 5 个区间分别对应：children[0]...children[4] * * m 值是事先计算得到的，计算的依据是让所有信息的大小正好等于页的大小： * PAGE_SIZE = (m-1)*4[keywordss 大小]+m*8[children 大小] */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BPlusTreeNode</span> </span>&#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> m = <span class="hljs-number">5</span>; <span class="hljs-comment">// 5 叉树</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] keywords = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m-<span class="hljs-number">1</span>]; <span class="hljs-comment">// 键值，用来划分数据区间</span>  <span class="hljs-keyword">public</span> BPlusTreeNode[] children = <span class="hljs-keyword">new</span> BPlusTreeNode[m];<span class="hljs-comment">// 保存子节点指针</span>&#125;<span class="hljs-comment">/** * 这是 B+ 树中叶子节点的定义。 * * B+ 树中的叶子节点跟内部结点是不一样的, * 叶子节点存储的是值，而非区间。 * 这个定义里，每个叶子节点存储 3 个数据行的键值及地址信息。 * * k 值是事先计算得到的，计算的依据是让所有信息的大小正好等于页的大小： * PAGE_SIZE = k*4[keyw.. 大小]+k*8[dataAd.. 大小]+8[prev 大小]+8[next 大小] */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BPlusTreeLeafNode</span> </span>&#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> k = <span class="hljs-number">3</span>;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] keywords = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k]; <span class="hljs-comment">// 数据的键值</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span>[] dataAddress = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[k]; <span class="hljs-comment">// 数据地址</span>  <span class="hljs-keyword">public</span> BPlusTreeLeafNode prev; <span class="hljs-comment">// 这个结点在链表中的前驱结点</span>  <span class="hljs-keyword">public</span> BPlusTreeLeafNode next; <span class="hljs-comment">// 这个结点在链表中的后继结点</span>&#125;</code></pre><p>对于相同个数的数据构建 <code>m</code> 叉树索引，<code>m</code> 叉树中的 <code>m</code> 越大，那树的高度就越小，那 <code>m</code> 叉树中的 <code>m</code> 是不是越大越好呢？到底多大才最合适呢？</p><p>不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是 <code>4KB</code>，这个值可以通过 <code>getconfig PAGE_SIZE</code> 命令查看）来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 <code>IO</code> 操作。所以，在选择 <code>m</code> 大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘 <code>IO</code> 操作。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/21/67a7ec70-c3c6-11e9-a9c0-05ac7c3e725c.png" srcset="/img/loading.gif" alt="image.png"><br>尽管索引可以提高数据库的查询效率，但是，作为一名开发工程师，你应该也知道，索引有利也有弊，它也会让写入数据的效率下降。这是为什么呢？</p><p>数据的写入过程，会涉及索引的更新，这是索引导致写入变慢的主要原因。</p><p>对于一个 <code>B+</code> 树来说，<code>m</code> 值是根据页的大小事先计算好的，也就是说，每个节点最多只能有 <code>m</code> 个子节点。在往数据库中写入数据的过程中，这样就有可能使索引中某些节点的子节点个数超过 <code>m</code>，这个节点的大小超过了一个页的大小，读取这样一个节点，就会导致多次磁盘 <code>IO</code> 操作。该如何解决这个问题呢？</p><p>实际上，处理思路并不复杂。只需要将这个节点分裂成两个节点。但是，节点分裂之后，其上层父节点的子节点个数就有可能超过 <code>m</code> 个。不过这也没关系，可以用同样的方法，将父节点也分裂成两个节点。这种级联反应会从下往上，一直影响到根节点。这个分裂过程，你可以结合着下面这个图一块看，会更容易理解（图中的 <code>B+</code> 树是一个三叉树。限定叶子节点中，数据的个数超过 <code>2</code> 个就分裂节点；非叶子节点中，子节点的个数超过 <code>3</code> 个就分裂节点）。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/21/a9cfa750-c3c6-11e9-a9c0-05ac7c3e725c.png" srcset="/img/loading.gif" alt="image.png"><br>正是因为要时刻保证 <code>B+</code> 树索引是一个 <code>m</code> 叉树，所以，索引的存在会导致数据库写入的速度降低。实际上，不光写入数据会变慢，删除数据也会变慢。这是为什么呢？</p><p>在删除某个数据的时候，也要对应的更新索引节点。这个处理思路有点类似跳表中删除数据的处理思路。频繁的数据删除，就会导致某些结点中，子节点的个数变得非常少，长此以往，如果每个节点的子节点都比较少，势必会影响索引的效率。</p><p>可以设置一个阈值。在 <code>B+</code> 树中，这个阈值等于 $\frac m 2$。如果某个节点的子节点个数小于 $\frac m 2$，就将它跟相邻的兄弟节点合并。不过，合并之后结点的子节点个数有可能会超过 <code>m</code>。针对这种情况，可以借助插入数据时候的处理方法，再分裂节点。</p><p>文字描述不是很直观，下面举了一个删除操作的例子，你可以对比着看下（图中的 <code>B+</code> 树是一个五叉树。限定叶子节点中，数据的个数少于 <code>2</code> 个就合并节点；非叶子节点中，子节点的个数少于 <code>3</code> 个就合并节点。）。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/21/fa21c990-c3c6-11e9-a9c0-05ac7c3e725c.png" srcset="/img/loading.gif" alt="image.png"><br>数据库索引以及 <code>B+</code> 树的由来，到此就讲完了。你有没有发现，<code>B+</code> 树的结构和操作，跟跳表非常类似。理论上讲，对跳表稍加改造，也可以替代 <code>B+</code> 树，作为数据库的索引实现的。</p><p><code>B+</code> 树发明于 <code>1972</code> 年，跳表发明于 <code>1989</code> 年，可以大胆猜想下，跳表的作者有可能就是受了 <code>B+</code> 树的启发，才发明出跳表来的。不过，这个也无从考证了。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>数据库索引实现，依赖的底层数据结构是 <code>B+</code> 树。它通过存储在磁盘的多叉树结构，做到了时间、空间的平衡，既保证了执行效率，又节省了内存。</p><p>前面的讲解中，为了一步一步详细地介绍 <code>B+</code> 树的由来，内容看起来比较零散。为了方便掌握和记忆，这里再总结一下 <code>B+</code> 树的特点：</p><ul><li><p>每个节点中子节点的个数不能超过 <code>m</code>，也不能小于 $\frac m 2$；</p></li><li><p>根节点的子节点个数可以不超过 $\frac m 2$，这是一个例外；</p></li><li><p><code>m</code> 叉树只存储索引，并不真正存储数据，这个有点儿类似跳表；</p></li><li><p>通过链表将叶子节点串联在一起，这样可以方便按区间查找；</p></li><li><p>一般情况，根节点会被存储在内存中，其他节点存储在磁盘中。</p></li></ul><p>除了 <code>B+</code> 树，你可能还听说过 <code>B</code> 树、<code>B-</code> 树，这里简单提一下。实际上，<code>B-</code> 树就是 <code>B</code> 树，英文翻译都是 <code>B-Tree</code>，这里的“-”并不是相对 <code>B+</code> 树中的“+”，而只是一个连接符。这个很容易误解，所以强调下。</p><p>而 <code>B</code> 树实际上是低级版的 <code>B+</code> 树，或者说 <code>B+</code> 树是 <code>B</code> 树的改进版。<code>B</code> 树跟 <code>B+</code> 树的不同点主要集中在这几个地方：</p><ul><li><p><code>B+</code> 树中的节点不存储数据，只是索引，而 <code>B</code> 树中的节点存储数据；</p></li><li><p><code>B</code> 树中的叶子节点并不需要链表来串联。</p></li></ul><p>也就是说，<code>B</code> 树只是一个每个节点的子节点个数不能小于 $\frac m 2$ 的 <code>m</code> 叉树。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p><code>B+</code> 树中，将叶子节点串起来的链表，是单链表还是双向链表？为什么？</p></li><li><p>对平衡二叉查找树进行改造，将叶子节点串在链表中，就支持了按照区间来查找数据。在散列表（下）讲到，散列表也经常跟链表一块使用，如果把散列表中的结点，也用链表串起来，能否支持按照区间查找数据呢？欢迎留言和我分享。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(高级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>44.向量空间</title>
    <link href="/passages/44/"/>
    <url>/passages/44/</url>
    
    <content type="html"><![CDATA[<p>很多人都喜爱听歌，以前用 <code>MP3</code> 听歌，现在直接通过音乐 <code>App</code> 在线就能听歌。而且，各种音乐 <code>App</code> 的功能越来越强大，不仅可以自己选歌听，还可以根据你听歌的口味偏好，给你推荐可能会喜爱的音乐，而且有时候，推荐的音乐还非常适合你的口味，甚至会惊艳到你！如此智能的一个功能，它是怎么实现的呢？</p><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><p>实际上，要解决这个问题，并不需要特别高深的理论。解决思路的核心思想非常简单、直白，用两句话就能总结出来。</p><ul><li><p>找到跟你口味偏好相似的用户，把他们爱听的歌曲推荐给你；</p></li><li><p>找出跟你喜爱的歌曲特征相似的歌曲，把这些歌曲推荐给你。</p></li></ul><p>接下来，就分别讲解一下这两种思路的具体实现方法。</p><h3 id="1-基于相似用户做推荐"><a href="#1-基于相似用户做推荐" class="headerlink" title="1. 基于相似用户做推荐"></a>1. 基于相似用户做推荐</h3><p>如何找到跟你口味偏好相似的用户呢？或者说如何定义口味偏好相似呢？实际上，思路也很简单，把跟你听类似歌曲的人，看做口味相似的用户。你可以看下面的这个图。用“1”表示“喜爱”，用“0”笼统地表示“不发表意见”。从图中可以看出，跟小明共同喜爱的歌曲最多，有 <code>5</code> 首。于是，就可以说，小明跟你的口味非常相似。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/20/278b6490-c2fa-11e9-8ea1-bd65331ffb8a.png" srcset="/img/loading.gif" alt="image.png"><br>只需要遍历所有的用户，对比每个用户跟你共同喜爱的歌曲个数，并且设置一个阈值，如果你和某个用户共同喜爱的歌曲个数超过这个阈值，就把这个用户看作跟你口味相似的用户，把这个用户喜爱但你还没听过的歌曲，推荐给你。</p><p>不过，刚刚的这个解决方案中有一个问题，如何知道用户喜爱哪首歌曲呢？也就是说，如何定义用户对某首歌曲的喜爱程度呢？</p><p>实际上，可以通过用户的行为，来定义这个喜爱程度。给每个行为定义一个得分，得分越高表示喜爱程度越高。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/20/a7df90d0-c2fa-11e9-8ea1-bd65331ffb8a.png" srcset="/img/loading.gif" alt="image.png"><br>还是刚刚那个例子，如果把每个人对每首歌曲的喜爱程度表示出来，就是下面这个样子。图中，某个人对某首歌曲是否喜爱，不再用“1”或者“0”来表示，而是对应一个具体的分值。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/20/cbd1fd20-c2fa-11e9-8ea1-bd65331ffb8a.png" srcset="/img/loading.gif" alt="image.png"><br>有了这样一个用户对歌曲的喜爱程度的对应表之后，如何来判断两个用户是否口味相似呢？</p><p>显然，不能再像之前那样，采用简单的计数来统计两个用户之间的相似度。还记得之前讲字符串相似度度量时，提到的编辑距离吗？这里的相似度度量，可以使用另外一个距离，那就是<strong>欧几里得距离</strong>（<code>Euclidean distance</code>）。欧几里得距离是用来计算两个向量之间的距离的。这个概念中有两个关键词，<strong>向量</strong>和<strong>距离</strong>，下面解释一下。</p><p>一维空间是一条线，用 <code>1</code>，<code>2</code>，<code>3</code>……这样单个的数，来表示一维空间中的某个位置；<br>二维空间是一个面，用 <code>(1,3)</code> <code>(4,2)</code> <code>(2,2)</code>……这样的两个数，来表示二维空间中的某个位置；<br>三维空间是一个立体空间，用 <code>(1,3,5)</code> <code>(3,1,7)</code> <code>(2,4,3)</code>……这样的三个数，来表示三维空间中的某个位置。<br>一维、二维、三维应该都不难理解，那更高维中的某个位置该如何表示呢？</p><p>类比一维、二维、三维的表示方法，<code>K</code> 维空间中的某个位置，可以写作（$X_1$，$X_2$，$X_3$，…，$X_K$）。这种表示方法就是<strong>向量</strong>（<code>vector</code>）。二维、三维空间中，两个位置之间有距离的概念，类比到高纬空间，同样也有距离的概念，这就是两个向量之间的距离。</p><p>那如何计算两个向量之间的距离呢？还是可以类比到二维、三维空间中距离的计算方法。通过类比，就可以得到两个向量之间距离的计算公式。这个计算公式就是欧几里得距离的计算公式：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/20/8401a170-c2fb-11e9-8ea1-bd65331ffb8a.png" srcset="/img/loading.gif" alt="image.png"><br>把每个用户对所有歌曲的喜爱程度，都用一个向量表示。计算出两个向量之间的欧几里得距离，作为两个用户的口味相似程度的度量。从图中的计算可以看出，小明与你的欧几里得距离距离最小，也就是说，你俩在高维空间中靠得最近，所以就可以断定，小明跟你的口味最相似。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/20/a422e180-c2fb-11e9-8ea1-bd65331ffb8a.png" srcset="/img/loading.gif" alt="image.png"></p><h3 id="2-基于相似歌曲做推荐"><a href="#2-基于相似歌曲做推荐" class="headerlink" title="2. 基于相似歌曲做推荐"></a>2. 基于相似歌曲做推荐</h3><p>但是，如果用户是一个新用户，还没有收集到足够多的行为数据，这个时候该如何推荐呢？现在再来看另外一种推荐方法，基于相似歌曲的推荐方法，也就是说，如果某首歌曲跟你喜爱的歌曲相似，就把它推荐给你。</p><p>如何判断两首歌曲是否相似呢？对于人来说，这个事情可能会比较简单，但是对于计算机来说，判断两首歌曲是否相似，那就需要通过量化的数据来表示了。应该通过什么数据来量化两个歌曲之间的相似程度呢？</p><p>最容易想到的是，对歌曲定义一些特征项，比如是伤感的还是愉快的，是摇滚还是民谣，是柔和的还是高亢的等等。类似基于相似用户的推荐方法，给每个歌曲的每个特征项打一个分数，这样每个歌曲就都对应一个特征项向量。可以基于这个特征项向量，来计算两个歌曲之间的欧几里得距离。欧几里得距离越小，表示两个歌曲的相似程度越大。</p><p>但是，要实现这个方案，需要有一个前提，那就是能够找到足够多，并且能够全面代表歌曲特点的特征项，除此之外，还要人工给每首歌标注每个特征项的得分。对于收录了海量歌曲的音乐 <code>App</code> 来说，这显然是一个非常大的工程。此外，人工标注有很大的主观性，也会影响到推荐的准确性。</p><p>既然基于歌曲特征项计算相似度不可行，那就换一种思路。对于两首歌，如果喜欢听的人群都是差不多的，那侧面就可以反映出，这两首歌比较相似。如图所示，每个用户对歌曲有不同的喜爱程度，依旧通过上一个解决方案中定义得分的标准，来定义喜爱程度。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/20/0b5d6cd0-c2fc-11e9-8ea1-bd65331ffb8a.png" srcset="/img/loading.gif" alt="image.png"><br>你有没有发现，这个图跟基于相似用户推荐中的图几乎一样。只不过这里把歌曲和用户主次颠倒了一下。基于相似用户的推荐方法中，针对每个用户，将对各个歌曲的喜爱程度作为向量。基于相似歌曲的推荐思路中，针对每个歌曲，将每个用户的打分作为向量。</p><p>有了每个歌曲的向量表示，通过计算向量之间的欧几里得距离，来表示歌曲之间的相似度。欧几里得距离越小，表示两个歌曲越相似。然后，就在用户已经听过的歌曲中，找出他喜爱程度较高的歌曲。然后，找出跟这些歌曲相似度很高的其他歌曲，推荐给他。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>实际上，这个问题是<strong>推荐系统</strong>（<code>Recommendation System</code>）里最典型的一类问题。之所以讲这部分内容，主要是想展示，算法的强大之处，利用简单的向量空间的欧几里得距离，就能解决如此复杂的问题。不过，上面只讲解了基本的理论，实践中遇到的问题还有很多，比如冷启动问题，产品初期积累的数据不多，不足以做推荐等等。这些更加深奥的内容，你可以之后自己在实践中慢慢探索。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>关于上面的推荐算法，你还能想到其他应用场景吗？欢迎留言和我分享。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(高级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>43.概率统计</title>
    <link href="/passages/43/"/>
    <url>/passages/43/</url>
    
    <content type="html"><![CDATA[<p>垃圾短信和骚扰电话，每个人都收到过吧？买房、贷款、投资理财、开发票，各种垃圾短信和骚扰电话，不胜其扰。<strong>如果你是一名手机应用开发工程师，让你实现一个简单的垃圾短信过滤功能以及骚扰电话拦截功能，该用什么样的数据结构和算法实现呢？</strong></p><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><p>实际上，解决这个问题并不会涉及很高深的算法。下面就一起看下，如何利用简单的数据结构和算法，解决这种看似非常复杂的问题。</p><h3 id="1-基于黑名单的过滤器"><a href="#1-基于黑名单的过滤器" class="headerlink" title="1. 基于黑名单的过滤器"></a>1. 基于黑名单的过滤器</h3><p>可以维护一个骚扰电话号码和垃圾短信发送号码的黑名单。这个黑名单的搜集，有很多途径，比如，可以从一些公开的网站上下载，也可以通过类似“手机自带的骚扰电话拦截”的功能，通过用户自主标记骚扰电话来收集。对于被多个用户标记，并且标记个数超过一定阈值的号码，就可以定义为骚扰电话，并将它加入到我们的黑名单中。</p><p>如果黑名单中的电话号码不多的话，可以使用散列表、二叉树等动态数据结构来存储，对内存的消耗并不会很大。如果把每个号码看作一个字符串，并且假设平均长度是 <code>16</code> 个字节，那存储 <code>50</code> 万个电话号码，大约需要 <code>10MB</code> 的内存空间。即便是对于手机这样的内存有限的设备来说，这点内存的消耗也是可以接受的。</p><p>但是，如果黑名单中的电话号码很多呢？比如有 <code>500</code> 万个。这个时候，如果再用散列表存储，就需要大约 <code>100MB</code> 的存储空间。为了实现一个拦截功能，耗费用户如此多的手机内存，这显然有点儿不合理。</p><p>上一篇提到，布隆过滤器最大的特点就是比较省存储空间，所以，用它来解决这个问题再合适不过了。如果要存储 <code>500</code> 万个手机号码，把位图大小设置为 <code>10</code> 倍数据大小，也就是 <code>5000</code> 万，那也只需要使用 <code>5000</code> 万个二进制位（<code>5000</code> 万 <code>bits</code>），换算成字节，也就是不到 <code>7MB</code> 的存储空间。比起散列表的解决方案，内存的消耗减少了很多。</p><p>实际上，还有一种时间换空间的方法，可以将内存的消耗优化到极致。</p><p>可以把黑名单存储在服务器端上，把过滤和拦截的核心工作，交给服务器端来做。手机端只负责将要检查的号码发送给服务器端，服务器端通过查黑名单，判断这个号码是否应该被拦截，并将结果返回给手机端。</p><p>用这个解决思路完全不需要占用手机内存。不过，有利就有弊。网络通信是比较慢的，所以，网络延迟就会导致处理速度降低。而且，这个方案还有个硬性要求，那就是只有在联网的情况下，才能正常工作。</p><p>不过，你可能还会说，布隆过滤器会有判错的概率呀！如果它把一个重要的电话或者短信，当成垃圾短信或者骚扰电话拦截了，对于用户来说，这是无法接受的。你说的没错，这是一个很大的问题。不过，现在先放一放，等三种过滤器都讲完之后，再来解答。</p><h3 id="2-基于规则的过滤器"><a href="#2-基于规则的过滤器" class="headerlink" title="2. 基于规则的过滤器"></a>2. 基于规则的过滤器</h3><p>刚刚讲了一种基于黑名单的垃圾短信过滤方法，但是，如果某个垃圾短信发送者的号码并不在黑名单中，那这种方法就没办法拦截了。所以，基于黑名单的过滤方式，还不够完善，再继续看一种基于规则的过滤方式。</p><p>对于垃圾短信来说，还可以通过短信的内容，来判断某条短信是否是垃圾短信。预先设定一些规则，如果某条短信符合这些规则，就可以判定它是垃圾短信。实际上，规则可以有很多，比如下面这几个：</p><ul><li><p>短信中包含特殊单词（或词语），比如一些非法、淫秽、反动词语等；</p></li><li><p>短信发送号码是群发号码，非正常的手机号码，比如 <code>+60389585</code>；</p></li><li><p>短信中包含回拨的联系方式，比如手机号码、微信、<code>QQ</code>、网页链接等，因为群发短信的号码一般都是无法回拨的；</p></li><li><p>短信格式花哨、内容很长，比如包含各种表情、图片、网页链接等；</p></li><li><p>符合已知垃圾短信的模板。垃圾短信一般都是重复群发，对于已经判定为垃圾短信的短信，可以抽象成模板，将获取到的短信与模板匹配，一旦匹配，就可以判定为垃圾短信。</p></li></ul><p>当然，如果短信只是满足其中一条规则，就判定为垃圾短信，那会存在比较大的误判的情况。可以综合多条规则进行判断。比如，满足 <code>2</code> 条以上才会被判定为垃圾短信；或者每条规则对应一个不同的得分，满足哪条规则，就累加对应的分数，某条短信的总得分超过某个阈值，才会被判定为垃圾短信。</p><p>不过，上面只是给出了一些制定规则的思路，具体落实到执行层面，其实还有很大的距离，还有很多细节需要处理。比如，第一条规则中，该如何定义特殊单词；第二条规则中，该如何定义什么样的号码是群发号码等等。限于篇幅，就不一一详细展开来讲了。这里只讲一下，如何定义特殊单词？</p><p>如果只是自己盘脑袋想，哪些单词属于特殊单词，那势必有比较大的主观性，也很容易漏掉某些单词。实际上，可以基于概率统计的方法，借助计算机强大的计算能力，找出哪些单词最常出现在垃圾短信中，将这些最常出现的单词，作为特殊单词，用来过滤短信。</p><p>不过这种方法的前提是，有大量的样本数据，也就是说，要有大量的短信（比如 <code>1000</code> 万条短信），并且还要求每条短信都做好了标记，它是垃圾短信还是非垃圾短信。</p><p>对这 <code>1000</code> 万条短信，进行分词处理（借助中文或者英文分词算法），去掉“的、和、是”等没有意义的停用词（<code>Stop words</code>），得到 <code>n</code> 个不同的单词。针对每个单词，统计有多少个垃圾短信出现了这个单词，有多少个非垃圾短信会出现这个单词，进而求出每个单词出现在垃圾短信中的概率，以及出现在非垃圾短信中的概率。如果某个单词出现在垃圾短信中的概率，远大于出现在非垃圾短信中的概率，那就把这个单词作为特殊单词，用来过滤垃圾短信。</p><p>文字描述不好理解，举个例子来解释一下。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/19/01cae150-c231-11e9-9aac-61b696f29a37.png" srcset="/img/loading.gif" alt="image.png"></p><h3 id="3-基于概率统计的过滤器"><a href="#3-基于概率统计的过滤器" class="headerlink" title="3. 基于概率统计的过滤器"></a>3. 基于概率统计的过滤器</h3><p>基于规则的过滤器，看起来很直观，也很好理解，但是它也有一定的局限性。一方面，这些规则受人的思维方式局限，规则未免太过简单；另一方面，垃圾短信发送者可能会针对规则，精心设计短信，绕过这些规则的拦截。对此，再来看一种更加高级的过滤方式，基于概率统计的过滤方式。</p><p>这种基于概率统计的过滤方式，基础理论是基于<strong>朴素贝叶斯算法</strong>。为了让你更好地理解下面的内容，先通过一个非常简单的例子来看下，什么是朴素贝叶斯算法？</p><p>假设事件 <code>A</code> 是“小明不去上学”，事件 <code>B</code> 是“下雨了”。现在统计了一下过去 <code>10</code> 天的下雨情况和小明上学的情况，作为样本数据。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/19/49a02990-c231-11e9-9aac-61b696f29a37.png" srcset="/img/loading.gif" alt="image.png"><br>先来分析一下，这组样本有什么规律。在这 <code>10</code> 天中，有 <code>4</code> 天下雨，所以下雨的概率 $P(B)= \frac 4 {10}$。<code>10</code> 天中有 <code>3</code> 天，小明没有去上学，所以小明不去上学的概率 $P(A)= \frac 3 {10}$。在 <code>4</code> 个下雨天中，小明有 <code>2</code> 天没去上学，所以下雨天不去上学的概率 $P(A|B)= \frac 2 4$。在小明没有去上学的 <code>3</code> 天中，有 <code>2</code> 天下雨了，所以小明因为下雨而不上学的概率是 $P(B|A)= \frac 2 3$。实际上，这 <code>4</code> 个概率值之间，有一定的关系，这个关系就是朴素贝叶斯算法，用公式表示出来，就是下面这个样子。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/19/f41c6b40-c231-11e9-9aac-61b696f29a37.png" srcset="/img/loading.gif" alt="image.png"><br>朴素贝叶斯算法是不是非常简单？用一个公式就可以将它概括。弄懂了朴素贝叶斯算法，再回到垃圾短信过滤这个问题上，看看如何利用朴素贝叶斯算法，来做垃圾短信的过滤。</p><p>基于概率统计的过滤器，是基于短信内容来判定是否是垃圾短信。而计算机没办法像人一样理解短信的含义。所以，需要把短信抽象成一组计算机可以理解并且方便计算的特征项，用这一组特征项代替短信本身，来做垃圾短信过滤。</p><p>可以通过分词算法，把一个短信分割成 <code>n</code> 个单词。这 <code>n</code> 个单词就是一组特征项，全权代表这个短信。因此，判定一个短信是否是垃圾短信这样一个问题，就变成了，判定同时包含这几个单词的短信是否是垃圾短信。</p><p>不过，这里并不像基于规则的过滤器那样，非黑即白，一个短信要么被判定为垃圾短信、要么被判定为非垃圾短信。使用概率，来表征一个短信是垃圾短信的可信程度。如果用公式将这个概率表示出来，就是下面这个样子：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/19/422e8890-c232-11e9-9aac-61b696f29a37.png" srcset="/img/loading.gif" alt="image.png"><br>尽管有大量的短信样本，但是没法通过样本数据统计得到这个概率。为什么不可以呢？你可能会说，只需要统计同时包含 $W_1$，$W_2$，$W_3$，…，$W_n$ 这 <code>n</code> 个单词的短信有多少个（假设有 <code>x</code> 个），然后看这里面属于垃圾短信的有几个（假设有 <code>y</code> 个），那包含 $W_1$，$W_2$，$W_3$，…，$W_n$ 这 <code>n</code> 个单词的短信是垃圾短信的概率就是 $\frac y x$。</p><p>理想很丰满，但现实往往很骨感。你忽视了非常重要的一点，那就是样本的数量再大，毕竟也是有限的，样本中不会有太多同时包含 $W_1$，$W_2$，$W_3$，…，$W_n$ 的短信的，甚至很多时候，样本中根本不存在这样的短信。没有样本，也就无法计算概率。所以这样的推理方式虽然正确，但是实践中并不好用。</p><p>这个时候，朴素贝叶斯公式就可以派上用场了。通过朴素贝叶斯公式，将这个概率的求解，分解为其他三个概率的求解。你可以看下面的图。那转化之后的三个概率是否可以通过样本统计得到呢？<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/19/af5b4b60-c232-11e9-9aac-61b696f29a37.png" srcset="/img/loading.gif" alt="image.png"><br>$P$（$W_1$，$W_2$，$W_3$，…，$W_n$ 同时出现在一条短信中 | 短信是垃圾短信）这个概率照样无法通过样本来统计得到。但是可以基于下面这条著名的概率规则来计算。</p><blockquote><p>独立事件发生的概率计算公式：$P(A * B) = P(A) * P(B)$</p></blockquote><blockquote><p>如果事件 <code>A</code> 和事件 <code>B</code> 是独立事件，两者的发生没有相关性，事件 <code>A</code>发生的概率 $P(A)$ 等于 <code>p1</code>，事件 <code>B</code> 发生的概率 $P(B)$ 等于 <code>p2</code>，那两个同时发生的概率 $P(A * B)$ 就等于 $P(A) * P(B)$。</p></blockquote><p>基于这条独立事件发生概率的计算公式，可以把 $P$（$W_1$，$W_2$，$W_3$，…，$W_n$ 同时出现在一条短信中 | 短信是垃圾短信）分解为下面这个公式：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/19/0a62d280-c233-11e9-9aac-61b696f29a37.png" srcset="/img/loading.gif" alt="image.png"><br>其中，$P$（$W_i$ 出现在短信中 | 短信是垃圾短信）表示垃圾短信中包含 $W_i$ 这个单词的概率有多大。这个概率值通过统计样本很容易就能获得。假设垃圾短信有 <code>y</code> 个，其中包含 $W_i$ 的有 <code>x</code> 个，那这个概率值就等于 $\frac x y$。</p><p>$P$（$W_1$，$W_2$，$W_3$，…，$W_n$ 同时出现在一条短信中 | 短信是垃圾短信）这个概率值，就计算出来了，再来看下剩下两个。</p><p>$P$（短信是垃圾短信）表示短信是垃圾短信的概率，这个很容易得到。把样本中垃圾短信的个数除以总样本短信个数，就是短信是垃圾短信的概率。</p><p>不过，$P$（$W_1$，$W_2$，$W_3$，…，$W_n$ 同时出现在一条短信中）这个概率还是不好通过样本统计得到，原因前面说过了，样本空间有限。不过，没必要非得计算这一部分的概率值。为什么这么说呢？</p><p>实际上，可以分别计算同时包含 $W_1$，$W_2$，$W_3$，…，$W_n$ 这 <code>n</code> 个单词的短信，是垃圾短信和非垃圾短信的概率。假设它们分别是 <code>p1</code> 和 <code>p2</code>。并不需要单纯地基于 <code>p1</code> 值的大小来判断是否是垃圾短信，而是通过对比 <code>p1</code> 和 <code>p2</code> 值的大小，来判断一条短信是否是垃圾短信。更细化一点讲，那就是，如果 <code>p1</code> 是 <code>p2</code> 的很多倍（比如 <code>10</code> 倍），才确信这条短信是垃圾短信。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/19/a37cb350-c233-11e9-9aac-61b696f29a37.png" srcset="/img/loading.gif" alt="image.png"><br>基于这两个概率的倍数来判断是否是垃圾短信的方法，就可以不用计算 $P$（$W_1$，$W_2$，$W_3$，…，$W_n$ 同时出现在一条短信中）这一部分的值了，因为计算 <code>p1</code> 与 <code>p2</code> 的时候，都会包含这个概率值的计算，所以在求解 <code>p1</code> 和 <code>p2</code> 倍数（<code>p1/p2</code>）的时候，也就不需要这个值。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>上面讲了基于黑名单、规则、概率统计三种垃圾短信的过滤方法，实际上，讲的这三种方法，还可以应用到很多类似的过滤、拦截的领域，比如垃圾邮件的过滤等等。</p><p>在讲黑名单过滤的时候，提到布隆过滤器可能会存在误判情况，可能会导致用户投诉。实际上，可以结合三种不同的过滤方式的结果，对同一个短信处理，如果三者都表明这个短信是垃圾短信，才把它当作垃圾短信拦截过滤，这样就会更精准。</p><p>当然，在实际的工程中，还需要结合具体的场景，以及大量的实验，不断去调整策略，权衡垃圾短信判定的<strong>准确率</strong>（是否会把不是垃圾的短信错判为垃圾短信）和<strong>召回率</strong>（是否能把所有的垃圾短信都找到），来实现我们的需求。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>关于垃圾短信过滤和骚扰电话的拦截，可以一块儿头脑风暴一下，看看你还有没有其他方法呢？欢迎留言和我分享。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(高级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>42.位图</title>
    <link href="/passages/42/"/>
    <url>/passages/42/</url>
    
    <content type="html"><![CDATA[<p>网页爬虫是搜索引擎中的非常重要的系统，负责爬取几十亿、上百亿的网页。爬虫的工作原理是，通过解析已经爬取页面中的网页链接，然后再爬取这些链接对应的网页。<strong>而同一个网页链接有可能被包含在多个页面中，这就会导致爬虫在爬取的过程中，重复爬取相同的网页。如果你是一名负责爬虫的工程师，你会如何避免这些重复的爬取呢？</strong></p><p>最容易想到的方法就是，记录已经爬取的网页链接（也就是 <code>URL</code>），在爬取一个新的网页之前，拿它的链接，在已经爬取的网页链接列表中搜索。如果存在，那就说明这个网页已经被爬取过了；如果不存在，那就说明这个网页还没有被爬取过，可以继续去爬取。等爬取到这个网页之后，将这个网页的链接添加到已经爬取的网页链接列表了。</p><p>思路非常简单，应该很容易就能想到。不过，该如何记录已经爬取的网页链接呢？需要用什么样的数据结构呢？</p><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><p>这个问题要处理的对象是网页链接，也就是 <code>URL</code>，需要支持的操作有两个，添加一个 <code>URL</code> 和查询一个 <code>URL</code>。除了这两个功能性的要求之外，在非功能性方面，还要求这两个操作的执行效率要尽可能高。除此之外，因为要处理的是上亿的网页链接，内存消耗会非常大，所以在存储效率上，要尽可能地高效。</p><p>回想一下，满足这些条件的数据结构有哪些呢？显然，散列表、红黑树、跳表这些动态数据结构，都能支持快速地插入、查找数据，但是对内存消耗方面，是否可以接受呢？</p><p>拿散列表来举例。假设要爬取 <code>10</code> 亿个网页（像 <code>Google</code>、百度这样的通用搜索引擎，爬取的网页可能会更多），为了判重，把这 <code>10</code> 亿网页链接存储在散列表中。估算下，大约需要多少内存？</p><p>假设一个 <code>URL</code> 的平均长度是 <code>64</code> 字节，那单纯存储这 <code>10</code> 亿个 <code>URL</code>，需要大约 <code>60GB</code> 的内存空间。因为散列表必须维持较小的装载因子，才能保证不会出现过多的散列冲突，导致操作的性能下降。而且，用链表法解决冲突的散列表，还会存储链表指针。所以，如果将这 <code>10</code> 亿个 <code>URL</code> 构建成散列表，那需要的内存空间会远大于 <code>60GB</code>，有可能会超过 <code>100GB</code>。</p><p>当然，对于一个大型的搜索引擎来说，即便是 <code>100GB</code> 的内存要求，其实也不算太高，可以采用分治的思想，用多台机器（比如 <code>20</code> 台内存是 <code>8GB</code> 的机器）来存储这 <code>10</code> 亿网页链接。</p><p>对于爬虫的 <code>URL</code> 去重这个问题，刚刚讲到的分治加散列表的思路，已经是可以实实在在工作的了。不过，<strong>作为一个有追求的工程师，应该考虑，在添加、查询数据的效率以及内存消耗方面，是否还有进一步的优化空间呢？</strong></p><p>你可能会说，散列表中添加、查找数据的时间复杂度已经是 $O(1)$，还能有进一步优化的空间吗？实际上，前面也讲过，时间复杂度并不能完全代表代码的执行时间。大 $O$ 时间复杂度表示法，会忽略掉常数、系数和低阶，并且统计的对象是语句的频度。不同的语句，执行时间也是不同的。时间复杂度只是表示执行时间随数据规模的变化趋势，并不能度量在特定的数据规模下，代码执行时间的多少。</p><p>如果时间复杂度中原来的系数是 <code>10</code>，现在能够通过优化，将系数降为 <code>1</code>，那在时间复杂度没有变化的情况下，执行效率就提高了 <code>10</code> 倍。对于实际的软件开发来说，<code>10</code> 倍效率的提升，显然是一个非常值得的优化。</p><p>如果用基于链表的方法解决冲突问题，散列表中存储的是 <code>URL</code>，那当查询的时候，通过哈希函数定位到某个链表之后，还需要依次比对每个链表中的 <code>URL</code>。这个操作是比较耗时的，主要有两点原因。</p><p>一方面，链表中的结点在内存中不是连续存储的，所以不能一下子加载到 <code>CPU</code> 缓存中，没法很好地利用到 <code>CPU</code> 高速缓存，所以数据访问性能方面会打折扣。</p><p>另一方面，链表中的每个数据都是 <code>URL</code>，而 <code>URL</code> 不是简单的数字，是平均长度为 <code>64</code> 字节的字符串。也就是说，要让待判重的 <code>URL</code>，跟链表中的每个 <code>URL</code>，做字符串匹配。显然，这样一个字符串匹配操作，比起单纯的数字比对，要慢很多。所以，基于这两点，执行效率方面肯定是有优化空间的。</p><p>对于内存消耗方面的优化，除了刚刚这种基于散列表的解决方案，貌似没有更好的法子了。实际上，如果要想内存方面有明显的节省，那就得换一种解决方案，也就是要着重讲的这种存储结构，<strong>布隆过滤器</strong>（<code>Bloom Filter</code>）。</p><p>在讲布隆过滤器前，要先讲一下另一种存储结构，<strong>位图</strong>（<code>BitMap</code>）。因为，布隆过滤器本身就是基于位图的，是对位图的一种改进。</p><p>先来看一个稍微简单的问题。<strong>有 <code>1</code> 千万个整数，整数的范围在 <code>1</code> 到 <code>1</code> 亿之间。如何快速查找某个整数是否在这 <code>1</code> 千万个整数中呢？</strong></p><p>当然，这个问题可以用散列表来解决。不过，还可以使用一种比较“特殊”的散列表，那就是位图。申请一个大小为 <code>1</code> 亿、数据类型为布尔类型（<code>true</code> 或者 <code>false</code>）的数组。将这 <code>1</code> 千万个整数作为数组下标，将对应的数组值设置成 <code>true</code>。比如，整数 <code>5</code> 对应下标为 <code>5</code> 的数组值设置为 <code>true</code>，也就是 <code>array[5]=true</code>。</p><p>当查询某个整数 <code>K</code> 是否在这 <code>1</code> 千万个整数中的时候，只需要将对应的数组值 <code>array[K]</code> 取出来，看是否等于 <code>true</code>。如果等于 <code>true</code>，那说明 <code>1</code> 千万整数中包含这个整数 <code>K</code>；相反，就表示不包含这个整数 <code>K</code>。</p><p>不过，很多语言中提供的布尔类型，大小是 <code>1</code> 个字节的，并不能节省太多内存空间。实际上，表示 <code>true</code> 和 <code>false</code> 两个值，只需要用一个二进制位（<code>bit</code>）就可以了。那如何通过编程语言，来表示一个二进制位呢？</p><p>这里就要用到位运算了。可以借助编程语言中提供的数据类型，比如 <code>int</code>、<code>long</code>、<code>char</code> 等类型，通过位运算，用其中的某个位表示某个数字。文字描述起来有点儿不好理解，这里把位图的代码实现写了出来，你可以对照着代码看下，应该就能看懂了。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BitMap</span> </span>&#123; <span class="hljs-comment">// Java 中 char 类型占 16bit，也即是 2 个字节</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] bytes;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> nbits;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BitMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nbits)</span> </span>&#123;    <span class="hljs-keyword">this</span>.nbits = nbits;    <span class="hljs-keyword">this</span>.bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[nbits/<span class="hljs-number">16</span>+<span class="hljs-number">1</span>];  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">if</span> (k &gt; nbits) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> byteIndex = k / <span class="hljs-number">16</span>;    <span class="hljs-keyword">int</span> bitIndex = k % <span class="hljs-number">16</span>;    bytes[byteIndex] |= (<span class="hljs-number">1</span> &lt;&lt; bitIndex);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">if</span> (k &gt; nbits) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">int</span> byteIndex = k / <span class="hljs-number">16</span>;    <span class="hljs-keyword">int</span> bitIndex = k % <span class="hljs-number">16</span>;    <span class="hljs-keyword">return</span> (bytes[byteIndex] &amp; (<span class="hljs-number">1</span> &lt;&lt; bitIndex)) != <span class="hljs-number">0</span>;  &#125;&#125;</code></pre><p>你应该可以发现，位图通过数组下标来定位数据，所以，访问效率非常高。而且，每个数字用一个二进制位来表示，在数字范围不大的情况下，所需要的内存空间非常节省。</p><p>比如刚刚那个例子，如果用散列表存储这 <code>1</code> 千万的数据，数据是 <code>32</code> 位的整型数，也就是需要 <code>4</code> 个字节的存储空间，那总共至少需要 <code>40MB</code> 的存储空间。如果通过位图的话，数字范围在 <code>1</code> 到 <code>1</code> 亿之间，只需要 <code>1</code> 亿个二进制位，也就是 <code>12MB</code> 左右的存储空间就够了。</p><p>关于位图，是不是挺简单的？不过这里有个假设，就是数字所在的范围不是很大。如果数字的范围很大，比如刚刚那个问题，数字范围不是 <code>1</code> 到 <code>1</code> 亿，而是 <code>1</code> 到 <code>10</code> 亿，那位图的大小就是 <code>10</code> 亿个二进制位，也就是 <code>120MB</code> 的大小，消耗的内存空间，不降反增。</p><p>这个时候，布隆过滤器就要出场了。布隆过滤器就是为了解决刚刚这个问题，对位图这种数据结构的一种改进。</p><p>还是刚刚那个例子，数据个数是 <code>1</code> 千万，数据的范围是 <code>1</code> 到 <code>10</code> 亿。布隆过滤器的做法是，仍然使用一个 <code>1</code> 亿个二进制大小的位图，然后通过哈希函数，对数字进行处理，让它落在这 <code>1</code> 到 <code>1</code> 亿范围内。比如把哈希函数设计成 <code>f(x)=x%n</code>。其中，<code>x</code> 表示数字，<code>n</code> 表示位图的大小（<code>1</code> 亿），也就是，对数字跟位图的大小进行取模求余。</p><p>不过，你肯定会说，哈希函数会存在冲突的问题啊，一亿零一和 <code>1</code> 两个数字，经过刚刚那个取模求余的哈希函数处理之后，最后的结果都是 <code>1</code>。这样就无法区分，位图存储的是 <code>1</code> 还是一亿零一了。</p><p>为了降低这种冲突概率，当然可以设计一个复杂点、随机点的哈希函数。除此之外，还有其他方法吗？来看布隆过滤器的处理方法。既然一个哈希函数可能会存在冲突，那用多个哈希函数一块儿定位一个数据，是否能降低冲突的概率呢？下面具体解释一下，布隆过滤器是怎么做的。</p><p>使用 <code>K</code> 个哈希函数，对同一个数字进行求哈希值，那会得到 <code>K</code> 个不同的哈希值，分别记作 $X_1$，$X_2$，$X_3$，…，$X_K$。把这 <code>K</code> 个数字作为位图中的下标，将对应的 BitMap[$X_1$]，BitMap[$X_2$]，BitMap[$X_3$]，…，BitMap[$X_K$] 都设置成 <code>true</code>，也就是说，用 <code>K</code> 个二进制位，来表示一个数字的存在。</p><p>当要查询某个数字是否存在的时候，用同样的 <code>K</code> 个哈希函数，对这个数字求哈希值，分别得到 $Y_1$，$Y_2$，$Y_3$，…，$Y_K$。然后看这 <code>K</code> 个哈希值，对应位图中的数值是否都为 <code>true</code>，如果都是 <code>true</code>，则说明，这个数字存在，如果有其中任意一个不为 <code>true</code>，那就说明这个数字不存在。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/18/851db9c0-c190-11e9-be13-e5fb1c0c4586.png" srcset="/img/loading.gif" alt="image.png"><br>对于两个不同的数字来说，经过一个哈希函数处理之后，可能会产生相同的哈希值。但是经过 <code>K</code> 个哈希函数处理之后，<code>K</code> 个哈希值都相同的概率就非常低了。尽管采用 <code>K</code> 个哈希函数之后，两个数字哈希冲突的概率降低了，但是，这种处理方式又带来了新的问题，那就是容易误判。看下面这个例子。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/18/a2cdf9d0-c190-11e9-be13-e5fb1c0c4586.png" srcset="/img/loading.gif" alt="image.png"><br>布隆过滤器的误判有一个特点，那就是，它只会对存在的情况有误判。如果某个数字经过布隆过滤器判断不存在，那说明这个数字真的不存在，不会发生误判；如果某个数字经过布隆过滤器判断存在，这个时候才会有可能误判，有可能并不存在。不过，只要调整哈希函数的个数、位图大小跟要存储数字的个数之间的比例，那就可以将这种误判的概率降到非常低。</p><p>尽管布隆过滤器会存在误判，但是，这并不影响它发挥大作用。很多场景对误判有一定的容忍度。比如上面要解决的爬虫判重这个问题，即便一个没有被爬取过的网页，被误判为已经被爬取，对于搜索引擎来说，也并不是什么大事情，是可以容忍的，毕竟网页太多了，搜索引擎也不可能 <code>100%</code> 都爬取到。</p><p>弄懂了布隆过滤器，爬虫网页去重的问题，就很简单了。</p><p>用布隆过滤器来记录已经爬取过的网页链接，假设需要判重的网页有 <code>10</code> 亿，那可以用一个 <code>10</code> 倍大小的位图来存储，也就是 <code>100</code> 亿个二进制位，换算成字节，那就是大约 <code>1.2GB</code>。之前用散列表判重，需要至少 <code>100GB</code> 的空间。相比来讲，布隆过滤器在存储空间的消耗上，降低了非常多。</p><p>那再来看下，利用布隆过滤器，在执行效率方面，是否比散列表更加高效呢？</p><p>布隆过滤器用多个哈希函数对同一个网页链接进行处理，<code>CPU</code> 只需要将网页链接从内存中读取一次，进行多次哈希计算，理论上讲这组操作是 <code>CPU</code> 密集型的。而在散列表的处理方式中，需要读取散列冲突拉链的多个网页链接，分别跟待判重的网页链接，进行字符串匹配。这个操作涉及很多内存数据的读取，所以是内存密集型的。但是 <code>CPU</code> 计算可是要比内存访问更快速的，所以，理论上讲，布隆过滤器的判重方式，更加快速。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>关于搜索引擎爬虫网页去重问题的解决，从散列表讲到位图，再讲到布隆过滤器。布隆过滤器非常适合这种不需要 <code>100%</code> 准确的、允许存在小概率误判的大规模判重场景。除了爬虫网页去重这个例子，还有比如统计一个大型网站的每天的 <code>UV</code> 数，也就是每天有多少用户访问了网站，就可以使用布隆过滤器，对重复访问的用户，进行去重。</p><p>前面讲到，布隆过滤器的误判率，主要跟哈希函数的个数、位图的大小有关。当往布隆过滤器中不停地加入数据之后，位图中 <code>true</code> 的位置就越来越少了，误判率就越来越高了。所以，对于无法事先知道要判重的数据个数的情况，需要支持自动扩容的功能。</p><p>当布隆过滤器中，数据个数与位图大小的比例超过某个阈值的时候，就重新申请一个新的位图。后面来的新数据，会被放置到新的位图中。但是，如果要判断某个数据是否在布隆过滤器中已经存在，就需要查看多个位图，相应的执行效率就降低了一些。</p><p>位图、布隆过滤器应用如此广泛，很多编程语言都已经实现了。比如 <code>Java</code> 中的 <code>BitSet</code> 类就是一个位图，<code>Redis</code> 也提供了 <code>BitMap</code> 位图类，<code>Google</code> 的 <code>Guava</code> 工具包提供了 <code>BloomFilter</code> 布隆过滤器的实现。如果你感兴趣，可以去研究下这些实现的源码。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>假设有 <code>1</code> 亿个整数，数据范围是从 <code>1</code> 到 <code>10</code> 亿，如何快速并且省内存地给这 <code>1</code> 亿个数据从小到大排序？</p></li><li><p>还记得在哈希函数（下）讲过的利用分治思想，用散列表以及哈希函数，实现海量图库中的判重功能吗？如果允许小概率的误判，那是否可以用布隆过滤器来解决呢？你可以参照当时的估算方法，重新估算下，用布隆过滤器需要多少台机器？欢迎留言和我分享。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(高级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>41.最短路径</title>
    <link href="/passages/41/"/>
    <url>/passages/41/</url>
    
    <content type="html"><![CDATA[<p>像 <code>Google</code> 地图、百度地图、高德地图这样的地图软件，你应该经常使用吧？如果想从家开车到公司，你只需要输入起始、结束地址，地图就会给你规划一条最优出行路线。这里的最优，有很多种定义，比如最短路线、最少用时路线、最少红绿灯路线等等。<strong>作为一名软件开发工程师，你是否思考过，地图软件的最优路线是如何计算出来的吗？底层依赖了什么算法呢？</strong></p><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><p>刚提到的最优问题包含三个：最短路线、最少用时和最少红绿灯。先解决最简单的，最短路线。</p><p>解决软件开发中的实际问题，最重要的一点就是<strong>建模</strong>，也就是将复杂的场景抽象成具体的数据结构。针对这个问题，该如何抽象成数据结构呢？</p><p>图这种数据结构的表达能力很强，显然，把地图抽象成图最合适不过了。把每个岔路口看作一个顶点，岔路口与岔路口之间的路看作一条边，路的长度就是边的权重。如果路是单行道，就在两个顶点之间画一条有向边；如果路是双行道，就在两个顶点之间画两条方向不同的边。这样，整个地图就被抽象成一个有向有权图。</p><p>具体的代码实现如下。于是，要求解的问题就转化为，在一个有向有权图中，求两个顶点间的最短路径。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> </span>&#123; <span class="hljs-comment">// 有向有权图的邻接表表示</span>  <span class="hljs-keyword">private</span> LinkedList&lt;Edge&gt; adj[]; <span class="hljs-comment">// 邻接表</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> v; <span class="hljs-comment">// 顶点个数</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;    <span class="hljs-keyword">this</span>.v = v;    <span class="hljs-keyword">this</span>.adj = <span class="hljs-keyword">new</span> LinkedList[v];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123;      <span class="hljs-keyword">this</span>.adj[i] = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> w)</span> </span>&#123; <span class="hljs-comment">// 添加一条边</span>    <span class="hljs-keyword">this</span>.adj[s].add(<span class="hljs-keyword">new</span> Edge(s, t, w));  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Edge</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> sid; <span class="hljs-comment">// 边的起始顶点编号</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> tid; <span class="hljs-comment">// 边的终止顶点编号</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> w; <span class="hljs-comment">// 权重</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Edge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sid, <span class="hljs-keyword">int</span> tid, <span class="hljs-keyword">int</span> w)</span> </span>&#123;      <span class="hljs-keyword">this</span>.sid = sid;      <span class="hljs-keyword">this</span>.tid = tid;      <span class="hljs-keyword">this</span>.w = w;    &#125;  &#125;  <span class="hljs-comment">// 下面这个类是为了 dijkstra 实现用的</span>  <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vertex</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id; <span class="hljs-comment">// 顶点编号 ID</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> dist; <span class="hljs-comment">// 从起始顶点到这个顶点的距离</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vertex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> dist)</span> </span>&#123;      <span class="hljs-keyword">this</span>.id = id;      <span class="hljs-keyword">this</span>.dist = dist;    &#125;  &#125;&#125;</code></pre><p>想要解决这个问题，有一个非常经典的算法，最短路径算法，更加准确地说，是<strong>单源最短路径算法</strong>（一个顶点到一个顶点）。提到最短路径算法，最出名的莫过于 <code>Dijkstra</code> 算法了。所以，现在来看，<code>Dijkstra</code> 算法是怎么工作的。</p><p>这个算法的原理稍微有点儿复杂，单纯的文字描述，不是很好懂。所以，还是结合代码来讲解。</p><pre><code class="hljs java"><span class="hljs-comment">// 因为 Java 提供的优先级队列，没有暴露更新数据的接口，所以我们需要重新实现一个</span><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorityQueue</span> </span>&#123; <span class="hljs-comment">// 根据 vertex.dist 构建小顶堆</span>  <span class="hljs-keyword">private</span> Vertex[] nodes;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PriorityQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;    <span class="hljs-keyword">this</span>.nodes = <span class="hljs-keyword">new</span> Vertex[v+<span class="hljs-number">1</span>];    <span class="hljs-keyword">this</span>.count = v;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> Vertex <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 留给读者实现... &#125;</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Vertex vertex)</span> </span>&#123; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 留给读者实现...&#125;</span>  <span class="hljs-comment">// 更新结点的值，并且从下往上堆化，重新符合堆的定义。时间复杂度 O(logn)。</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Vertex vertex)</span> </span>&#123; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 留给读者实现...&#125; </span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 留给读者实现...&#125;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123; <span class="hljs-comment">// 从顶点 s 到顶点 t 的最短路径</span>  <span class="hljs-keyword">int</span>[] predecessor = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">this</span>.v]; <span class="hljs-comment">// 用来还原最短路径</span>  Vertex[] vertexes = <span class="hljs-keyword">new</span> Vertex[<span class="hljs-keyword">this</span>.v];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.v; ++i) &#123;    vertexes[i] = <span class="hljs-keyword">new</span> Vertex(i, Integer.MAX_VALUE);  &#125;  PriorityQueue queue = <span class="hljs-keyword">new</span> PriorityQueue(<span class="hljs-keyword">this</span>.v);<span class="hljs-comment">// 小顶堆</span>  <span class="hljs-keyword">boolean</span>[] inqueue = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-keyword">this</span>.v]; <span class="hljs-comment">// 标记是否进入过队列</span>  vertexes[s].dist = <span class="hljs-number">0</span>;  queue.add(vertexes[s]);  inqueue[s] = <span class="hljs-keyword">true</span>;  <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;    Vertex minVertex= queue.poll(); <span class="hljs-comment">// 取堆顶元素并删除</span>    <span class="hljs-keyword">if</span> (minVertex.id == t) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 最短路径产生了</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; adj[minVertex.id].size(); ++i) &#123;      Edge e = adj[minVertex.id].get(i); <span class="hljs-comment">// 取出一条 minVetex 相连的边</span>      Vertex nextVertex = vertexes[e.tid]; <span class="hljs-comment">// minVertex--&gt;nextVertex</span>      <span class="hljs-keyword">if</span> (minVertex.dist + e.w &lt; nextVertex.dist) &#123; <span class="hljs-comment">// 更新 next 的 dist</span>        nextVertex.dist = minVertex.dist + e.w;        predecessor[nextVertex.id] = minVertex.id;        <span class="hljs-keyword">if</span> (inqueue[nextVertex.id] == <span class="hljs-keyword">true</span>) &#123;          queue.update(nextVertex); <span class="hljs-comment">// 更新队列中的 dist 值</span>        &#125; <span class="hljs-keyword">else</span> &#123;          queue.add(nextVertex);          inqueue[nextVertex.id] = <span class="hljs-keyword">true</span>;        &#125;      &#125;    &#125;  &#125;  <span class="hljs-comment">// 输出最短路径</span>  System.out.print(s);  print(s, t, predecessor);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span>[] predecessor)</span> </span>&#123;  <span class="hljs-keyword">if</span> (s == t) <span class="hljs-keyword">return</span>;  print(s, predecessor[t], predecessor);  System.out.print(<span class="hljs-string">"-&gt;"</span> + t);&#125;</code></pre><p>用 <code>vertexes</code> 数组，记录从起始顶点到每个顶点的距离（<code>dist</code>）。起初，把所有顶点的 <code>dist</code> 都初始化为无穷大（也就是代码中的 <code>Integer.MAX_VALUE</code>）。把起始顶点的 <code>dist</code> 值初始化为 <code>0</code>，然后将其放到优先级队列中。</p><p>从优先级队列中取出 <code>dist</code> 最小的顶点 <code>minVertex</code>，然后考察这个顶点可达的所有顶点（代码中的 <code>nextVertex</code>）。如果 <code>minVertex</code> 的 <code>dist</code> 值加上 <code>minVertex</code> 与 <code>nextVertex</code> 之间边的权重 <code>w</code> 小于 <code>nextVertex</code> 当前的 <code>dist</code> 值，也就是说，存在另一条更短的路径，它经过 <code>minVertex</code> 到达 <code>nextVertex</code>。那就把 <code>nextVertex</code> 的 <code>dist</code> 更新为 <code>minVertex</code> 的 <code>dist</code> 值加上 <code>w</code>。然后把 <code>nextVertex</code> 加入到优先级队列中。重复这个过程，直到找到终止顶点 <code>t</code> 或者队列为空。</p><p>以上就是 <code>Dijkstra</code> 算法的核心逻辑。除此之外，代码中还有两个额外的变量，<code>predecessor</code> 数组和 <code>inqueue</code> 数组。</p><p><code>predecessor</code> 数组的作用是为了还原最短路径，它记录每个顶点的前驱顶点。最后，通过递归的方式，将这个路径打印出来。打印路径的 <code>print</code> 递归代码就不详细讲了，这个跟在图的搜索中讲的打印路径方法一样。如果不理解的话，你可以回过头去看下那一篇。</p><p><code>inqueue</code> 数组是为了避免将一个顶点多次添加到优先级队列中。更新了某个顶点的 <code>dist</code> 值之后，如果这个顶点已经在优先级队列中了，就不要再将它重复添加进去了。</p><p>看完了代码和文字解释，可能还是有点懵，那就举个例子，再解释一下。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/17/9cd6bb50-c0b6-11e9-9e3a-517fabdf7fc0.png" srcset="/img/loading.gif" alt="image.png"><br>理解了 <code>Dijkstra</code> 的原理和代码实现，来看下，<code>Dijkstra</code> 算法的时间复杂度是多少？</p><p>在刚刚的代码实现中，最复杂就是 <code>while</code> 循环嵌套 <code>for</code> 循环那部分代码了。<code>while</code> 循环最多会执行 <code>V</code> 次（<code>V</code> 表示顶点的个数），而内部的 <code>for</code> 循环的执行次数不确定，跟每个顶点的相邻边的个数有关，分别记作 <code>E0</code>，<code>E1</code>，<code>E2</code>，……，<code>E(V-1)</code>。如果把这 <code>V</code> 个顶点的边都加起来，最大也不会超过图中所有边的个数 <code>E</code>（<code>E</code> 表示边的个数）。</p><p><code>for</code> 循环内部的代码涉及从优先级队列取数据、往优先级队列中添加数据、更新优先级队列中的数据，这样三个主要的操作。优先级队列是用堆来实现的，堆中的这几个操作，时间复杂度都是 $O(logV)$（堆中的元素个数不会超过顶点的个数 <code>V</code>）。</p><p>所以，综合这两部分，再利用乘法原则，整个代码的时间复杂度就是 <code>O(E*logV)</code>。</p><p>弄懂了 <code>Dijkstra</code> 算法，再来回答之前的问题，如何计算最优出行路线？</p><p>从理论上讲，用 <code>Dijkstra</code> 算法可以计算出两点之间的最短路径。但是，你有没有想过，对于一个超级大地图来说，岔路口、道路都非常多，对应到图这种数据结构上来说，就有非常多的顶点和边。如果为了计算两点之间的最短路径，在一个超级大图上动用 <code>Dijkstra</code> 算法，遍历所有的顶点和边，显然会非常耗时。那有没有什么优化的方法呢？</p><p>做工程不像做理论，一定要给出个最优解。理论上算法再好，如果执行效率太低，也无法应用到实际的工程中。<strong>对于软件开发工程师来说，我们经常要根据问题的实际背景，对解决方案权衡取舍。类似出行路线这种工程上的问题，我们没有必要非得求出个绝对最优解。很多时候，为了兼顾执行效率，我们只需要计算出一个可行的次优解就可以了。</strong></p><p>有了这个原则，你能想出刚刚那个问题的优化方案吗？</p><p>虽然地图很大，但是两点之间的最短路径或者说较好的出行路径，并不会很“发散”，只会出现在两点之间和两点附近的区块内。所以可以在整个大地图上，划出一个小的区块，这个小区块恰好可以覆盖住两个点，但又不会很大。只需要在这个小区块内部运行 <code>Dijkstra</code> 算法，这样就可以避免遍历整个大图，也就大大提高了执行效率。</p><p>不过你可能会说了，如果两点距离比较远，从北京海淀区某个地点，到上海黄浦区某个地点，那上面的这种处理方法，显然就不工作了，毕竟覆盖北京和上海的区块并不小。</p><p>给你点提示，你可以现在打开地图 <code>App</code>，缩小放大一下地图，看下地图上的路线有什么变化，然后再思考，这个问题该怎么解决。</p><p>对于这样两点之间距离较远的路线规划，可以把北京海淀区或者北京看作一个顶点，把上海黄浦区或者上海看作一个顶点，先规划大的出行路线。比如，如何从北京到上海，必须要经过某几个顶点，或者某几条干道，然后再细化每个阶段的小路线。</p><p>这样，最短路径问题就解决了。再来看另外两个问题，最少时间和最少红绿灯。</p><p>前面讲最短路径的时候，每条边的权重是路的长度。在计算最少时间的时候，算法还是不变，只需要把边的权重，从路的长度变成经过这段路所需要的时间。不过，这个时间会根据拥堵情况时刻变化。如何计算车通过一段路的时间呢？这是一个蛮有意思的问题，你可以自己思考下。</p><p>每经过一条边，就要经过一个红绿灯。关于最少红绿灯的出行方案，实际上，只需要把每条边的权值改为 <code>1</code> 即可，算法还是不变，可以继续使用前面讲的 <code>Dijkstra</code> 算法。不过，边的权值为 <code>1</code>，也就相当于无权图了，还可以使用之前讲过的广度优先搜索算法。因为前面讲过，广度优先搜索算法计算出来的两点之间的路径，就是两点的最短路径。</p><p>不过，这里给出的所有方案都非常粗糙，只是为了给你展示，如何结合实际的场景，灵活地应用算法，让算法为我们所用，真实的地图软件的路径规划，要比这个复杂很多。而且，比起 <code>Dijkstra</code> 算法，地图软件用的更多的是类似 <code>A*</code> 的启发式搜索算法，不过也是在 <code>Dijkstra</code> 算法上的优化罢了。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>上面了一种非常重要的图算法，<strong>Dijkstra 最短路径算法</strong>。实际上，最短路径算法还有很多，比如 <code>Bellford</code> 算法、<code>Floyd</code> 算法等等。</p><p>这些算法实现思路非常经典，掌握了这些思路，就可以拿来指导、解决其他问题。比如 <code>Dijkstra</code> 这个算法的核心思想，就可以拿来解决下面这个看似完全不相关的问题。</p><p>有一个翻译系统，只能针对单个词来做翻译。如果要翻译一整个句子，需要将句子拆成一个一个的单词，再丢给翻译系统。针对每个单词，翻译系统会返回一组可选的翻译列表，并且针对每个翻译打一个分，表示这个翻译的可信程度。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/17/57b3ec10-c0ba-11e9-9e3a-517fabdf7fc0.png" srcset="/img/loading.gif" alt="image.png"><br>针对每个单词，从可选列表中，选择其中一个翻译，组合起来就是整个句子的翻译。每个单词的翻译的得分之和，就是整个句子的翻译得分。随意搭配单词的翻译，会得到一个句子的不同翻译。针对整个句子，希望计算出得分最高的前 <code>k</code> 个翻译结果，你会怎么编程来实现呢？<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/17/8f62fcf0-c0ba-11e9-9e3a-517fabdf7fc0.png" srcset="/img/loading.gif" alt="image.png"><br>当然，最简单的办法还是借助回溯算法，穷举所有的排列组合情况，然后选出得分最高的前 <code>k</code> 个翻译结果。但是，这样做的时间复杂度会比较高，是 $O(m^n)$，其中，<code>m</code> 表示平均每个单词的可选翻译个数，<code>n</code> 表示一个句子中包含多少个单词。这个解决方案，你可以当作回溯算法的练习题，自己编程实现一下。</p><p>实际上，这个问题可以借助 <code>Dijkstra</code> 算法的核心思想，非常高效地解决。每个单词的可选翻译是按照分数从大到小排列的，所以 $a_0b_0c_0$ 肯定是得分最高组合结果。把 $a_0b_0c_0$ 及得分作为一个对象，放入到优先级队列中。</p><p>每次从优先级队列中取出一个得分最高的组合，并基于这个组合进行扩展。扩展的策略是每个单词的翻译分别替换成下一个单词的翻译。比如 $a_0b_0c_0$ 扩展后，会得到三个组合，$a_1b_0c_0$、$a_0b_1c_0$、$a_0b_0c_1$。把扩展之后的组合，加到优先级队列中。重复这个过程，直到获取到 <code>k</code> 个翻译组合或者队列为空。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/17/d4bf8790-c0bb-11e9-9e3a-517fabdf7fc0.png" srcset="/img/loading.gif" alt="image.png"><br>这种实现思路的时间复杂度是多少？</p><p>假设句子包含 <code>n</code> 个单词，每个单词平均有 <code>m</code> 个可选的翻译，求得分最高的前 <code>k</code> 个组合结果。每次一个组合出队列，就对应着一个组合结果，如果希望得到 <code>k</code> 个，那就对应着 <code>k</code> 次出队操作。每次有一个组合出队列，就有 <code>n</code> 个组合入队列。优先级队列中出队和入队操作的时间复杂度都是 $O(logX)$，<code>X</code> 表示队列中的组合个数。所以，总的时间复杂度就是 $O(k * n * logX)$。那 <code>X</code> 到底是多少呢？</p><p><code>k</code> 次出入队列，队列中的总数据不会超过 <code>k*n</code>，也就是说，出队、入队操作的时间复杂度是 $O(log(k*n))$。所以，总的时间复杂度就是 $O(k * n * log(k * n))$，比之前的指数级时间复杂度降低了很多。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>在计算最短时间的出行路线中，如何获得通过某条路的时间呢？</p></li><li><p>上面讲的出行路线问题，假设的是开车出行，那如果是公交出行呢？如果混合地铁、公交、步行，又该如何规划路线呢？欢迎留言和我分享。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(高级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>40.拓扑排序</title>
    <link href="/passages/40/"/>
    <url>/passages/40/</url>
    
    <content type="html"><![CDATA[<p>一个完整的项目往往会包含很多代码源文件。编译器在编译整个项目的时候，需要按照依赖关系，依次编译每个源文件。比如，<code>A.cpp</code> 依赖 <code>B.cpp</code>，那在编译的时候，编译器需要先编译 <code>B.cpp</code>，才能编译 <code>A.cpp</code>。</p><p>编译器通过分析源文件或者程序员事先写好的编译配置文件（比如 <code>Makefile</code> 文件），来获取这种局部的依赖关系。那编译器又该如何通过源文件两两之间的局部依赖关系，确定一个全局的编译顺序呢？<br><img src="./e5d0b8e4.jpeg" srcset="/img/loading.gif" alt="image"></p><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><p>这个问题的解决思路与“图”这种数据结构的一个经典算法“拓扑排序算法”有关。那什么是拓扑排序呢？这个概念很好理解，先来看一个生活中的拓扑排序的例子。</p><p>我们在穿衣服的时候都有一定的顺序，可以把这种顺序想成，衣服与衣服之间有一定的依赖关系。比如说，必须先穿袜子才能穿鞋，先穿内裤才能穿秋裤。假设现在有八件衣服要穿，它们之间的两两依赖关系已经很清楚了，那如何安排一个穿衣序列，能够满足所有的两两之间的依赖关系？</p><p>这就是个拓扑排序问题。从这个例子中，你应该能想到，在很多时候，拓扑排序的序列并不是唯一的。你可以下面的这幅图，有好几种满足这些局部先后关系的穿衣序列。<br><img src="./9069b4db.jpeg" srcset="/img/loading.gif" alt="image"><br>弄懂了这个生活中的例子，关于编译顺序的问题，你应该也有思路了。</p><p>拓扑排序的原理非常简单，重点应该放到拓扑排序的实现上面。</p><p>算法是构建在具体的数据结构之上的。针对这个问题，先来看下，如何将问题背景抽象成具体的数据结构？</p><p>可以把源文件与源文件之间的依赖关系，抽象成一个有向图。每个源文件对应图中的一个顶点，源文件之间的依赖关系就是顶点之间的边。</p><p>如果 <code>a</code> 先于 <code>b</code> 执行，也就是说 <code>b</code> 依赖于 <code>a</code>，那么就在顶点 <code>a</code> 和顶点 <code>b</code> 之间，构建一条从 <code>a</code> 指向 <code>b</code> 的边。而且，这个图不仅要是有向图，还要是一个有向无环图，也就是不能存在像 <code>a-&gt;b-&gt;c-&gt;a</code> 这样的循环依赖关系。因为图中一旦出现环，拓扑排序就无法工作了。实际上，拓扑排序本身就是基于有向无环图的一个算法。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> v; <span class="hljs-comment">// 顶点的个数</span>  <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="hljs-comment">// 邻接表</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;    <span class="hljs-keyword">this</span>.v = v;    adj = <span class="hljs-keyword">new</span> LinkedList[v];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;v; ++i) &#123;      adj[i] = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123; <span class="hljs-comment">// s 先于 t，边 s-&gt;t</span>    adj[s].add(t);  &#125;&#125;</code></pre><p>数据结构定义好了，现在来看，<strong>如何在这个有向无环图上，实现拓扑排序？</strong></p><p>拓扑排序有两种实现方法，都不难理解。它们分别是<strong>Kahn 算法</strong>和<strong>DFS 深度优先搜索算法</strong>。依次来看下它们都是怎么工作的。</p><h3 id="1-Kahn-算法"><a href="#1-Kahn-算法" class="headerlink" title="1. Kahn 算法"></a>1. Kahn 算法</h3><p><code>Kahn</code> 算法实际上用的是贪心算法思想，思路非常简单、好懂。</p><p>定义数据结构的时候，如果 <code>s</code> 需要先于 <code>t</code> 执行，那就添加一条 <code>s</code> 指向 <code>t</code> 的边。所以，如果某个顶点入度为 <code>0</code>，也就表示，没有任何顶点必须先于这个顶点执行，那么这个顶点就可以执行了。</p><p>先从图中，找出一个入度为 <code>0</code> 的顶点，将其输出到拓扑排序的结果序列中（对应代码中就是把它打印出来），并且把这个顶点从图中删除（也就是把这个顶点可达的顶点的入度都减 <code>1</code>）。循环执行上面的过程，直到所有的顶点都被输出。最后输出的序列，就是满足局部依赖关系的拓扑排序。</p><p><code>Kahn</code> 算法的代码实现如下，你可以结合着文字描述一块看下。不过，你应该能发现，这段代码实现更有技巧一些，并没有真正删除顶点的操作。代码中有详细的注释，就不多解释了。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">topoSortByKahn</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">int</span>[] inDegree = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[v]; <span class="hljs-comment">// 统计每个顶点的入度</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; adj[i].size(); ++j) &#123;      <span class="hljs-keyword">int</span> w = adj[i].get(j); <span class="hljs-comment">// i-&gt;w</span>      inDegree[w]++;    &#125;  &#125;  LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123;    <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) queue.add(i);  &#125;  <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;    <span class="hljs-keyword">int</span> i = queue.remove();    System.out.print(<span class="hljs-string">"-&gt;"</span> + i);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; adj[i].size(); ++j) &#123;      <span class="hljs-keyword">int</span> k = adj[i].get(j);      inDegree[k]--;      <span class="hljs-keyword">if</span> (inDegree[k] == <span class="hljs-number">0</span>) queue.add(k);    &#125;  &#125;&#125;</code></pre><h3 id="2-DFS-算法"><a href="#2-DFS-算法" class="headerlink" title="2. DFS 算法"></a>2. DFS 算法</h3><p>实际上，拓扑排序也可以用深度优先搜索来实现。不过这里的名字要稍微改下，更加确切的说法应该是深度优先遍历，遍历图中的所有顶点，而非只是搜索一个顶点到另一个顶点的路径。</p><p>关于这个算法的实现原理，先把代码贴在下面，下面具体解释。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">topoSortByDFS</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 先构建逆邻接表，边 s-&gt;t 表示，s 依赖于 t，t 先于 s</span>  LinkedList&lt;Integer&gt; inverseAdj[] = <span class="hljs-keyword">new</span> LinkedList[v];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123; <span class="hljs-comment">// 申请空间</span>    inverseAdj[i] = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123; <span class="hljs-comment">// 通过邻接表生成逆邻接表</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; adj[i].size(); ++j) &#123;      <span class="hljs-keyword">int</span> w = adj[i].get(j); <span class="hljs-comment">// i-&gt;w</span>      inverseAdj[w].add(i); <span class="hljs-comment">// w-&gt;i</span>    &#125;  &#125;  <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[v];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123; <span class="hljs-comment">// 深度优先遍历图</span>    <span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-keyword">false</span>) &#123;      visited[i] = <span class="hljs-keyword">true</span>;      dfs(i, inverseAdj, visited);    &#125;  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(    <span class="hljs-keyword">int</span> vertex, LinkedList&lt;Integer&gt; inverseAdj[], <span class="hljs-keyword">boolean</span>[] visited)</span> </span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inverseAdj[vertex].size(); ++i) &#123;    <span class="hljs-keyword">int</span> w = inverseAdj[vertex].get(i);    <span class="hljs-keyword">if</span> (visited[w] == <span class="hljs-keyword">true</span>) <span class="hljs-keyword">continue</span>;    visited[w] = <span class="hljs-keyword">true</span>;    dfs(w, inverseAdj, visited);  &#125; <span class="hljs-comment">// 先把 vertex 这个顶点可达的所有顶点都打印出来之后，再打印它自己</span>  System.out.print(<span class="hljs-string">"-&gt;"</span> + vertex);&#125;</code></pre><p>这个算法包含两个关键部分。</p><p>第一部分是<strong>通过邻接表构造逆邻接表</strong>。邻接表中，边 <code>s-&gt;t</code> 表示 <code>s</code> 先于 <code>t</code> 执行，也就是 <code>t</code> 要依赖 <code>s</code>。在逆邻接表中，边 <code>s-&gt;t</code> 表示 <code>s</code> 依赖于 <code>t</code>，<code>s</code> 后于 <code>t</code> 执行。为什么这么转化呢？这个跟这个算法的实现思想有关。</p><p>第二部分是这个算法的核心，也就是<strong>递归处理每个顶点</strong>。对于顶点 <code>vertex</code> 来说，先输出它可达的所有顶点，也就是说，先把它依赖的所有的顶点输出了，然后再输出自己。</p><p><strong>这两个算法的时间复杂度分别是多少呢？</strong></p><p>从 <code>Kahn</code> 代码中可以看出来，每个顶点被访问了一次，每个边也都被访问了一次，所以，<code>Kahn</code> 算法的时间复杂度就是 $O(V+E)$（<code>V</code> 表示顶点个数，<code>E</code> 表示边的个数）。</p><p><code>DFS</code> 算法的时间复杂度之前分析过。每个顶点被访问两次，每条边都被访问一次，所以时间复杂度也是 $O(V+E)$。</p><p>注意，这里的图可能不是连通的，有可能是有好几个不连通的子图构成，所以，<code>E</code> 并不一定大于 <code>V</code>，两者的大小关系不确定。所以，在表示时间复杂度的时候，<code>V</code>、<code>E</code> 都要考虑在内。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>拓扑排序应用非常广泛，解决的问题的模型也非常一致。凡是需要通过局部顺序来推导全局顺序的，一般都能用拓扑排序来解决。除此之外，拓扑排序还能检测图中环的存在。对于 <code>Kahn</code> 算法来说，如果最后输出的顶点个数，少于图中顶点个数，图中还有入度不是 <code>0</code> 的顶点，那就说明，图中存在环。</p><p>关于图中环的检测，在递归那一篇讲过一个例子，在查找最终推荐人的时候，可能会因为脏数据，造成存在循环推荐，比如，用户 <code>A</code> 推荐了用户 <code>B</code>，用户 <code>B</code> 推荐了用户 <code>C</code>，用户 <code>C</code> 又推荐了用户 <code>A</code>。如何避免这种脏数据导致的无限递归？这个问题当时留给你思考了，现在是时候解答了。</p><p>实际上，这就是环的检测问题。因为每次都只是查找一个用户的最终推荐人，所以，并不需要动用复杂的拓扑排序算法，而只需要记录已经访问过的用户 <code>ID</code>，当用户 <code>ID</code> 第二次被访问的时候，就说明存在环，也就说明存在脏数据。</p><pre><code class="hljs java">HashSet&lt;Integer&gt; hashTable = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(); <span class="hljs-comment">// 保存已经访问过的 actorId</span><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">findRootReferrerId</span><span class="hljs-params">(<span class="hljs-keyword">long</span> actorId)</span> </span>&#123;  <span class="hljs-keyword">if</span> (hashTable.contains(actorId)) &#123; <span class="hljs-comment">// 存在环</span>    <span class="hljs-keyword">return</span>;  &#125;  hashTable.add(actorId);  Long referrerId =        select referrer_id from [table] where actor_id = actorId;  <span class="hljs-keyword">if</span> (referrerId == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> actorId;  <span class="hljs-keyword">return</span> findRootReferrerId(referrerId);&#125;</code></pre><p>如果把这个问题改一下，想要知道数据库中的所有用户之间的推荐关系，有没有存在环的情况。这个问题，就需要用到拓扑排序算法了。把用户之间的推荐关系，从数据库中加载到内存中，然后构建成上面的这种有向图数据结构，再利用拓扑排序，就可以快速检测出是否存在环了。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>用图表示依赖关系的时候，如果 <code>a</code> 先于 <code>b</code> 执行，就画一条从 <code>a</code> 到 <code>b</code> 的有向边；反过来，如果 <code>a</code> 先于 <code>b</code>，画一条从 <code>b</code> 到 <code>a</code> 的有向边，表示 <code>b</code> 依赖 <code>a</code>，那上面的 <code>Kahn</code> 算法和 <code>DFS</code> 算法还能否正确工作呢？如果不能，应该如何改造一下呢？</p></li><li><p>上面讲了两种拓扑排序算法的实现思路，<code>Kahn</code> 算法和 <code>DFS</code> 深度优先搜索算法，如果换做 <code>BFS</code> 广度优先搜索算法，还可以实现吗？欢迎留言和我分享。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(高级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>39.动态规划实战</title>
    <link href="/passages/39/"/>
    <url>/passages/39/</url>
    
    <content type="html"><![CDATA[<p>当你在搜索框中，一不小心输错单词时，搜索引擎会非常智能地检测出你的拼写错误，并且用对应的正确单词来进行搜索。作为一名软件开发工程师，你是否想过，这个功能是怎么实现的呢？</p><h2 id="如何量化两个字符串的相似度？"><a href="#如何量化两个字符串的相似度？" class="headerlink" title="如何量化两个字符串的相似度？"></a>如何量化两个字符串的相似度？</h2><p>如何量化两个字符串之间的相似程度呢？有一个非常著名的量化方法，那就是编辑距离（<code>Edit Distance</code>）。</p><p>顾名思义，<strong>编辑距离</strong>指的就是，将一个字符串转化成另一个字符串，需要的最少编辑操作次数（比如增加一个字符、删除一个字符、替换一个字符）。编辑距离越大，说明两个字符串的相似程度越小；相反，编辑距离就越小，说明两个字符串的相似程度越大。对于两个完全相同的字符串来说，编辑距离就是 <code>0</code>。</p><p>根据所包含的编辑操作种类的不同，编辑距离有多种不同的计算方式，比较著名的有<strong>莱文斯坦距离</strong>（<code>Levenshtein distance</code>）和<strong>最长公共子串长度</strong>（<code>Longest common substring length</code>）。其中，莱文斯坦距离允许增加、删除、替换字符这三个编辑操作，最长公共子串长度只允许增加、删除字符这两个编辑操作。</p><p>而且，莱文斯坦距离和最长公共子串长度，从两个截然相反的角度，分析字符串的相似程度。莱文斯坦距离的大小，表示两个字符串差异的大小；而最长公共子串的大小，表示两个字符串相似程度的大小。</p><p>关于这两个计算方法，举个例子给你说明一下。这里面，两个字符串 <code>mitcmu</code> 和 <code>mtacnu</code> 的莱文斯坦距离是 <code>3</code>，最长公共子串长度是 <code>4</code>。如下图所示：<br><img src="./48f6d0eb.jpeg" srcset="/img/loading.gif" alt="image"></p><h2 id="如何编程计算莱文斯坦距离？"><a href="#如何编程计算莱文斯坦距离？" class="headerlink" title="如何编程计算莱文斯坦距离？"></a>如何编程计算莱文斯坦距离？</h2><p>这个问题是求把一个字符串变成另一个字符串，需要的最少编辑次数。整个求解过程，涉及多个决策阶段，需要依次考察一个字符串中的每个字符，跟另一个字符串中的字符是否匹配，匹配的话如何处理，不匹配的话又如何处理。所以，这个问题符合<strong>多阶段决策最优解模型</strong>。</p><p>前面讲了，贪心、回溯、动态规划可以解决的问题，都可以抽象成这样一个模型。要解决这个问题，可以先看一看，用最简单的回溯算法，该如何来解决。</p><p>回溯是一个递归处理的过程。如果 <code>a[i]</code> 与 <code>b[j]</code> 匹配，递归考察 <code>a[i+1]</code> 和 <code>b[j+1]</code>。如果 <code>a[i]</code> 与 <code>b[j]</code> 不匹配，有多种处理方式可选：</p><ul><li><p>可以删除 <code>a[i]</code>，然后递归考察 <code>a[i+1]</code> 和 <code>b[j]</code>；</p></li><li><p>可以删除 <code>b[j]</code>，然后递归考察 <code>a[i]</code> 和 <code>b[j+1]</code>；</p></li><li><p>可以在 <code>a[i]</code> 前面添加一个跟 <code>b[j]</code> 相同的字符，然后递归考察 <code>a[i]</code> 和 <code>b[j+1]</code>;</p></li><li><p>可以在 <code>b[j]</code> 前面添加一个跟 <code>a[i]</code> 相同的字符，然后递归考察 <code>a[i+1]</code> 和 <code>b[j]</code>；</p></li><li><p>可以将 <code>a[i]</code> 替换成 <code>b[j]</code>，或者将 <code>b[j]</code> 替换成 <code>a[i]</code>，然后递归考察 <code>a[i+1]</code> 和 <code>b[j+1]</code>。</p></li></ul><p>将上面的回溯算法的处理思路，翻译成代码，就是下面这个样子：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] a = <span class="hljs-string">"mitcmu"</span>.toCharArray();<span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] b = <span class="hljs-string">"mtacnu"</span>.toCharArray();<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">6</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> m = <span class="hljs-number">6</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> minDist = Integer.MAX_VALUE; <span class="hljs-comment">// 存储结果</span><span class="hljs-comment">// 调用方式 lwstBT(0, 0, 0);</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">lwstBT</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> edist)</span> </span>&#123;  <span class="hljs-keyword">if</span> (i == n || j == m) &#123;    <span class="hljs-keyword">if</span> (i &lt; n) edist += (n - i);    <span class="hljs-keyword">if</span> (j &lt; m) edist += (m - j);    <span class="hljs-keyword">if</span> (edist &lt; minDist) minDist = edist;    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-keyword">if</span> (a[i] == b[j]) &#123; <span class="hljs-comment">// 两个字符匹配</span>    lwstBT(i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>, edist);  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 两个字符不匹配</span>    lwstBT(i + <span class="hljs-number">1</span>, j, edist + <span class="hljs-number">1</span>); <span class="hljs-comment">// 删除 a[i] 或者 b[j] 前添加一个字符</span>    lwstBT(i, j + <span class="hljs-number">1</span>, edist + <span class="hljs-number">1</span>); <span class="hljs-comment">// 删除 b[j] 或者 a[i] 前添加一个字符</span>    lwstBT(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>, edist + <span class="hljs-number">1</span>); <span class="hljs-comment">// 将 a[i] 和 b[j] 替换为相同字符</span>  &#125;&#125;</code></pre><p>根据回溯算法的代码实现，可以画出递归树，看是否存在重复子问题。如果存在重复子问题，那就可以考虑能否用动态规划来解决；如果不存在重复子问题，那回溯就是最好的解决方法。<br><img src="./79d5874b.jpeg" srcset="/img/loading.gif" alt="image"><br>在递归树中，每个节点代表一个状态，状态包含三个变量 <code>(i, j, edist)</code>，其中，<code>edist</code> 表示处理到 <code>a[i]</code> 和 <code>b[j]</code> 时，已经执行的编辑操作的次数。</p><p>在递归树中，<code>(i, j)</code> 两个变量重复的节点很多，比如 <code>(3, 2)</code> 和 <code>(2, 3)</code>。对于 <code>(i, j)</code> 相同的节点，只需要保留 <code>edist</code> 最小的，继续递归处理就可以了，剩下的节点都可以舍弃。所以，状态就从 <code>(i, j, edist)</code> 变成了 <code>(i, j, min_edist)</code>，其中 <code>min_edist</code> 表示处理到 <code>a[i]</code> 和 <code>b[j]</code>，已经执行的最少编辑次数。</p><p>看到这里，有没有觉得，这个问题跟上两篇的动态规划例子非常相似？不过，这个问题的状态转移方式，要比之前的例子都要复杂很多。上一篇的矩阵最短路径问题中，到达状态 <code>(i, j)</code> 只能通过 <code>(i-1, j)</code> 或 <code>(i, j-1)</code> 两个状态转移过来，而这个问题，状态 <code>(i, j)</code> 可能从 <code>(i-1, j)</code>，<code>(i, j-1)</code>，<code>(i-1, j-1)</code> 三个状态中的任意一个转移过来。<br><img src="./9b87cf29.jpeg" srcset="/img/loading.gif" alt="image"><br>基于刚刚的分析，可以尝试着将把状态转移的过程，用公式写出来。这就是前面讲的状态转移方程。</p><pre><code class="hljs java">如果：a[i]!=b[j]，那么：min_edist(i, j) 就等于：min(min_edist(i-<span class="hljs-number">1</span>,j)+<span class="hljs-number">1</span>, min_edist(i,j-<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>, min_edist(i-<span class="hljs-number">1</span>,j-<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>)如果：a[i]==b[j]，那么：min_edist(i, j) 就等于：min(min_edist(i-<span class="hljs-number">1</span>,j)+<span class="hljs-number">1</span>, min_edist(i,j-<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>，min_edist(i-<span class="hljs-number">1</span>,j-<span class="hljs-number">1</span>))其中，min 表示求三数中的最小值。</code></pre><p>了解了状态与状态之间的递推关系，画出一个二维的状态表，按行依次来填充状态表中的每个值。<br><img src="./f68d773e.jpeg" srcset="/img/loading.gif" alt="image"><br>现在既有状态转移方程，又理清了完整的填表过程，代码实现就非常简单了。代码贴在下面，你可以对比着文字解释，一起看下。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lwstDP</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> m)</span> </span>&#123;  <span class="hljs-keyword">int</span>[][] minDist = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][m];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123; <span class="hljs-comment">// 初始化第 0 行:a[0..0] 与 b[0..j] 的编辑距离</span>    <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[j]) minDist[<span class="hljs-number">0</span>][j] = j;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j != <span class="hljs-number">0</span>) minDist[<span class="hljs-number">0</span>][j] = minDist[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span> minDist[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 初始化第 0 列:a[0..i] 与 b[0..0] 的编辑距离</span>    <span class="hljs-keyword">if</span> (a[i] == b[<span class="hljs-number">0</span>]) minDist[i][<span class="hljs-number">0</span>] = i;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) minDist[i][<span class="hljs-number">0</span>] = minDist[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span> minDist[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 按行填表</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; m; ++j) &#123;      <span class="hljs-keyword">if</span> (a[i] == b[j]) minDist[i][j] = min(          minDist[i-<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>, minDist[i][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>, minDist[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]);      <span class="hljs-keyword">else</span> minDist[i][j] = min(          minDist[i-<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>, minDist[i][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>, minDist[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);    &#125;  &#125;  <span class="hljs-keyword">return</span> minDist[n-<span class="hljs-number">1</span>][m-<span class="hljs-number">1</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>&#123;  <span class="hljs-keyword">int</span> minv = Integer.MAX_VALUE;  <span class="hljs-keyword">if</span> (x &lt; minv) minv = x;  <span class="hljs-keyword">if</span> (y &lt; minv) minv = y;  <span class="hljs-keyword">if</span> (z &lt; minv) minv = z;  <span class="hljs-keyword">return</span> minv;&#125;</code></pre><p>你可能会说，虽然能看懂思路，但是遇到新的问题的时候，还是会感觉到无从下手。这种感觉是非常正常的。关于复杂算法问题的解决思路，有一些经验、小技巧，可以分享给你。</p><p>当拿到一个问题的时候，<strong>可以先不思考计算机会如何实现这个问题，而是单纯考虑“人脑”会如何去解决这个问题</strong>。人脑比较倾向于思考具象化的、摸得着看得见的东西，不适合思考过于抽象的问题。所以，需要把抽象问题具象化。那如何具象化呢？可以实例化几个测试数据，通过人脑去分析具体实例的解，然后总结规律，再尝试套用学过的算法，看是否能够解决。</p><p>除此之外，还有一个非常有效、但也算不上技巧的东西，那就是<strong>多练</strong>。实际上，等你做多了题目之后，自然就会有感觉，看到问题，立马就能想到能否用动态规划解决，然后直接就可以寻找最优子结构，写出动态规划方程，然后将状态转移方程翻译成代码。</p><h2 id="如何编程计算最长公共子串长度？"><a href="#如何编程计算最长公共子串长度？" class="headerlink" title="如何编程计算最长公共子串长度？"></a>如何编程计算最长公共子串长度？</h2><p>最长公共子串作为编辑距离中的一种，只允许增加、删除字符两种编辑操作。从名字上，你可能觉得它看起来跟编辑距离没什么关系。实际上，从本质上来说，它表征的也是两个字符串之间的相似程度。</p><p>这个问题的解决思路，跟莱文斯坦距离的解决思路非常相似，也可以用动态规划解决。刚刚已经详细讲解了莱文斯坦距离的动态规划解决思路，所以，针对这个问题，这里直接定义状态，然后写状态转移方程。</p><p>每个状态还是包括三个变量 <code>(i, j, max_lcs)</code>，<code>max_lcs</code> 表示 <code>a[0…i]</code> 和 <code>b[0…j]</code> 的最长公共子串长度。那 <code>(i, j)</code> 这个状态都是由哪些状态转移过来的呢？</p><p>先来看回溯的处理思路。从 <code>a[0]</code> 和 <code>b[0]</code> 开始，依次考察两个字符串中的字符是否匹配。</p><ul><li><p>如果 <code>a[i]</code> 与 <code>b[j]</code> 互相匹配，将最大公共子串长度加一，并且继续考察 <code>a[i+1]</code> 和 <code>b[j+1]</code>。</p></li><li><p>如果 <code>a[i]</code> 与 <code>b[j]</code> 不匹配，最长公共子串长度不变，这个时候，有两个不同的决策路线：</p></li><li><p>删除 <code>a[i]</code>，或者在 <code>b[j]</code> 前面加上一个字符 <code>a[i]</code>，然后继续考察 <code>a[i+1]</code> 和 <code>b[j]</code>；</p></li><li><p>删除 <code>b[j]</code>，或者在 <code>a[i]</code> 前面加上一个字符 <code>b[j]</code>，然后继续考察 <code>a[i]</code> 和 <code>b[j+1]</code>。</p></li></ul><p>反过来也就是说，如果要求 <code>a[0…i]</code> 和 <code>b[0…j]</code> 的最长公共长度 <code>max_lcs(i, j)</code>，只有可能通过下面三个状态转移过来：</p><p><code>(i-1, j-1, max_lcs)</code>，其中 <code>max_lcs</code> 表示 <code>a[0…i-1</code>] 和 <code>b[0…j-1]</code> 的最长公共子串长度；</p><p><code>(i-1, j, max_lcs)</code>，其中 <code>max_lcs</code> 表示 <code>a[0…i-1]</code> 和<code>b[0…j]</code> 的最长公共子串长度；</p><p><code>(i, j-1, max_lcs)</code>，其中 <code>max_lcs</code> 表示 <code>a[0…i]</code> 和 <code>b[0…j-1]</code> 的最长公共子串长度。</p><p>如果把这个转移过程，用状态转移方程写出来，就是下面这个样子：</p><pre><code class="hljs java">如果：a[i]==b[j]，那么：max_lcs(i, j) 就等于：max(max_lcs(i-<span class="hljs-number">1</span>,j-<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>, max_lcs(i-<span class="hljs-number">1</span>, j), max_lcs(i, j-<span class="hljs-number">1</span>))；如果：a[i]!=b[j]，那么：max_lcs(i, j) 就等于：max(max_lcs(i-<span class="hljs-number">1</span>,j-<span class="hljs-number">1</span>), max_lcs(i-<span class="hljs-number">1</span>, j), max_lcs(i, j-<span class="hljs-number">1</span>))；其中 max 表示求三数中的最大值。</code></pre><p>有了状态转移方程，代码实现就简单多了。代码贴到了下面，你可以对比着文字一块儿看。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lcs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> m)</span> </span>&#123;  <span class="hljs-keyword">int</span>[][] maxlcs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][m];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<span class="hljs-comment">// 初始化第 0 行：a[0..0] 与 b[0..j] 的 maxlcs</span>    <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[j]) maxlcs[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j != <span class="hljs-number">0</span>) maxlcs[<span class="hljs-number">0</span>][j] = maxlcs[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>];    <span class="hljs-keyword">else</span> maxlcs[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<span class="hljs-comment">// 初始化第 0 列：a[0..i] 与 b[0..0] 的 maxlcs</span>    <span class="hljs-keyword">if</span> (a[i] == b[<span class="hljs-number">0</span>]) maxlcs[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) maxlcs[i][<span class="hljs-number">0</span>] = maxlcs[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];    <span class="hljs-keyword">else</span> maxlcs[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 填表</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; m; ++j) &#123;      <span class="hljs-keyword">if</span> (a[i] == b[j]) maxlcs[i][j] = max(          maxlcs[i-<span class="hljs-number">1</span>][j], maxlcs[i][j-<span class="hljs-number">1</span>], maxlcs[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);      <span class="hljs-keyword">else</span> maxlcs[i][j] = max(          maxlcs[i-<span class="hljs-number">1</span>][j], maxlcs[i][j-<span class="hljs-number">1</span>], maxlcs[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]);    &#125;  &#125;  <span class="hljs-keyword">return</span> maxlcs[n-<span class="hljs-number">1</span>][m-<span class="hljs-number">1</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>&#123;  <span class="hljs-keyword">int</span> maxv = Integer.MIN_VALUE;  <span class="hljs-keyword">if</span> (x &gt; maxv) maxv = x;  <span class="hljs-keyword">if</span> (y &gt; maxv) maxv = y;  <span class="hljs-keyword">if</span> (z &gt; maxv) maxv = z;  <span class="hljs-keyword">return</span> maxv;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>动态规划的理论尽管并不复杂，总结起来就是“<strong>一个模型三个特征</strong>”。但是，要想灵活应用并不简单。要想能真正理解、掌握动态规划，只有多练习。</p><p>这三篇中，加上课后思考题，总共有 <code>8</code> 个动态规划问题。这 <code>8</code> 个问题都非常经典。很多动态规划问题其实都可以抽象成这几个问题模型，所以，一定要多看几遍，多思考一下，争取真正搞懂它们。</p><p>只要弄懂了这几个问题，一般的动态规划问题，你应该都可以应付。对于动态规划这个知识点，就算是入门了，再学习更加复杂的就会简单很多。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>如何实现搜索引擎中的拼写纠错功能？</p><blockquote><p>当用户在搜索框内，输入一个拼写错误的单词时，就拿这个单词跟词库中的单词一一进行比较，计算编辑距离，将编辑距离最小的单词，作为纠正之后的单词，提示给用户。</p><p>这就是拼写纠错最基本的原理。不过，真正用于商用的搜索引擎，拼写纠错功能显然不会就这么简单。一方面，单纯利用编辑距离来纠错，效果并不一定好；另一方面，词库中的数据量可能很大，搜索引擎每天要支持海量的搜索，所以对纠错的性能要求很高。<br>针对纠错效果不好的问题，有很多种优化思路，这里介绍几种。</p><ul><li><p>并不仅仅取出编辑距离最小的那个单词，而是取出编辑距离最小的 <code>TOP 10</code>，然后根据其他参数，决策选择哪个单词作为拼写纠错单词。比如使用搜索热门程度来决定哪个单词作为拼写纠错单词。</p></li><li><p>还可以用多种编辑距离计算方法，比如上面讲到的两种，然后分别编辑距离最小的 <code>TOP 10</code>，然后求交集，用交集的结果，再继续优化处理。</p></li><li><p>还可以通过统计用户的搜索日志，得到最常被拼错的单词列表，以及对应的拼写正确的单词。搜索引擎在拼写纠错的时候，首先在这个最长被拼错单词列表中查找。如果一旦找到，直接返回对应的正确的单词。这样纠错的效果非常好。</p></li><li><p>还有更加高级一点的做法，引入个性化因素。针对每个用户，维护这个用户特有的搜索喜好，也就是常用的搜索关键词。当用户输入错误的单词的时候，首先在这个用户常用的搜索关键词中，计算编辑距离，查找编辑距离最小的单词。</p></li></ul><p>针对纠错性能方面，也有相应的优化方式。这里讲两种分治的优化思路。</p><ul><li><p>如果纠错功能的 <code>TPS</code> 不高，可以部署多台机器，每台机器运行一个独立的纠错功能。当有一个纠错请求的时候，通过负载均衡，分配到其中一台机器，来计算编辑距离，得到纠错单词。</p></li><li><p>如果纠错系统的响应时间太长，也就是，每个纠错请求处理时间过长，可以将纠错的词库，分割到很多台机器。当有一个纠错请求的时候，就将这个拼写错误的单词，同时发送到这多台机器，让多台机器并行处理，分别得到编辑距离最小的单词，然后再比对合并，最终决定出一个最优的纠错单词。</p></li></ul><p>真正的搜索引擎的拼写纠错优化，肯定不止这么简单，但是万变不离其宗。掌握了核心原理，就是掌握了解决问题的方法，剩下就靠你自己的灵活运用和实战操练了。</p></blockquote></li><li><p>有一个数字序列包含 <code>n</code> 个不同的数字，如何求出这个序列中的最长递增子序列长度？比如 <code>2, 9, 3, 6, 5, 1, 7</code> 这样一组数字序列，它的最长递增子序列就是 <code>2, 3, 5, 7</code>，所以最长递增子序列的长度是 <code>4</code>。欢迎留言和我分享。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>38.动态规划理论</title>
    <link href="/passages/38/"/>
    <url>/passages/38/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>上一篇，通过两个非常经典的问题，向你展示了用动态规划解决问题的过程。现在你对动态规划应该有了一个初步的认识。</p><h2 id="“一个模型三个特征”理论"><a href="#“一个模型三个特征”理论" class="headerlink" title="“一个模型三个特征”理论"></a>“一个模型三个特征”理论</h2><p>什么样的问题适合用动态规划来解决呢？换句话说，动态规划能解决的问题有什么规律可循呢？实际上，动态规划作为一个非常成熟的算法思想，很多人对此已经做了非常全面的总结。这里把这部分理论总结为“<strong>一个模型三个特征</strong>”。</p><p>首先来看，什么是“<strong>一个模型</strong>”？它指的是动态规划适合解决的问题的模型。把这个模型定义为“<strong>多阶段决策最优解模型</strong>”。下面具体来讲讲。</p><p>一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态。然后寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。</p><p>现在再来看，什么是“<strong>三个特征</strong>”？它们分别是<strong>最优子结构</strong>、<strong>无后效性</strong>和<strong>重复子问题</strong>。这三个概念比较抽象，下面来逐一详细解释一下。</p><h3 id="1-最优子结构"><a href="#1-最优子结构" class="headerlink" title="1. 最优子结构"></a>1. 最优子结构</h3><p>最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，可以通过子问题的最优解，推导出问题的最优解。如果把最优子结构，对应到前面定义的动态规划问题模型上，那也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。</p><h3 id="2-无后效性"><a href="#2-无后效性" class="headerlink" title="2. 无后效性"></a>2. 无后效性</h3><p>无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。    </p><h3 id="3-重复子问题"><a href="#3-重复子问题" class="headerlink" title="3. 重复子问题"></a>3. 重复子问题</h3><p>这个概念比较好理解。前面已经多次提过。如果用一句话概括一下，那就是，不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。</p><h2 id="“一个模型三个特征”实例剖析"><a href="#“一个模型三个特征”实例剖析" class="headerlink" title="“一个模型三个特征”实例剖析"></a>“一个模型三个特征”实例剖析</h2><p>“一个模型三个特征”这部分是理论知识，比较抽象，看了之后可能还是有点懵，有种似懂非懂的感觉，没关系，这个很正常。接下来，结合一个具体的动态规划问题，来详细解释。</p><p>假设有一个 <code>n</code> 乘以 <code>n</code> 的矩阵 <code>w[n][n]</code>。矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角。将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少呢？<br><img src="./4319a62f.jpeg" srcset="/img/loading.gif" alt="image"><br>先看看，这个问题是否符合“一个模型”？</p><p>从 <code>(0, 0)</code> 走到 <code>(n-1, n-1)</code>，总共要走 <code>2*(n-1)</code> 步，也就对应着 <code>2*(n-1)</code> 个阶段。每个阶段都有向右走或者向下走两种决策，并且每个阶段都会对应一个状态集合。</p><p>把状态定义为 <code>min_dist(i, j)</code>，其中 <code>i</code> 表示行，<code>j</code> 表示列。<code>min_dist</code> 表达式的值表示从 <code>(0, 0)</code> 到达 <code>(i, j)</code> 的最短路径长度。所以，这个问题是一个多阶段决策最优解问题，符合动态规划的模型。<br><img src="./bda61ae7.jpeg" srcset="/img/loading.gif" alt="image"><br>再来看，这个问题是否符合“三个特征”？<br>可以用回溯算法来解决这个问题。如果你自己写一下代码，画一下递归树，就会发现，递归树中有重复的节点。重复的节点表示，从左上角到节点对应的位置，有多种路线，这也能说明这个问题中存在重复子问题。<br><img src="./1bd0b304.jpeg" srcset="/img/loading.gif" alt="image"><br>如果走到 <code>(i, j)</code> 这个位置，只能通过 <code>(i-1, j)</code>，<code>(i, j-1)</code> 这两个位置移动过来，也就是说，想要计算 <code>(i, j)</code> 位置对应的状态，只需要关心 <code>(i-1, j)</code>，<code>(i, j-1)</code> 两个位置对应的状态，并不关心棋子是通过什么样的路线到达这两个位置的。而且，仅仅允许往下和往右移动，不允许后退，所以，前面阶段的状态确定之后，不会被后面阶段的决策所改变，所以，这个问题符合“无后效性”这一特征。</p><p>刚刚定义状态的时候，把从起始位置 <code>(0, 0)</code> 到 <code>(i, j)</code> 的最小路径，记作 <code>min_dist(i, j)</code>。因为只能往右或往下移动，所以，只有可能从 <code>(i, j-1)</code> 或者 <code>(i-1, j)</code> 两个位置到达 <code>(i, j)</code>。也就是说，到达 <code>(i, j)</code> 的最短路径要么经过 <code>(i, j-1)</code>，要么经过 <code>(i-1, j)</code>，而且到达 <code>(i, j)</code> 的最短路径肯定包含到达这两个位置的最短路径之一。换句话说就是，<code>min_dist(i, j)</code> 可以通过 <code>min_dist(i, j-1)</code> 和 <code>min_dist(i-1, j)</code> 两个状态推导出来。这就说明，这个问题符合“最优子结构”。</p><pre><code class="hljs java">min_dist(i, j) = w[i][j] + min(min_dist(i, j-<span class="hljs-number">1</span>), min_dist(i-<span class="hljs-number">1</span>, j))</code></pre><h2 id="两种动态规划解题思路总结"><a href="#两种动态规划解题思路总结" class="headerlink" title="两种动态规划解题思路总结"></a>两种动态规划解题思路总结</h2><p>现在再总结一下，动态规划解题的一般思路，让你面对动态规划问题的时候，能够有章可循，不至于束手无策。</p><p>个人觉得，解决动态规划问题，一般有两种思路。把它们分别叫作，状态转移表法和状态转移方程法。</p><h3 id="1-状态转移表法"><a href="#1-状态转移表法" class="headerlink" title="1. 状态转移表法"></a>1. 状态转移表法</h3><p>一般能用动态规划解决的问题，都可以使用回溯算法的暴力搜索解决。所以，当拿到问题的时候，可以先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树。从递归树中，很容易可以看出来，是否存在重复子问题，以及重复子问题是如何产生的。以此来寻找规律，看是否能用动态规划解决。</p><p>找到重复子问题之后，接下来，有两种处理思路，第一种是直接用<strong>回溯加“备忘录”</strong>的方法，来避免重复子问题。从执行效率上来讲，这跟动态规划的解决思路没有差别。第二种是使用动态规划的解决方法，<strong>状态转移表法</strong>。第一种思路，你可以看看上一篇的两个例子。重点来看状态转移表法是如何工作的。</p><p>先画出一个状态表。状态表一般都是二维的，所以你可以把它想象成二维数组。其中，每个状态包含三个变量，行、列、数组值。根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，将这个递推填表的过程，翻译成代码，就是动态规划代码了。</p><p>尽管大部分状态表都是二维的，但是如果问题的状态比较复杂，需要很多变量来表示，那对应的状态表可能就是高维的，比如三维、四维。那这个时候，就不适合用状态转移表法来解决了。一方面是因为高维状态转移表不好画图表示，另一方面是因为人脑确实很不擅长思考高维的东西。</p><p>现在来看一下，如何套用这个状态转移表法，来解决之前那个矩阵最短路径的问题？</p><p>从起点到终点，有很多种不同的走法。可以穷举所有走法，然后对比找出一个最短走法。不过如何才能无重复又不遗漏地穷举出所有走法呢？可以用回溯算法这个比较有规律的穷举算法。</p><p>回溯算法的代码实现如下所示。代码很短，而且前面也分析过很多回溯算法的例题，这里就不多做解释了，你自己来看看。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> minDist = Integer.MAX_VALUE; <span class="hljs-comment">// 全局变量或者成员变量</span><span class="hljs-comment">// 调用方式：minDistBacktracing(0, 0, 0, w, n);</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">minDistBT</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> dist, <span class="hljs-keyword">int</span>[][] w, <span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-comment">// 到达了 n-1, n-1 这个位置了，这里看着有点奇怪哈，你自己举个例子看下</span>  <span class="hljs-keyword">if</span> (i == n &amp;&amp; j == n) &#123;    <span class="hljs-keyword">if</span> (dist &lt; minDist) minDist = dist;    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-keyword">if</span> (i &lt; n) &#123; <span class="hljs-comment">// 往下走，更新 i=i+1, j=j</span>    minDistBT(i + <span class="hljs-number">1</span>, j, dist+w[i][j], w, n);  &#125;  <span class="hljs-keyword">if</span> (j &lt; n) &#123; <span class="hljs-comment">// 往右走，更新 i=i, j=j+1</span>    minDistBT(i, j+<span class="hljs-number">1</span>, dist+w[i][j], w, n);  &#125;&#125;</code></pre><p>有了回溯代码之后，接下来，要画出递归树，以此来寻找重复子问题。在递归树中，一个状态（也就是一个节点）包含三个变量 <code>(i, j, dist)</code>，其中 <code>i</code>，<code>j</code> 分别表示行和列，<code>dist</code> 表示从起点到达 <code>(i, j)</code> 的路径长度。从图中可以看出，尽管 <code>(i, j, dist)</code> 不存在重复的，但是 <code>(i, j)</code> 重复的有很多。对于 <code>(i, j)</code> 重复的节点，只需要选择 <code>dist</code> 最小的节点，继续递归求解，其他节点就可以舍弃了。<br><img src="./fe36fce1.jpeg" srcset="/img/loading.gif" alt="image"><br>既然存在重复子问题，就可以尝试看下，是否可以用动态规划来解决呢？</p><p>画出一个二维状态表，表中的行、列表示棋子所在的位置，表中的数值表示从起点到这个位置的最短路径。按照决策过程，通过不断状态递推演进，将状态表填好。为了方便代码实现，按行来进行依次填充。<br><img src="./dcd08767.jpeg" srcset="/img/loading.gif" alt="image"><br><img src="./a828813a.jpeg" srcset="/img/loading.gif" alt="image"><br>弄懂了填表的过程，代码实现就简单多了。将上面的过程，翻译成代码，就是下面这个样子。结合着代码、图和文字描述，应该更容易理解讲的内容。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistDP</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-keyword">int</span>[][] states = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];  <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123; <span class="hljs-comment">// 初始化 states 的第一行数据</span>    sum += matrix[<span class="hljs-number">0</span>][j];    states[<span class="hljs-number">0</span>][j] = sum;  &#125;  sum = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 初始化 states 的第一列数据</span>    sum += matrix[i][<span class="hljs-number">0</span>];    states[i][<span class="hljs-number">0</span>] = sum;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;      states[i][j] =             matrix[i][j] + Math.min(states[i][j-<span class="hljs-number">1</span>], states[i-<span class="hljs-number">1</span>][j]);    &#125;  &#125;  <span class="hljs-keyword">return</span> states[n-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];&#125;</code></pre><h3 id="2-状态转移方程法"><a href="#2-状态转移方程法" class="headerlink" title="2. 状态转移方程法"></a>2. 状态转移方程法</h3><p>状态转移方程法有点类似递归的解题思路。需要分析某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。根据最优子结构，写出递归公式，也就是所谓的状态转移方程。有了状态转移方程，代码实现就非常简单了。一般情况下，有两种代码实现方法，一种是<strong>递归加“备忘录”</strong>，另一种是<strong>迭代递推</strong>。</p><p>还是拿刚才的例子来举例。最优子结构前面已经分析过了，你可以回过头去再看下。为了方便你查看，把状态转移方程放到这里。</p><pre><code class="hljs java">min_dist(i, j) = w[i][j] + min(min_dist(i, j-<span class="hljs-number">1</span>), min_dist(i-<span class="hljs-number">1</span>, j))</code></pre><p>这里强调一下，<strong>状态转移方程是解决动态规划的关键</strong>。如果能写出状态转移方程，那动态规划问题基本上就解决一大半了，而翻译成代码非常简单。但是很多动态规划问题的状态本身就不好定义，状态转移方程也就更不好想到。</p><p>下面用递归加“备忘录”的方式，将状态转移方程翻译成来代码，你可以看看。对于另一种实现方式，跟状态转移表法的代码实现是一样的，只是思路不同。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] matrix = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>&#125;, &#123;<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;, &#123;<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>&#125;&#125;;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">4</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mem = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDist</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123; <span class="hljs-comment">// 调用 minDist(n-1, n-1);</span>  <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];  <span class="hljs-keyword">if</span> (mem[i][j] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> mem[i][j];  <span class="hljs-keyword">int</span> minLeft = Integer.MAX_VALUE;  <span class="hljs-keyword">if</span> (j-<span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;    minLeft = minDist(i, j-<span class="hljs-number">1</span>);  &#125;  <span class="hljs-keyword">int</span> minUp = Integer.MAX_VALUE;  <span class="hljs-keyword">if</span> (i-<span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;    minUp = minDist(i-<span class="hljs-number">1</span>, j);  &#125;    <span class="hljs-keyword">int</span> currMinDist = matrix[i][j] + Math.min(minLeft, minUp);  mem[i][j] = currMinDist;  <span class="hljs-keyword">return</span> currMinDist;&#125;</code></pre><p>两种动态规划解题思路到这里就讲完了。强调一点，不是每个问题都同时适合这两种解题思路。有的问题可能用第一种思路更清晰，而有的问题可能用第二种思路更清晰，所以，你要结合具体的题目来看，到底选择用哪种解题思路。</p><h2 id="四种算法思想比较分析"><a href="#四种算法思想比较分析" class="headerlink" title="四种算法思想比较分析"></a>四种算法思想比较分析</h2><p>到本篇为止，已经学习了四种算法思想，贪心、分治、回溯和动态规划。本篇的内容主要讲些理论知识，正好也分析一下这四种算法，看看它们之间有什么区别和联系。</p><p>如果将这四种算法思想分一下类，那贪心、回溯、动态规划可以归为一类，而分治单独可以作为一类，因为它跟其他三个都不大一样。为什么这么说呢？前三个算法解决问题的模型，都可以抽象成上面的多阶段决策最优解模型，而分治算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。</p><p>回溯算法是个“万金油”。基本上能用到动态规划、贪心解决的问题，都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了。</p><p>尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。</p><p>贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里不怎么强调重复子问题）。</p><p>其中，最优子结构、无后效性跟动态规划中的无异。“贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择。每一个阶段，都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇首先讲了什么样的问题适合用动态规划解决。这些问题可以总结概括为“一个模型三个特征”。其中，“一个模型”指的是，问题可以抽象成分阶段决策最优解模型。“三个特征”指的是最优子节、无后效性和重复子问题。</p><p>然后，讲了两种动态规划的解题思路。它们分别是状态转移表法和状态转移方程法。其中，状态转移表法解题思路大致可以概括为，<strong>回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码</strong>。状态转移方程法的大致思路可以概括为，<strong>找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码</strong>。</p><p>最后，对比了之前讲过的四种算法思想。贪心、回溯、动态规划可以解决的问题模型类似，都可以抽象成多阶段决策最优解模型。尽管分治算法也能解决最优问题，但是大部分问题的背景都不适合抽象成多阶段决策模型。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>假设有几种不同币值的硬币 <code>v1</code>，<code>v2</code>，……，<code>vn</code>（单位是元）。如果要支付 <code>w</code> 元，求最少需要多少个硬币。比如，有 <code>3</code> 种不同的硬币，<code>1</code> 元、<code>3</code> 元、<code>5</code> 元，要支付 <code>9</code> 元，最少需要 <code>3</code> 个硬币（<code>3</code> 个 <code>3</code> 元的硬币）。欢迎留言和我分享。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>时间复杂度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>37.初识动态规划</title>
    <link href="/passages/37/"/>
    <url>/passages/37/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>淘宝的“双十一”购物节有各种促销活动，比如“满 <code>200</code> 元减 <code>50</code> 元”。假设你女朋友的购物车中有 <code>n</code> 个（<code>n &gt; 100</code>）想买的商品，她希望从里面选几个，在凑够满减条件的前提下，让选出来的商品价格总和最大程度地接近满减条件（<code>200</code> 元），这样就可以极大限度地“薅羊毛”。作为程序员的你，能不能编个代码来帮她搞定呢？</p><h2 id="动态规划学习路线"><a href="#动态规划学习路线" class="headerlink" title="动态规划学习路线"></a>动态规划学习路线</h2><p>动态规划比较适合用来求解最优问题，比如求最大值、最小值等等。它可以非常显著地降低时间复杂度，提高代码的执行效率。不过，它也是出了名的难学。它的主要学习难点跟递归类似，那就是，求解问题的过程不太符合人类常规的思维方式。对于新手来说，要想入门确实不容易。不过，等你掌握了之后，你会发现，实际上并没有想象中那么难。</p><p>为了让你更容易理解动态规划，分了三篇讲解。这三篇分别是，初识动态规划、动态规划理论、动态规划实战。</p><p>第一篇，通过两个非常经典的动态规划问题模型，向你展示为什么需要动态规划，以及动态规划解题方法是如何演化出来的。实际上，只要掌握了这两个例子的解决思路，对于其他很多动态规划问题，都可以套用类似的思路来解决。</p><p>第二篇，总结动态规划适合解决的问题的特征，以及动态规划解题思路。除此之外，还会将贪心、分治、回溯、动态规划这四种算法思想放在一起，对比分析它们各自的特点以及适用的场景。</p><p>第三篇，应用第二篇讲的动态规划理论知识，实战解决三个非常经典的动态规划问题，加深对理论的理解。弄懂了这三篇中的例子，对于动态规划这个知识点，就算是入门了。</p><h2 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h2><p>对于一组不同重量、不可分割的物品，需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少呢？</p><p>关于这个问题，上一篇讲了回溯的解决方法，也就是穷举搜索所有可能的装法，然后找出满足条件的最大值。不过，回溯算法的复杂度比较高，是指数级别的。那有没有什么规律，可以有效降低时间复杂度呢？一起来看看。</p><pre><code class="hljs java"><span class="hljs-comment">// 回溯算法实现。注意：我把输入的变量都定义成了成员变量。</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxW = Integer.MIN_VALUE; <span class="hljs-comment">// 结果放到 maxW 中</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] weight = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 物品重量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>; <span class="hljs-comment">// 物品个数</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> w = <span class="hljs-number">9</span>; <span class="hljs-comment">// 背包承受的最大重量</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> cw)</span> </span>&#123; <span class="hljs-comment">// 调用 f(0, 0)</span>  <span class="hljs-keyword">if</span> (cw == w || i == n) &#123; <span class="hljs-comment">// cw==w 表示装满了，i==n 表示物品都考察完了</span>    <span class="hljs-keyword">if</span> (cw &gt; maxW) maxW = cw;    <span class="hljs-keyword">return</span>;  &#125;  f(i+<span class="hljs-number">1</span>, cw); <span class="hljs-comment">// 选择不装第 i 个物品</span>  <span class="hljs-keyword">if</span> (cw + weight[i] &lt;= w) &#123;    f(i+<span class="hljs-number">1</span>,cw + weight[i]); <span class="hljs-comment">// 选择装第 i 个物品</span>  &#125;&#125;</code></pre><p>规律是不是不好找？那就举个例子、画个图看看。假设背包的最大承载重量是 <code>9</code>。有 <code>5</code> 个不同的物品，每个物品的重量分别是 <code>2</code>，<code>2</code>，<code>4</code>，<code>6</code>，<code>3</code>。如果把这个例子的回溯求解过程，用递归树画出来，就是下面这个样子：<br><img src="./15aee2e8.jpeg" srcset="/img/loading.gif" alt="image"><br>递归树中的每个节点表示一种状态，用（<code>i, cw</code>）来表示。其中，<code>i</code> 表示将要决策第几个物品是否装入背包，<code>cw</code> 表示当前背包中物品的总重量。比如，（<code>2，2</code>）表示将要决策第 <code>2</code> 个物品是否装入背包，在决策前，背包中物品的总重量是 <code>2</code>。</p><p>从递归树中，你应该能会发现，有些子问题的求解是重复的，比如图中 <code>f(2, 2)</code> 和 <code>f(3, 4)</code> 都被重复计算了两次。可以借助递归那一篇讲的“备忘录”的解决方式，记录已经计算好的 <code>f(i, cw)</code>，当再次计算到重复的 <code>f(i, cw)</code> 的时候，可以直接从备忘录中取出来用，就不用再递归计算了，这样就可以避免冗余计算。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxW = Integer.MIN_VALUE; <span class="hljs-comment">// 结果放到 maxW 中</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] weight = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 物品重量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>; <span class="hljs-comment">// 物品个数</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> w = <span class="hljs-number">9</span>; <span class="hljs-comment">// 背包承受的最大重量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[][] mem = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">5</span>][<span class="hljs-number">10</span>]; <span class="hljs-comment">// 备忘录，默认值 false</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> cw)</span> </span>&#123; <span class="hljs-comment">// 调用 f(0, 0)</span>  <span class="hljs-keyword">if</span> (cw == w || i == n) &#123; <span class="hljs-comment">// cw==w 表示装满了，i==n 表示物品都考察完了</span>    <span class="hljs-keyword">if</span> (cw &gt; maxW) maxW = cw;    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-keyword">if</span> (mem[i][cw]) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 重复状态</span>  mem[i][cw] = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 记录 (i, cw) 这个状态</span>  f(i+<span class="hljs-number">1</span>, cw); <span class="hljs-comment">// 选择不装第 i 个物品</span>  <span class="hljs-keyword">if</span> (cw + weight[i] &lt;= w) &#123;    f(i+<span class="hljs-number">1</span>,cw + weight[i]); <span class="hljs-comment">// 选择装第 i 个物品</span>  &#125;&#125;</code></pre><p>这种解决方法非常好。实际上，它已经跟动态规划的执行效率基本上没有差别。但是，多一种方法就多一种解决思路，现在来看看动态规划是怎么做的。</p><p>把整个求解过程分为 <code>n</code> 个阶段，每个阶段会决策一个物品是否放到背包中。每个物品决策（放入或者不放入背包）完之后，背包中的物品的重量会有多种情况，也就是说，会达到多种不同的状态，对应到递归树中，就是有很多不同的节点。</p><p>把每一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合。可以通过合并每一层重复的状态，这样就保证每一层不同状态的个数都不会超过 <code>w</code> 个（<code>w</code> 表示背包的承载重量），也就是例子中的 <code>9</code>。于是，就成功避免了每层状态个数的指数级增长。</p><p>用一个二维数组 <code>states[n][w+1]</code>，来记录每层可以达到的不同状态。</p><p>第 <code>0</code> 个（下标从 <code>0</code> 开始编号）物品的重量是 <code>2</code>，要么装入背包，要么不装入背包，决策完之后，会对应背包的两种状态，背包中物品的总重量是 <code>0</code> 或者 <code>2</code>。用 <code>states[0][0]=true</code> 和 <code>states[0][2]=true</code> 来表示这两种状态。</p><p>第 <code>1</code> 个物品的重量也是 <code>2</code>，基于之前的背包状态，在这个物品决策完之后，不同的状态有 <code>3</code> 个，背包中物品总重量分别是 <code>0(0+0)</code>，<code>2(0+2 or 2+0)</code>，<code>4(2+2)</code>。用 <code>states[1][0]=true</code>，<code>states[1][2]=true</code>，<code>states[1][4]=true</code> 来表示这三种状态。</p><p>以此类推，直到考察完所有的物品后，整个 <code>states</code> 状态数组就都计算好了。如下图所示。图中 <code>0</code> 表示 <code>false</code>，<code>1</code> 表示 <code>true</code>。只需要在最后一层，找一个值为 <code>true</code> 的最接近 <code>w</code>（这里是 <code>9</code>）的值，就是背包中物品总重量的最大值。<br><img src="./125e61d2.jpeg" srcset="/img/loading.gif" alt="image"><br><img src="./a3303b27.jpeg" srcset="/img/loading.gif" alt="image"><br>把上面的过程，翻译成代码，如下：</p><pre><code class="hljs java"><span class="hljs-comment">// weight: 物品重量，n: 物品个数，w: 背包可承载重量</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">knapsack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] weight, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> w)</span> </span>&#123;  <span class="hljs-keyword">boolean</span>[][] states = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n][w+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 默认值 false</span>  states[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;  <span class="hljs-comment">// 第一行的数据要特殊处理，可以利用哨兵优化</span>  <span class="hljs-keyword">if</span> (weight[<span class="hljs-number">0</span>] &lt;= w) &#123;    states[<span class="hljs-number">0</span>][weight[<span class="hljs-number">0</span>]] = <span class="hljs-keyword">true</span>;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 动态规划状态转移</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= w; ++j) &#123;<span class="hljs-comment">// 不把第 i 个物品放入背包</span>      <span class="hljs-keyword">if</span> (states[i-<span class="hljs-number">1</span>][j] == <span class="hljs-keyword">true</span>) states[i][j] = states[i-<span class="hljs-number">1</span>][j];    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= w-weight[i]; ++j) &#123;<span class="hljs-comment">// 把第 i 个物品放入背包</span>      <span class="hljs-keyword">if</span> (states[i-<span class="hljs-number">1</span>][j]==<span class="hljs-keyword">true</span>) states[i][j+weight[i]] = <span class="hljs-keyword">true</span>;    &#125;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = w; i &gt;= <span class="hljs-number">0</span>; --i) &#123; <span class="hljs-comment">// 输出结果</span>    <span class="hljs-keyword">if</span> (states[n-<span class="hljs-number">1</span>][i] == <span class="hljs-keyword">true</span>) <span class="hljs-keyword">return</span> i;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>实际上，这就是一种用动态规划解决问题的思路。把问题分解为多个阶段，每个阶段对应一个决策。记录每一个阶段可达的状态集合（去掉重复的），然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，动态地往前推进。这也是动态规划这个名字的由来，你可以自己体会一下，是不是还挺形象的？</p><p>前面讲到，用回溯算法解决这个问题的时间复杂度 $O(2^n)$，是指数级的。那动态规划解决方案的时间复杂度是多少呢？我来分析一下。</p><p>这个代码的时间复杂度非常好分析，耗时最多的部分就是代码中的两层 <code>for</code> 循环，所以时间复杂度是 $O(n * w)$。<code>n</code> 表示物品个数，<code>w</code> 表示背包可以承载的总重量。</p><p>从理论上讲，指数级的时间复杂度肯定要比 $O(n * w)$ 高很多，但是为了有更加深刻的感受，举一个例子比较一下。</p><p>假设有 <code>10000</code> 个物品，重量分布在 <code>1</code> 到 <code>15000</code> 之间，背包可以承载的总重量是 <code>30000</code>。如果用回溯算法解决，用具体的数值表示出时间复杂度，就是 $2^{10000}$，这是一个相当大的一个数字。如果用动态规划解决，用具体的数值表示出时间复杂度，就是 $10000*30000$。虽然看起来也很大，但是和 $2^{10000}$ 比起来，要小太多了。</p><p>尽管动态规划的执行效率比较高，但是就刚刚的代码实现来说，需要额外申请一个 <code>n</code> 乘以 <code>w+1</code> 的二维数组，对空间的消耗比较多。所以，有时候会说，动态规划是一种空间换时间的解决思路。你可能要问了，有什么办法可以降低空间消耗吗？</p><p>实际上，只需要一个大小为 <code>w+1</code> 的一维数组就可以解决这个问题。动态规划状态转移的过程，都可以基于这个一维数组来操作。具体的代码实现贴在这里，你可以仔细看下。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">knapsack2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] items, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> w)</span> </span>&#123;  <span class="hljs-keyword">boolean</span>[] states = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[w+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 默认值 false</span>  states[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;  <span class="hljs-comment">// 第一行的数据要特殊处理，可以利用哨兵优化</span>  <span class="hljs-keyword">if</span> (items[<span class="hljs-number">0</span>] &lt;= w) &#123;    states[items[<span class="hljs-number">0</span>]] = <span class="hljs-keyword">true</span>;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 动态规划</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = w-items[i]; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<span class="hljs-comment">// 把第 i 个物品放入背包</span>      <span class="hljs-keyword">if</span> (states[j]==<span class="hljs-keyword">true</span>) states[j+items[i]] = <span class="hljs-keyword">true</span>;    &#125;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = w; i &gt;= <span class="hljs-number">0</span>; --i) &#123; <span class="hljs-comment">// 输出结果</span>    <span class="hljs-keyword">if</span> (states[i] == <span class="hljs-keyword">true</span>) <span class="hljs-keyword">return</span> i;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>这里特别强调一下代码中的第 <code>8</code> 行，<code>j</code> 需要从大到小来处理。如果按照 <code>j</code> 从小到大处理的话，会出现 <code>for</code> 循环重复计算的问题。你可以自己想一想。</p><h2 id="0-1-背包问题升级版"><a href="#0-1-背包问题升级版" class="headerlink" title="0-1 背包问题升级版"></a>0-1 背包问题升级版</h2><p>刚刚讲的背包问题，只涉及背包重量和物品重量。现在引入物品价值这一变量。对于一组不同重量、不同价值、不可分割的物品，选择将某些物品装入背包，在满足背包最大重量限制的前提下，背包中可装入物品的总价值最大是多少呢？</p><p>这个问题依旧可以用回溯算法来解决。这个问题并不复杂，所以具体的实现思路，就不用文字描述了，直接看代码。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxV = Integer.MIN_VALUE; <span class="hljs-comment">// 结果放到 maxV 中</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] items = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 物品的重量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] value = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>&#125;; <span class="hljs-comment">// 物品的价值</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>; <span class="hljs-comment">// 物品个数</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> w = <span class="hljs-number">9</span>; <span class="hljs-comment">// 背包承受的最大重量</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> cw, <span class="hljs-keyword">int</span> cv)</span> </span>&#123; <span class="hljs-comment">// 调用 f(0, 0, 0)</span>  <span class="hljs-keyword">if</span> (cw == w || i == n) &#123; <span class="hljs-comment">// cw==w 表示装满了，i==n 表示物品都考察完了</span>    <span class="hljs-keyword">if</span> (cv &gt; maxV) maxV = cv;    <span class="hljs-keyword">return</span>;  &#125;  f(i+<span class="hljs-number">1</span>, cw, cv); <span class="hljs-comment">// 选择不装第 i 个物品</span>  <span class="hljs-keyword">if</span> (cw + weight[i] &lt;= w) &#123;    f(i+<span class="hljs-number">1</span>,cw+weight[i], cv+value[i]); <span class="hljs-comment">// 选择装第 i 个物品</span>  &#125;&#125;</code></pre><p>针对上面的代码，还是画出递归树。在递归树中，每个节点表示一个状态。现在需要 <code>3</code> 个变量（<code>i</code>, <code>cw</code>, <code>cv</code>）来表示一个状态。其中，<code>i</code> 表示即将要决策第 <code>i</code> 个物品是否装入背包，<code>cw</code> 表示当前背包中物品的总重量，<code>cv</code> 表示当前背包中物品的总价值。<br><img src="./82d3dcaa.jpeg" srcset="/img/loading.gif" alt="image"><br>在递归树中，有几个节点的 <code>i</code> 和 <code>cw</code> 是完全相同的，比如 <code>f(2,2,4)</code> 和 <code>f(2,2,3)</code>。在背包中物品总重量一样的情况下，<code>f(2,2,4)</code> 这种状态对应的物品总价值更大，可以舍弃 <code>f(2,2,3)</code> 这种状态，只需要沿着 <code>f(2,2,4)</code> 这条决策路线继续往下决策就可以。</p><p>也就是说，对于 <code>(i, cw)</code> 相同的不同状态，只需要保留 <code>cv</code> 值最大的那个，继续递归处理，其他状态不予考虑。</p><p>思路说完了，但是代码如何实现呢？如果用回溯算法，这个问题就没法再用“备忘录”解决了。所以，就需要换一种思路，看看动态规划是不是更容易解决这个问题？</p><p>还是把整个求解过程分为 <code>n</code> 个阶段，每个阶段会决策一个物品是否放到背包中。每个阶段决策完之后，背包中的物品的总重量以及总价值，会有多种情况，也就是会达到多种不同的状态。</p><p>用一个二维数组 <code>states[n][w+1]</code>，来记录每层可以达到的不同状态。不过这里数组存储的值不再是 <code>boolean</code> 类型的了，而是当前状态对应的最大总价值。把每一层中 <code>(i, cw)</code> 重复的状态（节点）合并，只记录 <code>cv</code> 值最大的那个状态，然后基于这些状态来推导下一层的状态。</p><p>把这个动态规划的过程翻译成代码，就是下面这个样子：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">knapsack3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] weight, <span class="hljs-keyword">int</span>[] value, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> w)</span> </span>&#123;  <span class="hljs-keyword">int</span>[][] states = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][w+<span class="hljs-number">1</span>];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 初始化 states</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; w+<span class="hljs-number">1</span>; ++j) &#123;      states[i][j] = -<span class="hljs-number">1</span>;    &#125;  &#125;  states[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span> (weight[<span class="hljs-number">0</span>] &lt;= w) &#123;    states[<span class="hljs-number">0</span>][weight[<span class="hljs-number">0</span>]] = value[<span class="hljs-number">0</span>];  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 动态规划，状态转移</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= w; ++j) &#123; <span class="hljs-comment">// 不选择第 i 个物品</span>      <span class="hljs-keyword">if</span> (states[i-<span class="hljs-number">1</span>][j] &gt;= <span class="hljs-number">0</span>) states[i][j] = states[i-<span class="hljs-number">1</span>][j];    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= w-weight[i]; ++j) &#123; <span class="hljs-comment">// 选择第 i 个物品</span>      <span class="hljs-keyword">if</span> (states[i-<span class="hljs-number">1</span>][j] &gt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">int</span> v = states[i-<span class="hljs-number">1</span>][j] + value[i];        <span class="hljs-keyword">if</span> (v &gt; states[i][j+weight[i]]) &#123;          states[i][j+weight[i]] = v;        &#125;      &#125;    &#125;  &#125;  <span class="hljs-comment">// 找出最大值</span>  <span class="hljs-keyword">int</span> maxvalue = -<span class="hljs-number">1</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= w; ++j) &#123;    <span class="hljs-keyword">if</span> (states[n-<span class="hljs-number">1</span>][j] &gt; maxvalue) maxvalue = states[n-<span class="hljs-number">1</span>][j];  &#125;  <span class="hljs-keyword">return</span> maxvalue;&#125;</code></pre><p>关于这个问题的时间、空间复杂度的分析，跟上一个例子大同小异，所以就不赘述了。时间复杂度是 $O(n * w)$，空间复杂度也是 $O(n * w)$。跟上一个例子类似，空间复杂度也是可以优化的，你可以自己写一下。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇通过两个例子，展示了动态规划是如何解决问题的，并且一点一点详细讲解了动态规划解决问题的思路。这两个例子都是非常经典的动态规划问题，只要你真正搞懂这两个问题，基本上动态规划已经入门一半了。所以，要多花点时间，真正弄懂这两个问题。</p><p>从例子中，应该能发现，大部分动态规划能解决的问题，都可以通过回溯算法来解决，只不过回溯算法解决起来效率比较低，时间复杂度是指数级的。动态规划算法，在执行效率方面，要高很多。尽管执行效率提高了，但是动态规划的空间复杂度也提高了，所以，很多时候会说，动态规划是一种空间换时间的算法思想。</p><p>前面也说了，本篇的内容并不涉及理论的知识。这两个例子的分析过程，并没有涉及任何高深的理论方面的东西。而且，个人觉得，贪心、分治、回溯、动态规划，这四个算法思想有关的理论知识，大部分都是“后验性”的，也就是说，在解决问题的过程中，往往是先想到如何用某个算法思想解决问题，然后才用算法理论知识，去验证这个算法思想解决问题的正确性。所以，你大可不必过于急于寻求动态规划的理论知识。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>如何巧妙解决“双十一”购物时的凑单问题？</li></ul><blockquote><p>对于这个问题，你当然可以利用回溯算法，穷举所有的排列组合，看大于等于 <code>200</code> 并且最接近 <code>200</code> 的组合是哪一个？但是，这样效率太低了点，时间复杂度非常高，是指数级的。当 <code>n</code> 很大的时候，可能“双十一”已经结束了，你的代码还没有运行出结果，这显然会让你在女朋友心中的形象大大减分。</p><p>实际上，它跟第一个例子中讲的 <code>0-1</code> 背包问题很像，只不过是把“重量”换成了“价格”而已。购物车中有 <code>n</code> 个商品。针对每个商品都决策是否购买。每次决策之后，对应不同的状态集合。还是用一个二维数组 <code>states[n][x]</code>，来记录每次决策之后所有可达的状态。不过，这里的 <code>x</code> 值是多少呢？</p><p><code>0-1</code> 背包问题中，找的是小于等于 <code>w</code> 的最大值，<code>x</code> 就是背包的最大承载重量 <code>w+1</code>。对于这个问题来说，要找的是大于等于 <code>200</code>（满减条件）的值中最小的，所以就不能设置为 <code>200</code> 加 <code>1</code> 了。就这个实际的问题而言，如果要购买的物品的总价格超过 <code>200</code> 太多，比如 <code>1000</code>，那这个羊毛“薅”得就没有太大意义了。所以，可以限定 <code>x</code> 值为 <code>1001</code>。</p><p>不过，这个问题不仅要求大于等于 <code>200</code> 的总价格中的最小的，还要找出这个最小总价格对应都要购买哪些商品。实际上，可以利用 <code>states</code> 数组，倒推出这个被选择的商品序列。这里先把代码写出来，待会再照着代码给你解释。</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// items 商品价格，n 商品个数, w 表示满减条件，比如 200</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">double11advance</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] items, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> w)</span> </span>&#123;  <span class="hljs-keyword">boolean</span>[][] states = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n][<span class="hljs-number">3</span>*w+<span class="hljs-number">1</span>];<span class="hljs-comment">// 超过 3 倍就没有薅羊毛的价值了</span>  states[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;  <span class="hljs-comment">// 第一行的数据要特殊处理</span>  <span class="hljs-keyword">if</span> (items[<span class="hljs-number">0</span>] &lt;= <span class="hljs-number">3</span>*w) &#123;    states[<span class="hljs-number">0</span>][items[<span class="hljs-number">0</span>]] = <span class="hljs-keyword">true</span>;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 动态规划</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">3</span>*w; ++j) &#123;<span class="hljs-comment">// 不购买第 i 个商品</span>      <span class="hljs-keyword">if</span> (states[i-<span class="hljs-number">1</span>][j] == <span class="hljs-keyword">true</span>) states[i][j] = states[i-<span class="hljs-number">1</span>][j];    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">3</span>*w-items[i]; ++j) &#123;<span class="hljs-comment">// 购买第 i 个商品</span>      <span class="hljs-keyword">if</span> (states[i-<span class="hljs-number">1</span>][j]==<span class="hljs-keyword">true</span>) states[i][j+items[i]] = <span class="hljs-keyword">true</span>;    &#125;  &#125;  <span class="hljs-keyword">int</span> j;  <span class="hljs-keyword">for</span> (j = w; j &lt; <span class="hljs-number">3</span>*w+<span class="hljs-number">1</span>; ++j) &#123;     <span class="hljs-keyword">if</span> (states[n-<span class="hljs-number">1</span>][j] == <span class="hljs-keyword">true</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 输出结果大于等于 w 的最小值</span>  &#125;  <span class="hljs-keyword">if</span> (j == <span class="hljs-number">3</span>*w+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 没有可行解</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; --i) &#123; <span class="hljs-comment">// i 表示二维数组中的行，j 表示列</span>    <span class="hljs-keyword">if</span>(j-items[i] &gt;= <span class="hljs-number">0</span> &amp;&amp; states[i-<span class="hljs-number">1</span>][j-items[i]] == <span class="hljs-keyword">true</span>) &#123;      System.out.print(items[i] + <span class="hljs-string">" "</span>); <span class="hljs-comment">// 购买这个商品</span>      j = j - items[i];    &#125; <span class="hljs-comment">// else 没有购买这个商品，j 不变。</span>  &#125;  <span class="hljs-keyword">if</span> (j != <span class="hljs-number">0</span>) System.out.print(items[<span class="hljs-number">0</span>]);&#125;</code></pre><blockquote><p>代码的前半部分跟 <code>0-1</code> 背包问题没有什么不同，着重看后半部分，看它是如何打印出选择购买哪些商品的。</p><p>状态 <code>(i, j)</code> 只有可能从 <code>(i-1, j)</code> 或者 <code>(i-1, j-value[i])</code> 两个状态推导过来。所以，就检查这两个状态是否是可达的，也就是 <code>states[i-1][j]</code> 或者 <code>states[i-1][j-value[i]]</code> 是否是 <code>true</code>。</p><p>如果 <code>states[i-1][j]</code> 可达，就说明没有选择购买第 <code>i</code> 个商品，如果 <code>states[i-1][j-value[i]]</code> 可达，那就说明选择了购买第 <code>i</code> 个商品。从中选择一个可达的状态（如果两个都可达，就随意选择一个），然后，继续迭代地考察其他商品是否有选择购买。</p></blockquote><ul><li>“杨辉三角”不知道你听说过吗？现在对它进行一些改造。每个位置的数字可以随意填写，经过某个数字只能到达下面一层相邻的两个数字。假设你站在第一层，往下移动，把移动到最底层所经过的所有数字之和，定义为路径的长度。请你编程求出从最高层移动到最底层的最短路径长度。欢迎留言和我分享。<br><img src="./d2f3d20f.jpeg" srcset="/img/loading.gif" alt="image"></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>36.回溯算法</title>
    <link href="/passages/36/"/>
    <url>/passages/36/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>深度优先搜索算法利用的是回溯算法思想。这个算法思想非常简单，但是应用却非常广泛。它除了用来指导像深度优先搜索这种经典的算法设计之外，还可以用在很多实际的软件开发场景中，比如正则表达式匹配、编译原理中的语法分析等。</p><p>除此之外，很多经典的数学问题都可以用回溯算法解决，比如数独、八皇后、<code>0-1</code> 背包、图的着色、旅行商问题、全排列等等。</p><h2 id="如何理解“回溯算法”？"><a href="#如何理解“回溯算法”？" class="headerlink" title="如何理解“回溯算法”？"></a>如何理解“回溯算法”？</h2><p>在人们的一生中，会遇到很多重要的岔路口。在岔路口上，每个选择都会影响今后的人生。有的人在每个岔路口都能做出最正确的选择，最后生活、事业都达到了一个很高的高度；而有的人一路选错，最后碌碌无为。如果人生可以量化，那如何才能在岔路口做出最正确的选择，让自己的人生“最优”呢？</p><p>可以借助前面学过的贪心算法，在每次面对岔路口的时候，都做出看起来最优的选择，期望这一组选择可以使得人生达到“最优”。但是，前面也讲过，贪心算法并不一定能得到最优解。那有没有什么办法能得到最优解呢？</p><p><code>2004</code> 年上映了一部非常著名的电影《蝴蝶效应》，讲的就是主人公为了达到自己的目标，一直通过回溯的方法，回到童年，在关键的岔路口，重新做选择。当然，这只是科幻电影，人生是无法倒退的，但是这其中蕴含的思想其实就是回溯算法。</p><p>笼统地讲，回溯算法很多时候都应用在“搜索”这类问题上。不过这里说的搜索，并不是狭义的指前面讲过的图的搜索算法，而是在一组可能的解中，搜索满足期望的解。</p><p>回溯的处理思想，有点类似枚举搜索。枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，把问题求解的过程分为多个阶段。每个阶段，都会面对一个岔路口，先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。</p><p>理论的东西还是过于抽象，还是举例说明一下。举一个经典的回溯例子，你可能已经猜到了，那就是八皇后问题。</p><p>有一个 <code>8x8</code> 的棋盘，希望往里放 <code>8</code> 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子。可以看下面的图，第一幅图是满足条件的一种方法，第二幅图是不满足条件的。八皇后问题就是期望找到所有满足这种要求的放棋子方式。<br><img src="./9f6519ad.jpeg" srcset="/img/loading.gif" alt="image"><br>把这个问题划分成 <code>8</code> 个阶段，依次将 <code>8</code> 个棋子放到第一行、第二行、第三行……第八行。在放置的过程中，不停地检查当前的方法，是否满足要求。如果满足，则跳到下一行继续放置棋子；如果不满足，那就再换一种方法，继续尝试。</p><p>回溯算法非常适合用递归代码实现，所以，把八皇后的算法翻译成代码。在代码里添加了详细的注释，你可以对比着看下。</p><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">8</span>];<span class="hljs-comment">// 全局或成员变量, 下标表示行, 值表示 queen 存储在哪一列</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cal8queens</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row)</span> </span>&#123; <span class="hljs-comment">// 调用方式：cal8queens(0);</span>  <span class="hljs-keyword">if</span> (row == <span class="hljs-number">8</span>) &#123; <span class="hljs-comment">// 8 个棋子都放置好了，打印结果</span>    printQueens(result);    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 8 行棋子都放好了，已经没法再往下递归了，所以就 return</span>  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> column = <span class="hljs-number">0</span>; column &lt; <span class="hljs-number">8</span>; ++column) &#123; <span class="hljs-comment">// 每一行都有 8 中放法</span>    <span class="hljs-keyword">if</span> (isOk(row, column)) &#123; <span class="hljs-comment">// 有些放法不满足要求</span>      result[row] = column; <span class="hljs-comment">// 第 row 行的棋子放到了 column 列</span>      cal8queens(row+<span class="hljs-number">1</span>); <span class="hljs-comment">// 考察下一行</span>    &#125;  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOk</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> column)</span> </span>&#123;<span class="hljs-comment">// 判断 row 行 column 列放置是否合适</span>  <span class="hljs-keyword">int</span> leftup = column - <span class="hljs-number">1</span>, rightup = column + <span class="hljs-number">1</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123; <span class="hljs-comment">// 逐行往上考察每一行</span>    <span class="hljs-keyword">if</span> (result[i] == column) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 第 i 行的 column 列有棋子吗？</span>    <span class="hljs-keyword">if</span> (leftup &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 考察左上对角线：第 i 行 leftup 列有棋子吗？</span>      <span class="hljs-keyword">if</span> (result[i] == leftup) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">if</span> (rightup &lt; <span class="hljs-number">8</span>) &#123; <span class="hljs-comment">// 考察右上对角线：第 i 行 rightup 列有棋子吗？</span>      <span class="hljs-keyword">if</span> (result[i] == rightup) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    --leftup; ++rightup;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printQueens</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] result)</span> </span>&#123; <span class="hljs-comment">// 打印出一个二维矩阵</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; <span class="hljs-number">8</span>; ++row) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> column = <span class="hljs-number">0</span>; column &lt; <span class="hljs-number">8</span>; ++column) &#123;      <span class="hljs-keyword">if</span> (result[row] == column) System.out.print(<span class="hljs-string">"Q "</span>);      <span class="hljs-keyword">else</span> System.out.print(<span class="hljs-string">"* "</span>);    &#125;    System.out.println();  &#125;  System.out.println();&#125;</code></pre><h2 id="两个回溯算法的经典应用"><a href="#两个回溯算法的经典应用" class="headerlink" title="两个回溯算法的经典应用"></a>两个回溯算法的经典应用</h2><p>回溯算法的理论知识很容易弄懂。不过，对于新手来说，比较难的是用递归来实现。所以，再通过两个例子，来练习一下回溯算法的应用和实现。</p><h3 id="1-0-1-背包"><a href="#1-0-1-背包" class="headerlink" title="1. 0-1 背包"></a>1. 0-1 背包</h3><p><code>0-1</code> 背包是非常经典的算法问题，很多场景都可以抽象成这个问题模型。这个问题的经典解法是动态规划，不过还有一种简单但没有那么高效的解法，那就是回溯算法。</p><p><code>0-1</code> 背包问题有很多变体，这里介绍一种比较基础的。有一个背包，背包总的承载重量是 <code>Wkg</code>。现在有 <code>n</code> 个物品，每个物品的重量不等，并且不可分割。现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p><p>实际上，背包问题在贪心算法那一篇，已经讲过一个了，不过那里讲的物品是可以分割的，可以装某个物品的一部分到背包里面。这里的背包问题，物品是不可分割的，要么装要么不装，所以叫 <code>0-1</code> 背包问题。显然，这个问题已经无法通过贪心算法来解决了。现在来看看，用回溯算法如何来解决。</p><p>对于每个物品来说，都有两种选择，装进背包或者不装进背包。对于 <code>n</code> 个物品来说，总的装法就有 $2^n$ 种，去掉总重量超过 <code>Wkg</code> 的，从剩下的装法中选择总重量最接近 <code>Wkg</code> 的。不过，如何才能不重复地穷举出这 $2^n$ 种装法呢？</p><p>这里就可以用回溯的方法。可以把物品依次排列，整个问题就分解为了 <code>n</code> 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。描述起来很费劲，直接看代码，反而会更加清晰一些。</p><p>这里还稍微用到了一点搜索剪枝的技巧，就是当发现已经选择的物品的重量超过 <code>Wkg</code> 之后，就停止继续探测剩下的物品。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxW = Integer.MIN_VALUE; <span class="hljs-comment">// 存储背包中物品总重量的最大值</span><span class="hljs-comment">// cw 表示当前已经装进去的物品的重量和；i 表示考察到哪个物品了；</span><span class="hljs-comment">// w 背包重量；items 表示每个物品的重量；n 表示物品个数</span><span class="hljs-comment">// 假设背包可承受重量 100，物品个数 10，物品重量存储在数组 a 中，那可以这样调用函数：</span><span class="hljs-comment">// f(0, 0, a, 10, 100)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> cw, <span class="hljs-keyword">int</span>[] items, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> w)</span> </span>&#123;  <span class="hljs-keyword">if</span> (cw == w || i == n) &#123; <span class="hljs-comment">// cw==w 表示装满了 ;i==n 表示已经考察完所有的物品</span>    <span class="hljs-keyword">if</span> (cw &gt; maxW) maxW = cw;    <span class="hljs-keyword">return</span>;  &#125;  f(i+<span class="hljs-number">1</span>, cw, items, n, w);  <span class="hljs-keyword">if</span> (cw + items[i] &lt;= w) &#123;<span class="hljs-comment">// 已经超过可以背包承受的重量的时候，就不要再装了</span>    f(i+<span class="hljs-number">1</span>,cw + items[i], items, n, w);  &#125;&#125;</code></pre><h3 id="2-正则表达式"><a href="#2-正则表达式" class="headerlink" title="2. 正则表达式"></a>2. 正则表达式</h3><p>对于一个开发工程师来说，正则表达式你应该不陌生吧？在平时的开发中，或多或少都应该用过。实际上，正则表达式里最重要的一种算法思想就是回溯。</p><p>正则表达式中，最重要的就是通配符，通配符结合在一起，可以表达非常丰富的语义。为了方便，假设正表达式中只包含“ * ”和“ ? ”这两种通配符，并且对这两个通配符的语义稍微做些改变，其中，“ * ”匹配任意多个（大于等于 <code>0</code> 个）任意字符，“ ? ”匹配零个或者一个任意字符。基于以上背景假设，如何用回溯算法，判断一个给定的文本，能否跟给定的正则表达式匹配？</p><p>依次考察正则表达式中的每个字符，当是非通配符时，就直接跟文本的字符进行匹配，如果相同，则继续往下处理；如果不同，则回溯。如果遇到特殊字符的时候，就有多种处理方式了，也就是所谓的岔路口，比如“ * ”有多种匹配方案，可以匹配任意个文本串中的字符，就先随意的选择一种匹配方案，然后继续考察剩下的字符。如果中途发现无法继续匹配下去了，就回到这个岔路口，重新选择一种匹配方案，然后再继续匹配剩下的字符。</p><p>把这个过程翻译成了代码，你可以结合着一块看下。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pattern</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> matched = <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] pattern; <span class="hljs-comment">// 正则表达式</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> plen; <span class="hljs-comment">// 正则表达式长度</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pattern</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] pattern, <span class="hljs-keyword">int</span> plen)</span> </span>&#123;    <span class="hljs-keyword">this</span>.pattern = pattern;    <span class="hljs-keyword">this</span>.plen = plen;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] text, <span class="hljs-keyword">int</span> tlen)</span> </span>&#123; <span class="hljs-comment">// 文本串及长度</span>    matched = <span class="hljs-keyword">false</span>;    rmatch(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, text, tlen);    <span class="hljs-keyword">return</span> matched;  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rmatch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ti, <span class="hljs-keyword">int</span> pj, <span class="hljs-keyword">char</span>[] text, <span class="hljs-keyword">int</span> tlen)</span> </span>&#123;    <span class="hljs-keyword">if</span> (matched) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果已经匹配了，就不要继续递归了</span>    <span class="hljs-keyword">if</span> (pj == plen) &#123; <span class="hljs-comment">// 正则表达式到结尾了</span>      <span class="hljs-keyword">if</span> (ti == tlen) matched = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 文本串也到结尾了</span>      <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span> (pattern[pj] == <span class="hljs-string">'*'</span>) &#123; <span class="hljs-comment">// * 匹配任意个字符</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;= tlen-ti; ++k) &#123;        rmatch(ti+k, pj+<span class="hljs-number">1</span>, text, tlen);      &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pattern[pj] == <span class="hljs-string">'?'</span>) &#123; <span class="hljs-comment">// ? 匹配 0 个或者 1 个字符</span>      rmatch(ti, pj+<span class="hljs-number">1</span>, text, tlen);      rmatch(ti+<span class="hljs-number">1</span>, pj+<span class="hljs-number">1</span>, text, tlen);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ti &lt; tlen &amp;&amp; pattern[pj] == text[ti]) &#123; <span class="hljs-comment">// 纯字符匹配才行</span>      rmatch(ti+<span class="hljs-number">1</span>, pj+<span class="hljs-number">1</span>, text, tlen);    &#125;  &#125;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回溯算法的思想非常简单，大部分情况下，都是用来解决广义的搜索问题，也就是，从一组可能的解中，选择出一个满足要求的解。回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。利用剪枝，并不需要穷举搜索所有的情况，从而提高搜索效率。</p><p>尽管回溯算法的原理非常简单，但是却可以解决很多问题，比如开头提到的深度优先搜索、八皇后、<code>0-1</code> 背包问题、图的着色、旅行商问题、数独、全排列、正则表达式匹配等等。如果感兴趣的话，可以自己搜索研究一下，最好还能用代码实现一下。如果这几个问题都能实现的话，基本就掌握了回溯算法。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>现在对今天讲到的 <code>0-1</code> 背包问题稍加改造，如果每个物品不仅重量不同，价值也不同。如何在不超过背包重量的情况下，让背包中的总价值最大？欢迎留言和我分享。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>时间复杂度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>35.分治算法</title>
    <link href="/passages/35/"/>
    <url>/passages/35/</url>
    
    <content type="html"><![CDATA[<!-- more --><p><code>MapReduce</code> 是 <code>Google</code> 大数据处理的三驾马车之一，另外两个是 <code>GFS</code> 和 <code>Bigtable</code>。它在倒排索引、<code>PageRank</code> 计算、网页分析等搜索引擎相关的技术中都有大量的应用。</p><p>尽管开发一个 <code>MapReduce</code> 看起来很高深，感觉跟遥不可及。实际上，万变不离其宗，它的本质就是一种算法思想，分治算法。</p><h2 id="如何理解分治算法？"><a href="#如何理解分治算法？" class="headerlink" title="如何理解分治算法？"></a>如何理解分治算法？</h2><p>为什么说 <code>MapRedue</code> 的本质就是分治算法呢？先来看，什么是分治算法？</p><p>分治算法（<code>divide and conquer</code>）的核心思想其实就是四个字，分而治之 ，也就是将原问题划分成 <code>n</code> 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。</p><p>这个定义看起来有点类似递归的定义。关于分治和递归的区别，在排序（下）的时候说过，<strong>分治算法是一种处理问题的思想，递归是一种编程技巧</strong>。实际上，分治算法一般都比较适合用递归来实现。分治算法的递归实现中，每一层递归都会涉及这样三个操作：</p><ul><li><p>分解：将原问题分解成一系列子问题；</p></li><li><p>解决：递归地求解各个子问题，若子问题足够小，则直接求解；</p></li><li><p>合并：将子问题的结果合并成原问题。</p></li></ul><p>分治算法能解决的问题，一般需要满足下面这几个条件：</p><ul><li><p>原问题与分解成的小问题具有相同的模式；</p></li><li><p>原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别；</p></li><li><p>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</p></li><li><p>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。</p></li></ul><h2 id="分治算法应用举例分析"><a href="#分治算法应用举例分析" class="headerlink" title="分治算法应用举例分析"></a>分治算法应用举例分析</h2><p>理解分治算法的原理并不难，但是要想灵活应用并不容易。</p><p>还记得在排序算法里讲的数据的有序度、逆序度的概念吗？当时讲到，用有序度来表示一组数据的有序程度，用逆序度表示一组数据的无序程度。</p><p>假设有 <code>n</code> 个数据，期望数据从小到大排列，那完全有序的数据的有序度就是 $\frac {n(n-1)} 2$，逆序度等于 <code>0</code>；相反，倒序排列的数据的有序度就是 <code>0</code>，逆序度是 $\frac {n(n-1)} 2$。除了这两种极端情况外，通过计算有序对或者逆序对的个数，来表示数据的有序度或逆序度。<br><img src="./b95662c3.jpeg" srcset="/img/loading.gif" alt="image"><br>现在的问题是，<strong>如何编程求出一组数据的有序对个数或者逆序对个数呢？</strong>因为有序对个数和逆序对个数的求解方式是类似的，所以可以只思考逆序对个数的求解方法。</p><p>最笨的方法是，拿每个数字跟它后面的数字比较，看有几个比它小的。把比它小的数字个数记作 <code>k</code>，通过这样的方式，把每个数字都考察一遍之后，然后对每个数字对应的 <code>k</code> 值求和，最后得到的总和就是逆序对个数。不过，这样操作的时间复杂度是 $O(n^2)$。那有没有更加高效的处理方法呢？</p><p>用分治算法来试试。套用分治的思想来求数组 <code>A</code> 的逆序对个数。可以将数组分成前后两半 <code>A1</code> 和 <code>A2</code>，分别计算 <code>A1</code> 和 <code>A2</code> 的逆序对个数 <code>K1</code> 和 <code>K2</code>，然后再计算 <code>A1</code> 与 <code>A2</code> 之间的逆序对个数 <code>K3</code>。那数组 <code>A</code> 的逆序对个数就等于 <code>K1 + K2 + K3</code>。</p><p>前面讲过，使用分治算法其中一个要求是，子问题合并的代价不能太大，否则就起不了降低时间复杂度的效果了。那回到这个问题，如何快速计算出两个子问题 <code>A1</code> 与 <code>A2</code> 之间的逆序对个数呢？</p><p>这里就要借助归并排序算法了。如何借助归并排序算法来解决呢？</p><p>归并排序中有一个非常关键的操作，就是将两个有序的小数组，合并成一个有序的数组。实际上，在这个合并的过程中，就可以计算这两个小数组的逆序对个数了。每次合并操作，都计算逆序对个数，把这些计算出来的逆序对个数求和，就是这个数组的逆序对个数了。<br><img src="./fb7a9756.jpeg" srcset="/img/loading.gif" alt="image"><br>翻译成了代码如下，可以结合着图和文字描述一起看下。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>; <span class="hljs-comment">// 全局变量或者成员变量</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n)</span> </span>&#123;  num = <span class="hljs-number">0</span>;  mergeSortCounting(a, <span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>);  <span class="hljs-keyword">return</span> num;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSortCounting</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span> </span>&#123;  <span class="hljs-keyword">if</span> (p &gt;= r) <span class="hljs-keyword">return</span>;  <span class="hljs-keyword">int</span> q = (p+r)/<span class="hljs-number">2</span>;  mergeSortCounting(a, p, q);  mergeSortCounting(a, q+<span class="hljs-number">1</span>, r);  merge(a, p, q, r);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q, <span class="hljs-keyword">int</span> r)</span> </span>&#123;  <span class="hljs-keyword">int</span> i = p, j = q+<span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;  <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r-p+<span class="hljs-number">1</span>];  <span class="hljs-keyword">while</span> (i&lt;=q &amp;&amp; j&lt;=r) &#123;    <span class="hljs-keyword">if</span> (a[i] &lt;= a[j]) &#123;      tmp[k++] = a[i++];    &#125; <span class="hljs-keyword">else</span> &#123;      num += (q-i+<span class="hljs-number">1</span>); <span class="hljs-comment">// 统计 p-q 之间，比 a[j] 大的元素个数</span>      tmp[k++] = a[j++];    &#125;  &#125;  <span class="hljs-keyword">while</span> (i &lt;= q) &#123; <span class="hljs-comment">// 处理剩下的</span>    tmp[k++] = a[i++];  &#125;  <span class="hljs-keyword">while</span> (j &lt;= r) &#123; <span class="hljs-comment">// 处理剩下的</span>    tmp[k++] = a[j++];  &#125;  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= r-p; ++i) &#123; <span class="hljs-comment">// 从 tmp 拷贝回 a</span>    a[p+i] = tmp[i];  &#125;&#125;</code></pre><p>有很多人经常说，某某算法思想如此巧妙，我是怎么也想不到的。实际上，确实是的。有些算法确实非常巧妙，并不是每个人短时间都能想到的。比如这个问题，并不是每个人都能想到可以借助归并排序算法来解决，不夸张地说，如果之前没接触过，绝大部分人都想不到。但是，如果告诉你可以借助归并排序算法来解决，那你就应该要想到如何改造归并排序，来求解这个问题了，只要你能做到这一点，就很棒了。</p><p>关于分治算法，这还有两道比较经典的问题，你可以自己练习一下。</p><ul><li><p>二维平面上有 <code>n</code> 个点，如何快速计算出两个距离最近的点对？</p></li><li><p>有两个 <code>n*n</code> 的矩阵 <code>A</code>，<code>B</code>，如何快速求解两个矩阵的乘积 <code>C=A*B</code>？</p></li></ul><h2 id="分治思想在海量数据处理中的应用"><a href="#分治思想在海量数据处理中的应用" class="headerlink" title="分治思想在海量数据处理中的应用"></a>分治思想在海量数据处理中的应用</h2><p>分治算法思想的应用是非常广泛的，并不仅限于指导编程和算法设计。它还经常用在海量数据处理的场景中。前面讲的数据结构和算法，大部分都是基于内存存储和单机处理。但是，如果要处理的数据量非常大，没法一次性放到内存中，这个时候，这些数据结构和算法就无法工作了。</p><p>比如，给 <code>10GB</code> 的订单文件按照金额排序这样一个需求，看似是一个简单的排序问题，但是因为数据量大，有 <code>10GB</code>，而机器的内存可能只有 <code>2</code>、<code>3GB</code> 这样子，无法一次性加载到内存，也就无法通过单纯地使用快排、归并等基础算法来解决了。</p><p>要解决这种数据量大到内存装不下的问题，就可以利用分治的思想。可以将海量的数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后再将小数据集合合并成大数据集合。实际上，利用这种分治的处理思路，不仅仅能克服内存的限制，还能利用多线程或者多机处理，加快处理的速度。</p><p>比如刚刚举的那个例子，给 <code>10GB</code> 的订单排序，就可以先扫描一遍订单，根据订单的金额，将 <code>10GB</code> 的文件划分为几个金额区间。比如订单金额为 <code>1</code> 到 <code>100</code> 元的放到一个小文件，<code>101</code> 到 <code>200</code> 之间的放到另一个文件，以此类推。这样每个小文件都可以单独加载到内存排序，最后将这些有序的小文件合并，就是最终有序的 <code>10GB</code> 订单数据了。</p><p>如果订单数据存储在类似 <code>GFS</code> 这样的分布式系统上，当 <code>10GB</code> 的订单被划分成多个小文件的时候，每个文件可以并行加载到多台机器上处理，最后再将结果合并在一起，这样并行处理的速度也加快了很多。不过，这里有一个点要注意，就是数据的存储与计算所在的机器是同一个或者在网络中靠的很近（比如一个局域网内，数据存取速度很快），否则就会因为数据访问的速度，导致整个处理过程不但不会变快，反而有可能变慢。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分治算法用四个字概括就是“分而治之”，将原问题划分成 <code>n</code> 个规模较小而结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。这个思想非常简单、好理解。</p><p>本篇讲了两种分治算法的典型的应用场景，一个是用来指导编码，降低问题求解的时间复杂度，另一个是解决海量数据处理问题。比如 <code>MapReduce</code> 本质上就是利用了分治思想。</p><p>人们也时常感叹 <code>Google</code> 的创新能力如此之强，总是在引领技术的发展。实际上，<strong>创新并非离我们很远，创新的源泉来自对事物本质的认识。无数优秀架构设计的思想来源都是基础的数据结构和算法，这本身就是算法的一个魅力所在。</strong></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>为什么说 <code>MapReduce</code> 的本质就是分治思想？</p><blockquote><p>刚刚举的订单的例子，数据有 <code>10GB</code> 大小，可能给你的感受还不强烈。那如果要处理的数据是 <code>1T</code>、<code>10T</code>、<code>100T</code> 这样子的，那一台机器处理的效率肯定是非常低的。而对于谷歌搜索引擎来说，网页爬取、清洗、分析、分词、计算权重、倒排索引等等各个环节中，都会面对如此海量的数据（比如网页）。所以，利用集群并行处理显然是大势所趋。</p><p>一台机器过于低效，那就把任务拆分到多台机器上来处理。如果拆分之后的小任务之间互不干扰，独立计算，最后再将结果合并。这不就是分治思想吗？</p><p>实际上，<code>MapReduce</code> 框架只是一个任务调度器，底层依赖 <code>GFS</code> 来存储数据，依赖 <code>Borg</code> 管理机器。它从 <code>GFS</code> 中拿数据，交给 <code>Borg</code> 中的机器执行，并且时刻监控机器执行的进度，一旦出现机器宕机、进度卡壳等，就重新从 <code>Borg</code> 中调度一台机器执行。</p><p>尽管 <code>MapReduce</code> 的模型非常简单，但是在 <code>Google</code> 内部应用非常广泛。它除了可以用来处理这种数据与数据之间存在关系的任务，比如 <code>MapReduce</code> 的经典例子，统计文件中单词出现的频率。除此之外，它还可以用来处理数据与数据之间没有关系的任务，比如对网页分析、分词等，每个网页可以独立的分析、分词，而这两个网页之间并没有关系。网页几十亿、上百亿，如果单机处理，效率低下，就可以利用 <code>MapReduce</code> 提供的高可靠、高性能、高容错的并行计算框架，并行地处理这几十亿、上百亿的网页。</p></blockquote></li><li><p>前面讲过的数据结构、算法、解决思路，以及举的例子中，有哪些采用了分治算法的思想呢？除此之外，生活、工作中，还有没有其他用到分治算法的地方呢？你可以自己回忆、总结一下，这对你将零散的知识提炼成体系非常有帮助。欢迎留言和我分享。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>时间复杂度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>34.贪心算法</title>
    <link href="/passages/34/"/>
    <url>/passages/34/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>贪心算法（<code>greedy algorithm</code>）有很多经典的应用，比如霍夫曼编码（<code>Huffman Coding</code>）、<code>Prim</code> 和 <code>Kruskal</code> 最小生成树算法、还有 <code>Dijkstra</code> 单源最短路径算法。</p><h2 id="如何理解“贪心算法”？"><a href="#如何理解“贪心算法”？" class="headerlink" title="如何理解“贪心算法”？"></a>如何理解“贪心算法”？</h2><p>关于贪心算法，先看一个例子。</p><p>假设有一个可以容纳 <code>100kg</code> 物品的背包，可以装各种物品。有以下 <code>5</code> 种豆子，每种豆子的总量和总价值都各不相同。为了让背包中所装物品的总价值最大，如何选择在背包中装哪些豆子？每种豆子又该装多少呢？<br><img src="./671ec93d.jpeg" srcset="/img/loading.gif" alt="image"><br>实际上，这个问题很简单，只要先算一算每个物品的单价，按照单价由高到低依次来装就好了。单价从高到低排列，依次是：黑豆、绿豆、红豆、青豆、黄豆，所以，可以往背包里装 <code>20kg</code> 黑豆、<code>30kg</code> 绿豆、<code>50kg</code> 红豆。</p><p>这个问题的解决思路显而易见，它本质上借助的就是贪心算法。结合这个例子，总结一下贪心算法解决问题的步骤:</p><p><strong>第一步，当看到这类问题的时候，首先要联想到贪心算法</strong>：针对一组数据，定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。</p><p>类比到刚刚的例子，限制值就是重量不能超过 <code>100kg</code>，期望值就是物品的总价值。这组数据就是 <code>5</code> 种豆子。从中选出一部分，满足重量不超过 <code>100kg</code>，并且总价值最大。</p><p><strong>第二步，尝试看下这个问题是否可以用贪心算法解决</strong>：每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据。</p><p>类比到刚刚的例子，每次都从剩下的豆子里面，选择单价最高的，也就是重量相同的情况下，对价值贡献最大的豆子。</p><p><strong>第三步，举几个例子看下贪心算法产生的结果是否是最优的</strong>。大部分情况下，举几个例子验证一下就可以了。严格地证明贪心算法的正确性，是非常复杂的，需要涉及比较多的数学推理。而且，从实践的角度来说，大部分能用贪心算法解决的问题，贪心算法的正确性都是显而易见的，也不需要严格的数学推导证明。</p><p>实际上，用贪心算法解决问题的思路，并不总能给出最优解。</p><p>举一个例子。在一个有权图中，从顶点 <code>S</code> 开始，找一条到顶点 <code>T</code> 的最短路径（路径中边的权值和最小）。贪心算法的解决思路是，每次都选择一条跟当前顶点相连的权最小的边，直到找到顶点 <code>T</code>。按照这种思路，求出的最短路径是 <code>S-&gt;A-&gt;E-&gt;T</code>，路径长度是 <code>1+4+4=9</code>。<br><img src="./a04799c6.jpeg" srcset="/img/loading.gif" alt="image"><br>但是，这种贪心的选择方式，最终求的路径并不是最短路径，因为路径 <code>S-&gt;B-&gt;D-&gt;T</code> 才是最短路径，因为这条路径的长度是 <code>2+2+2=6</code>。为什么贪心算法在这个问题上不工作了呢？</p><p>在这个问题上，贪心算法不工作的主要原因是，前面的选择，会影响后面的选择。如果第一步从顶点 <code>S</code> 走到顶点 <code>A</code>，那接下来面对的顶点和边，跟第一步从顶点 <code>S</code> 走到顶点 <code>B</code>，是完全不同的。所以，即便第一步选择最优的走法（边最短），但有可能因为这一步选择，导致后面每一步的选择都很糟糕，最终也就无缘全局最优解了。</p><h2 id="贪心算法实战分析"><a href="#贪心算法实战分析" class="headerlink" title="贪心算法实战分析"></a>贪心算法实战分析</h2><p>对于贪心算法，是不是还有点懵？如果死抠理论的话，确实很难理解透彻。掌握贪心算法的关键是多练习。只要多练习几道题，自然就有感觉了。所以，下面一起分析几个具体的例子，帮助深入理解贪心算法。</p><h3 id="1-分糖果"><a href="#1-分糖果" class="headerlink" title="1. 分糖果"></a>1. 分糖果</h3><p>有 <code>m</code> 个糖果和 <code>n</code> 个孩子。现在要把糖果分给这些孩子吃，但是糖果少，孩子多（<code>m&lt;n</code>），所以糖果只能分配给一部分孩子。</p><p>每个糖果的大小不等，这 <code>m</code> 个糖果的大小分别是 <code>s1</code>，<code>s2</code>，<code>s3</code>，……，<code>sm</code>。除此之外，每个孩子对糖果大小的需求也是不一样的，只有糖果的大小大于等于孩子的对糖果大小的需求的时候，孩子才得到满足。假设这 <code>n</code> 个孩子对糖果大小的需求分别是 <code>g1</code>，<code>g2</code>，<code>g3</code>，……，<code>gn</code>。</p><p>问题是，如何分配糖果，能尽可能满足最多数量的孩子？</p><p>可以把这个问题抽象成，从 <code>n</code> 个孩子中，抽取一部分孩子分配糖果，让满足的孩子的个数（期望值）是最大的。这个问题的限制值就是糖果个数 <code>m</code>。</p><p>现在来看看如何用贪心算法来解决。对于一个孩子来说，如果小的糖果可以满足，就没必要用更大的糖果，这样更大的就可以留给其他对糖果大小需求更大的孩子。另一方面，对糖果大小需求小的孩子更容易被满足，所以，可以从需求小的孩子开始分配糖果。因为满足一个需求大的孩子跟满足一个需求小的孩子，对期望值的贡献是一样的。</p><p>每次从剩下的孩子中，找出对糖果大小需求最小的，然后发给他剩下的糖果中能满足他的最小的糖果，这样得到的分配方案，也就是满足的孩子个数最多的方案。</p><h3 id="2-钱币找零"><a href="#2-钱币找零" class="headerlink" title="2. 钱币找零"></a>2. 钱币找零</h3><p>这个问题在日常生活中更加普遍。假设有 <code>1</code> 元、<code>2</code> 元、<code>5</code> 元、<code>10</code> 元、<code>20</code> 元、<code>50</code> 元、<code>100</code> 元这些面额的纸币，它们的张数分别是 <code>c1</code>、<code>c2</code>、<code>c5</code>、<code>c10</code>、<code>c20</code>、<code>c50</code>、<code>c100</code>。现在要用这些钱来支付 <code>K</code> 元，最少要用多少张纸币呢？</p><p>在生活中，肯定是先用面值最大的来支付，如果不够，就继续用更小一点面值的，以此类推，最后剩下的用 <code>1</code> 元来补齐。</p><p>在贡献相同期望值（纸币数目）的情况下，希望多贡献点金额，这样就可以让纸币数更少，这就是一种贪心算法的解决思路。直觉告诉我们，这种处理方法就是最好的。实际上，要严谨地证明这种贪心算法的正确性，需要比较复杂的、有技巧的数学推导，这里不建议花太多时间在上面，不过如果感兴趣的话，可以自己去研究下。</p><h3 id="3-区间覆盖"><a href="#3-区间覆盖" class="headerlink" title="3. 区间覆盖"></a>3. 区间覆盖</h3><p>假设有 <code>n</code> 个区间，区间的起始端点和结束端点分别是 <code>[l1, r1]</code>，<code>[l2, r2]</code>，<code>[l3, r3]</code>，……，<code>[ln, rn]</code>。从这 <code>n</code> 个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间呢？<br><img src="./bab8c5ee.jpeg" srcset="/img/loading.gif" alt="image"><br>这个问题的处理思路稍微不是那么好懂，不过，建议最好能弄懂，因为这个处理思想在很多贪心算法问题中都有用到，比如任务调度、教师排课等等问题。</p><p>这个问题的解决思路是这样的：假设这 <code>n</code> 个区间中最左端点是 <code>lmin</code>，最右端点是 <code>rmax</code>。这个问题就相当于，选择几个不相交的区间，从左到右将 <code>[lmin, rmax]</code> 覆盖上。按照起始端点从小到大的顺序对这 <code>n</code> 个区间排序。</p><p>每次选择的时候，左端点跟前面的已经覆盖的区间不重合的，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间。这实际上就是一种贪心的选择方法。<br><img src="./473cd63c.jpeg" srcset="/img/loading.gif" alt="image"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上，贪心算法适用的场景比较有限。这种算法思想更多的是指导设计基础算法。比如最小生成树算法、单源最短路径算法，这些算法都用到了贪心算法。从个人的学习经验来讲，不要刻意去记忆贪心算法的原理，多练习才是最有效的学习方法。</p><p>贪心算法的最难的一块是如何将要解决的问题抽象成贪心算法模型，只要这一步搞定之后，贪心算法的编码一般都很简单。贪心算法解决问题的正确性虽然很多时候都看起来是显而易见的，但是要严谨地证明算法能够得到最优解，并不是件容易的事。所以，很多时候，只需要多举几个例子，看一下贪心算法的解决方案是否真的能得到最优解就可以了。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>如何用贪心算法实现霍夫曼编码？</li></ul><blockquote><p>假设有一个包含 <code>1000</code> 个字符的文件，每个字符占 <code>1</code> 个 <code>byte</code>（<code>1byte=8bits</code>），存储这 <code>1000</code> 个字符就一共需要 <code>8000bits</code>，那有没有更加节省空间的存储方式呢？</p><p>假设通过统计分析发现，这 <code>1000</code> 个字符中只包含 <code>6</code> 种不同字符，假设它们分别是 <code>a</code>、<code>b</code>、<code>c</code>、<code>d</code>、<code>e</code>、<code>f</code>。而 <code>3</code> 个二进制位（<code>bit</code>）就可以表示 <code>8</code> 个不同的字符，所以，为了尽量减少存储空间，每个字符用 <code>3</code> 个二进制位来表示。那存储这 <code>1000</code> 个字符只需要 <code>3000bits</code> 就可以了，比原来的存储方式节省了很多空间。不过，还有没有更加节省空间的存储方式呢？</p></blockquote><pre><code class="hljs java">a(<span class="hljs-number">000</span>)、b(<span class="hljs-number">001</span>)、c(<span class="hljs-number">010</span>)、d(<span class="hljs-number">011</span>)、e(<span class="hljs-number">100</span>)、f(<span class="hljs-number">101</span>)</code></pre><blockquote><p>霍夫曼编码就要登场了。霍夫曼编码是一种十分有效的编码方法，广泛用于数据压缩中，其压缩率通常在 <code>20%～90%</code> 之间。</p><p>霍夫曼编码不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率，根据频率的不同，选择不同长度的编码。霍夫曼编码试图用这种不等长的编码方法，来进一步增加压缩的效率。如何给不同频率的字符选择不同长度的编码呢？根据贪心的思想，可以把出现频率比较多的字符，用稍微短一些的编码；出现频率比较少的字符，用稍微长一些的编码。</p><p>对于等长的编码来说，解压缩起来很简单。比如刚才那个例子中，用 <code>3</code> 个 <code>bit</code> 表示一个字符。在解压缩的时候，每次从文本中读取 <code>3</code> 位二进制码，然后翻译成对应的字符。但是，霍夫曼编码是不等长的，每次应该读取 <code>1</code> 位还是 <code>2</code> 位、<code>3</code> 位等等来解压缩呢？这个问题就导致霍夫曼编码解压缩起来比较复杂。为了避免解压缩过程中的歧义，霍夫曼编码要求各个字符的编码之间，不会出现某个编码是另一个编码前缀的情况。<br><img src="./07a5ddfe.jpeg" srcset="/img/loading.gif" alt="image"><br>假设这 <code>6</code> 个字符出现的频率从高到低依次是 <code>a</code>、<code>b</code>、<code>c</code>、<code>d</code>、<code>e</code>、<code>f</code>。把它们编码下面这个样子，任何一个字符的编码都不是另一个的前缀，在解压缩的时候，每次会读取尽可能长的可解压的二进制串，所以在解压缩的时候也不会歧义。经过这种编码压缩之后，这 <code>1000</code> 个字符只需要 <code>2100bits</code> 就可以了。<br><img src="./2f4fb6ee.jpeg" srcset="/img/loading.gif" alt="image"><br>尽管霍夫曼编码的思想并不难理解，但是如何根据字符出现频率的不同，给不同的字符进行不同长度的编码呢？这里的处理稍微有些技巧。</p><p>把每个字符看作一个节点，并且辅带着把频率放到优先级队列中。从队列中取出频率最小的两个节点 <code>A</code>、<code>B</code>，然后新建一个节点 <code>C</code>，把频率设置为两个节点的频率之和，并把这个新节点 <code>C</code> 作为节点 <code>A</code>、<code>B</code> 的父节点。最后再把 <code>C</code> 节点放入到优先级队列中。重复这个过程，直到队列中没有数据。<br><img src="./b09938a4.jpeg" srcset="/img/loading.gif" alt="image"><br>现在，给每一条边加上画一个权值，指向左子节点的边统统标记为 <code>0</code>，指向右子节点的边，统统标记为 <code>1</code>，那从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码。<br><img src="./f70311e8.jpeg" srcset="/img/loading.gif" alt="image"></p></blockquote><ul><li><p>在一个非负整数 a 中，希望从中移除 k 个数字，让剩下的数字值最小，如何选择移除哪 k 个数字呢？</p></li><li><p>假设有 n 个人等待被服务，但是服务窗口只有一个，每个人需要被服务的时间长度是不同的，如何安排被服务的先后顺序，才能让这 n 个人总的等待时间最短？欢迎留言和我分享。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>时间复杂度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>33.`AC`自动机</title>
    <link href="/passages/33/"/>
    <url>/passages/33/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>很多支持用户发表文本内容的网站，比如 <code>BBS</code>，大都会有敏感词过滤功能，用来过滤掉用户输入的一些淫秽、反动、谩骂等内容。你有没有想过，这个功能是怎么实现的呢？</p><h2 id="基于单模式串和-Trie-树实现的敏感词过滤"><a href="#基于单模式串和-Trie-树实现的敏感词过滤" class="headerlink" title="基于单模式串和 Trie 树实现的敏感词过滤"></a>基于单模式串和 Trie 树实现的敏感词过滤</h2><p><code>BF</code> 算法、<code>RK</code> 算法、<code>BM</code> 算法、<code>KMP</code> 算法，还有 <code>Trie</code> 树。前面四种算法都是单模式串匹配算法，只有 <code>Trie</code> 树是多模式串匹配算法。</p><p>单模式串匹配算法，是在一个模式串和一个主串之间进行匹配，也就是说，在一个主串中查找一个模式串。多模式串匹配算法，就是在多个模式串和一个主串之间做匹配，也就是说，在一个主串中查找多个模式串。</p><p>尽管，单模式串匹配算法也能完成多模式串的匹配工作。例如: 可以针对每个敏感词，通过单模式串匹配算法（比如 <code>KMP</code> 算法）与用户输入的文字内容进行匹配。但是，这样做的话，每个匹配过程都需要扫描一遍用户输入的内容。整个过程下来就要扫描很多遍用户输入的内容。如果敏感词很多，比如几千个，并且用户输入的内容很长，假如有上千个字符，那就需要扫描几千遍这样的输入内容。很显然，这种处理思路比较低效。</p><p>与单模式匹配算法相比，多模式匹配算法在这个问题的处理上就很高效了。它只需要扫描一遍主串，就能在主串中一次性查找多个模式串是否存在，从而大大提高匹配效率。<code>Trie</code> 树就是一种多模式串匹配算法。那如何用 <code>Trie</code> 树实现敏感词过滤功能呢？</p><p>可以对敏感词字典进行预处理，构建成 <code>Trie</code> 树结构。这个预处理的操作只需要做一次，如果敏感词字典动态更新了，比如删除、添加了一个敏感词，只需要动态更新一下 <code>Trie</code> 树就可以了。</p><p>当用户输入一个文本内容后，把用户输入的内容作为主串，从第一个字符（假设是字符 <code>C</code>）开始，在 <code>Trie</code> 树中匹配。当匹配到 <code>Trie</code> 树的叶子节点，或者中途遇到不匹配字符的时候，将主串的开始匹配位置后移一位，也就是从字符 <code>C</code> 的下一个字符开始，重新在 <code>Trie</code> 树中匹配。</p><p>基于 <code>Trie</code> 树的这种处理方法，有点类似单模式串匹配的 <code>BF</code> 算法。单模式串匹配算法中，<code>KMP</code> 算法对 <code>BF</code> 算法进行改进，引入了 <code>next</code> 数组，让匹配失败时，尽可能将模式串往后多滑动几位。借鉴单模式串的优化改进方法，能否对多模式串 <code>Trie</code> 树进行改进，进一步提高 <code>Trie</code> 树的效率呢？这就要用到 <code>AC</code> 自动机算法了。</p><h2 id="经典的多模式串匹配算法：AC-自动机"><a href="#经典的多模式串匹配算法：AC-自动机" class="headerlink" title="经典的多模式串匹配算法：AC 自动机"></a>经典的多模式串匹配算法：AC 自动机</h2><p><code>AC</code> 自动机算法，全称是 <code>Aho-Corasick</code> 算法。其实，<code>Trie</code> 树跟 <code>AC</code> 自动机之间的关系，就像单串匹配中朴素的串匹配算法跟 <code>KMP</code> 算法之间的关系一样，只不过前者针对的是多模式串而已。所以，<code>AC</code> 自动机实际上就是在 <code>Trie</code> 树之上，加了类似 <code>KMP</code> 的 <code>next</code> 数组，只不过此处的 <code>next</code> 数组是构建在树上罢了。如果代码表示，就是下面这个样子：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AcNode</span> </span>&#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> data;   <span class="hljs-keyword">public</span> AcNode[] children = <span class="hljs-keyword">new</span> AcNode[<span class="hljs-number">26</span>]; <span class="hljs-comment">// 字符集只包含 a~z 这 26 个字符</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isEndingChar = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 结尾字符为 true</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> length = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 当 isEndingChar=true 时，记录模式串长度</span>  <span class="hljs-keyword">public</span> AcNode fail; <span class="hljs-comment">// 失败指针</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AcNode</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>&#123;    <span class="hljs-keyword">this</span>.data = data;  &#125;&#125;</code></pre><p>所以，<code>AC</code> 自动机的构建，包含两个操作：</p><ul><li><p>将多个模式串构建成 <code>Trie</code> 树；</p></li><li><p>在 <code>Trie</code> 树上构建失败指针（相当于 <code>KMP</code> 中的失效函数 <code>next</code> 数组）。</p></li></ul><p><strong>构建好 Trie 树之后，如何在它之上构建失败指针？</strong></p><p>举一个例子。这里有 <code>4</code> 个模式串，分别是 <code>c</code>，<code>bc</code>，<code>bcd</code>，<code>abcd</code>；主串是 <code>abcd</code>。<br><img src="./c3a6a5d2.jpeg" srcset="/img/loading.gif" alt="image"><br><code>Trie</code> 树中的每一个节点都有一个失败指针，它的作用和构建过程，跟 <code>KMP</code> 算法中的 <code>next</code> 数组极其相似。所以你<strong>要先理解 <code>KMP</code> 算法中 <code>next</code> 数组的构建过程</strong>。如果你还有点不清楚，建议先回头去弄懂 <code>KMP</code> 算法。</p><p>假设沿 <code>Trie</code> 树走到 <code>p</code> 节点，也就是下图中的紫色节点，那 <code>p</code> 的失败指针就是从 <code>root</code> 走到紫色节点形成的字符串 <code>abc</code>，跟所有模式串前缀匹配的最长可匹配后缀子串，就是箭头指的 <code>bc</code> 模式串。</p><p>这里的最长可匹配后缀子串，解释一下。字符串 <code>abc</code> 的后缀子串有两个 <code>bc</code>，<code>c</code>，拿它们与其他模式串匹配，如果某个后缀子串可以匹配某个模式串的前缀，那就把这个后缀子串叫作<strong>可匹配后缀子串</strong>。</p><p>从可匹配后缀子串中，找出最长的一个，就是刚刚讲到的最长可匹配后缀子串。将 <code>p</code> 节点的失败指针指向那个最长匹配后缀子串对应的模式串的前缀的最后一个节点，就是下图中箭头指向的节点。<br><img src="./6cbbd777.jpeg" srcset="/img/loading.gif" alt="image"><br>计算每个节点的失败指针这个过程看起来有些复杂。其实，如果把树中相同深度的节点放到同一层，那么某个节点的失败指针只有可能出现在它所在层的上一层。</p><p>可以像 <code>KMP</code> 算法那样，当要求某个节点的失败指针的时候，通过已经求得的、深度更小的那些节点的失败指针来推导。也就是说，可以逐层依次来求解每个节点的失败指针。所以，失败指针的构建过程，是一个按层遍历树的过程。</p><p>首先 <code>root</code> 的失败指针为 <code>NULL</code>，也就是指向自己。当已经求得某个节点 <code>p</code> 的失败指针之后，如何寻找它的子节点的失败指针呢？</p><p>假设节点 <code>p</code> 的失败指针指向节点 <code>q</code>，看节点 <code>p</code> 的子节点 <code>pc</code> 对应的字符，是否也可以在节点 <code>q</code> 的子节点中找到。如果找到了节点 <code>q</code> 的一个子节点 <code>qc</code>，对应的字符跟节点 <code>pc</code> 对应的字符相同，则将节点 <code>pc</code> 的失败指针指向节点 <code>qc</code>。<br><img src="./e9c22607.jpeg" srcset="/img/loading.gif" alt="image"><br>如果节点 <code>q</code> 中没有子节点的字符等于节点 <code>pc</code> 包含的字符，则令 <code>q = q -&gt; fail</code>（<code>fail</code> 表示失败指针，这里有没有很像 <code>KMP</code> 算法里求 <code>next</code> 的过程？），继续上面的查找，直到 <code>q</code> 是 <code>root</code> 为止，如果还没有找到相同字符的子节点，就让节点 <code>pc</code> 的失败指针指向 <code>root</code>。<br><img src="./ef840bc9.jpeg" srcset="/img/loading.gif" alt="image"><br>构建失败指针的代码贴在这里，你可以对照着讲解一块看下，应该更容易理解。这里面，构建 <code>Trie</code> 树的代码并没有贴出来，你可以参看上一篇的代码去实现。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildFailurePointer</span><span class="hljs-params">()</span> </span>&#123;  Queue&lt;AcNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();  root.fail = <span class="hljs-keyword">null</span>;  queue.add(root);  <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;    AcNode p = queue.remove();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;      AcNode pc = p.children[i];      <span class="hljs-keyword">if</span> (pc == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">continue</span>;      <span class="hljs-keyword">if</span> (p == root) &#123;        pc.fail = root;      &#125; <span class="hljs-keyword">else</span> &#123;        AcNode q = p.fail;        <span class="hljs-keyword">while</span> (q != <span class="hljs-keyword">null</span>) &#123;          AcNode qc = q.children[pc.data - <span class="hljs-string">'a'</span>];          <span class="hljs-keyword">if</span> (qc != <span class="hljs-keyword">null</span>) &#123;            pc.fail = qc;            <span class="hljs-keyword">break</span>;          &#125;          q = q.fail;        &#125;        <span class="hljs-keyword">if</span> (q == <span class="hljs-keyword">null</span>) &#123;          pc.fail = root;        &#125;      &#125;      queue.add(pc);    &#125;  &#125;&#125;</code></pre><p>通过按层来计算每个节点的子节点的失效指针，刚刚举的那个例子，最后构建完成之后的 <code>AC</code> 自动机就是下面这个样子：<br><img src="./3f8c2a50.jpeg" srcset="/img/loading.gif" alt="image"><br><code>AC</code> 自动机到此就构建完成了。现在来看下，<strong>如何在 <code>AC</code> 自动机上匹配主串</strong>？</p><p>还是拿之前的例子来讲解。在匹配过程中，主串从 <code>i = 0</code> 开始，<code>AC</code> 自动机从指针 <code>p = root</code> 开始，假设模式串是 <code>b</code>，主串是 <code>a</code>。</p><ul><li><p>如果 <code>p</code> 指向的节点有一个等于 <code>b[i]</code> 的子节点 <code>x</code>，就更新 <code>p</code> 指向 <code>x</code>，这个时候需要通过失败指针，检测一系列失败指针为结尾的路径是否是模式串。这一句不好理解，可以结合代码看。处理完之后，将 <code>i</code> 加一，继续这两个过程；</p></li><li><p>如果 <code>p</code> 指向的节点没有等于 <code>b[i]</code> 的子节点，那失败指针就派上用场了，让 <code>p = p -&gt; fail</code>，然后继续这 <code>2</code> 个过程。</p></li></ul><p>关于匹配的这部分，文字描述不如代码看得清楚，所以下面把代码贴了出来，非常简短，并且添加了详细的注释，可以对照着看下。这段代码输出的就是，在主串中每个可以匹配的模式串出现的位置。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] text)</span> </span>&#123; <span class="hljs-comment">// text 是主串</span>  <span class="hljs-keyword">int</span> n = text.length;  AcNode p = root;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;    <span class="hljs-keyword">int</span> idx = text[i] - <span class="hljs-string">'a'</span>;    <span class="hljs-keyword">while</span> (p.children[idx] == <span class="hljs-keyword">null</span> &amp;&amp; p != root) &#123;      p = p.fail; <span class="hljs-comment">// 失败指针发挥作用的地方</span>    &#125;    p = p.children[idx];    <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>) p = root; <span class="hljs-comment">// 如果没有匹配的，从 root 开始重新匹配</span>    AcNode tmp = p;    <span class="hljs-keyword">while</span> (tmp != root) &#123; <span class="hljs-comment">// 打印出可以匹配的模式串</span>      <span class="hljs-keyword">if</span> (tmp.isEndingChar == <span class="hljs-keyword">true</span>) &#123;        <span class="hljs-keyword">int</span> pos = i-tmp.length+<span class="hljs-number">1</span>;        System.out.println(<span class="hljs-string">" 匹配起始下标 "</span> + pos + <span class="hljs-string">"; 长度 "</span> + tmp.length);      &#125;      tmp = tmp.fail;    &#125;  &#125;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单模式串匹配算法是为了快速在主串中查找一个模式串，而多模式串匹配算法是为了快速在主串中查找多个模式串。</p><p><code>AC</code> 自动机是基于 <code>Trie</code> 树的一种改进算法，它跟 <code>Trie</code> 树的关系，就像单模式串中，<code>KMP</code> 算法与 <code>BF</code> 算法的关系一样。<code>KMP</code> 算法中有一个非常关键的 <code>next</code> 数组，类比到 <code>AC</code> 自动机中就是失败指针。而且，<code>AC</code> 自动机失败指针的构建过程，跟 <code>KMP</code> 算法中计算 <code>next</code> 数组极其相似。所以，要理解 <code>AC</code> 自动机，最好先掌握 <code>KMP</code> 算法，因为 <code>AC</code> 自动机其实就是 <code>KMP</code> 算法在多模式串上的改造。</p><p>整个 <code>AC</code> 自动机算法包含两个部分，第一部分是将多个模式串构建成 <code>AC</code> 自动机，第二部分是在 <code>AC</code> 自动机中匹配主串。第一部分又分为两个小的步骤，一个是将模式串构建成 <code>Trie</code> 树，另一个是在 <code>Trie</code> 树上构建失败指针。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>如何用多模式串匹配实现敏感词过滤功能？</li></ul><blockquote><p>实际上，上面贴出来的代码，已经是一个敏感词过滤的原型代码了。它可以找到所有敏感词出现的位置（在用户输入的文本中的起始下标）。只需要稍加改造，再遍历一遍文本内容（主串），就可以将文本中的所有敏感词替换成“<strong>*”。<br>所以这里着重讲一下，</strong><code>AC</code> 自动机实现的敏感词过滤系统，是否比单模式串匹配方法更高效呢？**</p><p>首先，需要将敏感词构建成 <code>AC</code> 自动机，包括构建 <code>Trie</code> 树以及构建失败指针。</p><p><code>Trie</code> 树构建的时间复杂度是 $O(m * len)$，其中 <code>len</code> 表示敏感词的平均长度，<code>m</code> 表示敏感词的个数。那构建失败指针的时间复杂度是多少呢？这里给出一个不是很准确的上界。<br>假设 <code>Trie</code> 树中总的节点个数是 <code>k</code>，每个节点构建失败指针的时候，（你可以看下代码）最耗时的环节是 <code>while</code> 循环中的 <code>q = q -&gt; fail</code>，每运行一次这个语句，<code>q</code> 指向节点的深度都会减少 <code>1</code>，而树的高度最高也不会超过 <code>len</code>，所以每个节点构建失败指针的时间复杂度是 $O(len)$。整个失败指针的构建过程就是 $O(k*len)$。</p><p>不过，<code>AC</code> 自动机的构建过程都是预先处理好的，构建好之后，并不会频繁地更新，所以不会影响到敏感词过滤的运行效率。<br>再来看下，<strong>用 <code>AC</code> 自动机做匹配的时间复杂度是多少？</strong></p><p>跟刚刚构建失败指针的分析类似，<code>for</code> 循环依次遍历主串中的每个字符，<code>for</code> 循环内部最耗时的部分也是 <code>while</code> 循环，而这一部分的时间复杂度也是 $O(len)$，所以总的匹配的时间复杂度就是 $O(n*len)$。因为敏感词并不会很长，而且这个时间复杂度只是一个非常宽泛的上限，实际情况下，可能近似于 $O(n)$，所以 <code>AC</code> 自动机做敏感词过滤，性能非常高。<br>你可能会说，从时间复杂度上看，<code>AC</code> 自动机匹配的效率跟 <code>Trie</code> 树一样啊。实际上，因为失效指针可能大部分情况下都指向 <code>root</code> 节点，所以绝大部分情况下，在 <code>AC</code> 自动机上做匹配的效率要远高于刚刚计算出的比较宽泛的时间复杂度。只有在极端情况下，如图所示，<code>AC</code> 自动机的性能才会退化的跟 <code>Trie</code> 树一样。<br><img src="./3903c8d0.jpeg" srcset="/img/loading.gif" alt="image"></p></blockquote><ul><li>你能试着分析总结一下，各个字符串匹配算法的特点和比较适合的应用场景吗？欢迎留言和我分享。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>32.`Trie`树</title>
    <link href="/passages/32/"/>
    <url>/passages/32/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>搜索引擎的搜索关键词提示功能，应该不陌生吧？为了方便快速输入，当你在搜索引擎的搜索框中，输入要搜索的文字的某一部分的时候，搜索引擎就会自动弹出下拉框，里面是各种关键词提示。可以直接从下拉框中选择要搜索的东西，而不用把所有内容都输入进去，一定程度上节省了搜索时间。</p><p>尽管这个功能几乎天天在用，作为一名工程师，你是否思考过，它是怎么实现的呢？它底层使用的是哪种数据结构和算法呢？</p><p>像 <code>Google</code>、百度这样的搜索引擎，它们的关键词提示功能非常全面和精准，肯定做了很多优化，但万变不离其宗，底层最基本的原理就是这种数据结构：<code>Trie</code> 树。</p><h2 id="什么是“Trie-树”？"><a href="#什么是“Trie-树”？" class="headerlink" title="什么是“Trie 树”？"></a>什么是“Trie 树”？</h2><p><code>Trie</code> 树，也叫“字典树”。顾名思义，它是一个树形结构。它是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。</p><p>举个简单的例子来说明一下。有 <code>6</code> 个字符串，它们分别是：<code>how</code>，<code>hi</code>，<code>her</code>，<code>hello</code>，<code>so</code>，<code>see</code>。希望在里面多次查找某个字符串是否存在。如果每次查找，都是拿要查找的字符串跟这 <code>6</code> 个字符串依次进行字符串匹配，那效率就比较低，有没有更高效的方法呢？</p><p>这个时候，就可以先对这 <code>6</code> 个字符串做一下预处理，组织成 <code>Trie</code> 树的结构，之后每次查找，都是在 <code>Trie</code> 树中进行匹配查找。<strong><code>Trie</code> 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起</strong>。最后构造出来的就是下面这个图中的样子。<br><img src="./3cc6a307.jpeg" srcset="/img/loading.gif" alt="image"><br>其中，根节点不包含任何信息。每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串（注意：红色节点并不都是叶子节点）。</p><p>为了更容易理解 <code>Trie</code> 树是怎么构造出来的，下面有一个 <code>Trie</code> 树构造的分解过程。构造过程的每一步，都相当于往 <code>Trie</code> 树中插入一个字符串。当所有字符串都插入完成之后，<code>Trie</code> 树就构造好了。<br><img src="./53dc616c.jpeg" srcset="/img/loading.gif" alt="image"><br><img src="./3aa2fcd8.jpeg" srcset="/img/loading.gif" alt="image"><br>当在 <code>Trie</code> 树中查找一个字符串的时候，比如查找字符串<code>her</code>，把将要查找的字符串分割成单个的字符 <code>h</code>，<code>e</code>，<code>r</code>，然后从 <code>Trie</code> 树的根节点开始匹配。如图所示，绿色的路径就是在 <code>Trie</code> 树中匹配的路径。<br><img src="./10f3603c.jpeg" srcset="/img/loading.gif" alt="image"><br>如果要查找的是字符串<code>he</code>呢？还用上面同样的方法，从根节点开始，沿着某条路径来匹配，如图所示，绿色的路径，是字符串<code>he</code>匹配的路径。但是，路径的最后一个节点<code>e</code>并不是红色的。也就是说，<code>he</code>是某个字符串的前缀子串，但并不能完全匹配任何字符串。<br><img src="./c6f8956a.jpeg" srcset="/img/loading.gif" alt="image"></p><h2 id="如何实现一棵-Trie-树？"><a href="#如何实现一棵-Trie-树？" class="headerlink" title="如何实现一棵 Trie 树？"></a>如何实现一棵 Trie 树？</h2><p>从刚刚 <code>Trie</code> 树的介绍来看，<code>Trie</code> 树主要有两个操作，<strong>一个是将字符串集合构造成 Trie 树</strong>。这个过程分解开来的话，就是一个将字符串插入到 <code>Trie</code> 树的过程。<strong>另一个是在 Trie 树中查询一个字符串</strong>。</p><p>了解了 <code>Trie</code> 树的两个主要操作之后，再来看下，如何存储一个 <code>Trie</code> 树？</p><p>从前面的图中，可以看出，<code>Trie</code> 树是一个多叉树。二叉树中，一个节点的左右子节点是通过两个指针来存储的，如下所示 <code>Java</code> 代码。那对于多叉树来说，怎么存储一个节点的所有子节点的指针呢？</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryTreeNode</span> </span>&#123;  <span class="hljs-keyword">char</span> data;  BinaryTreeNode left;  BinaryTreeNode right;  &#125;</code></pre><p>先介绍其中一种存储方式，也是经典的存储方式，大部分数据结构和算法书籍中都是这么讲的。还记得散列表吗？借助散列表的思想，通过一个下标与字符一一映射的数组，来存储子节点的指针。这句话稍微有点抽象，不怎么好懂，下面有一张图可以看看。<br><img src="./218b1201.jpeg" srcset="/img/loading.gif" alt="image"><br>假设字符串中只有从 <code>a</code> 到 <code>z</code> 这 <code>26</code> 个小写字母，在数组中下标为 <code>0</code> 的位置，存储指向子节点 <code>a</code> 的指针，下标为 <code>1</code> 的位置存储指向子节点 <code>b</code> 的指针，以此类推，下标为 <code>25</code> 的位置，存储的是指向的子节点 <code>z</code> 的指针。如果某个字符的子节点不存在，就在对应的下标的位置存储 <code>null</code>。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;  <span class="hljs-keyword">char</span> data;  TrieNode children[<span class="hljs-number">26</span>];&#125;</code></pre><p>当在 <code>Trie</code> 树中查找字符串的时候，就可以通过字符的 <code>ASCII</code> 码减去<code>a</code>的 <code>ASCII</code> 码，迅速找到匹配的子节点的指针。比如，<code>d</code> 的 <code>ASCII</code> 码减去 <code>a</code> 的 <code>ASCII</code> 码就是 <code>3</code>，那子节点 <code>d</code> 的指针就存储在数组中下标为 <code>3</code> 的位置中。</p><p>把上面的描述翻译成了代码，可以结合着一块看下，应该有助于理解。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;  <span class="hljs-keyword">private</span> TrieNode root = <span class="hljs-keyword">new</span> TrieNode(<span class="hljs-string">'/'</span>); <span class="hljs-comment">// 存储无意义字符</span>  <span class="hljs-comment">// 往 Trie 树中插入一个字符串</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] text)</span> </span>&#123;    TrieNode p = root;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; text.length; ++i) &#123;      <span class="hljs-keyword">int</span> index = text[i] - <span class="hljs-string">'a'</span>;      <span class="hljs-keyword">if</span> (p.children[index] == <span class="hljs-keyword">null</span>) &#123;        TrieNode newNode = <span class="hljs-keyword">new</span> TrieNode(text[i]);        p.children[index] = newNode;      &#125;      p = p.children[index];    &#125;    p.isEndingChar = <span class="hljs-keyword">true</span>;  &#125;  <span class="hljs-comment">// 在 Trie 树中查找一个字符串</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] pattern)</span> </span>&#123;    TrieNode p = root;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pattern.length; ++i) &#123;      <span class="hljs-keyword">int</span> index = pattern[i] - <span class="hljs-string">'a'</span>;      <span class="hljs-keyword">if</span> (p.children[index] == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 不存在 pattern</span>      &#125;      p = p.children[index];    &#125;    <span class="hljs-keyword">if</span> (p.isEndingChar == <span class="hljs-keyword">false</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 不能完全匹配，只是前缀</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 找到 pattern</span>  &#125;  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> data;    <span class="hljs-keyword">public</span> TrieNode[] children = <span class="hljs-keyword">new</span> TrieNode[<span class="hljs-number">26</span>];    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isEndingChar = <span class="hljs-keyword">false</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TrieNode</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>&#123;      <span class="hljs-keyword">this</span>.data = data;    &#125;  &#125;&#125;</code></pre><p>现在，再来看下，<strong>在 Trie 树中，查找某个字符串的时间复杂度是多少？</strong></p><p>如果要在一组字符串中，频繁地查询某些字符串，用 <code>Trie</code> 树会非常高效。构建 <code>Trie</code> 树的过程，需要扫描所有的字符串，时间复杂度是 $O(n)$（<code>n</code> 表示所有字符串的长度和）。但是一旦构建成功之后，后续的查询操作会非常高效。</p><p>每次查询时，如果要查询的字符串长度是 <code>k</code>，那只需要比对大约 <code>k</code> 个节点，就能完成查询操作。跟原本那组字符串的长度和个数没有任何关系。所以说，构建好 <code>Trie</code> 树后，在其中查找字符串的时间复杂度是 $O(k)$，<code>k</code> 表示要查找的字符串的长度。</p><h2 id="Trie-树真的很耗内存吗？"><a href="#Trie-树真的很耗内存吗？" class="headerlink" title="Trie 树真的很耗内存吗？"></a>Trie 树真的很耗内存吗？</h2><p><code>Trie</code> 树是一种非常独特的、高效的字符串匹配方法。但是，关于 <code>Trie</code> 树，有没有听过这样一种说法：“Trie 树是非常耗内存的，用的是一种空间换时间的思路”。这是什么原因呢？</p><p>刚刚在讲 <code>Trie</code> 树的实现的时候，讲到用数组来存储一个节点的子节点的指针。如果字符串中包含从 <code>a</code> 到 <code>z</code> 这 <code>26</code> 个字符，那每个节点都要存储一个长度为 <code>26</code> 的数组，并且每个数组存储一个 <code>8</code> 字节指针（或者是 <code>4</code> 字节，这个大小跟 <code>CPU</code>、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 <code>26</code> 个，比如 <code>3</code>、<code>4</code> 个，也要维护一个长度为 <code>26</code> 的数组。</p><p><code>Trie</code> 树的本质是避免重复存储一组字符串的相同前缀子串，但是现在每个字符（对应一个节点）的存储远远大于 <code>1</code> 个字节。按照上面举的例子，数组长度为 <code>26</code>，每个元素是 <code>8</code> 字节，那每个节点就会额外需要 <code>26*8 = 208</code> 个字节。而且这还是只包含 <code>26</code> 个字符的情况。</p><p>如果字符串中不仅包含小写字母，还包含大写字母、数字、甚至是中文，那需要的存储空间就更多了。所以，也就是说，在某些情况下，<code>Trie</code> 树不一定会节省存储空间。在重复的前缀并不多的情况下，<code>Trie</code> 树不但不能节省内存，还有可能会浪费更多的内存。</p><p>当然，不可否认，<code>Trie</code> 树尽管有可能很浪费内存，但是确实非常高效。那为了解决这个内存问题，是否有其他办法呢？</p><p>可以稍微牺牲一点查询的效率，将每个节点中的数组换成其他数据结构，来存储一个节点的子节点指针。用哪种数据结构呢？选择其实有很多，比如有序数组、跳表、散列表、红黑树等。</p><p>假设用有序数组，数组中的指针按照所指向的子节点中的字符的大小顺序排列。查询的时候，可以通过二分查找的方法，快速查找到某个字符应该匹配的子节点的指针。但是，在往 <code>Trie</code> 树中插入一个字符串的时候，为了维护数组中数据的有序性，就会稍微慢了点。</p><p>实际上，<code>Trie</code> 树的变体有很多，都可以在一定程度上解决内存消耗的问题。比如，<strong>缩点优化</strong>，就是对只有一个子节点的节点，而且此节点不是一个串的结束节点，可以将此节点与子节点合并。这样可以节省空间，但却增加了编码难度。这里就不展开详细讲解了，如果感兴趣，可以自行研究下。<br><img src="./78d2d025.jpeg" srcset="/img/loading.gif" alt="image"></p><h2 id="Trie-树与散列表、红黑树的比较"><a href="#Trie-树与散列表、红黑树的比较" class="headerlink" title="Trie 树与散列表、红黑树的比较"></a>Trie 树与散列表、红黑树的比较</h2><p>实际上，字符串的匹配问题，笼统上讲，其实就是数据的查找问题。对于支持动态数据高效操作的数据结构，前面已经讲过好多了，比如散列表、红黑树、跳表等等。实际上，这些数据结构也可以实现在一组字符串中查找字符串的功能。这里选了两种数据结构，散列表和红黑树，跟 <code>Trie</code> 树比较一下，看看它们各自的优缺点和应用场景。</p><p>在刚刚讲的这个场景，在一组字符串中查找字符串，<code>Trie</code> 树实际上表现得并不好。它对要处理的字符串有及其严苛的要求。</p><p>第一，字符串中包含的字符集不能太大。前面讲到，如果字符集太大，那存储空间可能就会浪费很多。即便可以优化，但也要付出牺牲查询、插入效率的代价。</p><p>第二，要求字符串的前缀重合比较多，不然空间消耗会变大很多。</p><p>第三，如果要用 <code>Trie</code> 树解决问题，那就要自己从零开始实现一个 <code>Trie</code> 树，还要保证没有 <code>bug</code>，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做。</p><p>第四，通过指针串起来的数据块是不连续的，而 <code>Trie</code> 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。</p><p>综合这几点，针对在一组字符串中查找字符串的问题，在工程中，更倾向于用散列表或者红黑树。因为这两种数据结构，都不需要自己去实现，直接利用编程语言中提供的现成类库就行了。</p><p>讲到这里，可能要疑惑了，讲了半天，这里对 <code>Trie</code> 树一通否定，还让用红黑树或者散列表，那 <code>Trie</code> 树是不是就没用了呢？是不是这里的内容就白看了呢？</p><p>实际上，<code>Trie</code> 树只是不适合精确匹配查找，这种问题更适合用散列表或者红黑树来解决。<code>Trie</code> 树比较适合的是查找前缀匹配的字符串，也就是类似开篇问题的那种场景。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Trie</code> 树是一种解决字符串快速匹配问题的数据结构。如果用来构建 <code>Trie</code> 树的这一组字符串中，前缀重复的情况不是很多，那 <code>Trie</code> 树这种数据结构总体上来讲是比较费内存的，是一种空间换时间的解决问题思路。</p><p>尽管比较耗费内存，但是对内存不敏感或者内存消耗在接受范围内的情况下，在 <code>Trie</code> 树中做字符串匹配还是非常高效的，时间复杂度是 $O(k)$，<code>k</code> 表示要匹配的字符串的长度。</p><p>但是，<code>Trie</code> 树的优势并不在于，用它来做动态集合数据的查找，因为，这个工作完全可以用更加合适的散列表或者红黑树来替代。<code>Trie</code> 树最有优势的是查找前缀匹配的字符串，比如搜索引擎中的关键词提示功能这个场景，就比较适合用它来解决，也是 <code>Trie</code> 树比较经典的应用场景。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li><p>如何利用 <code>Trie</code> 树，实现搜索关键词的提示功能？</p><blockquote><p>假设关键词库由用户的热门搜索关键词组成。将这个词库构建成一个 <code>Trie</code> 树。当用户输入其中某个单词的时候，把这个词作为一个前缀子串在 <code>Trie</code> 树中匹配。假设词库里只有 <code>hello</code>、<code>her</code>、<code>hi</code>、<code>how</code>、<code>so</code>、<code>see</code> 这 <code>6</code> 个关键词。当用户输入了字母 <code>h</code> 的时候，就把以 <code>h</code> 为前缀的 <code>hello</code>、<code>her</code>、<code>hi</code>、<code>how</code> 展示在搜索提示框内。当用户继续键入字母 <code>e</code> 的时候，就把以 <code>he</code> 为前缀的 <code>hello</code>、<code>her</code> 展示在搜索提示框内。这就是搜索关键词提示的最基本的算法原理。<br><img src="./702817b4.jpeg" srcset="/img/loading.gif" alt="image"><br>不过，这里讲的只是最基本的实现原理，实际上，搜索引擎的搜索关键词提示功能远非我讲的这么简单。如果再稍微深入一点，就会想到，上面的解决办法遇到下面几个问题：</p><ul><li><p>刚讲的思路是针对英文的搜索关键词提示，对于更加复杂的中文来说，词库中的数据又该如何构建成 <code>Trie</code> 树呢？</p></li><li><p>如果词库中有很多关键词，在搜索提示的时候，用户输入关键词，作为前缀在 <code>Trie</code> 树中可以匹配的关键词也有很多，如何选择展示哪些内容呢？</p></li><li><p>像 <code>Google</code> 这样的搜索引擎，用户单词拼写错误的情况下，<code>Google</code> 还是可以使用正确的拼写来做关键词提示，这个又是怎么做到的呢？</p></li></ul><p>实际上，<code>Trie</code> 树的这个应用可以扩展到更加广泛的一个应用上，就是自动输入补全，比如输入法自动补全功能、<code>IDE</code> 代码编辑器自动补全功能、浏览器网址输入的自动补全功能等等。</p></blockquote></li><li><p>如果现在有一个很大的字符串集合，比如包含 <code>1</code> 万条记录，如何通过编程量化分析这组字符串集合是否比较适合用 <code>Trie</code> 树解决呢？也就是如何统计字符串的字符集大小，以及前缀重合的程度呢？欢迎留言和我分享。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>31.字符串匹配基础（下）</title>
    <link href="/passages/31/"/>
    <url>/passages/31/</url>
    
    <content type="html"><![CDATA[<!-- more --><p><code>BM</code> 算法尽管很复杂，也不好理解，但却是工程中非常常用的一种高效字符串匹配算法。有统计说，它是最高效、最常用的字符串匹配算法。不过，在所有的字符串匹配算法里，要说最知名的一种的话，那就非 <code>KMP</code> 算法莫属。很多时候，提到字符串匹配，首先想到的就是 <code>KMP</code> 算法。实际上，<code>KMP</code> 算法跟 <code>BM</code> 算法的本质是一样的。</p><h2 id="KMP-算法基本原理"><a href="#KMP-算法基本原理" class="headerlink" title="KMP 算法基本原理"></a>KMP 算法基本原理</h2><p><code>KMP</code> 算法是根据三位作者（<code>D.E.Knuth</code>，<code>J.H.Morris</code> 和 <code>V.R.Pratt</code>）的名字来命名的，算法的全称是 <code>Knuth Morris Pratt</code> 算法，简称为 <code>KMP</code> 算法。</p><p><code>KMP</code> 算法的核心思想，跟 <code>BM</code> 算法非常相近。假设主串是 <code>a</code>，模式串是 <code>b</code>。在模式串与主串匹配的过程中，当遇到不可匹配的字符的时候，希望找到一些规律，可以将模式串往后多滑动几位，跳过那些肯定不会匹配的情况。</p><p>还记得上篇文章的好后缀和坏字符吗？这里可以类比一下，在模式串和主串匹配的过程中，把不能匹配的那个字符仍然叫作<strong>坏字符</strong>，把已经匹配的那段字符串叫作<strong>好前缀</strong>。<br><img src="./76843127.jpeg" srcset="/img/loading.gif" alt="image"><br>当遇到坏字符的时候，就要把模式串往后滑动，在滑动的过程中，只要模式串和好前缀有上下重合，前面几个字符的比较，就相当于拿好前缀的后缀子串，跟模式串的前缀子串在比较。这个比较的过程能否更高效呢？可以不用一个字符一个字符地比较吗？<br><img src="./d7f6d28a.jpeg" srcset="/img/loading.gif" alt="image"><br><code>KMP</code> 算法就是在试图寻找一种规律：在模式串和主串匹配的过程中，当遇到坏字符后，对于已经比对过的好前缀，能否找到一种规律，将模式串一次性滑动很多位？</p><p>只需要拿好前缀本身，在它的后缀子串中，查找最长的那个可以跟好前缀的前缀子串匹配的。假设最长的可匹配的那部分前缀子串是<code>{v}</code>，长度是 <code>k</code>。把模式串一次性往后滑动 <code>j-k</code> 位，相当于，每次遇到坏字符的时候，就把 <code>j</code> 更新为 <code>k</code>，<code>i</code> 不变，然后继续比较。<br><img src="./6e9b00d2.jpeg" srcset="/img/loading.gif" alt="image"><br>为了表述起来方便，把好前缀的所有后缀子串中，最长的可匹配前缀子串的那个后缀子串，叫作<strong>最长可匹配后缀子串</strong>；对应的前缀子串，叫作<strong>最长可匹配前缀子串</strong>。<br><img src="./c994bba8.jpeg" srcset="/img/loading.gif" alt="image"><br>如何来求好前缀的最长可匹配前缀和后缀子串呢？这个问题其实不涉及主串，只需要通过模式串本身就能求解。所以，能不能事先预处理计算好，在模式串和主串匹配的过程中，直接拿过来就用呢？</p><p>类似 <code>BM</code> 算法中的 <code>bc</code>、<code>suffix</code>、<code>prefix</code> 数组，<code>KMP</code> 算法也可以提前构建一个数组，用来存储模式串中每个前缀（这些前缀都有可能是好前缀）的最长可匹配前缀子串的结尾字符下标。把这个数组定义为<code>next</code> 数组，很多书中还给这个数组起了一个名字，叫<strong>失效函数</strong>（<code>failure function</code>）。</p><p>数组的下标是每个前缀结尾字符下标，数组的值是这个前缀的最长可以匹配前缀子串的结尾字符下标。这句话有点拗口，举一个例子。<br><img src="./376ed5f4.jpeg" srcset="/img/loading.gif" alt="image"><br>有了 <code>next</code> 数组，很容易就可以实现 <code>KMP</code> 算法了。先假设 <code>next</code> 数组已经计算好了，先给出 <code>KMP</code> 算法的框架代码。</p><pre><code class="hljs java"><span class="hljs-comment">// a, b 分别是主串和模式串；n, m 分别是主串和模式串的长度。</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> m)</span> </span>&#123;  <span class="hljs-keyword">int</span>[] next = getNexts(b, m);  <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;    <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; a[i] != b[j]) &#123; <span class="hljs-comment">// 一直找到 a[i] 和 b[j]</span>      j = next[j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">if</span> (a[i] == b[j]) &#123;      ++j;    &#125;    <span class="hljs-keyword">if</span> (j == m) &#123; <span class="hljs-comment">// 找到匹配模式串的了</span>      <span class="hljs-keyword">return</span> i - m + <span class="hljs-number">1</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre><h3 id="失效函数计算方法"><a href="#失效函数计算方法" class="headerlink" title="失效函数计算方法"></a>失效函数计算方法</h3><p><code>KMP</code> 算法的基本原理讲完了，现在来看最复杂的部分，也就是 <code>next</code> 数组是如何计算出来的？</p><p>当然，可以用非常笨的方法，比如要计算下面这个模式串 <code>b</code> 的 <code>next[4]</code>，就把 <code>b[0, 4]</code> 的所有后缀子串，从长到短找出来，依次看看，是否能跟模式串的前缀子串匹配。很显然，这个方法也可以计算得到 <code>next</code> 数组，但是效率非常低。有没有更加高效的方法呢？<br><img src="./01f88da8.jpeg" srcset="/img/loading.gif" alt="image"><br>这里的处理非常有技巧，类似于动态规划。</p><p>按照下标从小到大，依次计算 <code>next</code> 数组的值。当要计算 <code>next[i]</code> 的时候，前面的 <code>next[0]</code>，<code>next[1]</code>，……，<code>next[i-1]</code> 应该已经计算出来了。利用已经计算出来的 <code>next</code> 值，是否可以快速推导出 <code>next[i]</code> 的值呢？</p><p>如果 <code>next[i-1] = k-1</code>，也就是说，子串 <code>b[0, k-1]</code> 是 <code>b[0, i-1]</code> 的最长可匹配前缀子串。如果子串 <code>b[0, k-1]</code> 的下一个字符 <code>b[k]</code>，与 <code>b[0, i-1]</code> 的下一个字符 <code>b[i]</code> 匹配，那子串 <code>b[0, k]</code> 就是 <code>b[0, i]</code> 的最长可匹配前缀子串。所以，<code>next[i]</code> 等于 <code>k</code>。但是，如果 <code>b[0, k-1]</code> 的下一字符 <code>b[k]</code> 跟 <code>b[0, i-1]</code> 的下一个字符 <code>b[i]</code> 不相等呢？这个时候就不能简单地通过 <code>next[i-1]</code> 得到 <code>next[i]</code> 了。这个时候该怎么办呢？<br><img src="./3d23880f.jpeg" srcset="/img/loading.gif" alt="image"><br>假设 <code>b[0, i]</code> 的最长可匹配后缀子串是 <code>b[r, i]</code>。如果把最后一个字符去掉，那 <code>b[r, i-1]</code> 肯定是 <code>b[0, i-1]</code> 的可匹配后缀子串，但不一定是最长可匹配后缀子串。所以，既然 <code>b[0, i-1]</code> 最长可匹配后缀子串对应的模式串的前缀子串的下一个字符并不等于 <code>b[i]</code>，那么就可以考察 <code>b[0, i-1]</code> 的次长可匹配后缀子串 <code>b[x, i-1]</code> 对应的可匹配前缀子串 <code>b[0, i-1-x]</code> 的下一个字符 <code>b[i-x]</code> 是否等于 <code>b[i]</code>。如果等于，那 <code>b[x, i]</code> 就是 <code>b[0, i]</code> 的最长可匹配后缀子串。<br><img src="./6a85f16a.jpeg" srcset="/img/loading.gif" alt="image"><br>可是，如何求得 <code>b[0, i-1]</code> 的次长可匹配后缀子串呢？次长可匹配后缀子串肯定被包含在最长可匹配后缀子串中，而最长可匹配后缀子串又对应最长可匹配前缀子串 <code>b[0, y]</code>。于是，查找 <code>b[0, i-1]</code> 的次长可匹配后缀子串，这个问题就变成，查找 <code>b[0, y]</code> 的最长匹配后缀子串的问题了。<br><img src="./144a094c.jpeg" srcset="/img/loading.gif" alt="image"><br>按照这个思路，可以考察完所有的 <code>b[0, i-1]</code> 的可匹配后缀子串 <code>b[y, i-1]</code>，直到找到一个可匹配的后缀子串，它对应的前缀子串的下一个字符等于 <code>b[i]</code>，那这个 <code>b[y, i]</code> 就是 <code>b[0, i]</code> 的最长可匹配后缀子串。</p><p>前面已经给出 <code>KMP</code> 算法的框架代码了，现在把这部分的代码也写出来了。这两部分代码合在一起，就是整个 <code>KMP</code> 算法的代码实现。</p><pre><code class="hljs java"><span class="hljs-comment">// b 表示模式串，m 表示模式串的长度</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] getNexts(<span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> m) &#123;  <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];  next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;  <span class="hljs-keyword">int</span> k = -<span class="hljs-number">1</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; ++i) &#123;    <span class="hljs-keyword">while</span> (k != -<span class="hljs-number">1</span> &amp;&amp; b[k + <span class="hljs-number">1</span>] != b[i]) &#123;      k = next[k];    &#125;    <span class="hljs-keyword">if</span> (b[k + <span class="hljs-number">1</span>] == b[i]) &#123;      ++k;    &#125;    next[i] = k;  &#125;  <span class="hljs-keyword">return</span> next;&#125;</code></pre><h2 id="KMP-算法复杂度分析"><a href="#KMP-算法复杂度分析" class="headerlink" title="KMP 算法复杂度分析"></a>KMP 算法复杂度分析</h2><p>空间复杂度很容易分析，<code>KMP</code> 算法只需要一个额外的 <code>next</code> 数组，数组的大小跟模式串相同。所以空间复杂度是 $O(m)$，<code>m</code> 表示模式串的长度。</p><p><code>KMP</code> 算法包含两部分，第一部分是构建 <code>next</code> 数组，第二部分才是借助 <code>next</code> 数组匹配。所以，关于时间复杂度，要分别从这两部分来分析。</p><p>先来分析第一部分的时间复杂度。</p><p>计算 <code>next</code> 数组的代码中，第一层 <code>for</code> 循环中 <code>i</code> 从 <code>1</code> 到 <code>m-1</code>，也就是说，内部的代码被执行了 <code>m-1</code> 次。<code>for</code> 循环内部代码有一个 <code>while</code> 循环，如果能知道每次 <code>for</code> 循环、<code>while</code> 循环平均执行的次数，假设是 <code>k</code>，那时间复杂度就是 $O(k*m)$。但是，<code>while</code> 循环执行的次数不怎么好统计，所以放弃这种分析方法。</p><p>可以找一些参照变量，<code>i</code> 和 <code>k</code>。<code>i</code> 从 <code>1</code> 开始一直增加到 <code>m</code>，而 <code>k</code> 并不是每次 <code>for</code> 循环都会增加，所以，<code>k</code> 累积增加的值肯定小于 <code>m</code>。而 <code>while</code> 循环里 <code>k = next[k]</code>，实际上是在减小 <code>k</code> 的值，<code>k</code> 累积都没有增加超过 <code>m</code>，所以 <code>while</code> 循环里面 <code>k = next[k]</code> 总的执行次数也不可能超过 <code>m</code>。因此，<code>next</code> 数组计算的时间复杂度是 $O(m)$。</p><p>再来分析第二部分的时间复杂度。分析的方法是类似的。</p><p><code>i</code> 从 <code>0</code> 循环增长到 <code>n-1</code>，<code>j</code> 的增长量不可能超过 <code>i</code>，所以肯定小于 <code>n</code>。而 <code>while</code> 循环中的那条语句 <code>j = next[j-1]+1</code>，不会让 <code>j</code> 增长的，那有没有可能让 <code>j</code> 不变呢？也没有可能。因为 <code>next[j-1]</code> 的值肯定小于 <code>j-1</code>，所以 <code>while</code> 循环中的这条语句实际上也是在让 <code>j</code> 的值减少。而 <code>j</code> 总共增长的量都不会超过 <code>n</code>，那减少的量也不可能超过 <code>n</code>，所以 <code>while</code> 循环中的这条语句总的执行次数也不会超过 <code>n</code>，所以这部分的时间复杂度是 $O(n)$。</p><p>所以，综合两部分的时间复杂度，<code>KMP</code> 算法的时间复杂度就是 $O(m+n)$。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>KMP</code> 算法和 <code>BM</code> 算法的本质非常类似，都是根据规律在遇到坏字符的时候，把模式串往后多滑动几位。</p><p><code>BM</code> 算法有两个规则，坏字符和好后缀。<code>KMP</code> 算法借鉴 <code>BM</code> 算法的思想，可以总结成好前缀规则。这里面最难懂的就是 <code>next</code> 数组的计算。如果用最笨的方法来计算，确实不难，但是效率会比较低。所以，上面讲了一种类似动态规划的方法，按照下标 <code>i</code> 从小到大，依次计算 <code>next[i]</code>，并且 <code>next[i]</code> 的计算通过前面已经计算出来的 <code>next[0]</code>，<code>next[1]</code>，……，<code>next[i-1]</code> 来推导。</p><p><code>KMP</code> 算法的时间复杂度是 $O(n+m)$，不过它的分析过程稍微需要一点技巧，不那么直观，只要看懂就好了，并不需要掌握，在平常的开发中，很少会有这么难分析的代码。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><code>BF</code> 算法、<code>RK</code> 算法、<code>BM</code> 算法和 <code>KMP</code> 算法，关于这些算法，你觉得什么地方最难理解呢？欢迎留言和我分享。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>时间复杂度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>30.字符串匹配基础（中）</title>
    <link href="/passages/30/"/>
    <url>/passages/30/</url>
    
    <content type="html"><![CDATA[<!-- more --><p><code>BM</code>（<code>Boyer-Moore</code>）算法。它是一种非常高效的字符串匹配算法，有实验统计，它的性能是著名的 <code>KMP</code> 算法的 <code>3</code> 到 <code>4</code> 倍。</p><h2 id="BM-算法的核心思想"><a href="#BM-算法的核心思想" class="headerlink" title="BM 算法的核心思想"></a>BM 算法的核心思想</h2><p>把模式串和主串的匹配过程，看作模式串在主串中不停地往后滑动。当遇到不匹配的字符时，<code>BF</code> 算法和 <code>RK</code> 算法的做法是，模式串往后滑动一位，然后从模式串的第一个字符开始重新匹配。可以看下面的这幅图。<br><img src="./c5b9faa2.jpeg" srcset="/img/loading.gif" alt="image"><br>在这个例子里，主串中的 <code>c</code>，在模式串中是不存在的，所以，模式串向后滑动的时候，只要 <code>c</code> 与模式串有重合，肯定无法匹配。所以，可以一次性把模式串往后多滑动几位，把模式串移动到 <code>c</code> 的后面。<br><img src="./008347c5.jpeg" srcset="/img/loading.gif" alt="image"><br>由现象找规律，思考一下，当遇到不匹配的字符时，有什么固定的规律，可以将模式串往后多滑动几位呢？这样一次性往后滑动好几位，那匹配的效率岂不是就提高了？</p><p><code>BM</code> 算法，本质上其实就是在寻找这种规律。借助这种规律，在模式串与主串匹配的过程中，当模式串和主串某个字符不匹配的时候，能够跳过一些肯定不会匹配的情况，将模式串往后多滑动几位。</p><h2 id="BM-算法原理分析"><a href="#BM-算法原理分析" class="headerlink" title="BM 算法原理分析"></a>BM 算法原理分析</h2><p><code>BM</code> 算法包含两部分，分别是坏字符规则（<code>bad character rule</code>）和好后缀规则（<code>good suffix shift</code>）。下面依次来看，这两个规则分别都是怎么工作的。</p><h3 id="1-坏字符规则"><a href="#1-坏字符规则" class="headerlink" title="1. 坏字符规则"></a>1. 坏字符规则</h3><p>在匹配的过程中，都是按模式串的下标从小到大的顺序，依次与主串中的字符进行匹配的。这种匹配顺序比较符合我们的思维习惯，而 <code>BM</code> 算法的匹配顺序比较特别，它是按照模式串下标从大到小的顺序，倒着匹配的。下面有一张图，你可以看下。<br><img src="./04290ff5.jpeg" srcset="/img/loading.gif" alt="image"><br><img src="./fda9e9e8.jpeg" srcset="/img/loading.gif" alt="image"><br>从模式串的末尾往前倒着匹配，当发现某个字符没法匹配的时候。把这个没有匹配的字符叫作<strong>坏字符</strong>（主串中的字符）。<br><img src="./8d0ae5ab.jpeg" srcset="/img/loading.gif" alt="image"><br>拿坏字符 <code>c</code> 在模式串中查找，发现模式串中并不存在这个字符，也就是说，字符 <code>c</code> 与模式串中的任何字符都不可能匹配。这个时候，可以将模式串直接往后滑动三位，将模式串滑动到 <code>c</code> 后面的位置，再从模式串的末尾字符开始比较。<br><img src="./ad866b59.jpeg" srcset="/img/loading.gif" alt="image"><br>这个时候，模式串中最后一个字符 <code>d</code>，还是无法跟主串中的 <code>a</code> 匹配，这个时候，还能将模式串往后滑动三位吗？答案是不行的。因为这个时候，坏字符 <code>a</code> 在模式串中是存在的，模式串中下标是 <code>0</code> 的位置也是字符 <code>a</code>。这种情况下，可以将模式串往后滑动两位，让两个 <code>a</code> 上下对齐，然后再从模式串的末尾字符开始，重新匹配。<br><img src="./37c394df.jpeg" srcset="/img/loading.gif" alt="image"><br>第一次不匹配的时候，滑动了三位，第二次不匹配的时候，将模式串后移两位，那具体滑动多少位，到底有没有规律呢？</p><p>当发生不匹配的时候，把坏字符对应的模式串中的字符下标记作 <code>si</code>。如果坏字符在模式串中存在，把这个坏字符在模式串中的下标记作 <code>xi</code>。如果不存在，把 <code>xi</code> 记作 <code>-1</code>。那模式串往后移动的位数就等于 <code>si-xi</code>。（注意，这里说的下标，都是字符在模式串的下标）。<br><img src="./201d9b2a.jpeg" srcset="/img/loading.gif" alt="image"><br>这里要特别说明一点，如果坏字符在模式串里多处出现，那在计算 <code>xi</code> 的时候，选择最靠后的那个，因为这样不会让模式串滑动过多，导致本来可能匹配的情况被滑动略过。</p><p>利用坏字符规则，<code>BM</code> 算法在最好情况下的时间复杂度非常低，是 $O(n/m)$。比如，主串是 <code>aaabaaabaaabaaab</code>，模式串是 <code>aaaa</code>。每次比对，模式串都可以直接后移四位，所以，匹配具有类似特点的模式串和主串的时候，<code>BM</code> 算法非常高效。</p><p>不过，单纯使用坏字符规则还是不够的。因为根据 <code>si-xi</code> 计算出来的移动位数，有可能是负数，比如主串是 <code>aaaaaaaaaaaaaaaa</code>，模式串是 <code>baaa</code>。不但不会向后滑动模式串，还有可能倒退。所以，<code>BM</code> 算法还需要用到“好后缀规则”。</p><h3 id="2-好后缀规则"><a href="#2-好后缀规则" class="headerlink" title="2. 好后缀规则"></a>2. 好后缀规则</h3><p>好后缀规则实际上跟坏字符规则的思路很类似。可以看下面这幅图。当模式串滑动到图中的位置的时候，模式串和主串有 <code>2</code> 个字符是匹配的，倒数第 <code>3</code> 个字符发生了不匹配的情况。<br><img src="./a25bda4b.jpeg" srcset="/img/loading.gif" alt="image"><br>这个时候该如何滑动模式串呢？当然，还可以利用坏字符规则来计算模式串的滑动位数，不过，也可以使用好后缀处理规则。两种规则到底如何选择，下面会说明。抛开这个问题，现在来看，好后缀规则是怎么工作的？</p><p>把已经匹配的 <code>bc</code> 叫作好后缀，记作<code>{u}</code>。拿它在模式串中查找，如果找到了另一个跟<code>{u}</code>相匹配的子串<code>{u*}</code>，那就将模式串滑动到子串<code>{u*}</code>与主串中<code>{u}</code>对齐的位置。<br><img src="./b2af1786.jpeg" srcset="/img/loading.gif" alt="image"><br>如果在模式串中找不到另一个等于<code>{u}</code>的子串，就直接将模式串，滑动到主串中<code>{u}</code>的后面，因为之前的任何一次往后滑动，都没有匹配主串中<code>{u}</code>的情况。<br><img src="./d17e696f.jpeg" srcset="/img/loading.gif" alt="image"><br>不过，当模式串中不存在等于<code>{u}</code>的子串时，直接将模式串滑动到主串<code>{u}</code>的后面。这样做是否有点太过头呢？来看下面这个例子。这里面 <code>bc</code> 是好后缀，尽管在模式串中没有另外一个相匹配的子串<code>{u*}</code>，但是如果将模式串移动到好后缀的后面，如图所示，那就会错过模式串和主串可以匹配的情况。<br><img src="./a0afd368.jpeg" srcset="/img/loading.gif" alt="image"><br>如果好后缀在模式串中不存在可匹配的子串，那在一步一步往后滑动模式串的过程中，只要主串中的<code>{u}</code>与模式串有重合，那肯定就无法完全匹配。但是当模式串滑动到前缀与主串中<code>{u}</code>的后缀有部分重合的时候，并且重合的部分相等的时候，就有可能会存在完全匹配的情况。<br><img src="./81109319.jpeg" srcset="/img/loading.gif" alt="image"><br>所以，针对这种情况，不仅要看好后缀在模式串中，是否有另一个匹配的子串，还要检查好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的。</p><p>所谓某个字符串 <code>s</code> 的后缀子串，就是最后一个字符跟 <code>s</code> 对齐的子串，比如 <code>abc</code> 的后缀子串就包括 <code>c</code>, <code>bc</code>。所谓前缀子串，就是起始字符跟 <code>s</code> 对齐的子串，比如 <code>abc</code> 的前缀子串有 <code>a</code>，<code>ab</code>。从好后缀的后缀子串中，找一个最长的并且能跟模式串的前缀子串匹配的，假设是<code>{v}</code>，然后将模式串滑动到如图所示的位置。<br><img src="./949540c3.jpeg" srcset="/img/loading.gif" alt="image"><br>当模式串和主串中的某个字符不匹配的时候，如何选择用好后缀规则还是坏字符规则，来计算模式串往后滑动的位数？</p><p>可以分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数。这种处理方法还可以避免前面提到的，根据坏字符规则，计算得到的往后滑动的位数，有可能是负数的情况。</p><h2 id="BM-算法代码实现"><a href="#BM-算法代码实现" class="headerlink" title="BM 算法代码实现"></a>BM 算法代码实现</h2><p>“坏字符规则”本身不难理解。当遇到坏字符时，要计算往后移动的位数 <code>si-xi</code>，其中 <code>xi</code> 的计算是重点，如何求得 <code>xi</code> 呢？或者说，如何查找坏字符在模式串中出现的位置呢？</p><p>如果拿坏字符，在模式串中顺序遍历查找，这样就会比较低效，势必影响这个算法的性能。有没有更加高效的方式呢？之前讲的散列表，这里就可以派上用场了。可以将模式串中的每个字符及其下标都存到散列表中。这样就可以快速找到坏字符在模式串的位置下标了。</p><p>关于这个散列表，这里只实现一种最简单的情况，假设字符串的字符集不是很大，每个字符长度是 <code>1</code> 字节，用大小为 <code>256</code> 的数组，来记录每个字符在模式串中出现的位置。数组的下标对应字符的 <code>ASCII</code> 码值，数组中存储这个字符在模式串中出现的位置。<br><img src="./b9c04959.jpeg" srcset="/img/loading.gif" alt="image"><br>如果将上面的过程翻译成代码，就是下面这个样子。其中，变量 <code>b</code> 是模式串，<code>m</code> 是模式串的长度，<code>bc</code> 表示刚刚讲的散列表。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIZE = <span class="hljs-number">256</span>; <span class="hljs-comment">// 全局变量或成员变量</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">generateBC</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] bc)</span> </span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; ++i) &#123;    bc[i] = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化 bc</span>  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;    <span class="hljs-keyword">int</span> ascii = (<span class="hljs-keyword">int</span>)b[i]; <span class="hljs-comment">// 计算 b[i] 的 ASCII 值</span>    bc[ascii] = i;  &#125;&#125;</code></pre><p>掌握了坏字符规则之后，先把 <code>BM</code> 算法代码的大框架写好，先不考虑好后缀规则，仅用坏字符规则，并且不考虑 <code>si-xi</code> 计算得到的移动位数可能会出现负数的情况。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bm</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> m)</span> </span>&#123;  <span class="hljs-keyword">int</span>[] bc = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[SIZE]; <span class="hljs-comment">// 记录模式串中每个字符最后出现的位置</span>  generateBC(b, m, bc); <span class="hljs-comment">// 构建坏字符哈希表</span>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// i 表示主串与模式串对齐的第一个字符</span>  <span class="hljs-keyword">while</span> (i &lt;= n - m) &#123;    <span class="hljs-keyword">int</span> j;    <span class="hljs-keyword">for</span> (j = m - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123; <span class="hljs-comment">// 模式串从后往前匹配</span>      <span class="hljs-keyword">if</span> (a[i+j] != b[j]) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 坏字符对应模式串中的下标是 j</span>    &#125;    <span class="hljs-keyword">if</span> (j &lt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> i; <span class="hljs-comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span>    &#125;    <span class="hljs-comment">// 这里等同于将模式串往后滑动 j-bc[(int)a[i+j]] 位</span>    i = i + (j - bc[(<span class="hljs-keyword">int</span>)a[i+j]]);   &#125;  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre><p>为了方便理解，下面有一张图，将其中的一些关键变量标注在上面了，结合着图，代码应该更好理解。<br><img src="./02f1d9a1.jpeg" srcset="/img/loading.gif" alt="image"><br>至此，已经实现了包含坏字符规则的框架代码，只剩下往框架代码中填充好后缀规则了。现在，就来看看，如何实现好后缀规则。它的实现要比坏字符规则复杂一些。</p><p>先简单回顾一下，前面讲过好后缀的处理规则中最核心的内容：</p><ul><li><p>在模式串中，查找跟好后缀匹配的另一个子串；</p></li><li><p>在好后缀的后缀子串中，查找最长的、能跟模式串前缀子串匹配的后缀子串；</p></li></ul><p>在不考虑效率的情况下，这两个操作都可以用很“暴力”的匹配查找方式解决。但是，如果想要 <code>BM</code> 算法的效率很高，这部分就不能太低效。如何来做呢？</p><p>因为好后缀也是模式串本身的后缀子串，所以，可以在模式串和主串正式匹配之前，通过预处理模式串，预先计算好模式串的每个后缀子串，对应的另一个可匹配子串的位置。这个预处理过程比较有技巧，很不好懂，应该是这篇文章最难懂的内容了，要认真多读几遍。</p><p>先来看看，<strong>如何表示模式串中不同的后缀子串呢</strong>？因为后缀子串的最后一个字符的位置是固定的，下标为 <code>m-1</code>，只需要记录长度就可以了。通过长度，可以确定一个唯一的后缀子串。<br><img src="./47c1ca78.jpeg" srcset="/img/loading.gif" alt="image"><br>现在，要引入最关键的变量 <code>suffix</code> 数组。<code>suffix</code> 数组的下标 <code>k</code>，表示后缀子串的长度，下标对应的数组值存储的是，在模式串中跟好后缀<code>{u}</code>相匹配的子串<code>{u*}</code>的起始下标值。这句话不好理解，举一个例子。<br><img src="./d7be9aec.jpeg" srcset="/img/loading.gif" alt="image"><br>但是，如果模式串中有多个（大于 <code>1</code> 个）子串跟后缀子串<code>{u}</code>匹配，那 <code>suffix</code> 数组中该存储哪一个子串的起始位置呢？为了避免模式串往后滑动得过头了，肯定要存储模式串中最靠后的那个子串的起始位置，也就是下标最大的那个子串的起始位置。不过，这样处理就足够了吗？</p><p>实际上，仅仅是选最靠后的子串片段来存储是不够的。再回忆一下好后缀规则。</p><p>不仅要在模式串中，查找跟好后缀匹配的另一个子串，还要在好后缀的后缀子串中，查找最长的能跟模式串前缀子串匹配的后缀子串。</p><p>如果只记录刚刚定义的 <code>suffix</code>，实际上，只能处理规则的前半部分，也就是，在模式串中，查找跟好后缀匹配的另一个子串。所以，除了 <code>suffix</code> 数组之外，还需要另外一个 <code>boolean</code> 类型的 <code>prefix</code> 数组，来记录模式串的后缀子串是否能匹配模式串的前缀子串。<br><img src="./72bbc0fb.jpeg" srcset="/img/loading.gif" alt="image"><br>现在来看下，<strong>如何来计算并填充这两个数组的值</strong>？这个计算过程非常巧妙。</p><p>拿下标从 <code>0</code> 到 <code>i</code> 的子串（<code>i</code> 可以是 <code>0</code> 到 <code>m-2</code>）与整个模式串，求公共后缀子串。如果公共后缀子串的长度是 <code>k</code>，那就记录 <code>suffix[k]=j</code>（<code>j</code> 表示公共后缀子串的起始下标）。如果 <code>j</code> 等于 <code>0</code>，也就是说，公共后缀子串也是模式串的前缀子串，就记录 <code>prefix[k]=true</code>。<br><img src="./491ce881.jpeg" srcset="/img/loading.gif" alt="image"><br>把 <code>suffix</code> 数组和 <code>prefix</code> 数组的计算过程，用代码实现出来，就是下面这个样子：</p><pre><code class="hljs java"><span class="hljs-comment">// b 表示模式串，m 表示长度，suffix，prefix 数组事先申请好了</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">generateGS</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] suffix, <span class="hljs-keyword">boolean</span>[] prefix)</span> </span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123; <span class="hljs-comment">// 初始化</span>    suffix[i] = -<span class="hljs-number">1</span>;    prefix[i] = <span class="hljs-keyword">false</span>;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; ++i) &#123; <span class="hljs-comment">// b[0, i]</span>    <span class="hljs-keyword">int</span> j = i;    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; <span class="hljs-comment">// 公共后缀子串长度</span>    <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; b[j] == b[m-<span class="hljs-number">1</span>-k]) &#123; <span class="hljs-comment">// 与 b[0, m-1] 求公共后缀子串</span>      --j;      ++k;      suffix[k] = j+<span class="hljs-number">1</span>; <span class="hljs-comment">//j+1 表示公共后缀子串在 b[0, i] 中的起始下标</span>    &#125;       <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span>) prefix[k] = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 如果公共后缀子串也是模式串的前缀子串</span>  &#125;&#125;</code></pre><p>有了这两个数组之后，现在来看，<strong>在模式串跟主串匹配的过程中，遇到不能匹配的字符时，如何根据好后缀规则，计算模式串往后滑动的位数</strong>？</p><p>假设好后缀的长度是 <code>k</code>。先拿好后缀，在 <code>suffix</code> 数组中查找其匹配的子串。如果 <code>suffix[k]</code> 不等于 <code>-1</code>（<code>-1</code> 表示不存在匹配的子串），那就将模式串往后移动 <code>j-suffix[k]+1</code> 位（<code>j</code> 表示坏字符对应的模式串中的字符下标）。如果 <code>suffix[k]</code> 等于 <code>-1</code>，表示模式串中不存在另一个跟好后缀匹配的子串片段。可以用下面这条规则来处理。<br><img src="./ac59d876.jpeg" srcset="/img/loading.gif" alt="image"><br>好后缀的后缀子串 <code>b[r, m-1]</code>（其中，<code>r</code> 取值从 <code>j+2</code> 到 <code>m-1</code>）的长度 <code>k=m-r</code>，如果 <code>prefix[k]</code> 等于 <code>true</code>，表示长度为 <code>k</code> 的后缀子串，有可匹配的前缀子串，这样可以把模式串后移 <code>r</code> 位。<br><img src="./c16df881.jpeg" srcset="/img/loading.gif" alt="image"><br>如果两条规则都没有找到可以匹配好后缀及其后缀子串的子串，就将整个模式串后移 <code>m</code> 位。<br><img src="./a3ce8512.jpeg" srcset="/img/loading.gif" alt="image"><br>至此，好后缀规则的代码实现也讲完了。把好后缀规则加到前面的代码框架里，就可以得到 <code>BM</code> 算法的完整版代码实现。</p><pre><code class="hljs java"><span class="hljs-comment">// a,b 表示主串和模式串；n，m 表示主串和模式串的长度。</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bm</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> m)</span> </span>&#123;  <span class="hljs-keyword">int</span>[] bc = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[SIZE]; <span class="hljs-comment">// 记录模式串中每个字符最后出现的位置</span>  generateBC(b, m, bc); <span class="hljs-comment">// 构建坏字符哈希表</span>  <span class="hljs-keyword">int</span>[] suffix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];  <span class="hljs-keyword">boolean</span>[] prefix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m];  generateGS(b, m, suffix, prefix);  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// j 表示主串与模式串匹配的第一个字符</span>  <span class="hljs-keyword">while</span> (i &lt;= n - m) &#123;    <span class="hljs-keyword">int</span> j;    <span class="hljs-keyword">for</span> (j = m - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123; <span class="hljs-comment">// 模式串从后往前匹配</span>      <span class="hljs-keyword">if</span> (a[i+j] != b[j]) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 坏字符对应模式串中的下标是 j</span>    &#125;    <span class="hljs-keyword">if</span> (j &lt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> i; <span class="hljs-comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span>    &#125;    <span class="hljs-keyword">int</span> x = j - bc[(<span class="hljs-keyword">int</span>)a[i+j]];    <span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (j &lt; m-<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 如果有好后缀的话</span>      y = moveByGS(j, m, suffix, prefix);    &#125;    i = i + Math.max(x, y);  &#125;  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// j 表示坏字符对应的模式串中的字符下标 ; m 表示模式串长度</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">moveByGS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] suffix, <span class="hljs-keyword">boolean</span>[] prefix)</span> </span>&#123;  <span class="hljs-keyword">int</span> k = m - <span class="hljs-number">1</span> - j; <span class="hljs-comment">// 好后缀长度</span>  <span class="hljs-keyword">if</span> (suffix[k] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> j - suffix[k] +<span class="hljs-number">1</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = j+<span class="hljs-number">2</span>; r &lt;= m-<span class="hljs-number">1</span>; ++r) &#123;    <span class="hljs-keyword">if</span> (prefix[m-r] == <span class="hljs-keyword">true</span>) &#123;      <span class="hljs-keyword">return</span> r;    &#125;  &#125;  <span class="hljs-keyword">return</span> m;&#125;</code></pre><h2 id="BM-算法的性能分析及优化"><a href="#BM-算法的性能分析及优化" class="headerlink" title="BM 算法的性能分析及优化"></a>BM 算法的性能分析及优化</h2><p>先来分析 <code>BM</code> 算法的内存消耗。整个算法用到了额外的 <code>3</code> 个数组，其中 <code>bc</code> 数组的大小跟字符集大小有关，<code>suffix</code> 数组和 <code>prefix</code> 数组的大小跟模式串长度 <code>m</code> 有关。</p><p>如果处理字符集很大的字符串匹配问题，<code>bc</code> 数组对内存的消耗就会比较多。因为好后缀和坏字符规则是独立的，如果运行的环境对内存要求苛刻，可以只使用好后缀规则，不使用坏字符规则，这样就可以避免 <code>bc</code> 数组过多的内存消耗。不过，单纯使用好后缀规则的 <code>BM</code> 算法效率就会下降一些了。</p><p>对于执行效率来说，可以先从时间复杂度的角度来分析。</p><p>实际上，前面讲的 <code>BM</code> 算法是个初级版本。为了更容易理解，有些复杂的优化这里没有讲。基于目前的这个版本，在极端情况下，预处理计算 <code>suffix</code> 数组、<code>prefix</code> 数组的性能会比较差。</p><p>比如模式串是 <code>aaaaaaa</code> 这种包含很多重复的字符的模式串，预处理的时间复杂度就是 $O(m^2)$。当然，大部分情况下，时间复杂度不会这么差。关于如何优化这种极端情况下的时间复杂度退化，如果感兴趣，可以自己研究一下。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>BM</code> 算法。尽管复杂、难懂，但匹配的效率却很高，在实际的软件开发中，特别是一些文本编辑器中，应用比较多。如果一遍看不懂的话，就多看几遍。</p><p><code>BM</code> 算法核心思想是，利用模式串本身的特点，在模式串中某个字符与主串不能匹配的时候，将模式串往后多滑动几位，以此来减少不必要的字符比较，提高匹配的效率。<code>BM</code> 算法构建的规则有两类，坏字符规则和好后缀规则。好后缀规则可以独立于坏字符规则使用。因为坏字符规则的实现比较耗内存，为了节省内存，可以只用好后缀规则来实现 <code>BM</code> 算法。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>你熟悉的编程语言中的查找函数，或者工具、软件中的查找功能，都是用了哪种字符串匹配算法呢？欢迎留言和我分享.</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>时间复杂度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>29.字符串匹配基础（上）</title>
    <link href="/passages/29/"/>
    <url>/passages/29/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>字符串匹配这样一个功能，对于任何一个开发工程师来说，应该都不会陌生。用的最多的就是编程语言提供的字符串查找函数，比如 <code>Java</code> 中的 <code>indexOf()</code>，<code>Python</code> 中的 <code>find()</code> 函数等，它们底层就是依赖字符串匹配算法。</p><p>字符串匹配算法很多，比较经典的有：<code>BF</code> 算法和 <code>RK</code> 算法以及 <code>BM</code> 算法和 <code>KMP</code> 算法。</p><h2 id="BF-算法"><a href="#BF-算法" class="headerlink" title="BF 算法"></a>BF 算法</h2><p><code>BF</code> 算法中的 <code>BF</code> 是 <code>Brute Force</code> 的缩写，中文叫作暴力匹配算法，也叫朴素匹配算法。从名字可以看出，这种算法的字符串匹配方式很“暴力”，当然也就会比较简单、好懂，但相应的性能也不高。</p><p>先定义两个概念，方便后面讲解。它们分别是<strong>主串</strong>和<strong>模式串</strong>。这俩概念很好理解，举个例子。</p><p>比方说，在字符串 <code>A</code> 中查找字符串 <code>B</code>，那字符串 <code>A</code> 就是主串，字符串 <code>B</code> 就是模式串。把主串的长度记作 <code>n</code>，模式串的长度记作 <code>m</code>。因为是在主串中查找模式串，所以 <code>n&gt;m</code>。</p><p>作为最简单、最暴力的字符串匹配算法，<code>BF</code> 算法的思想可以用一句话来概括，那就是，<strong>在主串中，检查起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的</strong>。<br><img src="./89cd9db0.png" srcset="/img/loading.gif" alt="image"><br>从上面的算法思想和例子，可以看出，在极端情况下，比如主串是“aaaaa…aaaaaa”（省略号表示有很多重复的字符 <code>a</code>），模式串是“aaaaab”。每次都比对 <code>m</code> 个字符，要比对 <code>n-m+1</code> 次，所以，这种算法的最坏情况时间复杂度是 $O(n*m)$。</p><p>尽管理论上，<code>BF</code> 算法的时间复杂度很高，是 $O(n*m)$，但在实际的开发中，它却是一个比较常用的字符串匹配算法。为什么这么说呢？原因有两点。</p><p>第一，实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以就停止了，不需要把 <code>m</code> 个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度是 $O(n*m)$，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。</p><p>第二，朴素字符串匹配算法思想简单，代码实现也非常简单。简单意味着不容易出错，如果有 <code>bug</code> 也容易暴露和修复。在工程中，在满足性能要求的前提下，简单是首选。这也是常说的<code>KISS</code>（<code>Keep it Simple and Stupid</code>）设计原则。</p><p>所以，在实际的软件开发中，绝大部分情况下，朴素的字符串匹配算法就够用了。</p><h2 id="RK-算法"><a href="#RK-算法" class="headerlink" title="RK 算法"></a>RK 算法</h2><p><code>RK</code> 算法的全称叫 <code>Rabin-Karp</code> 算法，是由它的两位发明者 <code>Rabin</code> 和 <code>Karp</code> 的名字来命名的。这个算法理解起来也不是很难。个人觉得，它其实就是刚刚的 <code>BF</code> 算法的升级版。</p><p><code>RK</code> 算法的思路是这样的：通过哈希算法对主串中的 <code>n-m+1</code> 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了（这里先不考虑哈希冲突的问题）。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。<br><img src="./fbfb8447.png" srcset="/img/loading.gif" alt="image"><br>不过，通过哈希算法计算子串的哈希值的时候，需要遍历子串中的每个字符。尽管模式串与子串比较的效率提高了，但是，算法整体的效率并没有提高。有没有方法可以提高哈希算法计算子串哈希值的效率呢？</p><p>这就需要哈希算法设计的非常有技巧了。假设要匹配的字符串的字符集中只包含 <code>K</code> 个字符，可以用一个 <code>K</code> 进制数来表示一个子串，这个 <code>K</code> 进制数转化成十进制数，作为子串的哈希值。表述起来有点抽象，举了一个例子。</p><p>在十进制的表示法中，一个数字的值是通过下面的方式计算出来的。对应到二十六进制，一个包含 <code>a</code> 到 <code>z</code> 这 <code>26</code> 个字符的字符串，计算哈希的时候，只需要把进位从 <code>10</code> 改成 <code>26</code> 就可以。<br><img src="./a9125775.png" srcset="/img/loading.gif" alt="image"><br>现在，为了方便解释，假设字符串中只包含 <code>a～z</code> 这 <code>26</code> 个小写字符，用二十六进制来表示一个字符串，对应的哈希值就是二十六进制数转化成十进制的结果。</p><p>这种哈希算法有一个特点，在主串中，相邻两个子串的哈希值的计算公式有一定关系。这有个例子，先找一下规律，再来看后面的讲解。<br><img src="./8291363f.png" srcset="/img/loading.gif" alt="image"><br>从这里例子中，很容易就能得出这样的规律：相邻两个子串 <code>s[i-1]</code> 和 <code>s[i]</code>（<code>i</code> 表示子串在主串中的起始位置，子串的长度都为 <code>m</code>），对应的哈希值计算公式有交集，也就是说，可以使用 <code>s[i-1]</code> 的哈希值很快的计算出 <code>s[i]</code> 的哈希值。如果用公式表示的话，就是下面这个样子：<br><img src="./89c16587.png" srcset="/img/loading.gif" alt="image"><br>不过，这里有一个小细节需要注意，那就是 $26^{m-1}$ 这部分的计算，可以通过查表的方法来提高效率。事先计算好 $26^0$、$26^1$、$26^2$……$26^{m-1}$，并且存储在一个长度为 <code>m</code> 的数组中，公式中的“次方”就对应数组的下标。当需要计算 <code>26</code> 的 <code>x</code> 次方的时候，就可以从数组的下标为 <code>x</code> 的位置取值，直接使用，省去了计算的时间。</p><p><code>RK</code> 算法是 <code>BF</code> 算法的改进，它巧妙借助了哈希算法，让匹配的效率有了很大的提升。<code>RK</code> 算法的效率要比 <code>BF</code> 算法高，现在，就来分析一下，<code>RK</code> 算法的时间复杂度到底是多少呢？</p><p>整个 <code>RK</code> 算法包含两部分，计算子串哈希值和模式串哈希值与子串哈希值之间的比较。第一部分，前面也分析了，可以通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值了，所以这部分的时间复杂度是 $O(n)$。</p><p>模式串哈希值与每个子串哈希值之间的比较的时间复杂度是 $O(1)$，总共需要比较 <code>n-m+1</code> 个子串的哈希值，所以，这部分的时间复杂度也是 $O(n)$。所以，<code>RK</code> 算法整体的时间复杂度就是 $O(n)$。</p><p>这里还有一个问题就是，模式串很长，相应的主串中的子串也会很长，通过上面的哈希算法计算得到的哈希值就可能很大，如果超过了计算机中整型数据可以表示的范围，那该如何解决呢？</p><p>刚刚设计的哈希算法是没有散列冲突的，也就是说，一个字符串与一个二十六进制数一一对应，不同的字符串的哈希值肯定不一样。因为是基于进制来表示一个字符串的，可以类比成十进制、十六进制来思考一下。实际上，为了能将哈希值落在整型数据范围内，可以牺牲一下，允许哈希冲突。这个时候哈希算法该如何设计呢？</p><p>哈希算法的设计方法有很多，举一个例子说明一下。假设字符串中只包含 <code>a～z</code> 这 <code>26</code> 个英文字母，那每个字母对应一个数字，比如 <code>a</code> 对应 <code>1</code>，<code>b</code> 对应 <code>2</code>，以此类推，<code>z</code> 对应 <code>26</code>。可以把字符串中每个字母对应的数字相加，最后得到的和作为哈希值。这种哈希算法产生的哈希值的数据范围就相对要小很多了。</p><p>不过，你也应该发现，这种哈希算法的哈希冲突概率也是挺高的。当然，只是举了一个最简单的设计方法，还有很多更加优化的方法，比如将每一个字母从小到大对应一个素数，而不是 <code>1，2，3……</code>这样的自然数，这样冲突的概率就会降低一些。</p><p>那现在新的问题来了。之前只需要比较一下模式串和子串的哈希值，如果两个值相等，那这个子串就一定可以匹配模式串。但是，当存在哈希冲突的时候，有可能存在这样的情况，子串和模式串的哈希值虽然是相同的，但是两者本身并不匹配。</p><p>实际上，解决方法很简单。当发现一个子串的哈希值跟模式串的哈希值相等的时候，只需要再对比一下子串和模式串本身就好了。当然，如果子串的哈希值与模式串的哈希值不相等，那对应的子串和模式串肯定也是不匹配的，就不需要比对子串和模式串本身了。</p><p>所以，哈希算法的冲突概率要相对控制得低一些，如果存在大量冲突，就会导致 <code>RK</code> 算法的时间复杂度退化，效率下降。极端情况下，如果存在大量的冲突，每次都要再对比子串和模式串本身，那时间复杂度就会退化成 $O(n*m)$。但也不要太悲观，一般情况下，冲突不会很多，<code>RK</code> 算法的效率还是比 <code>BF</code> 算法高的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>BF</code> 算法是最简单、粗暴的字符串匹配算法，它的实现思路是，拿模式串与主串中是所有子串匹配，看是否有能匹配的子串。所以，时间复杂度也比较高，是 $O(n*m)$，<code>n</code>、<code>m</code> 表示主串和模式串的长度。不过，在实际的软件开发中，因为这种算法实现简单，对于处理小规模的字符串匹配很好用。</p><p><code>RK</code> 算法是借助哈希算法对 <code>BF</code> 算法进行改造，即对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间。所以，理想情况下，<code>RK</code> 算法的时间复杂度是 $O(n)$，跟 <code>BF</code> 算法相比，效率提高了很多。不过这样的效率取决于哈希算法的设计方法，如果存在冲突的情况下，时间复杂度可能会退化。极端情况下，哈希算法大量冲突，时间复杂度就退化为 $O(n*m)$。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>假设有下面这样一个二维字符串矩阵（图中的主串），借助上面的处理思路，如何在其中查找另一个二维字符串矩阵（图中的模式串）呢？<br><img src="./99d7a834.png" srcset="/img/loading.gif" alt="image"></p><blockquote><p>以模式串矩阵的大小，去匹配主串矩阵，每个小矩阵可以构建成字符串，就能用 <code>RK</code> 算法做字符串匹配了。</p><p>如果主串的大小是 <code>M * N</code>，模式串大小为 <code>m * n</code>，则时间复杂度为 $O(M - m + 1) * (N - n + 1)$。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>时间复杂度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>28.深度和广度优先搜索</title>
    <link href="/passages/28/"/>
    <url>/passages/28/</url>
    
    <content type="html"><![CDATA[<p>在社交网络中，有一个六度分隔理论，具体是说，你与世界上的另一个人间隔的关系不会超过六度，也就是说平均只需要六步就可以联系到任何两个互不相识的人。</p><p>一个用户的一度连接用户很好理解，就是他的好友，二度连接用户就是他好友的好友，三度连接用户就是他好友的好友的好友。在社交网络中，往往通过用户之间的连接关系，来实现推荐“可能认识的人”这么一个功能。</p><h2 id="什么是“搜索”算法？"><a href="#什么是“搜索”算法？" class="headerlink" title="什么是“搜索”算法？"></a>什么是“搜索”算法？</h2><p>算法是作用于具体数据结构之上的，深度优先搜索算法和广度优先搜索算法都是基于“图”这种数据结构的。这是因为，图这种数据结构的表达能力很强，大部分涉及搜索的场景都可以抽象成“图”。</p><p>图上的搜索算法，最直接的理解就是，在图中找出从一个顶点出发，到另一个顶点的路径。具体方法有很多，比如今天要讲的两种最简单、最“暴力”的深度优先、广度优先搜索，还有 <code>A*</code>、<code>IDA*</code> 等启发式搜索算法。</p><p>先给出图的代码实现。需要说明一下，深度优先搜索算法和广度优先搜索算法，既可以用在无向图，也可以用在有向图上。在今天的文章中，都针对无向图来讲解。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> </span>&#123; <span class="hljs-comment">// 无向图</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> v; <span class="hljs-comment">// 顶点的个数</span>  <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="hljs-comment">// 邻接表</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;    <span class="hljs-keyword">this</span>.v = v;    adj = <span class="hljs-keyword">new</span> LinkedList[v];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;v; ++i) &#123;      adj[i] = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123; <span class="hljs-comment">// 无向图一条边存两次</span>    adj[s].add(t);    adj[t].add(s);  &#125;&#125;</code></pre><h2 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h2><p>广度优先搜索（<code>Breadth-First-Search</code>），平常都简称为 <code>BFS</code>。直观地讲，它其实就是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。理解起来并不难，所以这里有一张示意图，可以看下。<br><img src="./cc5e6398.png" srcset="/img/loading.gif" alt="image"><br>尽管广度优先搜索的原理挺简单，但代码实现还是稍微有点复杂度。</p><p>这里面，<code>bfs()</code> 函数就是基于之前定义的，图的广度优先搜索的代码实现。其中 <code>s</code> 表示起始顶点，<code>t</code> 表示终止顶点。搜索一条从 <code>s</code> 到 <code>t</code> 的路径。实际上，这样求得的路径就是从 <code>s</code> 到 <code>t</code> 的最短路径。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123;  <span class="hljs-keyword">if</span> (s == t) <span class="hljs-keyword">return</span>;  <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[v];  visited[s]=<span class="hljs-keyword">true</span>;  Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();  queue.add(s);  <span class="hljs-keyword">int</span>[] prev = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[v];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123;    prev[i] = -<span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">while</span> (queue.size() != <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">int</span> w = queue.poll();   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; adj[w].size(); ++i) &#123;      <span class="hljs-keyword">int</span> q = adj[w].get(i);      <span class="hljs-keyword">if</span> (!visited[q]) &#123;        prev[q] = w;        <span class="hljs-keyword">if</span> (q == t) &#123;          print(prev, s, t);          <span class="hljs-keyword">return</span>;        &#125;        visited[q] = <span class="hljs-keyword">true</span>;        queue.add(q);      &#125;    &#125;  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prev, <span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123; <span class="hljs-comment">// 递归打印 s-&gt;t 的路径</span>  <span class="hljs-keyword">if</span> (prev[t] != -<span class="hljs-number">1</span> &amp;&amp; t != s) &#123;    print(prev, s, prev[t]);  &#125;  System.out.print(t + <span class="hljs-string">" "</span>);&#125;</code></pre><p>这段代码不是很好理解，里面有三个重要的辅助变量 <code>visited</code>、<code>queue</code>、<code>prev</code>。只要理解这三个变量，读懂这段代码估计就没什么问题了。</p><p><strong>visited</strong>是用来记录已经被访问的顶点，用来避免顶点被重复访问。如果顶点 <code>q</code> 被访问，那相应的 <code>visited[q]</code> 会被设置为 <code>true</code>。</p><p><strong>queue</strong>是一个队列，用来存储已经被访问、但相连的顶点还没有被访问的顶点。因为广度优先搜索是逐层访问的，也就是说，只有把第 <code>k</code> 层的顶点都访问完成之后，才能访问第 <code>k+1</code> 层的顶点。当访问到第 <code>k</code> 层的顶点的时候，需要把第 <code>k</code> 层的顶点记录下来，稍后才能通过第 <code>k</code> 层的顶点来找第 <code>k+1</code> 层的顶点。所以，用这个队列来实现记录的功能。</p><p><strong>prev</strong>用来记录搜索路径。当从顶点 <code>s</code> 开始，广度优先搜索到顶点 <code>t</code> 后，<code>prev</code> 数组中存储的就是搜索的路径。不过，这个路径是反向存储的。<code>prev[w]</code> 存储的是，顶点 <code>w</code> 是从哪个前驱顶点遍历过来的。比如，通过顶点 <code>2</code> 的邻接表访问到顶点 <code>3</code>，那 <code>prev[3]</code> 就等于 <code>2</code>。为了正向打印出路径，需要递归地来打印，可以看下 <code>print()</code> 函数的实现方式。</p><p>为了方便理解，这里有一个广度优先搜索的分解图，可以结合着代码一块儿看。<br><img src="./fd1d54b3.png" srcset="/img/loading.gif" alt="image"><br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/26/a94fcb00-c7ce-11e9-bd0a-57cc00d1a72f.png" srcset="/img/loading.gif" alt="image.png"><br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/26/b200fb70-c7ce-11e9-bd0a-57cc00d1a72f.png" srcset="/img/loading.gif" alt="image.png"><br>掌握了广优先搜索算法的原理，广度优先搜索的时间、空间复杂度是多少呢？</p><p>最坏情况下，终止顶点 <code>t</code> 离起始顶点 <code>s</code> 很远，需要遍历完整个图才能找到。这个时候，每个顶点都要进出一遍队列，每个边也都会被访问一次，所以，广度优先搜索的时间复杂度是 $O(V+E)$，其中，<code>V</code> 表示顶点的个数，<code>E</code> 表示边的个数。当然，对于一个连通图来说，也就是说一个图中的所有顶点都是连通的，<code>E</code> 肯定要大于等于 <code>V-1</code>，所以，广度优先搜索的时间复杂度也可以简写为 $O(E)$。</p><p>广度优先搜索的空间消耗主要在几个辅助变量 <code>visited</code> 数组、<code>queue</code> 队列、<code>prev</code> 数组上。这三个存储空间的大小都不会超过顶点的个数，所以空间复杂度是 $O(V)$。</p><h2 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h2><p>深度优先搜索（<code>Depth-First-Search</code>），简称 <code>DFS</code>。最直观的例子就是“走迷宫”。</p><p>假设你站在迷宫的某个岔路口，然后想找到出口。你随意选择一个岔路口来走，走着走着发现走不通的时候，就回退到上一个岔路口，重新选择一条路继续走，直到最终找到出口。这种走法就是一种深度优先搜索策略。</p><p>可以看下面的这幅图。搜索的起始顶点是 <code>s</code>，终止顶点是 <code>t</code>，希望在图中寻找一条从顶点 <code>s</code> 到顶点 <code>t</code> 的路径。如果映射到迷宫那个例子，<code>s</code> 就是起始所在的位置，<code>t</code> 就是出口。</p><p>下面的图用深度递归算法，把整个搜索的路径标记出来了。这里面实线箭头表示遍历，虚线箭头表示回退。从图中可以看出，深度优先搜索找出来的路径，并不是顶点 <code>s</code> 到顶点 <code>t</code> 的最短路径。<br><img src="./134fe9f3.png" srcset="/img/loading.gif" alt="image"><br>实际上，深度优先搜索用的是一种比较著名的算法思想，回溯思想。这种思想解决问题的过程，非常适合用递归来实现。</p><p>把上面的过程用递归来翻译出来，就是下面这个样子。深度优先搜索代码实现也用到了 <code>prev</code>、<code>visited</code> 变量以及 <code>print()</code> 函数，它们跟广度优先搜索代码实现里的作用是一样的。不过，深度优先搜索代码实现里，有个比较特殊的变量 <code>found</code>，它的作用是，当已经找到终止顶点 <code>t</code> 之后，就不再递归地继续查找了。</p><pre><code class="hljs java"><span class="hljs-keyword">boolean</span> found = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 全局变量或者类成员变量</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123;  found = <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[v];  <span class="hljs-keyword">int</span>[] prev = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[v];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123;    prev[i] = -<span class="hljs-number">1</span>;  &#125;  recurDfs(s, t, visited, prev);  print(prev, s, t);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recurDfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> w, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">boolean</span>[] visited, <span class="hljs-keyword">int</span>[] prev)</span> </span>&#123;  <span class="hljs-keyword">if</span> (found == <span class="hljs-keyword">true</span>) <span class="hljs-keyword">return</span>;  visited[w] = <span class="hljs-keyword">true</span>;  <span class="hljs-keyword">if</span> (w == t) &#123;    found = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; adj[w].size(); ++i) &#123;    <span class="hljs-keyword">int</span> q = adj[w].get(i);    <span class="hljs-keyword">if</span> (!visited[q]) &#123;      prev[q] = w;      recurDfs(q, t, visited, prev);    &#125;  &#125;&#125;</code></pre><p>理解了深度优先搜索算法之后，深度度优先搜索的时、空间间复杂度是多少呢？</p><p>从前面画的图可以看出，每条边最多会被访问两次，一次是遍历，一次是回退。所以，图上的深度优先搜索算法的时间复杂度是 $O(E)$，<code>E</code> 表示边的个数。</p><p>深度优先搜索算法的消耗内存主要是 <code>visited</code>、<code>prev</code> 数组和递归调用栈。<code>visited</code>、<code>prev</code> 数组的大小跟顶点的个数 <code>V</code> 成正比，递归调用栈的最大深度不会超过顶点的个数，所以总的空间复杂度就是 $O(V)$。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>广度优先搜索和深度优先搜索是图上的两种最常用、最基本的搜索算法，比起其他高级的搜索算法，比如 <code>A*</code>、<code>IDA*</code> 等，要简单粗暴，没有什么优化，所以，也被叫作暴力搜索算法。所以，这两种搜索算法仅适用于状态空间不大，也就是说图不大的搜索。</p><p>广度优先搜索，通俗的理解就是，地毯式层层推进，从起始顶点开始，依次往外遍历。广度优先搜索需要借助队列来实现，遍历得到的路径就是<strong>起始顶点到终止顶点的最短路径</strong>。深度优先搜索用的是回溯思想，非常适合用递归实现。换种说法，深度优先搜索是借助栈来实现的。在执行效率方面，深度优先和广度优先搜索的时间复杂度都是 $O(E)$，空间复杂度是 $O(V)$。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li><p>如何找出社交网络中某个用户的三度好友关系？</p><blockquote><p>这个问题非常适合用图的广度优先搜索算法来解决，因为广度优先搜索是层层往外推进的。首先，遍历与起始顶点最近的一层顶点，也就是用户的一度好友，然后再遍历与用户距离的边数为 <code>2</code> 的顶点，也就是二度好友关系，以及与用户距离的边数为 <code>3</code> 的顶点，也就是三度好友关系。</p><p>只需要稍加改造一下广度优先搜索代码，用一个数组来记录每个顶点与起始顶点的距离，非常容易就可以找出三度好友关系。</p></blockquote></li><li><p>上面的问题，能否用深度优先搜索来解决呢？</p><blockquote><p><code>DFS</code>递归时传多一个离初始节点的距离值，访问节点时，距离超过<code>3</code>的不再继续递归</p></blockquote></li><li><p>学习数据结构最难的不是理解和掌握原理，而是能灵活地将各种场景和问题抽象成对应的数据结构和算法。上面的内容中提到，迷宫可以抽象成图，走迷宫可以抽象成搜索算法，如何在计算机中存储一个迷宫？</p><blockquote><p>初始化两个顶点为迷宫起点和终点，从起点开始，遇到分叉点，为每个分支都新建一个节点，并和前一节点连接，递归每个分支直到终点</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>时间复杂度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>27.图的表示</title>
    <link href="/passages/27/"/>
    <url>/passages/27/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>涉及图的算法有很多，也非常复杂，比如图的搜索、最短路径、最小生成树、二分图等等。</p><h2 id="如何理解“图”？"><a href="#如何理解“图”？" class="headerlink" title="如何理解“图”？"></a>如何理解“图”？</h2><p>树中的元素称为节点，图中的元素就叫作<strong>顶点</strong>（<code>vertex</code>）。从图中可以看出来，图中的一个顶点可以与任意其他顶点建立连接关系。把这种建立的关系叫作<strong>边</strong>（<code>edge</code>）。<br><img src="./492c2903.png" srcset="/img/loading.gif" alt="image"></p><p>拿微信举例子。可以把每个用户看作一个顶点。如果两个用户之间互加好友，那就在两者之间建立一条边。所以，整个微信的好友关系就可以用一张图来表示。其中，每个用户有多少个好友，对应到图中，就叫作顶点的<strong>度</strong>（<code>degree</code>），就是跟顶点相连接的边的条数。</p><p>实际上，微博的社交关系跟微信还有点不一样，或者说更加复杂一点。微博允许单向关注，也就是说，用户 <code>A</code> 关注了用户 <code>B</code>，但用户 <code>B</code> 可以不关注用户 <code>A</code>。那如何用图来表示这种单向的社交关系呢？</p><p>可以把图结构稍微改造一下，引入边的“方向”的概念。</p><p>如果用户 <code>A</code> 关注了用户 <code>B</code>，我们就在图中画一条从 <code>A</code> 到 <code>B</code> 的带箭头的边，来表示边的方向。如果用户 <code>A</code> 和用户 <code>B</code> 互相关注了，那我们就画一条从 <code>A</code> 指向 <code>B</code> 的边，再画一条从 <code>B</code> 指向 <code>A</code> 的边。把这种边有方向的图叫作“<strong>有向图</strong>”。以此类推，把边没有方向的图就叫作“<strong>无向图</strong>”。</p><p>无向图中有“度”这个概念，表示一个顶点有多少条边。在有向图中，把度分为<strong>入度</strong>（<code>In-degree</code>）和<strong>出度</strong>（<code>Out-degree</code>）。<br><img src="./1c62e1b3.png" srcset="/img/loading.gif" alt="image"></p><p>顶点的入度，表示有多少条边指向这个顶点；顶点的出度，表示有多少条边是以这个顶点为起点指向其他顶点。对应到微博的例子，入度就表示有多少粉丝，出度就表示关注了多少人。</p><p>再来看另一种社交软件：<code>QQ</code>。</p><p><code>QQ</code> 中的社交关系要更复杂的一点。<code>QQ</code> 不仅记录了用户之间的好友关系，还记录了两个用户之间的亲密度，如果两个用户经常往来，那亲密度就比较高；如果不经常往来，亲密度就比较低。如何在图中记录这种好友关系的亲密度呢？</p><p>这里就要用到另一种图，<strong>带权图</strong>（<code>weighted graph</code>）。在带权图中，每条边都有一个权重（<code>weight</code>），可以通过这个权重来表示 <code>QQ</code> 好友间的亲密度。<br><img src="./154cff6e.png" srcset="/img/loading.gif" alt="image"><br>如何在内存中存储图这种数据结构呢？</p><h2 id="邻接矩阵存储方法"><a href="#邻接矩阵存储方法" class="headerlink" title="邻接矩阵存储方法"></a>邻接矩阵存储方法</h2><p>图最直观的一种存储方法就是，<strong>邻接矩阵</strong>（<code>Adjacency Matrix</code>）。</p><p>邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点 <code>i</code> 与顶点 <code>j</code> 之间有边，就将 <code>A[i][j]</code> 和 <code>A[j][i]</code> 标记为 <code>1</code>；对于有向图来说，如果顶点 <code>i</code> 到顶点 <code>j</code> 之间，有一条箭头从顶点 <code>i</code> 指向顶点 <code>j</code> 的边，那就将 <code>A[i][j]</code> 标记为 <code>1</code>。同理，如果有一条箭头从顶点 <code>j</code> 指向顶点 <code>i</code> 的边，就将 <code>A[j][i]</code> 标记为 <code>1</code>。对于带权图，数组中就存储相应的权重。<br><img src="./eaf4c670.png" srcset="/img/loading.gif" alt="image"><br>用邻接矩阵来表示一个图，虽然简单、直观，但是比较浪费存储空间。</p><p>对于无向图来说，如果 <code>A[i][j]</code> 等于 <code>1</code>，那 <code>A[j][i]</code> 也肯定等于 <code>1</code>。实际上，只需要存储一个就可以了。也就是说，无向图的二维数组中，如果将其用对角线划分为上下两部分，只需要利用上面或者下面这样一半的空间就足够了，另外一半白白浪费掉了。</p><p>如果存储的是<strong>稀疏图</strong>（<code>Sparse Matrix</code>），也就是说，顶点很多，但每个顶点的边并不多，那邻接矩阵的存储方法就更加浪费空间了。比如微信有好几亿的用户，对应到图上就是好几亿的顶点。但是每个用户的好友并不会很多，一般也就三五百个而已。如果用邻接矩阵来存储，那绝大部分的存储空间都被浪费了。</p><p>但这也并不是说，邻接矩阵的存储方法就完全没有优点。首先，邻接矩阵的存储方式简单、直接，因为基于数组，所以在获取两个顶点的关系时，就非常高效。其次，用邻接矩阵存储图的另外一个好处是方便计算。这是因为，用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算。比如求解最短路径问题时会提到一个 <code>Floyd-Warshall</code> 算法，就是利用矩阵循环相乘若干次得到结果。</p><h2 id="邻接表存储方法"><a href="#邻接表存储方法" class="headerlink" title="邻接表存储方法"></a>邻接表存储方法</h2><p>针对上面邻接矩阵比较浪费内存空间的问题，再来看另外一种图的存储方法，<strong>邻接表</strong>（<code>Adjacency List</code>）。</p><p>下面有一张邻接表的图。乍一看，邻接表是不是有点像散列表？每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。另外，图中画的是一个有向图的邻接表存储方式，每个顶点对应的链表里面，存储的是指向的顶点。对于无向图来说，也是类似的，不过，每个顶点的链表中存储的，是跟这个顶点有边相连的顶点。<br><img src="./b17f2523.png" srcset="/img/loading.gif" alt="image"><br>还记得时间、空间复杂度互换的设计思想吗？邻接矩阵存储起来比较浪费空间，但是使用起来比较节省时间。相反，邻接表存储起来比较节省空间，但是使用起来就比较耗时间。</p><p>就像图中的例子，如果要确定，是否存在一条从顶点 <code>2</code> 到顶点 <code>4</code> 的边，那就要遍历顶点 <code>2</code> 对应的那条链表，看链表中是否存在顶点 <code>4</code>。而且链表的存储方式对缓存不友好。所以，比起邻接矩阵的存储方式，在邻接表中查询两个顶点之间的关系就没那么高效了。</p><p>可以将邻接表中的链表改成平衡二叉查找树。实际开发中，也可以选择用红黑树。这样，就可以更加快速地查找两个顶点之间是否存在边了。当然，这里的二叉查找树可以换成其他动态数据结构，比如跳表、散列表等。除此之外，还可以将链表改成有序动态数组，可以通过二分查找的方法来快速定位两个顶点之间否是存在边。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于图，需要理解这样几个概念：无向图、有向图、带权图、顶点、边、度、入度、出度。除此之外，还有图的两个主要的存储方式：邻接矩阵和邻接表。</p><p>邻接矩阵存储方法的缺点是比较浪费空间，但是优点是查询效率高，而且方便矩阵运算。邻接表存储方法中每个顶点都对应一个链表，存储与其相连接的其他顶点。尽管邻接表的存储方式比较节省存储空间，但链表不方便查找，所以查询效率没有邻接矩阵存储方式高。针对这个问题，邻接表还有改进升级版，即将链表换成更加高效的动态数据结构，比如平衡二叉查找树、跳表、散列表等。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li><p>如何存储微博、微信等社交网络中的好友关系？</p><blockquote><p>微博、微信是两种“图”，前者是有向图，后者是无向图。在这个问题上，两者的解决思路差不多，所以只拿微博来谈谈。</p><p>数据结构是为算法服务的，所以具体选择哪种存储方法，与期望支持的操作有关系。针对微博用户关系，假设需要支持下面这样几个操作：</p><ul><li><p>判断用户 <code>A</code> 是否关注了用户 <code>B</code>；</p></li><li><p>判断用户 <code>A</code> 是否是用户 <code>B</code> 的粉丝；</p></li><li><p>用户 <code>A</code> 关注用户 <code>B</code>；</p></li><li><p>用户 <code>A</code> 取消关注用户 <code>B</code>；</p></li><li><p>根据用户名称的首字母排序，分页获取用户的粉丝列表；</p></li><li><p>根据用户名称的首字母排序，分页获取用户的关注列表。</p></li></ul><p>因为社交网络是一张稀疏图，使用邻接矩阵存储比较浪费存储空间。所以，这里采用邻接表来存储。</p><p>不过，用一个邻接表来存储这种有向图是不够的。去查找某个用户关注了哪些用户非常容易，但是如果要想知道某个用户都被哪些用户关注了，也就是用户的粉丝列表，是非常困难的。</p><p>基于此，还需要一个逆邻接表。邻接表中存储了用户的关注关系，逆邻接表中存储的是用户的被关注关系。对应到图上，邻接表中，每个顶点的链表中，存储的就是这个顶点指向的顶点，逆邻接表中，每个顶点的链表中，存储的是指向这个顶点的顶点。如果要查找某个用户关注了哪些用户，可以在邻接表中查找；如果要查找某个用户被哪些用户关注了，从逆邻接表中查找。<br><img src="./aaf900a0.png" srcset="/img/loading.gif" alt="image"><br>基础的邻接表不适合快速判断两个用户之间是否是关注与被关注的关系，所以要选择改进版本，将邻接表中的链表改为支持快速查找的动态数据结构。选择哪种动态数据结构呢？红黑树、跳表、有序动态数组还是散列表呢？</p><p>因为需要按照用户名称的首字母排序，分页来获取用户的粉丝列表或者关注列表，用跳表这种结构再合适不过了。这是因为，跳表插入、删除、查找都非常高效，时间复杂度是 $O(logn)$，空间复杂度上稍高，是 $O(n)$。最重要的一点，跳表中存储的数据本来就是有序的了，分页获取粉丝列表或关注列表，就非常高效。</p><p>如果对于小规模的数据，比如社交网络中只有几万、几十万个用户，可以将整个社交关系存储在内存中，上面的解决思路是没有问题的。但是如果像微博那样有上亿的用户，数据规模太大，就无法全部存储在内存中了。这个时候该怎么办呢？</p><p>可以通过哈希算法等数据分片方式，将邻接表存储在不同的机器上。可以看下面这幅图，在机器 <code>1</code> 上存储顶点 <code>1，2，3</code> 的邻接表，在机器 <code>2</code> 上，存储顶点 <code>4，5</code> 的邻接表。逆邻接表的处理方式也一样。当要查询顶点与顶点关系的时候，就利用同样的哈希算法，先定位顶点所在的机器，然后再在相应的机器上查找。<br><img src="./c79ae35c.png" srcset="/img/loading.gif" alt="image"><br>除此之外，还有另外一种解决思路，就是利用外部存储（比如硬盘），因为外部存储的存储空间要比内存会宽裕很多。数据库是经常用来持久化存储关系数据的，所以这里介绍一种数据库的存储方式。</p><p>用下面这张表来存储这样一个图。为了高效地支持前面定义的操作，可以在表上建立多个索引，比如第一列、第二列，给这两列都建立索引。<br><img src="./d9f2d587.png" srcset="/img/loading.gif" alt="image"></p></blockquote></li><li><p>除了社交网络可以用图来表示之外，符合图这种结构特点的例子还有很多，比如知识图谱（<code>Knowledge Graph</code>）。关于图这种数据结构，还能想到其他生活或者工作中的例子吗？</p><blockquote><p>互联网上网页之间通过超链接连接成一张有向图；城市乃至全国交通网络是一张加权图；人与人之间的人际关系够成一张图，著名的六度分割理论。</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>26.堆的应用</title>
    <link href="/passages/26/"/>
    <url>/passages/26/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>搜索引擎的热门搜索排行榜功能你用过吗？你知道这个功能是如何实现的吗？实际上，它的实现并不复杂。搜索引擎每天会接收大量的用户搜索请求，它会把这些用户输入的搜索关键词记录下来，然后再离线地统计分析，得到最热门的 <code>Top 10</code> 搜索关键词。</p><p>那请你思考下，假设现在有一个包含 <code>10</code> 亿个搜索关键词的日志文件，如何能快速获取到热门榜 <code>Top 10</code> 的搜索关键词呢？</p><p>下面就来讲一讲，堆这种数据结构几个非常重要的应用：优先级队列、求 <code>Top K</code> 和求中位数。</p><h2 id="堆的应用一：优先级队列"><a href="#堆的应用一：优先级队列" class="headerlink" title="堆的应用一：优先级队列"></a>堆的应用一：优先级队列</h2><p>优先级队列，顾名思义，它首先应该是一个队列。队列最大的特性就是先进先出。不过，在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。</p><p>如何实现一个优先级队列呢？方法有很多，但是用堆来实现是最直接、最高效的。这是因为，堆和优先级队列非常相似。一个堆就可以看作一个优先级队列。很多时候，它们只是概念上的区分而已。往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。</p><p>优先级队列，它的应用场景非常多。很多数据结构和算法都要依赖它。比如，赫夫曼编码、图的最短路径、最小生成树算法等等。不仅如此，很多语言中，都提供了优先级队列的实现，比如，<code>Java</code> 的 <code>PriorityQueue</code>，<code>C++</code> 的 <code>priority_queue</code> 等。</p><p>这里有两个具体的例子：</p><p><strong>1. 合并有序小文件</strong></p><p>假设有 <code>100</code> 个小文件，每个文件的大小是 <code>100MB</code>，每个文件中存储的都是有序的字符串。现在希望将这些 <code>100</code> 个小文件合并成一个有序的大文件。这里就会用到优先级队列。</p><p>整体思路有点像归并排序中的合并函数。从这 <code>100</code> 个文件中，各取第一个字符串，放入数组中，然后比较大小，把最小的那个字符串放入合并后的大文件中，并从数组中删除。</p><p>假设，这个最小的字符串来自于 <code>13.txt</code> 这个小文件，就再从这个小文件取下一个字符串，放到数组中，重新比较大小，并且选择最小的放入合并后的大文件，将它从数组中删除。依次类推，直到所有的文件中的数据都放入到大文件为止。</p><p>这里用数组这种数据结构，来存储从小文件中取出来的字符串。每次从数组中取最小字符串，都需要循环遍历整个数组，显然，这不是很高效。有没有更加高效方法呢？</p><p>这里就可以用到优先级队列，也可以说是堆。将从小文件中取出来的字符串放入到小顶堆中，那堆顶的元素，也就是优先级队列队首的元素，就是最小的字符串。将这个字符串放入到大文件中，并将其从堆中删除。然后再从小文件中取出下一个字符串，放入到堆中。循环这个过程，就可以将 <code>100</code> 个小文件中的数据依次放入到大文件中。</p><p>删除堆顶数据和往堆中插入数据的时间复杂度都是 $O(logn)$，$n$ 表示堆中的数据个数，这里就是 <code>100</code>。是不是比原来数组存储的方式高效了很多呢？</p><p><strong>2. 高性能定时器</strong></p><p>假设有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。定时器每过一个很小的单位时间（比如 <code>1</code> 秒），就扫描一遍任务，看是否有任务到达设定的执行时间。如果到达了，就拿出来执行。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/96236510-ddb2-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>但是，这样每过 <code>1</code> 秒就扫描一遍任务列表的做法比较低效，主要原因有两点：第一，任务的约定执行时间离当前时间可能还有很久，这样前面很多次扫描其实都是徒劳的；第二，每次都要扫描整个任务列表，如果任务列表很大的话，势必会比较耗时。</p><p>针对这些问题，就可以用优先级队列来解决。按照任务设定的执行时间，将这些任务存储在优先级队列中，队列首部（也就是小顶堆的堆顶）存储的是最先执行的任务。</p><p>这样，定时器就不需要每隔 <code>1</code> 秒就扫描一遍任务列表了。它拿队首任务的执行时间点，与当前时间点相减，得到一个时间间隔 <code>T</code>。</p><p>这个时间间隔 <code>T</code> 就是，从当前时间开始，需要等待多久，才会有第一个任务需要被执行。这样，定时器就可以设定在 <code>T</code> 秒之后，再来执行任务。从当前时间点到（<code>T - 1</code>）秒这段时间里，定时器都不需要做任何事情。</p><p>当 <code>T</code> 秒时间过去之后，定时器取优先级队列中队首的任务执行。然后再计算新的队首任务的执行时间点与当前时间点的差值，把这个值作为定时器执行下一个任务需要等待的时间。</p><p>这样，定时器既不用间隔 <code>1</code> 秒就轮询一次，也不用遍历整个任务列表，性能也就提高了。</p><h2 id="堆的应用二：利用堆求-Top-K"><a href="#堆的应用二：利用堆求-Top-K" class="headerlink" title="堆的应用二：利用堆求 Top K"></a>堆的应用二：利用堆求 Top K</h2><p><code>Top K</code> 的问题可以抽象成两类。一类是针对静态数据集合，也就是说数据集合事先确定，不会再变。另一类是针对动态数据集合，也就是说数据集合事先并不确定，有数据动态地加入到集合中。</p><p>针对静态数据，如何在一个包含 <code>n</code> 个数据的数组中，查找前 <code>K</code> 大数据呢？可以维护一个大小为 <code>K</code> 的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。如果比堆顶元素大，就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 <code>K</code> 大数据了。</p><p>遍历数组需要 $O(n)$ 的时间复杂度，一次堆化操作需要 $O(logK)$ 的时间复杂度，所以最坏情况下，$n$ 个元素都入堆一次，时间复杂度就是 $O(nlogK)$。</p><p>针对动态数据求得 <code>Top K</code> 就是实时 <code>Top K</code>。怎么理解呢？举一个例子。一个数据集合中有两个操作，一个是添加数据，另一个询问当前的前 <code>K</code> 大数据。</p><p>如果每次询问前 <code>K</code> 大数据，都基于当前的数据重新计算的话，那时间复杂度就是 $O(nlogK)$，$n$ 表示当前的数据的大小。实际上，可以一直都维护一个 <code>K</code> 大小的小顶堆，当有数据被添加到集合中时，就拿它与堆顶的元素对比。如果比堆顶元素大，就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理。这样，无论任何时候需要查询当前的前 <code>K</code> 大数据，都可以立刻返回给他。</p><h2 id="堆的应用三：利用堆求中位数"><a href="#堆的应用三：利用堆求中位数" class="headerlink" title="堆的应用三：利用堆求中位数"></a>堆的应用三：利用堆求中位数</h2><p>中位数，顾名思义，就是处在中间位置的那个数。如果数据的个数是奇数，把数据从小到大排列，那第 $\frac n 2+1$ 个数据就是中位数；如果数据的个数是偶数的话，那处于中间位置的数据有两个，第 $\frac n 2$ 个和第 $\frac n 2 +1$ 个数据，这个时候，可以随意取一个作为中位数，比如取两个数中靠前的那个，就是第 $\frac n2$ 个数据。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/a8cd8830-ddb2-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>对于一组<strong>静态数据</strong>，中位数是固定的，可以先排序，第 $\frac n2$ 个数据就是中位数。每次询问中位数的时候，直接返回这个固定的值就好了。所以，尽管排序的代价比较大，但是边际成本会很小。但是，如果面对的是<strong>动态数据</strong>集合，中位数在不停地变动，如果再用先排序的方法，每次询问中位数的时候，都要先进行排序，那效率就不高了。</p><p><strong>借助堆这种数据结构，不用排序，就可以非常高效地实现求中位数操作。它是如何做到的？</strong></p><p>需要维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。</p><p>也就是说，如果有 $n$ 个数据，$n$ 是偶数，从小到大排序，那前 $\frac n 2$ 个数据存储在大顶堆中，后 $\frac n 2$ 个数据存储在小顶堆中。这样，大顶堆中的堆顶元素就是要找的中位数。如果 $n$ 是奇数，情况是类似的，大顶堆就存储 $\frac n 2+1$ 个数据，小顶堆中就存储 $\frac n 2$ 个数据。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/b31473d0-ddb2-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>数据是动态变化的，当新添加一个数据的时候，如何调整两个堆，让大顶堆中的堆顶元素继续是中位数呢？</p><p>如果新加入的数据小于等于大顶堆的堆顶元素，就将这个新数据插入到大顶堆；否则，就将这个新数据插入到小顶堆。</p><p>这个时候就有可能出现，两个堆中的数据个数不符合前面约定的情况：如果 $n$ 是偶数，两个堆中的数据个数都是 $\frac n2$；如果 $n$ 是奇数，大顶堆有 $\frac n2 +1$ 个数据，小顶堆有 $\frac n2$ 个数据。这个时候，可以从一个堆中不停地将堆顶元素移动到另一个堆，通过这样的调整，来让两个堆中的数据满足上面的约定。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/b7784320-ddb2-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>于是，就可以利用两个堆，一个大顶堆、一个小顶堆，实现在动态数据集合中求中位数的操作。插入数据因为需要涉及堆化，所以时间复杂度变成了 $O(logn)$，但是求中位数只需要返回大顶堆的堆顶元素就可以了，所以时间复杂度就是 $O(1)$。</p><p>实际上，利用两个堆不仅可以快速求出中位数，还可以快速求其他百分位的数据，原理是类似的。“如何快速求接口的 <code>99%</code> 响应时间？”现在就来看下，利用两个堆如何来实现。</p><p>先解释一下，什么是“<code>99%</code> 响应时间”。</p><p>中位数的概念就是将数据从小到大排列，处于中间位置，就叫中位数，这个数据会大于等于前面 <code>50%</code> 的数据。<code>99</code> 百分位数的概念可以类比中位数，如果将一组数据从小到大排列，这个 <code>99</code> 百分位数就是大于前面 <code>99%</code> 数据的那个数据。</p><p>如果还是不太理解，再举个例子。假设有 <code>100</code> 个数据，分别是 <code>1，2，3，……，100</code>，那 <code>99</code> 百分位数就是 <code>99</code>，因为小于等于 <code>99</code> 的数占总个数的 <code>99%</code>。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/ffaa9f80-ddb2-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>再来看 <code>99%</code> 响应时间。如果有 <code>100</code> 个接口访问请求，每个接口请求的响应时间都不同，比如 <code>55</code> 毫秒、<code>100</code> 毫秒、<code>23</code> 毫秒等，把这 <code>100</code> 个接口的响应时间按照从小到大排列，排在第 <code>99</code> 的那个数据就是 <code>99%</code> 响应时间，也叫 <code>99</code> 百分位响应时间。</p><p>总结一下，如果有 <code>n</code> 个数据，将数据从小到大排列之后，<code>99</code> 百分位数大约就是第 <code>n*99%</code> 个数据，同类，<code>80</code> 百分位数大约就是第 <code>n*80%</code> 个数据。</p><p>弄懂了这些，再来看如何求 <code>99%</code> 响应时间。</p><p>维护两个堆，一个大顶堆，一个小顶堆。假设当前总数据的个数是 <code>n</code>，大顶堆中保存 <code>n*99%</code> 个数据，小顶堆中保存 <code>n*1%</code> 个数据。大顶堆堆顶的数据就是要找的 <code>99%</code> 响应时间。</p><p>每次插入一个数据的时候，要判断这个数据跟大顶堆和小顶堆堆顶数据的大小关系，然后决定插入到哪个堆中。如果这个新插入的数据比大顶堆的堆顶数据小，那就插入大顶堆；如果这个新插入的数据比小顶堆的堆顶数据大，那就插入小顶堆。</p><p>但是，为了保持大顶堆中的数据占 <code>99%</code>，小顶堆中的数据占 <code>1%</code>，在每次新插入数据之后，都要重新计算，这个时候大顶堆和小顶堆中的数据个数，是否还符合 <code>99:1</code> 这个比例。如果不符合，就将一个堆中的数据移动到另一个堆，直到满足这个比例。移动的方法类似前面求中位数的方法.</p><p>通过这样的方法，每次插入数据，可能会涉及几个数据的堆化操作，所以时间复杂度是 $O(logn)$。每次求 <code>99%</code> 响应时间的时候，直接返回大顶堆中的堆顶数据即可，时间复杂度是 $O(1)$。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>优先级队列是一种特殊的队列，优先级高的数据先出队，而不再像普通的队列那样，先进先出。实际上，堆就可以看作优先级队列，只是称谓不一样罢了。求 <code>Top K</code> 问题又可以分为针对静态数据和针对动态数据，只需要利用一个堆，就可以做到非常高效率的查询 <code>Top K</code> 的数据。求中位数实际上还有很多变形，比如求 <code>99</code> 百分位数据、<code>90</code> 百分位数据等，处理的思路都是一样的，即利用两个堆，一个大顶堆，一个小顶堆，随着数据的动态添加，动态调整两个堆中的数据，最后大顶堆的堆顶元素就是要求的数据。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>假设现在有一个包含 <code>10</code> 亿个搜索关键词的日志文件，如何快速获取到 <code>Top 10</code> 最热门的搜索关键词呢？</p><blockquote><p>处理这个问题，有很多高级的解决方法，比如使用 <code>MapReduce</code> 等。但是，如果将处理的场景限定为单机，可以使用的内存为 <code>1GB</code>。那这个问题该如何解决呢？</p><p>因为用户搜索的关键词，有很多可能都是重复的，所以首先要统计每个搜索关键词出现的频率。可以通过散列表、平衡二叉查找树或者其他一些支持快速查找、插入的数据结构，来记录关键词及其出现的次数。</p><p>假设选用散列表。就顺序扫描这 <code>10</code> 亿个搜索关键词。当扫描到某个关键词时，去散列表中查询。如果存在，就将对应的次数加一；如果不存在，就将它插入到散列表，并记录次数为 <code>1</code>。以此类推，等遍历完这 <code>10</code> 亿个搜索关键词之后，散列表中就存储了不重复的搜索关键词以及出现的次数。</p><p>然后，再根据前面讲的用堆求 <code>Top K</code> 的方法，建立一个大小为 <code>10</code> 的小顶堆，遍历散列表，依次取出每个搜索关键词及对应出现的次数，然后与堆顶的搜索关键词对比。如果出现次数比堆顶搜索关键词的次数多，那就删除堆顶的关键词，将这个出现次数更多的关键词加入到堆中。</p><p>以此类推，当遍历完整个散列表中的搜索关键词之后，堆中的搜索关键词就是出现次数最多的 <code>Top 10</code> 搜索关键词了。</p><p>不知道你发现了没有，上面的解决思路其实存在漏洞。<code>10</code> 亿的关键词还是很多的。假设 <code>10</code> 亿条搜索关键词中不重复的有 <code>1</code> 亿条，如果每个搜索关键词的平均长度是 <code>50</code> 个字节，那存储 <code>1</code> 亿个关键词起码需要 <code>5GB</code> 的内存空间，而散列表因为要避免频繁冲突，不会选择太大的装载因子，所以消耗的内存空间就更多了。而机器只有 <code>1GB</code> 的可用内存空间，所以无法一次性将所有的搜索关键词加入到内存中。这个时候该怎么办呢？</p><p>在哈希算法那一节讲过，相同数据经过哈希算法得到的哈希值是一样的。可以根据哈希算法的这个特点，将 <code>10</code> 亿条搜索关键词先通过哈希算法分片到 <code>10</code> 个文件中。</p><p>具体可以这样做：创建 <code>10</code> 个空文件 <code>00，01，02，……，09</code>。遍历这 <code>10</code> 亿个关键词，并且通过某个哈希算法对其求哈希值，然后哈希值同 <code>10</code> 取模，得到的结果就是这个搜索关键词应该被分到的文件编号。</p><p>对这 <code>10</code> 亿个关键词分片之后，每个文件都只有 <code>1</code> 亿的关键词，去除掉重复的，可能就只有 <code>1000</code> 万个，每个关键词平均 <code>50</code> 个字节，所以总的大小就是 <code>500MB</code>。<code>1GB</code> 的内存完全可以放得下。</p><p>针对每个包含 <code>1</code> 亿条搜索关键词的文件，利用散列表和堆，分别求出 <code>Top 10</code>，然后把这个 <code>10</code> 个 <code>Top 10</code> 放在一块，然后取这 <code>100</code> 个关键词中，出现次数最多的 <code>10</code> 个关键词，这就是这 <code>10</code> 亿数据中的 <code>Top 10</code> 最频繁的搜索关键词了。</p></blockquote></li><li><p>有一个访问量非常大的新闻网站，希望将点击量排名 <code>Top 10</code> 的新闻摘要，滚动显示在网站首页 <code>banner</code> 上，并且每隔 <code>1</code> 小时更新一次。如果你是负责开发这个功能的工程师，会如何来实现呢？</p><blockquote><p>大致思路是这样子，</p><ul><li>对每篇新闻摘要计算一个<code>hashcode</code>，并建立摘要与<code>hashcode</code>的关联关系，使用<code>map</code>存储，以<code>hashCode</code>为<code>key</code>，新闻摘要为值</li><li>按每小时一个文件的方式记录下被点击的摘要的<code>hashCode</code></li><li>当一个小时结果后，上一个小时的文件被关闭，开始计算上一个小时的点击<code>top10</code></li><li>将<code>hashcode</code>分片到多个文件中，通过对<code>hashCode</code>取模运算，即可将相同的<code>hashCode</code>分片到相同的文件中</li><li>针对每个文件取<code>top10</code>的<code>hashCode</code>，使用<code>Map&lt;hashCode,int&gt;</code>的方式，统计出所有的摘要点击次数，然后再使用小顶堆（大小为<code>10</code>）计算<code>top10</code>,</li><li>再针对所有分片计算一个总的<code>top10</code>,最后合并的逻辑也是使用小顶堆，计算<code>top10</code></li><li>如果仅展示前一个小时的<code>top10</code>,计算结束</li><li>如果需要展示全天，需要与上一次的计算按<code>hashCode</code>进行合并，然后在这合并的数据中取<code>top10</code></li><li>在展示时，将计算得到的<code>top10</code>的<code>hashcode</code>，转化为新闻摘要显示即可</li></ul></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>25.堆和堆排序</title>
    <link href="/passages/25/"/>
    <url>/passages/25/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>“堆”（<code>Heap</code>）这种数据结构的应用场景非常多，最经典的莫过于堆排序了。堆排序是一种原地的、时间复杂度为 $O(nlog⁡n)$ 的排序算法。</p><p>快速排序，平均情况下，它的时间复杂度为 $O(nlog⁡n)$。尽管这两种排序算法的时间复杂度都是 $O(nlog⁡n)$，甚至堆排序比快速排序的时间复杂度还要稳定，但是，在实际的软件开发中，快速排序的性能要比堆排序好，这是为什么呢？</p><h2 id="如何理解“堆”？"><a href="#如何理解“堆”？" class="headerlink" title="如何理解“堆”？"></a>如何理解“堆”？</h2><p>堆是一种特殊的树。什么样的树才是堆? 只要满足这两点，它就是一个堆:</p><ul><li>堆是一个完全二叉树；</li><li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</li></ul><p>第一点，堆必须是一个完全二叉树。完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</p><p>第二点，堆中的每个节点的值必须大于等于（或者小于等于）其子树中每个节点的值。换一种说法，堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。这两种表述是等价的。</p><p>对于每个节点的值都大于等于子树中每个节点值的堆，我们叫作“大顶堆”。对于每个节点的值都小于等于子树中每个节点值的堆，我们叫作“小顶堆”。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/6098fe60-ddb1-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>其中第 <code>1</code> 个和第 <code>2</code> 个是大顶堆，第 <code>3</code> 个是小顶堆，第 <code>4</code> 个不是堆。除此之外，从图中还可以看出来，对于同一组数据，可以构建多种不同形态的堆。</p><h2 id="如何实现一个堆？"><a href="#如何实现一个堆？" class="headerlink" title="如何实现一个堆？"></a>如何实现一个堆？</h2><p>要实现一个堆，先要知道，<strong>堆都支持哪些操作</strong>以及<strong>如何存储一个堆</strong>。</p><p>完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/79230980-ddb1-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>从图中可以看到，数组中下标为 $i$ 的节点的左子节点，就是下标为 $i∗2$ 的节点，右子节点就是下标为 $i∗2+1$ 的节点，父节点就是下标为 $\frac i 2$ 的节点。</p><p><strong>1. 往堆中插入一个元素</strong></p><p>往堆中插入一个元素后，需要继续满足堆的两个特性。</p><p>如果把新插入的元素放到堆的最后，可以看下面的这个图，是不是不符合堆的特性了？于是，就需要进行调整，让其重新满足堆的特性，这个过程我们起了一个名字，就叫作堆化（<code>heapify</code>）。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/95dd02b0-ddb1-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>堆化实际上有两种，从下往上和从上往下。这里先谈谈从下往上的堆化方法。</p><p>堆化非常简单，就是顺着节点所在的路径，向上或者向下，对比，然后交换。</p><p>这里有一张堆化的过程分解图。让新插入的节点与父节点对比大小。如果不满足子节点小于等于父节点的大小关系，我们就互换两个节点。一直重复这个过程，直到父子节点之间满足刚说的那种大小关系。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/9c04c920-ddb1-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Heap</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] a; <span class="hljs-comment">// 数组，从下标 1 开始存储数据</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;  <span class="hljs-comment">// 堆可以存储的最大数据个数</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count; <span class="hljs-comment">// 堆中已经存储的数据个数</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Heap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;    a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[capacity + <span class="hljs-number">1</span>];    n = capacity;    count = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;    <span class="hljs-keyword">if</span> (count &gt;= n) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 堆满了</span>    ++count;    a[count] = data;    <span class="hljs-keyword">int</span> i = count;    <span class="hljs-keyword">while</span> (i/<span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span> &amp;&amp; a[i] &gt; a[i/<span class="hljs-number">2</span>]) &#123; <span class="hljs-comment">// 自下往上堆化</span>      swap(a, i, i/<span class="hljs-number">2</span>); <span class="hljs-comment">// swap() 函数作用：交换下标为 i 和 i/2 的两个元素</span>      i = i/<span class="hljs-number">2</span>;    &#125;  &#125; &#125;</code></pre><p><strong>2. 删除堆顶元素</strong></p><p>从堆的定义的第二条中，任何节点的值都大于等于（或小于等于）子树节点的值，可以发现，堆顶元素存储的就是堆中数据的最大值或者最小值。</p><p>假设构造的是大顶堆，堆顶元素就是最大的元素。当删除堆顶元素之后，就需要把第二大的元素放到堆顶，那第二大元素肯定会出现在左右子节点中。然后再迭代地删除第二大节点，以此类推，直到叶子节点被删除。</p><p>这里有一个分解图。不过这种方法有点问题，就是最后堆化出来的堆并不满足完全二叉树的特性。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/aa873b90-ddb1-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>实际上，稍微改变一下思路，就可以解决这个问题。你看下面这幅图。把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。这就是<strong>从上往下的堆化方法</strong>。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/addc5a00-ddb1-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>因为移除的是数组中的最后一个元素，而在堆化的过程中，都是交换操作，不会出现数组中的“空洞”，所以这种方法堆化之后的结果，肯定满足完全二叉树的特性。</p><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeMax</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 堆中没有数据</span>  a[<span class="hljs-number">1</span>] = a[count];  --count;  heapify(a, count, <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> i)</span> </span>&#123; <span class="hljs-comment">// 自上往下堆化</span>  <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;    <span class="hljs-keyword">int</span> maxPos = i;    <span class="hljs-keyword">if</span> (i*<span class="hljs-number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="hljs-number">2</span>]) maxPos = i*<span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span> (i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]) maxPos = i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (maxPos == i) <span class="hljs-keyword">break</span>;    swap(a, i, maxPos);    i = maxPos;  &#125;&#125;</code></pre><p>我们知道，一个包含 $n$ 个节点的完全二叉树，树的高度不会超过 $log_2⁡n$。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 $O(log⁡n)$。插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 $O(log⁡n)$。</p><h2 id="如何基于堆实现排序？"><a href="#如何基于堆实现排序？" class="headerlink" title="如何基于堆实现排序？"></a>如何基于堆实现排序？</h2><p>前面文章讲过好几种排序算法，回忆一下，有时间复杂度是 $O(n^2)$ 的冒泡排序、插入排序、选择排序，有时间复杂度是 $O(nlog⁡n)$ 的归并排序、快速排序，还有线性排序。</p><p>这里借助于堆这种数据结构实现的排序算法，就叫作堆排序。这种排序方法的时间复杂度非常稳定，是 $O(nlog⁡n)$，并且它还是原地排序算法。如此优秀，它是怎么做到的呢？</p><p>我们可以把堆排序的过程大致分解成两个大的步骤，<strong>建堆</strong>和<strong>排序</strong>。</p><p><strong>1. 建堆</strong></p><p>首先将数组原地建成一个堆。所谓“原地”就是，不借助另一个数组，就在原数组上操作。建堆的过程，有两种思路。</p><p>第一种是借助我们前面讲的，在堆中插入一个元素的思路。尽管数组中包含 $n$ 个数据，但是我们可以假设，起初堆中只包含一个数据，就是下标为 $1$ 的数据。然后，我们调用前面讲的插入操作，将下标从 $2$ 到 $n$ 的数据依次插入到堆中。这样我们就将包含 $n$ 个数据的数组，组织成了堆。</p><p>第二种实现思路，跟第一种截然相反，也是这里要详细讲的。第一种建堆思路的处理过程是从前往后处理数组数据，并且每个数据插入堆中时，都是从下往上堆化。而第二种实现思路，是从后往前处理数组，并且每个数据都是从上往下堆化。</p><p>下图画了一个第二种实现思路的建堆分解步骤图。因为叶子节点往下堆化只能自己跟自己比较，所以直接从第一个非叶子节点开始，依次堆化就行了。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/c71087d0-ddb1-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png">)<img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/cdd9e570-ddb1-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>对于程序员来说，看代码可能更好理解一些，代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n/<span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; --i) &#123;    heapify(a, n, i);  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> i)</span> </span>&#123;  <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;    <span class="hljs-keyword">int</span> maxPos = i;    <span class="hljs-keyword">if</span> (i*<span class="hljs-number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="hljs-number">2</span>]) maxPos = i*<span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span> (i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]) maxPos = i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (maxPos == i) <span class="hljs-keyword">break</span>;    swap(a, i, maxPos);    i = maxPos;  &#125;&#125;</code></pre><p>在这段代码中，对下标从 $\frac n 2$ 开始到 $1$ 的数据进行堆化，下标是 $\frac n 2 +1$ 到 $n$ 的节点是叶子节点，我们不需要堆化。实际上，对于完全二叉树来说，下标从 $\frac n 2 +1$ 到 $n$ 的节点都是叶子节点。</p><p>建堆操作的时间复杂度是多少呢？</p><p>每个节点堆化的时间复杂度是 $O(log⁡n)$，那 $\frac n 2+1$ 个节点堆化的总时间复杂度是不是就是 $O(nlog⁡n)$ 呢？这个答案虽然也没错，但是这个值还是不够精确。实际上，堆排序的建堆过程的时间复杂度是 $O(n)$。</p><p>因为叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度 $k$ 成正比。</p><p>只需要将每个节点的高度求和，得出的就是建堆的时间复杂度。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/d9e82390-ddb1-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>将每个非叶子节点的高度求和，就是下面这个公式：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/dd6144c0-ddb1-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>这个公式的求解稍微有点技巧，不过高中应该都学过：把公式左右都乘以 $2$，就得到另一个公式 $S2$。我们将 $S2$ 错位对齐，并且用 $S2$ 减去 $S1$，可以得到 $S$。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/e09323c0-ddb1-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>$S$ 的中间部分是一个等比数列，所以最后可以用等比数列的求和公式来计算，最终的结果就是下面图中画的这个样子。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/e3b59970-ddb1-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>因为 $h=log_2⁡n$，代入公式 $S$，就能得到 $S=O(n)$，所以，建堆的时间复杂度就是 $O(n)$。</p><p><strong>2. 排序</strong></p><p>建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。把它跟最后一个元素交换，那最大元素就放到了下标为 $n$ 的位置。</p><p>这个过程有点类似上面的“删除堆顶元素”的操作，当堆顶元素移除之后，把下标为 $n$ 的元素放到堆顶，然后再通过堆化的方法，将剩下的 $n−1$ 个元素重新构建成堆。堆化完成之后，再取堆顶的元素，放到下标是 $n−1$ 的位置，一直重复这个过程，直到最后堆中只剩下标为 $1$ 的一个元素，排序工作就完成了。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/edeb6e10-ddb1-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>代码如下：</p><pre><code class="hljs java"><span class="hljs-comment">// n 表示数据的个数，数组 a 中的数据从下标 1 到 n 的位置。</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n)</span> </span>&#123;  buildHeap(a, n);  <span class="hljs-keyword">int</span> k = n;  <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">1</span>) &#123;    swap(a, <span class="hljs-number">1</span>, k);    --k;    heapify(a, k, <span class="hljs-number">1</span>);  &#125;&#125;</code></pre><p>现在分析一下堆排序的时间复杂度、空间复杂度以及稳定性。</p><p>整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 $O(n)$，排序过程的时间复杂度是 $O(nlog⁡n)$，所以，堆排序整体的时间复杂度是 $O(nlog⁡n)$。</p><p>堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。</p><p>这里要稍微解释一下，在前面的讲述以及代码中，都假设，堆中的数据是从数组下标为 $1$ 的位置开始存储。那如果从 $0$ 开始存储，实际上处理思路是没有任何变化的，唯一变化的，可能就是，代码实现的时候，计算子节点和父节点的下标的公式改变了。</p><p>如果节点的下标是 $i$，那左子节点的下标就是 $2∗i+1$，右子节点的下标就是 $2∗i+2$，父节点的下标就是 $\frac {i−1}{2}$。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>堆是一种完全二叉树。它最大的特性是：每个节点的值都大于等于（或小于等于）其子树节点的值。因此，堆被分成了两类，大顶堆和小顶堆。</p><p>堆中比较重要的两个操作是插入一个数据和删除堆顶元素。这两个操作都要用到堆化。插入一个数据的时候，我们把新插入的数据放到数组的最后，然后从下往上堆化；删除堆顶数据的时候，我们把数组中的最后一个元素放到堆顶，然后从上往下堆化。这两个操作时间复杂度都是 $O(log⁡n)$。</p><p>除此之外，还有堆排序。堆排序包含两个过程，<strong>建堆和排序</strong>。将下标从 $\frac n 2$ 到 $1$ 的节点，依次进行从上到下的堆化操作，然后就可以将数组中的数据组织成堆这种数据结构。接下来，迭代地将堆顶的元素放到堆的末尾，并将堆的大小减一，然后再堆化，重复这个过程，直到堆中只剩下一个元素，整个数组中的数据就都有序排列了。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>在实际开发中，为什么快速排序要比堆排序性能好？</p><blockquote><p>主要有两方面的原因:</p><p><strong>第一点，堆排序数据访问的方式没有快速排序友好。</strong><br>对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。<br>比如，堆排序中，最重要的一个操作就是数据的堆化。比如下面这个例子，对堆顶节点进行堆化，会依次访问数组下标是 $1，2，4，8$ 的元素，而不是像快速排序那样，局部顺序访问，所以，这样对 <code>CPU</code> 缓存是不友好的。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/02d12950-ddb2-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br><strong>第二点，对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。</strong><br>在写排序的时候，提过两个概念，<strong>有序度</strong>和<strong>逆序度</strong>。对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，比较和交换（或移动）。快速排序数据交换的次数不会比逆序度多。</p><p>但是堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/0a9d7800-ddb2-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>对于第二点，可以自己做个试验看下。用一个记录交换次数的变量，在代码中，每次交换的时候，就对这个变量加一，排序完成之后，这个变量的值就是总的数据交换次数。这样就能很直观地理解刚刚说的，堆排序比快速排序交换次数多。</p></blockquote></li><li><p>对于完全二叉树来说，下标从 $\frac n 2 +1$ 到 $n$ 的都是叶子节点，这个结论是怎么推导出来的呢？</p><blockquote><p>使用数组存储表示完全二叉树时，从数组下标为$1$开始存储数据，数组下标为$i$的节点，左子节点为$2i$, 右子节点为$2i + 1$. 这个结论很重要（可以用数学归纳法证明)，将此结论记为『原理1』，以下证明会用到这个原理。</p><p>为什么，对于完全二叉树来说，下标从 $\frac n 2 +1$ 到 $n$ 的节点都是叶子节点？ 使用反证法证明即可：</p><p>如果下标为$\frac n 2 +1$的节点不是叶子节点，即它存在子节点，按照『原理1』，它的左子节点为：$2(\frac n 2 +1) = n + 2$，明显可以看出，这个数字已经大于$n + 1$，超出了实现完全二叉树所用数组的大小（数组下标从$1$开始记录数据，对于$n$个节点来说，数组大小是$n + 1$），左子节点都已经超出了数组容量，更何况右子节点。以此类推，很容易得出：下标大于$\frac n 2 +1$的节点肯定都是也叶子节点了，故而得出结论：对于完全二叉树来说，下标从 $\frac n 2 +1$ 到 $n$ 的节点都是叶子节点</p></blockquote></li><li><p>堆的一种经典应用是堆排序。关于堆，你还能想到它的其他应用吗？</p><blockquote><p>堆的应用除了堆排以外，还有如下一些应用：</p><ul><li>从大数量级数据中筛选出$top n$ 条数据； 比如：从几十亿条订单日志中筛选出金额靠前的<code>1000</code>条数据</li><li>在一些场景中，会根据不同优先级来处理网络请求，此时也可以用到优先队列(用堆实现的数据结构)；比如：网络框架<code>Volley</code>就用了<code>Java</code>中<code>PriorityBlockingQueue</code>，当然它是线程安全的</li><li>可以用堆来实现多路归并，从而实现有序，<code>leetcode</code>上也有相关的一题：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">Merge K Sorted Lists</a></li></ul></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>时间复杂度</tag>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24.递归树</title>
    <link href="/passages/24/"/>
    <url>/passages/24/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>除了用递推公式这种比较复杂的分析方法，有没有更简单的方法呢？下面就来学习另外一种方法，<strong>借助递归树来分析递归算法的时间复杂度</strong>。</p><h2 id="递归树与时间复杂度分析"><a href="#递归树与时间复杂度分析" class="headerlink" title="递归树与时间复杂度分析"></a>递归树与时间复杂度分析</h2><p>递归的思想就是，将大问题分解为小问题来求解，然后再将小问题分解为小小问题。这样一层一层地分解，直到问题的数据规模被分解得足够小，不用继续递归分解为止。</p><p>如果把这个一层一层的分解过程画成图，它其实就是一棵树。给这棵树起一个名字，叫作<strong>递归树</strong>。<br>这里画了一棵斐波那契数列的递归树。节点里的数字表示数据的规模，一个节点的求解可以分解为左右子节点两个问题的求解。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/346dbb60-ddb0-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>现在，就来看看，<strong>如何用递归树来求解时间复杂度</strong>。</p><p>归并排序算法的递归实现代码非常简洁。现在就借助归并排序来看看，如何用递归树，来分析递归代码的时间复杂度。</p><p>归并排序每次会将数据规模一分为二。把归并排序画成递归树，就是下面这个样子：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/3a3e8830-ddb0-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>因为每次分解都是一分为二，所以代价很低，所以把时间上的消耗记作常量 $1$。归并算法中比较耗时的是归并操作，也就是把两个子数组合并为大数组。从图中可以看出，每一层归并操作消耗的时间总和是一样的，跟要排序的数据规模有关。把每一层归并操作消耗的时间记作 $n$。</p><p>现在，只需要知道这棵树的高度 $h$，用高度 $h$ 乘以每一层的时间消耗 $n$，就可以得到总的时间复杂度 $O(n∗h)$。</p><p>从归并排序的原理和递归树，可以看出来，归并排序递归树是一棵满二叉树。满二叉树的高度大约是 $log_2⁡n$，所以，归并排序递归实现的时间复杂度就是 $O(nlog⁡n)$。这里的时间复杂度都是估算的，对树的高度的计算也没有那么精确，但是这并不影响复杂度的计算结果。</p><h2 id="实战一：分析快速排序的时间复杂度"><a href="#实战一：分析快速排序的时间复杂度" class="headerlink" title="实战一：分析快速排序的时间复杂度"></a>实战一：分析快速排序的时间复杂度</h2><p>为什么说用递推公式来求解平均时间复杂度非常复杂？</p><p>快速排序在最好情况下，每次分区都能一分为二，这个时候用递推公式 $T(n)=2T(\frac n 2)+n$，很容易就能推导出时间复杂度是 $O(nlog⁡n)$。但是，并不可能每次分区都这么幸运，正好一分为二。</p><p>假设平均情况下，每次分区之后，两个分区的大小比例为 $1:k$。当 $k=9$ 时，如果用递推公式的方法来求解时间复杂度的话，递推公式就写成 $T(n)=T(\frac {n}{10})+T(\frac {9n}{10})+n$。</p><p>这个公式可以推导出时间复杂度，但是推导过程非常复杂。那如果<strong>用递归树来分析快速排序的平均情况时间复杂度，是不是比较简单呢</strong>？</p><p>还是取 $k$ 等于 <code>9</code>，也就是说，每次分区都很不平均，一个分区是另一个分区的 <code>9</code> 倍。如果把递归分解的过程画成递归树，就是下面这个样子：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/57ca7760-ddb0-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>快速排序的过程中，每次分区都要遍历待分区区间的所有数据，所以，每一层分区操作所遍历的数据的个数之和就是 $n$。现在只要求出递归树的高度 $h$，这个快排过程遍历的数据个数就是 $h∗n$ ，也就是说，时间复杂度就是 $O(h ∗ n)$。</p><p>因为每次分区并不是均匀地一分为二，所以递归树并不是满二叉树。这样一个递归树的高度是多少呢？</p><p>快速排序结束的条件就是待排序的小区间，大小为 $1$，也就是说叶子节点里的数据规模是 $1$。从根节点 $n$ 到叶子节点 $1$，递归树中最短的一个路径每次都乘以 $\frac{1}{10}$，最长的一个路径每次都乘以 $\frac{9}{10}$。通过计算，可以得到，从根节点到叶子节点的最短路径是 $log_{10}⁡n$，最长的路径是 $log$$\frac{10}{9}$⁡$n$。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/692a8e50-ddb0-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"></p><p>所以，遍历数据的个数总和就介于 $nlog_{10}n$ 和 $nlog_\frac{10}{9}⁡n$ 之间。根据复杂度的大 $O$ 表示法，对数复杂度的底数不管是多少，统一写成 $log⁡n$，所以，当分区大小比例是 $1:9$ 时，快速排序的时间复杂度仍然是 $O(nlog⁡n)$。</p><p>刚刚假设 $k=9$，那如果 $k=99$，也就是说，每次分区极其不平均，两个区间大小是 $1:99$，这个时候的时间复杂度是多少呢？</p><p>可以类比上面 $k=9$ 的分析过程。当 $k=99$ 的时候，树的最短路径就是 $log_{100}n$，最长路径是 $log_\frac{100}{99}⁡n$，所以总遍历数据个数介于 $nlog_{100}n$ 和 $nlog_\frac{100}{99}n$ 之间。尽管底数变了，但是时间复杂度也仍然是 $O(nlog⁡n)$。</p><p>也就是说，对于 $k$ 等于 $99$，$9999$，甚至是 $999999$，$99999999$……，只要 $k$ 的值不随 $n$ 变化，是一个事先确定的常量，那快排的时间复杂度就是 $O(nlogn)$。所以，从概率论的角度来说，快排的平均时间复杂度就是 $O(nlog⁡n)$。</p><h2 id="实战二：分析斐波那契数列的时间复杂度"><a href="#实战二：分析斐波那契数列的时间复杂度" class="headerlink" title="实战二：分析斐波那契数列的时间复杂度"></a>实战二：分析斐波那契数列的时间复杂度</h2><p>为了方便回忆，我把它的代码实现贴在这里:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;  <span class="hljs-keyword">return</span> f(n-<span class="hljs-number">1</span>) + f(n-<span class="hljs-number">2</span>);&#125;</code></pre><p>先把上面的递归代码画成递归树，就是下面这个样子：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/80b44070-ddb0-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>这棵递归树的高度是多少呢？</p><p>$f(n)$  分解为 $f(n−1)$ 和 $f(n−2)$，每次数据规模都是 <code>−1</code> 或者 <code>−2</code>，叶子节点的数据规模是 <code>1</code> 或者 <code>2</code>。所以，从根节点走到叶子节点，每条路径是长短不一的。如果每次都是 <code>−1</code>，那最长路径大约就是 <code>n</code>；如果每次都是 <code>−2</code>，那最短路径大约就是 $\frac n 2$。</p><p>每次分解之后的合并操作只需要一次加法运算，把这次加法运算的时间消耗记作 <code>1</code>。所以，从上往下，第一层的总时间消耗是 <code>1</code>，第二层的总时间消耗是 <code>2</code>，第三层的总时间消耗就是 $2^2$。依次类推，第 $k$ 层的时间消耗就是 $2^{k-1}$，那整个算法的总的时间消耗就是每一层时间消耗之和。</p><p>如果路径长度都为 $n$，那这个总和就是 $2^n-1$。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/a3eece70-ddb0-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>如果路径长度都是$\frac n 2$ ，那整个算法的总的时间消耗就是 $2^{\frac n 2}$$−1$。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/a70cb040-ddb0-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>所以，这个算法的时间复杂度就介于 $O(2^n)$ 和 $O(2^{\frac n 2})$ 之间。虽然这样得到的结果还不够精确，只是一个范围，但是也基本上知道了上面算法的时间复杂度是指数级的，非常高。</p><h2 id="实战三：分析全排列的时间复杂度"><a href="#实战三：分析全排列的时间复杂度" class="headerlink" title="实战三：分析全排列的时间复杂度"></a>实战三：分析全排列的时间复杂度</h2><p>在高中的时候都学过排列组合。“如何把 $n$ 个数据的所有排列都找出来”，这就是全排列的问题。</p><p>如何编程打印一组数据的所有排列呢？这里就可以用递归来实现。</p><p>如果确定了最后一位数据，那就变成了求解剩下 $n−1$ 个数据的排列问题。而最后一位数据可以是 $n$ 个数据中的任意一个，因此它的取值就有 $n$ 种情况。所以，“$n$ 个数据的排列”问题，就可以分解成 $n$ 个“$n−1$ 个数据的排列”的子问题。</p><p>如果把它写成递推公式，就是下面这个样子：</p><pre><code class="hljs plain">假设数组中存储的是 1，2， 3...n。        f(1,2,...n) &#x3D; &#123;最后一位是 1, f(n-1)&#125; + &#123;最后一位是 2, f(n-1)&#125; +...+&#123;最后一位是 n, f(n-1)&#125;。</code></pre><p>如果把递推公式改写成代码，就是下面这个样子：</p><pre><code class="hljs java"><span class="hljs-comment">// 调用方式：</span><span class="hljs-comment">// int[]a = a=&#123;1, 2, 3, 4&#125;; printPermutations(a, 4, 4);</span><span class="hljs-comment">// k 表示要处理的子数组的数据个数</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printPermutations</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] data, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;  <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;      System.out.print(data[i] + <span class="hljs-string">" "</span>);    &#125;    System.out.println();  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;    <span class="hljs-keyword">int</span> tmp = data[i];    data[i] = data[k-<span class="hljs-number">1</span>];    data[k-<span class="hljs-number">1</span>] = tmp;    printPermutations(data, n, k - <span class="hljs-number">1</span>);    tmp = data[i];    data[i] = data[k-<span class="hljs-number">1</span>];    data[k-<span class="hljs-number">1</span>] = tmp;  &#125;&#125;</code></pre><p>如何借助递归树，分析出这个代码的时间复杂度。<br>首先，还是画出递归树。不过，现在的递归树已经不是标准的二叉树了。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/c1f062d0-ddb0-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>第一层分解有 $n$ 次交换操作，第二层有 $n$ 个节点，每个节点分解需要 $n−1$ 次交换，所以第二层总的交换次数是 $n∗(n−1)$。第三层有 $n∗(n−1)$ 个节点，每个节点分解需要 $n−2$ 次交换，所以第三层总的交换次数是 $n∗(n−1)∗(n−2)$。</p><p>以此类推，第 kk 层总的交换次数就是 $n∗(n−1)∗(n−2)∗…∗(n−k+1)$。最后一层的交换次数就是 $n∗(n−1)∗(n−2)∗…∗2∗1$。每一层的交换次数之和就是总的交换次数。</p><pre><code class="hljs plain">n + n*(n-1) + n*(n-1)*(n-2) +... + n*(n-1)*(n-2)*...*2*1</code></pre><p>这个公式的求和比较复杂，看最后一个数，$n∗(n−1)∗(n−2)∗…∗2∗1$ 等于 $n!$，而前面的 $n−1$ 个数都小于最后一个数，所以，总和肯定小于 $n∗n!$，也就是说，全排列的递归算法的时间复杂度大于 $O(n!)$，小于 $O(n∗n!)$，虽然没法知道非常精确的时间复杂度，但是这样一个范围已经让我们知道，全排列的时间复杂度是非常高的。</p><p><strong>掌握分析的方法很重要，思路是重点，不要纠结于精确的时间复杂度到底是多少。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有些代码比较适合用递推公式来分析，比如归并排序的时间复杂度、快速排序的最好情况时间复杂度；有些比较适合采用递归树来分析，比如快速排序的平均时间复杂度。而有些可能两个都不怎么适合使用，比如二叉树的递归前中后序遍历。</p><p>时间复杂度分析的理论知识并不多，也不复杂，掌握起来也不难，但是，在平时的工作、学习中，面对的代码千差万别，能够灵活应用学到的复杂度分析方法，来分析现有的代码，并不是件简单的事情，所以，平时要多实战、多分析，只有这样，面对任何代码的时间复杂度分析，才能做到游刃有余、毫不畏惧。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><code>1</code>个细胞的生命周期是 <code>3</code> 小时，<code>1</code> 小时分裂一次。求 <code>n</code> 小时后，容器内有多少细胞？请用递归时间复杂度的分析方法，分析一下这个递归问题的时间复杂度。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>递归树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>23.红黑树（下）</title>
    <link href="/passages/23/"/>
    <url>/passages/23/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>红黑树是一个让人又爱又恨的数据结构，“爱”是因为它稳定、高效的性能，“恨”是因为实现起来实在太难了。下面的红黑树的实现，理解起来可能会有些困难。但是，我觉得没必要去死磕它。</p><p>因为，即便你将左右旋背得滚瓜烂熟，保证你过不几天就忘光了。因为，学习红黑树的代码实现，对于你平时做项目开发没有太大帮助。对于绝大部分开发工程师来说，这辈子你可能都用不着亲手写一个红黑树。除此之外，它对于算法面试也几乎没什么用，一般情况下，靠谱的面试官也不会让你手写红黑树的。</p><p>如果你对数据结构和算法很感兴趣，想要开拓眼界、训练思维，还是很推荐你看一看这篇的内容。但是如果学完今天的内容你还觉得懵懵懂懂的话，也不要纠结。要有的放矢去学习。你先把平时要用的、基础的东西都搞会了，如果有余力了，再来深入地研究这节内容。</p><p><font color='green'>上一篇讲到红黑树定义的时候，提到红黑树的叶子节点都是黑色的空节点。当时只是粗略地解释了，这是为了代码实现方便，那更加确切的原因是什么呢？</font></p><h2 id="实现红黑树的基本思想"><a href="#实现红黑树的基本思想" class="headerlink" title="实现红黑树的基本思想"></a>实现红黑树的基本思想</h2><p>实际上，红黑树的平衡过程跟魔方复原非常神似，大致过程就是：<strong>遇到什么样的节点排布，就对应怎么去调整</strong>。只要按照这些固定的调整规则来操作，就能将一个非平衡的红黑树调整成平衡的。</p><p>还记得红黑树的定义吗？回顾一下。一棵合格的红黑树需要满足这样几个要求：</p><ul><li>根节点是黑色的；</li><li>每个叶子节点都是黑色的空节点（<code>NIL</code>），也就是说，叶子节点不存储数据；</li><li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；</li><li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点。</li></ul><p>在插入、删除节点的过程中，第三、第四点要求可能会被破坏，而“平衡调整”，实际上就是要把被破坏的第三、第四点恢复过来。<br>有两个非常重要的操作，<strong>左旋</strong>（<code>rotate left</code>）、<strong>右旋</strong>（<code>rotate right</code>）。左旋全称其实是叫<strong>围绕某个节点的左旋</strong>，那右旋的就叫<strong>围绕某个节点的右旋</strong>。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/d6d78f90-ddae-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>红黑树的插入、删除操作会破坏红黑树的定义，具体来说就是会破坏红黑树的平衡，所以，现在就来看下，红黑树在插入、删除数据之后，如何调整平衡，继续当一棵合格的红黑树的。</p><h2 id="插入操作的平衡调整"><a href="#插入操作的平衡调整" class="headerlink" title="插入操作的平衡调整"></a>插入操作的平衡调整</h2><p>红黑树规定，<strong>插入的节点必须是红色的</strong>。而且，<strong>二叉查找树中新插入的节点都是放在叶子节点上</strong>。所以，关于插入操作的平衡调整，有这样两种特殊情况:</p><ul><li><p>如果插入节点的父节点是黑色的，那就什么都不用做，它仍然满足红黑树的定义。</p></li><li><p>如果插入的节点是根节点，那就直接改变它的颜色，把它变成黑色就可以了。</p></li></ul><p>除此之外，其他情况都会违背红黑树的定义，于是就需要进行调整，调整的过程包含两种基础的操作：<strong>左右旋转</strong>和<strong>改变颜色</strong>。</p><p>红黑树的平衡调整过程是一个迭代的过程。把正在处理的节点叫作<strong>关注节点</strong>。关注节点会随着不停地迭代处理，而不断发生变化。最开始的关注节点就是新插入的节点。</p><p>新节点插入之后，如果红黑树的平衡被打破，那一般会有下面三种情况:</p><p><strong>CASE 1：如果关注节点是 <code>a</code>，它的叔叔节点 <code>d</code> 是红色</strong>，就依次执行下面的操作：</p><ul><li>将关注节点 <code>a</code> 的父节点 <code>b</code>、叔叔节点 <code>d</code> 的颜色都设置成黑色；</li><li>将关注节点 <code>a</code> 的祖父节点 <code>c</code> 的颜色设置成红色；</li><li>关注节点变成 <code>a</code> 的祖父节点 <code>c</code>；</li><li>跳到 <code>CASE 2</code> 或者 <code>CASE 3</code>。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/04379e80-ddaf-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"></li></ul><p><strong>CASE 2：如果关注节点是 <code>a</code>，它的叔叔节点 <code>d</code> 是黑色，关注节点 <code>a</code> 是其父节点 <code>b</code> 的右子节点</strong>，就依次执行下面的操作：</p><ul><li>关注节点变成节点 <code>a</code> 的父节点 <code>b</code>；</li><li>围绕新的关注节点 <code>b</code> 左旋；</li><li>跳到 <code>CASE 3</code>。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/0756b8d0-ddaf-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"></li></ul><p><strong>CASE 3：如果关注节点是 <code>a</code>，它的叔叔节点 <code>d</code> 是黑色，关注节点 <code>a</code> 是其父节点 <code>b</code> 的左子节点</strong>，就依次执行下面的操作：</p><ul><li>围绕关注节点 <code>a</code> 的祖父节点 <code>c</code> 右旋；</li><li>将关注节点 <code>a</code> 的父节点 <code>b</code>、兄弟节点 <code>c</code> 的颜色互换。</li><li>调整结束。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/0afb56d0-ddaf-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"></li></ul><h2 id="删除操作的平衡调整"><a href="#删除操作的平衡调整" class="headerlink" title="删除操作的平衡调整"></a>删除操作的平衡调整</h2><p>删除操作的平衡调整分为两步，第一步是<strong>针对删除节点初步调整</strong>。初步调整只是保证整棵红黑树在一个节点删除之后，仍然满足最后一条定义的要求，也就是说，每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；第二步是<strong>针对关注节点进行二次调整</strong>，让它满足红黑树的第三条定义，即不存在相邻的两个红色节点。</p><p><strong>1. 针对删除节点初步调整</strong></p><p>这里需要注意一下，红黑树的定义中“只包含红色节点和黑色节点”，经过初步调整之后，为了保证满足红黑树定义的最后一条要求，有些节点会被标记成两种颜色，“红 - 黑”或者“黑 - 黑”。如果一个节点被标记为了“黑 - 黑”，那在计算黑色节点个数的时候，要算成两个黑色节点。</p><p><strong>CASE 1：如果要删除的节点是 <code>a</code>，它只有一个子节点 <code>b</code></strong>，那就依次进行下面的操作：</p><ul><li>删除节点 <code>a</code>，并且把节点 <code>b</code> 替换到节点 <code>a</code> 的位置，这一部分操作跟普通的二叉查找树的删除操作一样；</li><li>节点 <code>a</code> 只能是黑色，节点 <code>b</code> 也只能是红色，其他情况均不符合红黑树的定义。这种情况下，把节点 <code>b</code> 改为黑色；</li><li>调整结束，不需要进行二次调整。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/2eb41580-ddaf-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"></li></ul><p><strong>CASE 2：如果要删除的节点 <code>a</code> 有两个非空子节点，并且它的后继节点就是节点 <code>a</code> 的右子节点 <code>c</code></strong>。就依次进行下面的操作：</p><ul><li>如果节点 <code>a</code> 的后继节点就是右子节点 <code>c</code>，那右子节点 <code>c</code> 肯定没有左子树。把节点 <code>a</code> 删除，并且将节点 <code>c</code> 替换到节点 <code>a</code> 的位置。这一部分操作跟普通的二叉查找树的删除操作无异；</li><li>然后把节点 <code>c</code> 的颜色设置为跟节点 a 相同的颜色；</li><li>如果节点 <code>c</code> 是黑色，为了不违反红黑树的最后一条定义，给节点 <code>c</code> 的右子节点 <code>d</code> 多加一个黑色，这个时候节点 <code>d</code> 就成了“红 - 黑”或者“黑 - 黑”；</li><li>这个时候，关注节点变成了节点 <code>d</code>，第二步的调整操作就会针对关注节点来做。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/32812310-ddaf-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"></li></ul><p><strong>CASE 3：如果要删除的是节点 <code>a</code>，它有两个非空子节点，并且节点 <code>a</code> 的后继节点不是右子节点</strong>，就依次进行下面的操作：</p><ul><li>找到后继节点 <code>d</code>，并将它删除，删除后继节点 <code>d</code> 的过程参照 <code>CASE 1</code>；</li><li>将节点 <code>a</code> 替换成后继节点 <code>d</code>；</li><li>把节点 <code>d</code> 的颜色设置为跟节点 <code>a</code> 相同的颜色；</li><li>如果节点 <code>d</code> 是黑色，为了不违反红黑树的最后一条定义，给节点 <code>d</code> 的右子节点 <code>c</code> 多加一个黑色，这个时候节点 <code>c</code> 就成了“红 - 黑”或者“黑 - 黑”；</li><li>这个时候，关注节点变成了节点 <code>c</code>，第二步的调整操作就会针对关注节点来做。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/35ed4bf0-ddaf-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"></li></ul><p><strong>2. 针对关注节点进行二次调整</strong></p><p>经过初步调整之后，关注节点变成了“红 - 黑”或者“黑 - 黑”节点。针对这个关注节点，再分四种情况来进行二次调整。二次调整是为了让红黑树中不存在相邻的红色节点。</p><p><strong>CASE 1：如果关注节点是 <code>a</code>，它的兄弟节点 <code>c</code> 是红色的</strong>，就依次进行下面的操作：</p><ul><li>围绕关注节点 <code>a</code> 的父节点 <code>b</code> 左旋；</li><li>关注节点 <code>a</code> 的父节点 <code>b</code> 和祖父节点 <code>c</code> 交换颜色；</li><li>关注节点不变；</li><li>继续从四种情况中选择适合的规则来调整。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/3a52f000-ddaf-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"></li></ul><p><strong>CASE 2：如果关注节点是 <code>a</code>，它的兄弟节点 <code>c</code> 是黑色的，并且节点 <code>c</code> 的左右子节点 <code>d</code>、<code>e</code> 都是黑色的</strong>，就依次进行下面的操作：</p><ul><li>将关注节点 <code>a</code> 的兄弟节点 <code>c</code> 的颜色变成红色；</li><li>从关注节点 <code>a</code> 中去掉一个黑色，这个时候节点 <code>a</code> 就是单纯的红色或者黑色；</li><li>给关注节点 <code>a</code> 的父节点 <code>b</code> 添加一个黑色，这个时候节点 <code>b</code> 就变成了“红 - 黑”或者“黑 - 黑”；</li><li>关注节点从 <code>a</code> 变成其父节点 <code>b</code>；</li><li>继续从四种情况中选择符合的规则来调整。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/3f19c6e0-ddaf-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"></li></ul><p><strong>CASE 3：如果关注节点是 <code>a</code>，它的兄弟节点 <code>c</code> 是黑色，<code>c</code> 的左子节点 <code>d</code> 是红色，<code>c</code> 的右子节点 <code>e</code> 是黑色</strong>，就依次进行下面的操作：</p><ul><li>围绕关注节点 <code>a</code> 的兄弟节点 <code>c</code> 右旋；</li><li>节点 <code>c</code> 和节点 <code>d</code> 交换颜色；</li><li>关注节点不变；</li><li>跳转到 <code>CASE 4</code>，继续调整。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/428b46f0-ddaf-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"></li></ul><p><strong>CASE 4：如果关注节点 <code>a</code> 的兄弟节点 <code>c</code> 是黑色的，并且 <code>c</code> 的右子节点是红色的</strong>，就依次进行下面的操作：</p><ul><li>围绕关注节点 <code>a</code> 的父节点 <code>b</code> 左旋；</li><li>将关注节点 <code>a</code> 的兄弟节点 <code>c</code> 的颜色，跟关注节点 <code>a</code> 的父节点 <code>b</code> 设置成相同的颜色；</li><li>将关注节点 <code>a</code> 的父节点 <code>b</code> 的颜色设置为黑色；</li><li>从关注节点 <code>a</code> 中去掉一个黑色，节点 <code>a</code> 就变成了单纯的红色或者黑色；</li><li>将关注节点 <code>a</code> 的叔叔节点 <code>e</code> 设置为黑色；</li><li>调整结束。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/46d26680-ddaf-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>“红黑树一向都很难学”，有这种想法的人很多。但其实主要原因是，很多人试图去记忆它的平衡调整策略。实际上，只需要能看懂上面的过程，没有知识盲点，就算是掌握了这部分内容了。毕竟实际的软件开发并不是闭卷考试，当你真的需要实现一个红黑树的时候，可以对照着上面的步骤，一点一点去实现。</p><p>现在就来总结一下，如何比较轻松地看懂上面的操作过程。</p><p>第一点，<strong>把红黑树的平衡调整的过程比作魔方复原，不要过于深究这个算法的正确性</strong>。只需要明白，只要按照固定的操作步骤，保持插入、删除的过程，不破坏平衡树的定义就行了。</p><p>第二点，<strong>找准关注节点，不要搞丢、搞错关注节点</strong>。因为每种操作规则，都是基于关注节点来做的，只有弄对了关注节点，才能对应到正确的操作规则中。在迭代的调整过程中，关注节点在不停地改变，所以，这个过程一定要注意，不要弄丢了关注节点。</p><p>第三点，<strong>插入操作的平衡调整比较简单，但是删除操作就比较复杂</strong>。针对删除操作，有两次调整，第一次是针对要删除的节点做初步调整，让调整后的红黑树继续满足第四条定义，“每个节点到可达叶子节点的路径都包含相同个数的黑色节点”。但是这个时候，第三条定义就不满足了，有可能会存在两个红色节点相邻的情况。第二次调整就是解决这个问题，让红黑树不存在相邻的红色节点。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>为什么红黑树的定义中，要求叶子节点是黑色的空节点？</p><blockquote><p>之所以有这么奇怪的要求，其实就是为了实现起来方便。只要满足这一条要求，那在任何时刻，红黑树的平衡操作都可以归结为刚刚讲的那几种情况。</p><p>还是有点不好理解，通过一个例子来解释一下。假设红黑树的定义中不包含刚刚提到的那一条“叶子节点必须是黑色的空节点”，往一棵红黑树中插入一个数据，新插入节点的父节点也是红色的，两个红色的节点相邻，这个时候，红黑树的定义就被破坏了。那应该如何调整呢？<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/5a9ec280-ddaf-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>你会发现，这个时候，前面讲的插入时，三种情况下的平衡调整规则，没有一种是适用的。但是，如果把黑色的空节点都给它加上，变成下面这样，你会发现，它满足 <code>CASE 2</code> 了。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/5e3d1ef0-ddaf-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>你可能会说，可以调整一下平衡调整规则啊。比如把 <code>CASE 2</code> 改为“如果关注节点 <code>a</code> 的叔叔节点 <code>b</code> 是黑色或者不存在，<code>a</code> 是父节点的右子节点，就进行某某操作”。当然可以，但是这样的话规则就没有原来简洁了。</p><p>你可能还会想，这样给红黑树添加黑色的空的叶子节点，会不会比较浪费存储空间呢？答案是不会的。实际上，在具体实现的时候，只需要像下面这样，共用一个黑色的、空的叶子节点就行了。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/61c77e30-ddaf-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"></p></blockquote></li><li><p>如果你以前了解或者学习过红黑树，关于红黑树的实现，你是怎样来学习的？在学习的过程中，有过什么样的心得体会？有没有什么好的学习方法？</p></li></ul><p>欢迎留言和我分享。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>红黑树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22.红黑树（上）</title>
    <link href="/passages/22/"/>
    <url>/passages/22/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>上两篇依次讲了树、二叉树、二叉查找树。二叉查找树是最常用的一种二叉树，它支持快速插入、删除、查找操作，各个操作的时间复杂度跟树的高度成正比，理想情况下，时间复杂度是 $O(logn)$。</p><p>不过，二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于 $log_2n$ 的情况，从而导致各个操作的效率下降。极端情况下，二叉树会退化为链表，时间复杂度会退化到 $O(n)$。要解决这个复杂度退化的问题，需要设计一种平衡二叉查找树，也就是下面要讲的这种数据结构。</p><p>很多书籍里，但凡讲到平衡二叉查找树，就会拿红黑树作为例子。不仅如此，如果你有一定的开发经验，你会发现，在工程中，很多用到平衡二叉查找树的地方都会用红黑树。<font color='green'>为什么工程中都喜欢用红黑树，而不是其他平衡二叉查找树呢？</font></p><h2 id="什么是“平衡二叉查找树”？"><a href="#什么是“平衡二叉查找树”？" class="headerlink" title="什么是“平衡二叉查找树”？"></a>什么是“平衡二叉查找树”？</h2><p>平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 <code>1</code>。从这个定义来看，上一篇的完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/2490b440-ddab-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>平衡二叉查找树不仅满足上面平衡二叉树的定义，还满足二叉查找树的特点。最先被发明的平衡二叉查找树是 <code>AVL</code> 树，它严格符合刚讲到的平衡二叉查找树的定义，即任何节点的左右子树高度相差不超过 <code>1</code>，是一种高度平衡的二叉查找树。</p><p>但是很多平衡二叉查找树其实并没有严格符合上面的定义（树中任意一个节点的左右子树的高度相差不能大于 <code>1</code>），比如下面要讲的红黑树，它从根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍。</p><p>学习数据结构和算法是为了应用到实际的开发中的，所以，没必要去死抠定义。对于平衡二叉查找树这个概念，要从这个数据结构的由来，去理解“平衡”的意思。</p><p>发明平衡二叉查找树这类数据结构的初衷是，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。</p><p>所以，<strong>平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些</strong>。</p><h2 id="如何定义一棵“红黑树”？"><a href="#如何定义一棵“红黑树”？" class="headerlink" title="如何定义一棵“红黑树”？"></a>如何定义一棵“红黑树”？</h2><p>平衡二叉查找树其实有很多，比如，<code>Splay Tree</code>（伸展树）、<code>Treap</code>（树堆）等，但是提到平衡二叉查找树，听到的基本都是红黑树。它的出镜率甚至要高于“平衡二叉查找树”这几个字，有时候，甚至默认平衡二叉查找树就是红黑树，那现在就来看看这个“明星树”。</p><p>红黑树的英文是“<code>Red-Black Tree</code>”，简称 <code>R-B Tree</code>。它是一种不严格的平衡二叉查找树，前面说了，它的定义是不严格符合平衡二叉查找树的定义的。那红黑树究竟是怎么定义的呢？</p><p>顾名思义，红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：</p><ul><li><p>根节点是黑色的；</p></li><li><p>每个叶子节点都是黑色的空节点（<code>NIL</code>），也就是说，叶子节点不存储数据；</p></li><li><p>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；</p></li><li><p>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；</p></li></ul><p>这里的第二点要求“叶子节点都是黑色的空节点”，稍微有些奇怪，它主要是为了简化红黑树的代码实现而设置的。<strong>这里暂时不考虑这一点，所以，在画图和讲解的时候，将黑色的、空的叶子节点都省略掉了</strong>。</p><p>为了更好地理解上面的定义，下面有两个红黑树的图例，你可以对照着看下。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/b3cec750-ddab-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"></p><h2 id="红黑树是“近似平衡”的"><a href="#红黑树是“近似平衡”的" class="headerlink" title="红黑树是“近似平衡”的"></a>红黑树是“近似平衡”的</h2><p>平衡二叉查找树的初衷，是为了解决二叉查找树因为动态更新导致的性能退化问题。所以，<strong>“平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化的太严重。</strong></p><p>二叉查找树很多操作的性能都跟树的高度成正比。一棵极其平衡的二叉树（满二叉树或完全二叉树）的高度大约是 $log_2n$，所以如果要证明红黑树是近似平衡的，只需要分析，红黑树的高度是否比较稳定地趋近 $log_2n$ 就好了。</p><p><strong>首先，我们来看，如果将红色节点从红黑树中去掉，那单纯包含黑色节点的红黑树的高度是多少呢？</strong></p><p>红色节点删除之后，有些节点就没有父节点了，它们会直接拿这些节点的祖父节点（父节点的父节点）作为父节点。所以，之前的二叉树就变成了四叉树。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/23/55e2fa10-ddad-11e9-9c38-2bb533c1f573.png" srcset="/img/loading.gif" alt="image.png"><br>红黑树的定义里有这么一条：从任意节点到可达的叶子节点的每个路径包含相同数目的黑色节点。从四叉树中取出某些节点，放到叶节点位置，四叉树就变成了完全二叉树。所以，仅包含黑色节点的四叉树的高度，比包含相同节点个数的完全二叉树的高度还要小。</p><p>完全二叉树的高度近似 $log_2n$，这里的四叉“黑树”的高度要低于完全二叉树，所以去掉红色节点的“黑树”的高度也不会超过 $log_2n$。</p><p><strong>现在知道了只包含黑色节点的“黑树”的高度，那现在把红色节点加回去，高度会变成多少呢？</strong></p><p>从上面的红黑树的例子和定义看，在红黑树中，红色节点不能相邻，也就是说，有一个红色节点就要至少有一个黑色节点，将它跟其他红色节点隔开。红黑树中包含最多黑色节点的路径不会超过 $log_2n$，所以加入红色节点之后，最长路径不会超过 $2log_2n$，也就是说，红黑树的高度近似 $2log_2n$。</p><p>所以，红黑树的高度只比高度平衡的 <code>AVL</code> 树的高度（$log_2n$）仅仅大了一倍，在性能上，下降得并不多。这样推导出来的结果不够精确，实际上红黑树的性能更好。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>学习数据结构和算法，要学习它的由来、特性、适用的场景以及它能解决的问题。对于红黑树，也不例外。如果能搞懂这几个问题，其实就已经足够了。</strong></p><p>红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。红黑树的高度近似 $log_2n$，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是 $O(logn)$。</p><p>因为红黑树是一种性能非常稳定的二叉查找树，所以，在工程中，但凡是用到动态插入、删除、查找数据的场景，都可以用到它。不过，它实现起来比较复杂，如果自己写代码实现，难度会有些高，这个时候，其实更倾向用跳表来替代它。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>为什么在工程中大家都喜欢用红黑树这种平衡二叉查找树？</p><blockquote><p>前面提到 <code>Treap</code>、<code>Splay Tree</code>，绝大部分情况下，它们操作的效率都很高，但是也无法避免极端情况下时间复杂度的退化。尽管这种情况出现的概率不大，但是对于单次操作时间非常敏感的场景来说，它们并不适用。</p><p><code>AVL</code> 树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊，<code>AVL</code> 树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用 <code>AVL</code> 树的代价就有点高了。</p><p>红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 <code>AVL</code> 树要低。</p><p>所以，红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。</p></blockquote></li><li><p>动态数据结构支持动态地数据插入、删除、查找操作，除了红黑树，还学习过哪些呢？能对比一下各自的优势、劣势，以及应用场景吗？</p><blockquote><p>动态数据结构是支持动态的更新操作，里面存储的数据是时刻在变化的，通俗一点讲，它不仅仅支持查询，还支持删除、插入数据。而且，这些操作都非常高效。如果不高效，也就算不上是有效的动态数据结构了。所以，这里的红黑树算一个，支持动态的插入、删除、查找，而且效率都很高。链表、队列、栈实际上算不上，因为操作非常有限，查询效率不高。</p><p>散列表：插入删除查找都是$O(1)$, 是最常用的，但其缺点是不能顺序遍历以及扩容缩容的性能损耗。适用于那些不需要顺序遍历，数据更新不那么频繁的。</p><p>跳表：插入删除查找都是$O(logn)$, 并且能顺序遍历。缺点是空间复杂度$O(n)$。适用于不那么在意内存空间的，其顺序遍历和区间查找非常方便。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>红黑树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21.二叉树（下）</title>
    <link href="/passages/21/"/>
    <url>/passages/21/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>上一篇学习了树、二叉树以及二叉树的遍历，下面再来学习一种特殊的的二叉树，二叉查找树。二叉查找树最大的特点就是，支持动态数据集合的快速插入、删除、查找操作。</p><p>之前说过，散列表也是支持这些操作的，并且散列表的这些操作比二叉查找树更高效，时间复杂度是 $O(1)$。<font color='green'>既然有了这么高效的散列表，使用二叉树的地方是不是都可以替换成散列表呢？有没有哪些地方是散列表做不了，必须要用二叉树来做的呢？</font></p><h2 id="二叉查找树（Binary-Search-Tree）"><a href="#二叉查找树（Binary-Search-Tree）" class="headerlink" title="二叉查找树（Binary Search Tree）"></a>二叉查找树（Binary Search Tree）</h2><p>二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树。顾名思义，二叉查找树是为了实现快速查找而生的。不过，它不仅仅支持快速查找一个数据，还支持快速插入、删除一个数据。它是怎么做到这些的呢？</p><p>这些都依赖于二叉查找树的特殊结构。<strong>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值</strong>。下面画了几个二叉查找树的例子，你一看应该就清楚了。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/21/ba87d4f0-dc71-11e9-ae1c-9de23c38e7aa.png" srcset="/img/loading.gif" alt="image.png"><br>前面讲到，二叉查找树支持快速查找、插入、删除操作，现在就依次来看下，这三个操作是如何实现的。</p><p><strong>1. 二叉查找树的查找操作</strong><br>首先看如何在二叉查找树中查找一个节点。先取根节点，如果它等于要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/21/dedd48d0-dc71-11e9-ae1c-9de23c38e7aa.png" srcset="/img/loading.gif" alt="image.png"><br>这里把查找的代码实现了一下，贴在下面了，结合代码，理解起来会更加容易。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearchTree</span> </span>&#123;  <span class="hljs-keyword">private</span> Node tree;  <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;    Node p = tree;    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">if</span> (data &lt; p.data) p = p.left;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &gt; p.data) p = p.right;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;  &#125;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data;    <span class="hljs-keyword">private</span> Node left;    <span class="hljs-keyword">private</span> Node right;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;      <span class="hljs-keyword">this</span>.data = data;    &#125;  &#125;&#125;</code></pre><p><strong>2. 二叉查找树的插入操作</strong></p><p>二叉查找树的插入过程有点类似查找操作。新插入的数据一般都是在叶子节点上，所以只需要从根节点开始，依次比较要插入的数据和节点的大小关系。</p><p>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/21/0f1f9020-dc72-11e9-ae1c-9de23c38e7aa.png" srcset="/img/loading.gif" alt="image.png"><br>同样，插入的代码也实现了一下，贴在下面，你可以看看。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;  <span class="hljs-keyword">if</span> (tree == <span class="hljs-keyword">null</span>) &#123;    tree = <span class="hljs-keyword">new</span> Node(data);    <span class="hljs-keyword">return</span>;  &#125;  Node p = tree;  <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">if</span> (data &gt; p.data) &#123;      <span class="hljs-keyword">if</span> (p.right == <span class="hljs-keyword">null</span>) &#123;        p.right = <span class="hljs-keyword">new</span> Node(data);        <span class="hljs-keyword">return</span>;      &#125;      p = p.right;    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// data &lt; p.data</span>      <span class="hljs-keyword">if</span> (p.left == <span class="hljs-keyword">null</span>) &#123;        p.left = <span class="hljs-keyword">new</span> Node(data);        <span class="hljs-keyword">return</span>;      &#125;      p = p.left;    &#125;  &#125;&#125;</code></pre><p><strong>3. 二叉查找树的删除操作</strong></p><p>二叉查找树的查找、插入操作都比较简单易懂，但是它的删除操作就比较复杂了 。针对要删除节点的子节点个数的不同，需要分三种情况来处理。</p><p>第一种情况是，如果要删除的节点没有子节点，只需要直接将父节点中，指向要删除节点的指针置为 <code>null</code>。比如图中的删除节点 <code>55</code>。</p><p>第二种情况是，如果要删除的节点只有一个子节点（只有左子节点或者右子节点），只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点 <code>13</code>。</p><p>第三种情况是，如果要删除的节点有两个子节点，这就比较复杂了。需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，可以应用上面两条规则来删除这个最小节点。比如图中的删除节点 <code>18</code>。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/21/6ea74830-dc72-11e9-ae1c-9de23c38e7aa.png" srcset="/img/loading.gif" alt="image.png"><br>老规矩，还是把删除的代码贴在这里。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;  Node p = tree; <span class="hljs-comment">// p 指向要删除的节点，初始化指向根节点</span>  Node pp = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// pp 记录的是 p 的父节点</span>  <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; p.data != data) &#123;    pp = p;    <span class="hljs-keyword">if</span> (data &gt; p.data) p = p.right;    <span class="hljs-keyword">else</span> p = p.left;  &#125;  <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 没有找到</span>  <span class="hljs-comment">// 要删除的节点有两个子节点</span>  <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span> &amp;&amp; p.right != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 查找右子树中最小节点</span>    Node minP = p.right;    Node minPP = p; <span class="hljs-comment">// minPP 表示 minP 的父节点</span>    <span class="hljs-keyword">while</span> (minP.left != <span class="hljs-keyword">null</span>) &#123;      minPP = minP;      minP = minP.left;    &#125;    p.data = minP.data; <span class="hljs-comment">// 将 minP 的数据替换到 p 中</span>    p = minP; <span class="hljs-comment">// 下面就变成了删除 minP 了</span>    pp = minPP;  &#125;  <span class="hljs-comment">// 删除节点是叶子节点或者仅有一个子节点</span>  Node child; <span class="hljs-comment">// p 的子节点</span>  <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span>) child = p.left;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.right != <span class="hljs-keyword">null</span>) child = p.right;  <span class="hljs-keyword">else</span> child = <span class="hljs-keyword">null</span>;  <span class="hljs-keyword">if</span> (pp == <span class="hljs-keyword">null</span>) tree = child; <span class="hljs-comment">// 删除的是根节点</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pp.left == p) pp.left = child;  <span class="hljs-keyword">else</span> pp.right = child;&#125;</code></pre><p>实际上，关于二叉查找树的删除操作，还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除”，但是并不真正从树中将这个节点去掉。这样原本删除的节点还需要存储在内存中，比较浪费内存空间，但是删除操作就变得简单了很多。而且，这种处理方法也并没有增加插入、查找操作代码实现的难度。</p><p><strong>4. 二叉查找树的其他操作</strong></p><p>除了插入、删除、查找操作之外，二叉查找树中还可以支持<strong>快速地查找最大节点和最小节点、前驱节点和后继节点</strong>。这些操作就不一一展示了。</p><p>二叉查找树除了支持上面几个操作之外，还有一个重要的特性，就是<strong>中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 $O(n)$，非常高效</strong>。因此，二叉查找树也叫作二叉排序树。</p><h2 id="支持重复数据的二叉查找树"><a href="#支持重复数据的二叉查找树" class="headerlink" title="支持重复数据的二叉查找树"></a>支持重复数据的二叉查找树</h2><p>前面讲二叉查找树的时候，默认树中节点存储的都是数字。很多时候，在实际的软件开发中，在二叉查找树中存储的，是一个包含很多字段的对象。利用对象的某个字段作为键值（<code>key</code>）来构建二叉查找树。把对象中的其他字段叫作卫星数据。</p><p>前面讲的二叉查找树的操作，针对的都是不存在键值相同的情况。那如果存储的两个对象键值相同，这种情况该怎么处理呢？这里有两种解决方法。</p><p>第一种方法比较容易。二叉查找树中每一个节点不仅会存储一个数据，因此通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</p><p>第二种方法比较不好理解，不过更加优雅。</p><p>每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/21/ff8ffe00-dc72-11e9-ae1c-9de23c38e7aa.png" srcset="/img/loading.gif" alt="image.png"><br>当要查找数据的时候，遇到值相同的节点，并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/21/0d894340-dc73-11e9-ae1c-9de23c38e7aa.png" srcset="/img/loading.gif" alt="image.png"><br>对于删除操作，也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/21/173db2e0-dc73-11e9-ae1c-9de23c38e7aa.png" srcset="/img/loading.gif" alt="image.png"></p><h2 id="二叉查找树的时间复杂度分析"><a href="#二叉查找树的时间复杂度分析" class="headerlink" title="二叉查找树的时间复杂度分析"></a>二叉查找树的时间复杂度分析</h2><p>好了，对于二叉查找树常用操作的实现方式，应该掌握得差不多了。现在，来分析一下，二叉查找树的插入、删除、查找操作的时间复杂度。</p><p>实际上，二叉查找树的形态各式各样。比如这个图中，对于同一组数据，构造了三种二叉查找树。它们的查找、插入、删除操作的执行效率都是不一样的。图中第一种二叉查找树，根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 $O(n)$。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/21/34662550-dc73-11e9-ae1c-9de23c38e7aa.png" srcset="/img/loading.gif" alt="image.png"><br>刚刚其实分析了一种最糟糕的情况，现在来分析一个最理想的情况，二叉查找树是一棵完全二叉树（或满二叉树）。这个时候，插入、删除、查找的时间复杂度是多少呢？</p><p>从前面的例子、图，以及还有代码来看，不管操作是插入、删除还是查找，<strong>时间复杂度其实都跟树的高度成正比，也就是 $O(height)$</strong>。既然这样，现在问题就转变成另外一个了，也就是，如何求一棵包含 <code>n</code> 个节点的完全二叉树的高度？</p><p>树的高度就等于最大层数减一，为了方便计算，转换成层来表示。从图中可以看出，包含 <code>n</code> 个节点的完全二叉树中，第一层包含 <code>1</code> 个节点，第二层包含 <code>2</code> 个节点，第三层包含 <code>4</code> 个节点，依次类推，下面一层节点个数是上一层的 <code>2</code> 倍，第 <code>K</code> 层包含的节点个数就是 $2^{K-1}$。</p><p>不过，对于完全二叉树来说，最后一层的节点个数有点儿不遵守上面的规律了。它包含的节点个数在 <code>1</code> 个到 $2^{L-1}$ 个之间（假设最大层数是 <code>L</code>）。如果把每一层的节点个数加起来就是总的节点个数 <code>n</code>。也就是说，如果节点的个数是 <code>n</code>，那么 <code>n</code> 满足这样一个关系：</p><pre><code class="hljs plain">n &gt;&#x3D; 1+2+4+8+...+2^(L-2)+1n &lt;&#x3D; 1+2+4+8+...+2^(L-2)+2^(L-1)</code></pre><p>借助等比数列的求和公式，可以计算出，<code>L</code> 的范围是 [$log_2(n+1)$, $log_2n + 1$]。完全二叉树的层数小于等于 $log_2n + 1$，也就是说，完全二叉树的高度小于等于 $log_2n$。</p><p>显然，极度不平衡的二叉查找树，它的查找性能肯定不能满足需求。需要构建一种不管怎么删除、插入数据，在任何时候，都能保持任意节点左右子树都比较平衡的二叉查找树，这就是下一篇要详细讲的，一种特殊的二叉查找树，平衡二叉查找树。平衡二叉查找树的高度接近 <code>logn</code>，所以插入、删除、查找操作的时间复杂度也比较稳定，是 $O(logn)$。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面学习了一种特殊的二叉树，二叉查找树。它支持快速地查找、插入、删除操作。</p><p>二叉查找树中，每个节点的值都大于左子树节点的值，小于右子树节点的值。不过，这只是针对没有重复数据的情况。对于存在重复数据的二叉查找树，介绍了两种构建方法，一种是让每个节点存储多个值相同的数据；另一种是，每个节点中存储一个数据。针对这种情况，只需要稍加改造原来的插入、删除、查找操作即可。</p><p>在二叉查找树中，查找、插入、删除等很多操作的时间复杂度都跟树的高度成正比。两个极端情况的时间复杂度分别是 $O(n)$ 和 $O(logn)$，分别对应二叉树退化成链表的情况和完全二叉树。</p><p>为了避免时间复杂度的退化，针对二叉查找树，又设计了一种更加复杂的树，平衡二叉查找树，时间复杂度可以做到稳定的 $O(logn)$，下一篇具体来讲。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 $O(1)$，非常高效。而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 $O(logn)$，相对散列表，好像并没有什么优势，那为什么还要用二叉查找树呢？</p><blockquote><p>有下面几个原因：</p><p>第一，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，只需要中序遍历，就可以在 $O(n)$ 的时间复杂度内，输出有序的数据序列。</p><p>第二，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 $O(logn)$。</p><p>第三，笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 <code>logn</code> 小，所以实际的查找速度可能不一定比 $O(logn)$ 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</p><p>第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</p><p>最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</p><p>综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。在实际的开发过程中，需要结合具体的需求来选择使用哪一个。</p></blockquote></li><li><p>如何通过编程，求出一棵给定二叉树的确切高度呢？</p><blockquote><p>确定二叉树高度有两种思路：<br>第一种是深度优先思想的递归，分别求左右子树的高度。当前节点的高度就是左右子树中较大的那个<code>+1</code>；<br>第二种可以采用层次遍历的方式，每一层记录都记录下当前队列的长度，这个是队尾，每一层队头从<code>0</code>开始。然后每遍历一个元素，队头下标<code>+1</code>。直到队头下标等于队尾下标。这个时候表示当前层遍历完成。每一层刚开始遍历的时候，树的高度<code>+1</code>。最后队列为空，就能得到树的高度。</p></blockquote></li></ul><h2 id="二叉查找树的完整实现"><a href="#二叉查找树的完整实现" class="headerlink" title="二叉查找树的完整实现"></a>二叉查找树的完整实现</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearchTree</span> </span>&#123;  <span class="hljs-keyword">private</span> Node tree;  <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;    Node p = tree;    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">if</span> (data &lt; p.data) p = p.left;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &gt; p.data) p = p.right;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;    <span class="hljs-keyword">if</span> (tree == <span class="hljs-keyword">null</span>) &#123;      tree = <span class="hljs-keyword">new</span> Node(data);      <span class="hljs-keyword">return</span>;    &#125;    Node p = tree;    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">if</span> (data &gt; p.data) &#123;        <span class="hljs-keyword">if</span> (p.right == <span class="hljs-keyword">null</span>) &#123;          p.right = <span class="hljs-keyword">new</span> Node(data);          <span class="hljs-keyword">return</span>;        &#125;        p = p.right;      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// data &lt; p.data</span>        <span class="hljs-keyword">if</span> (p.left == <span class="hljs-keyword">null</span>) &#123;          p.left = <span class="hljs-keyword">new</span> Node(data);          <span class="hljs-keyword">return</span>;        &#125;        p = p.left;      &#125;    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;    Node p = tree; <span class="hljs-comment">// p指向要删除的节点，初始化指向根节点</span>    Node pp = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// pp记录的是p的父节点</span>    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; p.data != data) &#123;      pp = p;      <span class="hljs-keyword">if</span> (data &gt; p.data) p = p.right;      <span class="hljs-keyword">else</span> p = p.left;    &#125;    <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 没有找到</span>    <span class="hljs-comment">// 要删除的节点有两个子节点</span>    <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span> &amp;&amp; p.right != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 查找右子树中最小节点</span>      Node minP = p.right;      Node minPP = p; <span class="hljs-comment">// minPP表示minP的父节点</span>      <span class="hljs-keyword">while</span> (minP.left != <span class="hljs-keyword">null</span>) &#123;        minPP = minP;        minP = minP.left;      &#125;      p.data = minP.data; <span class="hljs-comment">// 将minP的数据替换到p中</span>      p = minP; <span class="hljs-comment">// 下面就变成了删除minP了</span>      pp = minPP;    &#125;    <span class="hljs-comment">// 删除节点是叶子节点或者仅有一个子节点</span>    Node child; <span class="hljs-comment">// p的子节点</span>    <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span>) child = p.left;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.right != <span class="hljs-keyword">null</span>) child = p.right;    <span class="hljs-keyword">else</span> child = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">if</span> (pp == <span class="hljs-keyword">null</span>) tree = child; <span class="hljs-comment">// 删除的是根节点</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pp.left == p) pp.left = child;    <span class="hljs-keyword">else</span> pp.right = child;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">findMin</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (tree == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    Node p = tree;    <span class="hljs-keyword">while</span> (p.left != <span class="hljs-keyword">null</span>) &#123;      p = p.left;    &#125;    <span class="hljs-keyword">return</span> p;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">findMax</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (tree == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    Node p = tree;    <span class="hljs-keyword">while</span> (p.right != <span class="hljs-keyword">null</span>) &#123;      p = p.right;    &#125;    <span class="hljs-keyword">return</span> p;  &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data;    <span class="hljs-keyword">private</span> Node left;    <span class="hljs-keyword">private</span> Node right;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;      <span class="hljs-keyword">this</span>.data = data;    &#125;  &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20.二叉树（上）</title>
    <link href="/passages/20/"/>
    <url>/passages/20/</url>
    
    <content type="html"><![CDATA[<!-- more --><p><font color='green'>二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储？</font></p><h2 id="树（Tree）"><a href="#树（Tree）" class="headerlink" title="树（Tree）"></a>树（Tree）</h2><p>首先来看，什么是“树”？再完备的定义，都没有图直观。所以在下图中画了几棵“树”。你来看看，这些“树”都有什么特征？<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/20/5f1ea5b0-db88-11e9-b03e-bd9724e985f2.png" srcset="/img/loading.gif" alt="image.png"><br>你有没有发现，“树”这种数据结构真的很像现实生活中的“树”，这里面每个元素叫作“节点”；用来连线相邻节点之间的关系，叫作“父子关系”。</p><p>比如下面这幅图，<code>A</code> 节点就是 <code>B</code> 节点的<strong>父节点</strong>，<code>B</code> 节点是 <code>A</code> 节点的<strong>子节点</strong>。<code>B</code>、<code>C</code>、<code>D</code> 这三个节点的父节点是同一个节点，所以它们之间互称为<strong>兄弟节点</strong>。把没有父节点的节点叫作<strong>根节点</strong>，也就是图中的节点 <code>E</code>。把没有子节点的节点叫作<strong>叶子节点</strong>或者<strong>叶节点</strong>，比如图中的 <code>G</code>、<code>H</code>、<code>I</code>、<code>J</code>、<code>K</code>、<code>L</code> 都是叶子节点。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/20/99a3e100-db88-11e9-b03e-bd9724e985f2.png" srcset="/img/loading.gif" alt="image.png"><br>除此之外，关于“树”，还有三个比较相似的概念：<strong>高度</strong>（<code>Height</code>）、<strong>深度</strong>（<code>Depth</code>）、<strong>层</strong>（<code>Level</code>）。它们的定义是这样的：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/20/ad719c90-db88-11e9-b03e-bd9724e985f2.png" srcset="/img/loading.gif" alt="image.png"><br>这三个概念的定义比较容易混淆，描述起来也比较空洞。举个例子说明一下，你一看应该就能明白。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/20/b6f75b10-db88-11e9-b03e-bd9724e985f2.png" srcset="/img/loading.gif" alt="image.png"><br>记这几个概念，还有一个小窍门，就是类比“高度”“深度”“层”这几个名词在生活中的含义。</p><p>在生活中，“高度”这个概念，其实就是从下往上度量，比如要度量第 <code>10</code> 层楼的高度、第 <code>13</code> 层楼的高度，起点都是地面。所以，树这种数据结构的高度也是一样，从最底层开始计数，并且计数的起点是 <code>0</code>。</p><p>“深度”这个概念在生活中是从上往下度量的，比如水中鱼的深度，是从水平面开始度量的。所以，树这种数据结构的深度也是类似的，从根结点开始度量，并且计数起点也是 <code>0</code>。</p><p>“层数”跟深度的计算类似，不过，计数起点是 <code>1</code>，也就是说根节点的位于第 <code>1</code> 层。</p><h2 id="二叉树（Binary-Tree）"><a href="#二叉树（Binary-Tree）" class="headerlink" title="二叉树（Binary Tree）"></a>二叉树（Binary Tree）</h2><p>树结构多种多样，不过最常用还是二叉树。</p><p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是<strong>左子节点</strong>和<strong>右子节点</strong>。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。下面画的这几个都是二叉树。以此类推，你可以想象一下四叉树、八叉树长什么样子。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/20/a772f710-db8a-11e9-b03e-bd9724e985f2.png" srcset="/img/loading.gif" alt="image.png"><br>这个图里面，有两个比较特殊的二叉树，分别是编号 <code>2</code> 和编号 <code>3</code> 这两个。</p><p>其中，编号 <code>2</code> 的二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作<strong>满二叉树</strong>。</p><p>编号 <code>3</code> 的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作<strong>完全二叉树</strong>。</p><p>满二叉树很好理解，也很好识别，但是完全二叉树，有的人可能就分不清了。下面画了几个完全二叉树和非完全二叉树的例子，你可以对比着看看。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/20/fc2231e0-db8a-11e9-b03e-bd9724e985f2.png" srcset="/img/loading.gif" alt="image.png"><br>你可能会说，满二叉树的特征非常明显，把它单独拎出来讲，这个可以理解。但是完全二叉树的特征不怎么明显啊，单从长相上来看，完全二叉树并没有特别特殊的地方啊，更像是“芸芸众树”中的一种。</p><p>那为什么还要特意把它拎出来讲呢？为什么偏偏把最后一层的叶子节点靠左排列的叫完全二叉树？如果靠右排列就不能叫完全二叉树了吗？这个定义的由来或者说目的在哪里？</p><p>要理解完全二叉树定义的由来，需要先了解，<strong>如何表示（或者存储）一棵二叉树？</strong></p><p>想要存储一棵二叉树，有两种方法，一种是基于指针或者引用的<strong>二叉链式存储法</strong>，一种是基于数组的<strong>顺序存储法</strong>。</p><p>先来看比较简单、直观的<strong>链式存储法</strong>。从图中你应该可以很清楚地看到，每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式比较常用。大部分二叉树代码都是通过这种结构来实现的。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/20/5124bcd0-db8b-11e9-b03e-bd9724e985f2.png" srcset="/img/loading.gif" alt="image.png"><br>再来看基于数组的<strong>顺序存储法</strong>。把根节点存储在下标 <code>i = 1</code> 的位置，那左子节点存储在下标 <code>2 * i = 2</code> 的位置，右子节点存储在 <code>2 * i + 1 = 3</code> 的位置。以此类推，<code>B</code> 节点的左子节点存储在 <code>2 * i = 2 * 2 = 4</code> 的位置，右子节点存储在 <code>2 * i + 1 = 2 * 2 + 1 = 5</code> 的位置。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/20/72498a30-db8b-11e9-b03e-bd9724e985f2.png" srcset="/img/loading.gif" alt="image.png"><br>总结一下，如果节点 <code>X</code> 存储在数组中下标为 <code>i</code> 的位置，下标为 <code>2 * i</code> 的位置存储的就是左子节点，下标为 <code>2 * i + 1</code> 的位置存储的就是右子节点。反过来，下标为 <code>i/2</code> 的位置存储就是它的父节点。通过这种方式，只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 <code>1</code> 的位置），这样就可以通过下标计算，把整棵树都串起来。</p><p>不过，刚刚举的例子是一棵完全二叉树，所以仅仅“浪费”了一个下标为 <code>0</code> 的存储位置。如果是非完全二叉树，其实会浪费比较多的数组存储空间。你可以看下面这个例子。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/20/8e8f8be0-db8b-11e9-b03e-bd9724e985f2.png" srcset="/img/loading.gif" alt="image.png"><br>所以，如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。</p><p>当讲到堆和堆排序的时候，你会发现，堆其实就是一种完全二叉树，最常用的存储方式就是数组。</p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>前面讲了二叉树的基本定义和存储方法，现在来看二叉树中非常重要的操作，二叉树的遍历。这也是非常常见的面试题。</p><p>如何将所有节点都遍历打印出来呢？经典的方法有三种，<strong>前序遍历</strong>、<strong>中序遍历</strong>和<strong>后序遍历</strong>。其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。</p><ul><li><p>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</p></li><li><p>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</p></li><li><p>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/20/c973b010-db8b-11e9-b03e-bd9724e985f2.png" srcset="/img/loading.gif" alt="image.png"><br>实际上，<strong>二叉树的前、中、后序遍历就是一个递归的过程</strong>。比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。</p></li></ul><p>写递归代码的关键，就是看能不能写出递推公式，而写递推公式的关键就是，如果要解决问题 <code>A</code>，就假设子问题 <code>B</code>、<code>C</code> 已经解决，然后再来看如何利用 <code>B</code>、<code>C</code> 来解决 <code>A</code>。所以，可以把前、中、后序遍历的递推公式都写出来。</p><pre><code class="hljs c">前序遍历的递推公式：preOrder(r) = print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)中序遍历的递推公式：inOrder(r) = inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)后序遍历的递推公式：postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r</code></pre><p>有了递推公式，代码写起来就简单多了。这三种遍历方式的代码，下面都写出来了，你可以看看。</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(Node* root)</span> </span>&#123;  <span class="hljs-keyword">if</span> (root == null) <span class="hljs-keyword">return</span>;  print root <span class="hljs-comment">// 此处为伪代码，表示打印 root 节点</span>  preOrder(root-&gt;left);  preOrder(root-&gt;right);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(Node* root)</span> </span>&#123;  <span class="hljs-keyword">if</span> (root == null) <span class="hljs-keyword">return</span>;  inOrder(root-&gt;left);  print root <span class="hljs-comment">// 此处为伪代码，表示打印 root 节点</span>  inOrder(root-&gt;right);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(Node* root)</span> </span>&#123;  <span class="hljs-keyword">if</span> (root == null) <span class="hljs-keyword">return</span>;  postOrder(root-&gt;left);  postOrder(root-&gt;right);  print root <span class="hljs-comment">// 此处为伪代码，表示打印 root 节点</span>&#125;</code></pre><p>二叉树的前、中、后序遍历的递归实现是不是很简单？你知道<strong>二叉树遍历的时间复杂度是多少</strong>吗？一起来看看。</p><p>从前面画的前、中、后序遍历的顺序图，可以看出来，每个节点最多会被访问两次，所以遍历操作的时间复杂度，跟节点的个数 <code>n</code> 成正比，也就是说二叉树遍历的时间复杂度是 $O(n)$。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇讲了一种非线性表数据结构，树。关于树，有几个比较常用的概念需要掌握，那就是：根节点、叶子节点、父节点、子节点、兄弟节点，还有节点的高度、深度、层数，以及树的高度。</p><p>平时最常用的树就是二叉树。二叉树的每个节点最多有两个子节点，分别是左子节点和右子节点。二叉树中，有两种比较特殊的树，分别是满二叉树和完全二叉树。满二叉树又是完全二叉树的一种特殊情况。</p><p>二叉树既可以用链式存储，也可以用数组顺序存储。数组顺序存储的方式比较适合完全二叉树，其他类型的二叉树用数组存储会比较浪费存储空间。除此之外，二叉树里非常重要的操作就是前、中、后序遍历操作，遍历的时间复杂度是 $O(n)$，你需要理解并能用递归代码来实现。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>给定一组数据，比如 <code>1，3，5，6，9，10</code>。你来算算，可以构建出多少种不同的二叉树？</p></li><li><p>上面讲了三种二叉树的遍历方式，前、中、后序。实际上，还有另外一种遍历方式，也就是按层遍历，你知道如何实现吗？</p></li></ul><p>欢迎留言和我分享。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>19.哈希算法（下）</title>
    <link href="/passages/19/"/>
    <url>/passages/19/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>上一篇讲了哈希算法的四个应用，它们分别是：安全加密、数据校验、唯一标识、散列函数。下面再来看剩余三种应用：<strong>负载均衡、数据分片、分布式存储</strong>。</p><p>你可能已经发现，这三个应用都跟分布式系统有关。没错，下面就一起看下，<font color='green'>哈希算法是如何解决这些分布式问题的</font>。</p><h2 id="应用五：负载均衡"><a href="#应用五：负载均衡" class="headerlink" title="应用五：负载均衡"></a>应用五：负载均衡</h2><p>负载均衡算法有很多，比如轮询、随机、加权轮询等。那如何才能实现一个会话粘滞（<code>session sticky</code>）的负载均衡算法呢？也就是说，需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。</p><p>最直接的方法就是，维护一张映射关系表，这张表的内容是客户端 <code>IP</code> 地址或者会话 <code>ID</code> 与服务器编号的映射关系。客户端发出的每次请求，都要先在映射表中查找应该路由到的服务器编号，然后再请求编号对应的服务器。这种方法简单直观，但也有几个弊端：</p><ul><li><p>如果客户端很多，映射表可能会很大，比较浪费内存空间；</p></li><li><p>客户端下线、上线，服务器扩容、缩容都会导致映射失效，这样维护映射表的成本就会很大；</p></li></ul><p>如果借助哈希算法，这些问题都可以非常完美地解决。<strong>可以通过哈希算法，对客户端 <code>IP</code> 地址或者会话 <code>ID</code> 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号</strong>。这样，就可以把同一个 <code>IP</code> 过来的所有请求，都路由到同一个后端服务器上。</p><h2 id="应用六：数据分片"><a href="#应用六：数据分片" class="headerlink" title="应用六：数据分片"></a>应用六：数据分片</h2><p>哈希算法还可以用于数据的分片。这里有两个例子。</p><p><strong>1. 如何统计“搜索关键词”出现的次数？</strong></p><p>假如有 <code>1T</code> 的日志文件，这里面记录了用户的搜索关键词，想要快速统计出每个关键词被搜索的次数，该怎么做呢？</p><p>来分析一下。这个问题有两个难点，第一个是搜索日志很大，没办法放到一台机器的内存中。第二个难点是，如果只用一台机器来处理这么巨大的数据，处理时间会很长。</p><p>针对这两个难点，可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。具体的思路是这样的：为了提高处理的速度，用 <code>n</code> 台机器并行处理。从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟 <code>n</code> 取模，最终得到的值，就是应该被分配到的机器编号。</p><p>这样，哈希值相同的搜索关键词就被分配到了同一个机器上。也就是说，同一个搜索关键词会被分配到同一个机器上。每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。</p><p>实际上，这里的处理过程也是 <code>MapReduce</code> 的基本设计思想。</p><p><strong>2. 如何快速判断图片是否在图库中？</strong></p><p>如何快速判断图片是否在图库中？上一节讲过这个例子，不知道你还记得吗？当时介绍了一种方法，即给每个图片取唯一标识（或者信息摘要），然后构建散列表。</p><p>假设现在图库中有 <code>1</code> 亿张图片，很显然，在单台机器上构建散列表是行不通的。因为单台机器的内存有限，而 <code>1</code> 亿张图片构建散列表显然远远超过了单台机器的内存上限。</p><p>同样可以对数据进行分片，然后采用多机处理。准备 <code>n</code> 台机器，让每台机器只维护某一部分图片对应的散列表。每次从图库中读取一个图片，计算唯一标识，然后与机器个数 <code>n</code> 求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。</p><p>当要判断一个图片是否在图库中的时候，通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数 <code>n</code> 求余取模。假设得到的值是 <code>k</code>，那就去编号 <code>k</code> 的机器构建的散列表中查找。</p><p>现在，来估算一下，给这 <code>1</code> 亿张图片构建散列表大约需要多少台机器。</p><p>散列表中每个数据单元包含两个信息，哈希值和图片文件的路径。假设通过 <code>MD5</code> 来计算哈希值，那长度就是 <code>128</code> 比特，也就是 <code>16</code> 字节。文件路径长度的上限是 <code>256</code> 字节，可以假设平均长度是 <code>128</code> 字节。如果用链表法来解决冲突，那还需要存储指针，指针只占用 <code>8</code> 字节。所以，散列表中每个数据单元就占用 <code>152</code> 字节（这里只是估算，并不准确）。</p><p>假设一台机器的内存大小为 <code>2GB</code>，散列表的装载因子为 <code>0.75</code>，那一台机器可以给大约 <code>1000</code> 万（<code>2GB*0.75/152</code>）张图片构建散列表。所以，如果要对 <code>1</code> 亿张图片构建索引，需要大约十几台机器。在工程中，这种估算还是很重要的，能事先对需要投入的资源、资金有个大概的了解，能更好地评估解决方案的可行性。</p><p>实际上，针对这种海量数据的处理问题，都可以采用多机分布式处理。借助这种分片的思路，可以突破单机内存、<code>CPU</code> 等资源的限制。</p><h2 id="应用七：分布式存储"><a href="#应用七：分布式存储" class="headerlink" title="应用七：分布式存储"></a>应用七：分布式存储</h2><p>现在互联网面对的都是海量的数据、海量的用户。为了提高数据的读取、写入能力，一般都采用分布式的方式来存储数据，比如分布式缓存。有海量的数据需要缓存，所以一个缓存机器肯定是不够的。于是，就需要将数据分布在多台机器上。</p><p>该如何决定将哪个数据放到哪个机器上呢？可以借用前面数据分片的思想，即通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号。</p><p>但是，如果数据增多，原来的 <code>10</code> 个机器已经无法承受了，就需要扩容了，比如扩到 <code>11</code> 个机器，这时候麻烦就来了。因为，这里并不是简单地加个机器就可以了。</p><p>原来的数据是通过与 <code>10</code> 来取模的。比如 <code>13</code> 这个数据，存储在编号为 <code>3</code> 这台机器上。但是新加了一台机器中，我们对数据按照 <code>11</code> 取模，原来 <code>13</code> 这个数据就被分配到 <code>2</code> 号这台机器上了。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/20/b4969870-db6c-11e9-b03e-bd9724e985f2.png" srcset="/img/loading.gif" alt="image.png"><br>因此，所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。这样就相当于，缓存中的数据一下子就都失效了。所有的数据请求都会穿透缓存，直接去请求数据库。这样就可能发生雪崩效应，压垮数据库。</p><p>所以，需要一种方法，使得在新加入一个机器后，并不需要做大量的数据搬移。这时候，<strong>一致性哈希算法</strong>就要登场了。</p><p>假设有 <code>k</code> 个机器，数据的哈希值的范围是 <code>[0, MAX]</code>。将整个范围划分成 <code>m</code> 个小区间（<code>m</code> 远大于 <code>k</code>），每个机器负责 <code>m/k</code> 个小区间。当有新机器加入的时候，就将某几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。</p><p>一致性哈希算法的基本思想就是这么简单。除此之外，它还会借助一个虚拟的环和虚拟结点，更加优美地实现出来。这里就不展开讲了，如果感兴趣，你可以自行查找。</p><p>除了上面讲到的分布式缓存，实际上，一致性哈希算法的应用非常广泛，在很多分布式存储系统中，都可以见到一致性哈希算法的影子。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面讲了三种哈希算法在分布式系统中的应用，它们分别是：<strong>负载均衡、数据分片、分布式存储</strong>。</p><p>在<strong>负载均衡</strong>应用中，利用哈希算法替代映射表，可以实现一个会话粘滞的负载均衡策略。</p><p>在<strong>数据分片</strong>应用中，通过哈希算法对处理的海量数据进行分片，多机分布式处理，可以突破单机资源的限制。</p><p>在<strong>分布式存储</strong>应用中，利用一致性哈希算法，可以解决缓存等分布式系统的扩容、缩容导致数据大量搬移的难题。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>这两篇总共讲了七个哈希算法的应用。实际上，这些也只是冰山一角，哈希算法还有很多其他的应用，比如网络协议中的 <code>CRC</code> 校验、<code>Git commit id</code> 等等。除了这些，你还能想到其他用到哈希算法的地方吗？</li></ul><p>欢迎留言和我分享。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>哈希算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>18.哈希算法（上）</title>
    <link href="/passages/18/"/>
    <url>/passages/18/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>记得 <code>2011</code> 年 <code>CSDN</code> 的“脱库”事件吗？当时，<code>CSDN</code> 网站被黑客攻击，超过 <code>600</code> 万用户的注册邮箱和密码明文被泄露，很多网友对 <code>CSDN</code> 明文保存用户密码行为产生了不满。如果你是 <code>CSDN</code> 的一名工程师，<font color='green'>你会如何存储用户密码这么重要的数据吗？仅仅 <code>MD5</code> 加密一下存储就够了吗？</font>要想搞清楚这个问题，就要先弄明白哈希算法。</p><p>哈希算法历史悠久，业界著名的哈希算法也有很多，比如 <code>MD5</code>、<code>SHA</code> 等。在平时的开发中，基本上都是拿现成的直接用。所以，下面不会重点剖析哈希算法的原理，也不会说如何设计一个哈希算法，而是从实战的角度告诉你，<strong>在实际的开发中，该如何用哈希算法解决问题。</strong></p><h2 id="什么是哈希算法？"><a href="#什么是哈希算法？" class="headerlink" title="什么是哈希算法？"></a>什么是哈希算法？</h2><p>前面几篇讲到“散列表”“散列函数”，这里又讲到“哈希算法”，你是不是有点一头雾水？实际上，不管是“散列”还是“哈希”，这都是中文翻译的差别，英文其实就是“<strong>Hash</strong>”。所以，常听到有人把“散列表”叫作“哈希表”“Hash 表”，把“哈希算法”叫作“Hash 算法”或者“散列算法”。那到底什么是哈希算法呢？</p><p>哈希算法的定义和原理非常简单，基本上一句话就可以概括了。将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。但是，要想设计一个优秀的哈希算法并不容易，下面总结了需要满足的几点要求：</p><ul><li><p>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；</p></li><li><p>对输入数据非常敏感，哪怕原始数据只修改了一个 <code>Bit</code>，最后得到的哈希值也大不相同；</p></li><li><p>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</p></li><li><p>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。</p></li></ul><p>这些定义和要求都比较理论，可能还是不好理解，拿 <code>MD5</code> 这种哈希算法来具体说明一下。</p><p>分别对“今天我来讲哈希算法”和“jiajia”这两个文本，计算 <code>MD5</code> 哈希值，得到两串看起来毫无规律的字符串（<code>MD5</code> 的哈希值是 <code>128</code> 位的 <code>Bit</code> 长度，为了方便表示，把它们转化成了 <code>16</code> 进制编码）。可以看出来，无论要哈希的文本有多长、多短，通过 <code>MD5</code> 哈希之后，得到的哈希值的长度都是相同的，而且得到的哈希值看起来像一堆随机数，完全没有规律。</p><pre><code class="hljs plain">MD5(&quot; 今天我来讲哈希算法 &quot;) &#x3D; bb4767201ad42c74e650c1b6c03d78faMD5(&quot;jiajia&quot;) &#x3D; cd611a31ea969b908932d44d126d195b</code></pre><p>再来看两个非常相似的文本，“我今天讲哈希算法！”和“我今天讲哈希算法”。这两个文本只有一个感叹号的区别。如果用 <code>MD5</code> 哈希算法分别计算它们的哈希值，你会发现，尽管只有一字之差，得到的哈希值也是完全不同的。</p><pre><code class="hljs plain">MD5(&quot; 我今天讲哈希算法！&quot;) &#x3D; 425f0d5a917188d2c3c3dc85b5e4f2cbMD5(&quot; 我今天讲哈希算法 &quot;) &#x3D; a1fb91ac128e6aa37fe42c663971ac3d</code></pre><p>在前面也说了，通过哈希算法得到的哈希值，很难反向推导出原始数据。比如上面的例子中，就很难通过哈希值 <code>a1fb91ac128e6aa37fe42c663971ac3d</code> 反推出对应的文本“我今天讲哈希算法”。</p><p>哈希算法要处理的文本可能是各种各样的。比如，对于非常长的文本，如果哈希算法的计算时间很长，那就只能停留在理论研究的层面，很难应用到实际的软件开发中。比如，把今天这篇包含 <code>4000</code> 多个汉字的文章，用 <code>MD5</code> 计算哈希值，用不了 <code>1ms</code> 的时间。</p><p>哈希算法的应用非常非常多，选了最常见的七个，分别是<strong>安全加密</strong>、<strong>唯一标识</strong>、<strong>数据校验</strong>、<strong>散列函数</strong>、<strong>负载均衡</strong>、<strong>数据分片</strong>、<strong>分布式存储</strong>。这节先来看前四个应用。</p><h2 id="应用一：安全加密"><a href="#应用一：安全加密" class="headerlink" title="应用一：安全加密"></a>应用一：安全加密</h2><p>说到哈希算法的应用，最先想到的应该就是安全加密。最常用于加密的哈希算法是 <strong><code>MD5</code></strong>（<code>MD5 Message-Digest Algorithm</code>，<code>MD5</code> 消息摘要算法）和 <strong><code>SHA</code></strong>（<code>Secure Hash Algorithm</code>，安全散列算法）。</p><p>除了这两个之外，当然还有很多其他加密算法，比如 <strong><code>DES</code></strong>（<code>Data Encryption Standard</code>，数据加密标准）、<strong><code>AES</code></strong>（<code>Advanced Encryption Standard</code>，高级加密标准）。</p><p>前面讲到的哈希算法四点要求，对用于加密的哈希算法来说，有两点格外重要。第一点是很难根据哈希值反向推导出原始数据，第二点是散列冲突的概率要很小。</p><p>第一点很好理解，加密的目的就是防止原始数据泄露，所以很难通过哈希值反向推导原始数据，这是一个最基本的要求。所以着重讲一下第二点。实际上，不管是什么哈希算法，只能尽量减少碰撞冲突的概率，理论上是没办法做到完全不冲突的。为什么这么说呢？</p><p>这里就基于组合数学中一个非常基础的理论，<strong>鸽巢原理</strong>（也叫抽屉原理）。这个原理本身很简单，它是说，如果有 <code>10</code> 个鸽巢，有 <code>11</code> 只鸽子，那肯定有 <code>1</code> 个鸽巢中的鸽子数量多于 <code>1</code> 个，换句话说就是，肯定有 <code>2</code> 只鸽子在 <code>1</code> 个鸽巢内。</p><p>有了鸽巢原理的铺垫之后，再来看，<strong>为什么哈希算法无法做到零冲突？</strong></p><p>哈希算法产生的哈希值的长度是固定且有限的。比如前面举的 <code>MD5</code> 的例子，哈希值是固定的 <code>128</code> 位二进制串，能表示的数据是有限的，最多能表示 $2^{128}$ 个数据，而要哈希的数据是无穷的。基于鸽巢原理，如果对 $2^{128}+1$ 个数据求哈希值，就必然会存在哈希值相同的情况。这里你应该能想到，一般情况下，哈希值越长的哈希算法，散列冲突的概率越低。</p><pre><code class="hljs plain">2^128&#x3D;340282366920938463463374607431768211456</code></pre><p>为了让你能有个更加直观的感受，找了两段字符串放在这里。这两段字符串经过 <code>MD5</code> 哈希算法加密之后，产生的哈希值是相同的。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/20/58769940-db68-11e9-b03e-bd9724e985f2.png" srcset="/img/loading.gif" alt="image.png"><br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/20/5eb06110-db68-11e9-b03e-bd9724e985f2.png" srcset="/img/loading.gif" alt="image.png"><br>不过，即便哈希算法存在散列冲突的情况，但是因为哈希值的范围很大，冲突的概率极低，所以相对来说还是很难破解的。像 <code>MD5</code>，有 $2^{128}$ 个不同的哈希值，这个数据已经是一个天文数字了，所以散列冲突的概率要小于 $\frac 1 {2^{128}}$。</p><p>如果拿到一个 <code>MD5</code> 哈希值，希望通过毫无规律的穷举的方法，找到跟这个 <code>MD5</code> 值相同的另一个数据，那耗费的时间应该是个天文数字。所以，即便哈希算法存在冲突，但是在有限的时间和资源下，哈希算法还是被很难破解的。</p><p>除此之外，没有绝对安全的加密。越复杂、越难破解的加密算法，需要的计算时间也越长。比如 <code>SHA-256</code> 比 <code>SHA-1</code> 要更复杂、更安全，相应的计算时间就会比较长。密码学界也一直致力于找到一种快速并且很难被破解的哈希算法。在实际的开发过程中，也需要权衡破解难度和计算时间，来决定究竟使用哪种加密算法。</p><h2 id="应用二：唯一标识"><a href="#应用二：唯一标识" class="headerlink" title="应用二：唯一标识"></a>应用二：唯一标识</h2><p>先来举一个例子。如果要在海量的图库中，搜索一张图是否存在，不能单纯地用图片的元信息（比如图片名称）来比对，因为有可能存在名称相同但图片内容不同，或者名称不同图片内容相同的情况。那该如何搜索呢？</p><p>任何文件在计算中都可以表示成二进制码串，所以，比较笨的办法就是，拿要查找的图片的二进制码串与图库中所有图片的二进制码串一一比对。如果相同，则说明图片在图库中存在。但是，每个图片小则几十 <code>KB</code>、大则几 <code>MB</code>，转化成二进制是一个非常长的串，比对起来非常耗时。有没有比较快的方法呢？</p><p>可以给每一个图片取一个唯一标识，或者说信息摘要。比如，可以从图片的二进制码串开头取 <code>100</code> 个字节，从中间取 <code>100</code> 个字节，从最后再取 <code>100</code> 个字节，然后将这 <code>300</code> 个字节放到一块，通过哈希算法（比如 <code>MD5</code>），得到一个哈希字符串，用它作为图片的唯一标识。通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量。</p><p>如果还想继续提高效率，可以把每个图片的唯一标识，和相应的图片文件在图库中的路径信息，都存储在散列表中。当要查看某个图片是不是在图库中的时候，先通过哈希算法对这个图片取唯一标识，然后在散列表中查找是否存在这个唯一标识。</p><p>如果不存在，那就说明这个图片不在图库中；如果存在，再通过散列表中存储的文件路径，获取到这个已经存在的图片，跟现在要插入的图片做全量的比对，看是否完全一样。如果一样，就说明已经存在；如果不一样，说明两张图片尽管唯一标识相同，但是并不是相同的图片。</p><h2 id="应用三：数据校验"><a href="#应用三：数据校验" class="headerlink" title="应用三：数据校验"></a>应用三：数据校验</h2><p>电驴这样的 <code>BT</code> 下载软件你肯定用过吧？<code>BT</code> 下载的原理是基于 <code>P2P</code> 协议的。从多个机器上并行下载一个 <code>2GB</code> 的电影，这个电影文件可能会被分割成很多文件块（比如可以分成 <code>100</code> 块，每块大约 <code>20MB</code>）。等所有的文件块都下载完成之后，再组装成一个完整的电影文件就行了。</p><p>网络传输是不安全的，下载的文件块有可能是被宿主机器恶意修改过的，又或者下载过程中出现了错误，所以下载的文件块可能不是完整的。如果没有能力检测这种恶意修改或者文件下载出错，就会导致最终合并后的电影无法观看，甚至导致电脑中毒。现在的问题是，如何来校验文件块的安全、正确、完整呢？</p><p>具体的 <code>BT</code> 协议很复杂，校验方法也有很多，来说其中的一种思路。</p><p>通过哈希算法，对 <code>100</code> 个文件块分别取哈希值，并且保存在种子文件中。在前面讲过，哈希算法有一个特点，对数据很敏感。只要文件块的内容有一丁点儿的改变，最后计算出的哈希值就会完全不同。所以，当文件块下载完成之后，可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。</p><h2 id="应用四：散列函数"><a href="#应用四：散列函数" class="headerlink" title="应用四：散列函数"></a>应用四：散列函数</h2><p>前面讲了很多哈希算法的应用，实际上，散列函数也是哈希算法的一种应用。</p><p>前两篇讲到，散列函数是设计一个散列表的关键。它直接决定了散列冲突的概率和散列表的性能。不过，相对哈希算法的其他应用，散列函数对于散列算法冲突的要求要低很多。即便出现个别散列冲突，只要不是过于严重，都可以通过开放寻址法或者链表法解决。</p><p>不仅如此，散列函数对于散列算法计算得到的值，是否能反向解密也并不关心。散列函数中用到的散列算法，更加关注散列后的值是否能平均分布，也就是，一组数据是否能均匀地散列在各个槽中。除此之外，散列函数执行的快慢，也会影响散列表的性能，所以，散列函数用的散列算法一般都比较简单，比较追求效率。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面的内容比较偏实战，讲到了哈希算法的四个应用场景。</p><p>第一个应用是<strong>唯一标识</strong>，哈希算法可以对大数据做信息摘要，通过一个较短的二进制编码来表示很大的数据。</p><p>第二个应用是用于<strong>校验数据的完整性和正确性</strong>。</p><p>第三个应用是<strong>安全加密</strong>，讲到任何哈希算法都会出现散列冲突，但是这个冲突概率非常小。越是复杂哈希算法越难破解，但同样计算时间也就越长。所以，选择哈希算法的时候，要权衡安全性和计算时间来决定用哪种哈希算法。</p><p>第四个应用是<strong>散列函数</strong>，这个前面讲散列表的时候已经详细地讲过，它对哈希算法的要求非常特别，更加看重的是散列的平均性和哈希算法的执行效率。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>如何防止数据库中的用户信息被脱库？你会如何存储用户密码这么重要的数据？</p><blockquote><p>可以通过哈希算法，对用户密码进行加密之后再存储，不过最好选择相对安全的加密算法，比如 <code>SHA</code> 等（因为 <code>MD5</code> 已经号称被破解了）。不过仅仅这样加密之后存储就万事大吉了吗？</p><p>字典攻击你听说过吗？如果用户信息被“脱库”，黑客虽然拿到是加密之后的密文，但可以通过“猜”的方式来破解密码，这是因为，有些用户的密码太简单。比如很多人习惯用 <code>00000</code>、<code>123456</code> 这样的简单数字组合做密码，很容易就被猜中。</p><p>那就需要维护一个常用密码的字典表，把字典中的每个密码用哈希算法计算哈希值，然后拿哈希值跟脱库后的密文比对。如果相同，基本上就可以认为，这个加密之后的密码对应的明文就是字典中的这个密码。（注意，这里说是的是“基本上可以认为”，因为根据前面的学习，哈希算法存在散列冲突，也有可能出现，尽管密文一样，但是明文并不一样的情况。）</p><p>针对字典攻击，可以引入一个盐（<code>salt</code>），跟用户的密码组合在一起，增加密码的复杂度。拿组合之后的字符串来做哈希算法加密，将它存储到数据库中，进一步增加破解的难度。不过这里想多说一句，我认为安全和攻击是一种博弈关系，不存在绝对的安全。所有的安全措施，只是增加攻击的成本而已。</p></blockquote></li><li><p>区块链现在是一个很火的领域，它被很多人神秘化，不过其底层的实现原理并不复杂。其中，哈希算法就是它的一个非常重要的理论基础。你知道区块链使用的是哪种哈希算法吗？是为了解决什么问题而使用的呢？</p><blockquote><p>区块链是一块块区块组成的，每个区块分为两部分：<strong>区块头</strong>和<strong>区块体</strong>。<br>区块头保存着自己区块体和上一个区块头的哈希值。<br>因为这种链式关系和哈希值的唯一性，只要区块链上任意一个区块被修改过，后面所有区块保存的哈希值就不对了。<br>区块链使用的是 <code>SHA256</code> 哈希算法，计算哈希值非常耗时，如果要篡改一个区块，就必须重新计算该区块后面所有的区块的哈希值，短时间内几乎不可能做到。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>哈希算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>17.散列表（下）</title>
    <link href="/passages/17/"/>
    <url>/passages/17/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>你有没有发现，有两种数据结构，散列表和链表，经常会被放在一起使用。还记得前面的文章中都有哪些地方讲到散列表和链表的组合使用吗？</p><p>在链表那讲到如何用链表来实现 <code>LRU</code> 缓存淘汰算法，但是链表实现的 <code>LRU</code> 缓存淘汰算法的时间复杂度是 $O(n)$，当时也提到了，通过散列表可以将这个时间复杂度降低到 $O(1)$。</p><p>在跳表那提到 <code>Redis</code> 的有序集合是使用跳表来实现的，跳表可以看作一种改进版的链表。当时也提到，<code>Redis</code> 有序集合不仅使用了跳表，还用到了散列表。</p><p>除此之外，如果你熟悉 <code>Java</code> 编程语言，你会发现 <code>LinkedHashMap</code> 这样一个常用的容器，也用到了散列表和链表两种数据结构。</p><p>下面就来看看，在这几个问题中，散列表和链表都是如何组合起来使用的，以及为什么散列表和链表会经常放到一块使用。</p><h2 id="LRU-缓存淘汰算法"><a href="#LRU-缓存淘汰算法" class="headerlink" title="LRU 缓存淘汰算法"></a>LRU 缓存淘汰算法</h2><p>在链表那提到，借助散列表，可以把 <code>LRU</code> 缓存淘汰算法的时间复杂度降低为 $O(1)$。现在，就来看看它是如何做到的。</p><p>首先，来回顾一下当时是如何通过链表实现 <code>LRU</code> 缓存淘汰算法的。</p><p>需要维护一个按照访问时间从大到小有序排列的链表结构。因为缓存大小有限，当缓存空间不够，需要淘汰一个数据的时候，就直接将链表头部的结点删除。</p><p>当要缓存某个数据的时候，先在链表中查找这个数据。如果没有找到，则直接将数据放到链表的尾部；如果找到了，就把它移动到链表的尾部。因为查找数据需要遍历链表，所以单纯用链表实现的 <code>LRU</code> 缓存淘汰算法的时间复杂很高，是 $O(n)$。</p><p>实际上，总结一下，一个缓存（<code>cache</code>）系统主要包含下面这几个操作：</p><ul><li><p>往缓存中添加一个数据；</p></li><li><p>从缓存中删除一个数据；</p></li><li><p>在缓存中查找一个数据。</p></li></ul><p>这三个操作都要涉及“查找”操作，如果单纯地采用链表的话，时间复杂度只能是 $O(n)$。如果将散列表和链表两种数据结构组合使用，可以将这三个操作的时间复杂度都降低到 $O(1)$。具体的结构就是下面这个样子：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/20/64064bd0-db58-11e9-b03e-bd9724e985f2.png" srcset="/img/loading.gif" alt="image.png"><br>使用双向链表存储数据，链表中的每个结点处理存储数据（<code>data</code>）、前驱指针（<code>prev</code>）、后继指针（<code>next</code>）之外，还新增了一个特殊的字段 <code>hnext</code>。这个 <code>hnext</code> 有什么作用呢？</p><p>因为散列表是通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是刚刚提到的<strong>双向链表</strong>，另一个链是散列表中的<strong>拉链</strong>。<strong>前驱和后继指针是为了将结点串在双向链表中，<code>hnext</code> 指针是为了将结点串在散列表的拉链中。</strong></p><p>了解了这个散列表和双向链表的组合存储结构之后，再来看，前面讲到的缓存的三个操作，是如何做到时间复杂度是 $O(1)$ 的？</p><p>首先，来看<strong>如何查找一个数据</strong>。前面讲过，散列表中查找数据的时间复杂度接近 $O(1)$，所以通过散列表，可以很快地在缓存中找到一个数据。当找到数据之后，还需要将它移动到双向链表的尾部。</p><p>其次，来看<strong>如何删除一个数据</strong>。需要找到数据所在的结点，然后将结点删除。借助散列表，可以在 $O(1)$ 时间复杂度里找到要删除的结点。因为链表是双向链表，双向链表可以通过前驱指针 $O(1)$ 时间复杂度获取前驱结点，所以在双向链表中，删除结点只需要 $O(1)$ 的时间复杂度。</p><p>最后，来看<strong>如何添加一个数据</strong>。添加数据到缓存稍微有点麻烦，需要先看这个数据是否已经在缓存中。如果已经在其中，需要将其移动到双向链表的尾部；如果不在其中，还要看缓存有没有满。如果满了，则将双向链表头部的结点删除，然后再将数据放到链表的尾部；如果没有满，就直接将数据放到链表的尾部。</p><p>这整个过程涉及的查找操作都可以通过散列表来完成。其他的操作，比如删除头结点、链表尾部插入数据等，都可以在 $O(1)$ 的时间复杂度内完成。所以，这三个操作的时间复杂度都是 $O(1)$。至此，就通过散列表和双向链表的组合使用，实现了一个高效的、支持 <code>LRU</code> 缓存淘汰算法的缓存系统原型。</p><h2 id="Redis-有序集合"><a href="#Redis-有序集合" class="headerlink" title="Redis 有序集合"></a>Redis 有序集合</h2><p>在跳表那一节，讲到有序集合的操作时，稍微做了些简化。实际上，在有序集合中，每个成员对象有两个重要的属性，<code>key</code>（键值）和 <code>score</code>（分值）。不仅会通过 <code>score</code> 来查找数据，还会通过 <code>key</code> 来查找数据。</p><p>举个例子，比如用户积分排行榜有这样一个功能：可以通过用户的 <code>ID</code> 来查找积分信息，也可以通过积分区间来查找用户 <code>ID</code> 或者姓名信息。这里包含 <code>ID</code>、姓名和积分的用户信息，就是成员对象，用户 <code>ID</code> 就是 <code>key</code>，积分就是 <code>score</code>。</p><p>所以，如果细化一下 <code>Redis</code> 有序集合的操作，那就是下面这样：</p><ul><li><p>添加一个成员对象；</p></li><li><p>按照键值来删除一个成员对象；</p></li><li><p>按照键值来查找一个成员对象；</p></li><li><p>按照分值区间查找数据，比如查找积分在 <code>[100, 356]</code> 之间的成员对象；</p></li><li><p>按照分值从小到大排序成员变量；</p></li></ul><p>如果仅仅按照分值将成员对象组织成跳表的结构，那按照键值来删除、查询成员对象就会很慢，解决方法与 <code>LRU</code> 缓存淘汰算法的解决方法类似。可以再按照键值构建一个散列表，这样按照 <code>key</code> 来删除、查找一个成员对象的时间复杂度就变成了 $O(1)$。同时，借助跳表结构，其他操作也非常高效。</p><p>实际上，<code>Redis</code> 有序集合的操作还有另外一类，也就是查找成员对象的排名（<code>Rank</code>）或者根据排名区间查找成员对象。这个功能单纯用刚刚讲的这种组合结构就无法高效实现了。</p><h2 id="Java-LinkedHashMap"><a href="#Java-LinkedHashMap" class="headerlink" title="Java LinkedHashMap"></a>Java LinkedHashMap</h2><p><code>HashMap</code> 底层是通过散列表这种数据结构实现的。而 <code>LinkedHashMap</code> 前面比 <code>HashMap</code> 多了一个“<code>Linked</code>”，这里的“<code>Linked</code>”是不是说，<code>LinkedHashMap</code> 是一个通过链表法解决散列冲突的散列表呢？</p><p>实际上，<code>LinkedHashMap</code> 并没有这么简单，其中的“<code>Linked</code>”也并不仅仅代表它是通过链表法解决散列冲突的。关于这一点，在我是初学者的时候，也误解了很久。</p><p>先来看一段代码。你觉得这段代码会以什么样的顺序打印 <code>3，1，5，2</code> 这几个 <code>key</code> 呢？原因又是什么呢？</p><pre><code class="hljs java">HashMap&lt;Integer, Integer&gt; m = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();m.put(<span class="hljs-number">3</span>, <span class="hljs-number">11</span>);m.put(<span class="hljs-number">1</span>, <span class="hljs-number">12</span>);m.put(<span class="hljs-number">5</span>, <span class="hljs-number">23</span>);m.put(<span class="hljs-number">2</span>, <span class="hljs-number">22</span>);<span class="hljs-keyword">for</span> (Map.Entry e : m.entrySet()) &#123;  System.out.println(e.getKey());&#125;</code></pre><p>先告诉你答案，上面的代码会按照数据插入的顺序依次来打印，也就是说，打印的顺序就是 <code>3，1，5，2</code>。你有没有觉得奇怪？散列表中数据是经过散列函数打乱之后无规律存储的，这里是如何实现按照数据的插入顺序来遍历打印的呢？</p><p>可能你已经猜到了，<code>LinkedHashMap</code> 也是通过散列表和链表组合在一起实现的。实际上，它不仅支持按照插入顺序遍历数据，还支持按照访问顺序来遍历数据。你可以看下面这段代码：</p><pre><code class="hljs java"><span class="hljs-comment">// 10 是初始大小，0.75 是装载因子，true 是表示按照访问时间排序</span>HashMap&lt;Integer, Integer&gt; m = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;(<span class="hljs-number">10</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-keyword">true</span>);m.put(<span class="hljs-number">3</span>, <span class="hljs-number">11</span>);m.put(<span class="hljs-number">1</span>, <span class="hljs-number">12</span>);m.put(<span class="hljs-number">5</span>, <span class="hljs-number">23</span>);m.put(<span class="hljs-number">2</span>, <span class="hljs-number">22</span>);m.put(<span class="hljs-number">3</span>, <span class="hljs-number">26</span>);m.get(<span class="hljs-number">5</span>);<span class="hljs-keyword">for</span> (Map.Entry e : m.entrySet()) &#123;  System.out.println(e.getKey());&#125;</code></pre><p>这段代码打印的结果是 <code>1，2，3，5</code>。这里分析一下，为什么这段代码会按照这样顺序来打印。</p><p>每次调用 <code>put()</code> 函数，往 <code>LinkedHashMap</code> 中添加数据的时候，都会将数据添加到链表的尾部，所以，在前四个操作完成之后，链表中的数据是下面这样：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/20/d5284830-db59-11e9-b03e-bd9724e985f2.png" srcset="/img/loading.gif" alt="image.png"><br>在第 <code>8</code> 行代码中，再次将键值为 <code>3</code> 的数据放入到 <code>LinkedHashMap</code> 的时候，会先查找这个键值是否已经有了，然后，再将已经存在的 <code>(3,11)</code> 删除，并且将新的 <code>(3,26)</code> 放到链表的尾部。所以，这个时候链表中的数据就是下面这样：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/20/dd376c40-db59-11e9-b03e-bd9724e985f2.png" srcset="/img/loading.gif" alt="image.png"><br>当第 <code>9</code> 行代码访问到 <code>key</code> 为 <code>5</code> 的数据的时候，将被访问到的数据移动到链表的尾部。所以，第 <code>9</code> 行代码之后，链表中的数据是下面这样：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/20/e625ccc0-db59-11e9-b03e-bd9724e985f2.png" srcset="/img/loading.gif" alt="image.png"><br>所以，最后打印出来的数据是 <code>1，2，3，5</code>。从上面的分析，你有没有发现，按照访问时间排序的 <code>LinkedHashMap</code> 本身就是一个支持 <code>LRU</code> 缓存淘汰策略的缓存系统？实际上，它们两个的实现原理也是一模一样的。</p><p>总结一下，实际上，<strong><code>LinkedHashMap</code> 是通过双向链表和散列表这两种数据结构组合实现的。<code>LinkedHashMap</code> 中的“<code>Linked</code>”实际上是指的是双向链表，并非指用链表法解决散列冲突。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，就需要将散列表中的数据拷贝到数组中，然后排序，再遍历。</p><p>因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，将散列表和链表（或者跳表）结合在一起使用。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>上面的几个散列表和链表组合的例子里，都是使用双向链表。如果把双向链表改成单链表，还能否正常工作？为什么呢？</p><blockquote><p>在删除一个元素时，虽然能 $O(1)$ 的找到目标结点，但是要删除该结点需要拿到前一个结点的指针，遍历到前一个结点复杂度会变为 $O(n)$，所以用双链表实现比较合适。<br>（但其实硬要操作的话，单链表也是可以实现 $O(1)$ 时间复杂度删除结点的）。</p></blockquote></li><li><p>假设猎聘网有<code>10</code>万名猎头，每个猎头可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假设你是猎聘网的一名工程师，如何在内存中存储这<code>10</code>万个猎头的<code>ID</code>和积分信息，让它能够支持这样几个操作：</p><ul><li>根据猎头<code>ID</code>查收查找、删除、更新这个猎头的积分信息；</li><li>查找积分在某个区间的猎头<code>ID</code>列表；</li><li>查找按照积分从小到大排名在第<code>x</code>位到第<code>y</code>位之间的猎头<code>ID</code>列表。  <blockquote><p>以积分排序构建一个跳表，再以猎头 <code>ID</code> 构建一个散列表。</p><ul><li><code>ID</code> 在散列表中所以可以 $O(1)$ 查找到这个猎头；</li><li>积分以跳表存储，跳表支持区间查询；</li></ul></blockquote></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>散列表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>16.散列表（中）</title>
    <link href="/passages/16/"/>
    <url>/passages/16/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>通过上一篇可以学习到散列表的查询效率并不能笼统地说成是 $O(1)$。它跟散列函数、装载因子、散列冲突等都有关系。如果散列函数设计得不好，或者装载因子过高，都可能导致散列冲突发生的概率升高，查询效率下降。</p><p>在极端情况下，有些恶意的攻击者，还有可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里。如果使用的是基于链表的冲突解决方法，那这个时候，散列表就会退化为链表，查询的时间复杂度就从 $O(1)$ 急剧退化为 $O(n)$。</p><p>如果散列表中有 <code>10</code> 万个数据，退化后的散列表查询的效率就下降了 <code>10</code> 万倍。更直接点说，如果之前运行 <code>100</code> 次查询只需要 <code>0.1</code> 秒，那现在就需要 <code>1</code> 万秒。这样就有可能因为查询操作消耗大量 <code>CPU</code> 或者线程资源，导致系统无法响应其他请求，从而达到拒绝服务攻击（<code>DoS</code>）的目的。这也就是散列表碰撞攻击的基本原理。</p><p>下面就来学习一下，<font color='green'>如何设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能的急剧下降，并且能抵抗散列碰撞攻击？</font></p><h2 id="如何设计散列函数？"><a href="#如何设计散列函数？" class="headerlink" title="如何设计散列函数？"></a>如何设计散列函数？</h2><p>散列函数设计的好坏，决定了散列表冲突的概率大小，也直接决定了散列表的性能。那什么才是好的散列函数呢？</p><p>首先，<strong>散列函数的设计不能太复杂</strong>。过于复杂的散列函数，势必会消耗很多计算时间，也就间接的影响到散列表的性能。其次，<strong>散列函数生成的值要尽可能随机并且均匀分布</strong>，这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。</p><p>实际工作中，还需要综合考虑各种因素。这些因素有关键字的长度、特点、分布、还有散列表的大小等。散列函数各式各样，下面举几个常用的、简单的散列函数的设计方法，让你有个直观的感受。</p><p>第一个例子就是上一篇的学生运动会的例子，我们通过分析参赛编号的特征，把编号中的后两位作为散列值。还可以用类似的散列函数处理手机号码，因为手机号码前几位重复的可能性很大，但是后面几位就比较随机，可以取手机号的后四位作为散列值。这种散列函数的设计方法，一般叫作“数据分析法”。</p><p>第二个例子就是上一篇的思考题，如何实现 <code>Word</code> 拼写检查功能。这里面的散列函数，就可以这样设计：将单词中每个字母的 <code>ASCll</code> 码值“进位”相加，然后再跟散列表的大小求余、取模，作为散列值。比如，英文单词 <code>nice</code>，转化出来的散列值就是下面这样：</p><pre><code class="hljs plain">hash(&quot;nice&quot;)&#x3D;((&quot;n&quot; - &quot;a&quot;) * 26*26*26 + (&quot;i&quot; - &quot;a&quot;)*26*26 + (&quot;c&quot; - &quot;a&quot;)*26+ (&quot;e&quot;-&quot;a&quot;)) &#x2F; 78978</code></pre><p>实际上，散列函数的设计方法还有很多，比如直接寻址法、平方取中法、折叠法、随机数法等，这些只要了解就行了，不需要全都掌握。</p><h2 id="装载因子过大了怎么办？"><a href="#装载因子过大了怎么办？" class="headerlink" title="装载因子过大了怎么办？"></a>装载因子过大了怎么办？</h2><p>上一篇讲到散列表的装载因子的时候说过，装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。</p><p>对于没有频繁插入和删除的静态数据集合来说，很容易根据数据的特点、分布等，设计出完美的、极少冲突的散列函数，因为毕竟之前数据都是已知的。</p><p>对于动态散列表来说，数据集合是频繁变动的，事先无法预估将要加入的数据个数，所以也无法事先申请一个足够大的散列表。随着数据慢慢加入，装载因子就会慢慢变大。当装载因子大到一定程度之后，散列冲突就会变得不可接受。这个时候，该如何处理呢？</p><p>还记得前面多次讲的“动态扩容”吗？你可以回想一下，是如何做数组、栈、队列的动态扩容的。</p><p>针对散列表，当装载因子过大时，也可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新散列表中。假设每次扩容都申请一个原来散列表大小两倍的空间。如果原来散列表的装载因子是 <code>0.8</code>，那经过扩容之后，新散列表的装载因子就下降为原来的一半，变成了 <code>0.4</code>。</p><p>针对数组的扩容，数据搬移操作比较简单。但是，针对散列表的扩容，数据搬移操作要复杂很多。因为散列表的大小变了，数据的存储位置也变了，所以需要通过散列函数重新计算每个数据的存储位置。</p><p>你可以看下面图里这个例子。在原来的散列表中，<code>21</code> 这个元素原来存储在下标为 <code>0</code> 的位置，搬移到新的散列表中，存储在下标为 <code>7</code> 的位置。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/19/14526470-da9f-11e9-aeb5-dd57c0620d4c.png" srcset="/img/loading.gif" alt="image.png"><br>对于支持动态扩容的散列表，插入操作的时间复杂度是多少呢？前面章节已经多次分析过支持动态扩容的数组、栈等数据结构的时间复杂度了。所以，这里就不啰嗦了。</p><p>插入一个数据，最好情况下，不需要扩容，最好时间复杂度是 $O(1)$。最坏情况下，散列表装载因子过高，启动扩容，需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是 $O(n)$。用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是 $O(1)$。</p><p>实际上，对于动态散列表，随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。如果对空间消耗非常敏感，可以在装载因子小于某个值之后，启动动态缩容。当然，如果更加在意执行效率，能够容忍多消耗一点内存空间，那就可以不用费劲来缩容了。</p><p>前面讲到，当散列表的装载因子超过某个阈值时，就需要进行扩容。装载因子阈值需要选择得当。如果太大，会导致冲突过多；如果太小，会导致内存浪费严重。</p><p>装载因子阈值的设置要权衡时间、空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 <code>1</code>。</p><h2 id="如何避免低效地扩容？"><a href="#如何避免低效地扩容？" class="headerlink" title="如何避免低效地扩容？"></a>如何避免低效地扩容？</h2><p>刚刚分析得到，大部分情况下，动态扩容的散列表插入一个数据都很快，但是在特殊情况下，当装载因子已经到达阈值，需要先进行扩容，再插入数据。这个时候，插入数据就会变得很慢，甚至会无法接受。</p><p>举一个极端的例子，如果散列表当前大小为 <code>1GB</code>，要想扩容为原来的两倍大小，那就需要对 <code>1GB</code> 的数据重新计算哈希值，并且从原来的散列表搬移到新的散列表，听起来就很耗时，是不是？</p><p>如果业务代码直接服务于用户，尽管大部分情况下，插入一个数据的操作都很快，但是，极个别非常慢的插入操作，也会让用户崩溃。这个时候，“一次性”扩容的机制就不合适了。</p><p>为了解决一次性扩容耗时过多的情况，可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，只申请新空间，但并不将老的数据搬移到新散列表中。</p><p>当有新数据要插入时，将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/19/828c9fa0-da9f-11e9-aeb5-dd57c0620d4c.png" srcset="/img/loading.gif" alt="image.png"><br>这期间的查询操作怎么来做呢？对于查询操作，为了兼容了新、老散列表中的数据，先从新散列表中查找，如果没有找到，再去老的散列表中查找。</p><p>通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。这种实现方式，任何情况下，插入一个数据的时间复杂度都是 $O(1)$。</p><h2 id="如何选择冲突解决方法？"><a href="#如何选择冲突解决方法？" class="headerlink" title="如何选择冲突解决方法？"></a>如何选择冲突解决方法？</h2><p>上一节讲了两种主要的散列冲突的解决办法，开放寻址法和链表法。这两种冲突解决办法在实际的软件开发中都非常常用。比如，<code>Java</code> 中 <code>LinkedHashMap</code> 就采用了链表法解决冲突，<code>ThreadLocalMap</code> 是通过线性探测的开放寻址法来解决冲突。那你知道，这两种冲突解决方法各有什么优势和劣势，又各自适用哪些场景吗？</p><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>先来看看，开放寻址法的优点有哪些。</p><p>开放寻址法不像链表法，需要拉很多链表。散列表中的数据都存储在数组中，可以有效地利用 <code>CPU</code> 缓存加快查询速度。而且，这种方法实现的散列表，序列化起来比较简单。链表法包含指针，序列化起来就没那么容易。你可不要小看序列化，很多场合都会用到的。</p><p>再来看下，开放寻址法有哪些缺点。</p><p>上一篇讲到，用开放寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。</p><p>所以，总结一下，<strong>当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 <code>Java</code> 中的 <code>ThreadLocalMap</code> 使用开放寻址法解决散列冲突的原因。</strong></p><h3 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h3><p>首先，链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。实际上，这一点也是前面讲过的链表优于数组的地方。</p><p>链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 <code>1</code> 的情况。接近 <code>1</code> 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 <code>10</code>，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。</p><p>还记得之前在链表那一节讲的吗？链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。而且，因为链表中的结点是零散分布在内存中的，不是连续的，所以对 <code>CPU</code> 缓存是不友好的，这方面对于执行效率也有一定的影响。</p><p>当然，如果存储的是大对象，也就是说要存储的对象的大小远远大于一个指针的大小（<code>4</code> 个字节或者 <code>8</code> 个字节），那链表中指针的内存消耗在大对象面前就可以忽略了。</p><p>实际上，对链表法稍加改造，可以实现一个更加高效的散列表。那就是，将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是 $O(logn)$。这样也就有效避免了前面讲到的散列碰撞攻击。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/19/3c0edba0-daa0-11e9-aeb5-dd57c0620d4c.png" srcset="/img/loading.gif" alt="image.png"><br>所以，总结一下，<strong>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</strong></p><h2 id="工业级散列表举例分析"><a href="#工业级散列表举例分析" class="headerlink" title="工业级散列表举例分析"></a>工业级散列表举例分析</h2><p><strong>1. 初始大小</strong></p><p><code>HashMap</code> 默认的初始大小是 <code>16</code>，当然这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高 <code>HashMap</code> 的性能。</p><p><strong>2. 装载因子和动态扩容</strong></p><p>最大装载因子默认是 <code>0.75</code>，当 <code>HashMap</code> 中元素个数超过 <code>0.75*capacity</code>（<code>capacity</code> 表示散列表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。</p><p><strong>3. 散列冲突解决方法</strong></p><p><code>HashMap</code> 底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 <code>HashMap</code> 的性能。</p><p>于是，在 <code>JDK1.8</code> 版本中，为了对 <code>HashMap</code> 做进一步优化，引入了红黑树。而当链表长度太长（默认超过 <code>8</code>）时，链表就转换为红黑树。可以利用红黑树快速增删改查的特点，提高 <code>HashMap</code> 的性能。当红黑树结点个数少于 <code>8</code> 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。</p><p><strong>4. 散列函数</strong></p><p>散列函数的设计并不复杂，追求的是简单高效、分布均匀。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;    <span class="hljs-keyword">int</span> h = key.hashCode()；    <span class="hljs-keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>)) &amp; (capitity -<span class="hljs-number">1</span>); <span class="hljs-comment">//capicity 表示散列表的大小</span>&#125;</code></pre><p>其中，<code>hashCode()</code> 返回的是 <code>Java</code> 对象的 <code>hash code</code>。比如 <code>String</code> 类型的对象的 <code>hashCode()</code> 就是下面这样：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">int</span> var1 = <span class="hljs-keyword">this</span>.hash;  <span class="hljs-keyword">if</span>(var1 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">this</span>.value.length &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">char</span>[] var2 = <span class="hljs-keyword">this</span>.value;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var3 = <span class="hljs-number">0</span>; var3 &lt; <span class="hljs-keyword">this</span>.value.length; ++var3) &#123;      var1 = <span class="hljs-number">31</span> * var1 + var2[var3];    &#125;    <span class="hljs-keyword">this</span>.hash = var1;  &#125;  <span class="hljs-keyword">return</span> var1;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上一篇的内容比较偏理论，本篇的内容侧重实战。主要讲了如何设计一个工业级的散列表，以及如何应对各种异常情况，防止在极端情况下，散列表的性能退化过于严重。分了三部分来讲解这些内容，分别是：如何设计散列函数，如何根据装载因子动态扩容，以及如何选择散列冲突解决方法。</p><p>关于散列函数的设计，要尽可能让散列后的值随机且均匀分布，这样会尽可能地减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀。除此之外，散列函数的设计也不能太复杂，太复杂就会太耗时间，也会影响散列表的性能。</p><p>关于散列冲突解决方法的选择，对比了开放寻址法和链表法两种方法的优劣和适应的场景。大部分情况下，链表法更加普适。而且，还可以通过将链表法中的链表改造成其他动态查找数据结构，比如红黑树，来避免散列表时间复杂度退化成 $O(n)$，抵御散列碰撞攻击。但是，对于小规模数据、装载因子不高的散列表，比较适合用开放寻址法。</p><p>对于动态散列表来说，不管如何设计散列函数，选择什么样的散列冲突解决方法。随着数据的不断增加，散列表总会出现装载因子过高的情况。这个时候，就需要启动动态扩容。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><strong>何为一个工业级的散列表？工业级的散列表应该具有哪些特性？</strong></li></ul><blockquote><p>结合学过的知识，应该有这样的要求：</p><ul><li>支持快速的查询、插入、删除操作；</li><li>内存占用合理，不能浪费过多空间；</li><li>性能稳定，在极端情况下，散列表的性能也不会退化到无法接受的情况。</li></ul><p><strong>如何设计这样一个散列表呢？</strong>根据前面的知识，从<code>3</code>个方面来考虑设计思路：</p><ul><li>设计一个合适的散列函数；</li><li>定义装载因子阈值，并且设计动态扩容策略；</li><li>选择合适的散列冲突解决方法。</li></ul><p>关于散列函数、装载因子、动态扩容策略，还有散列冲突的解决办法，前面都讲过了，具体如何选择，还要结合具体的业务场景、具体的业务数据来具体分析。不过只要朝这三个方向努力，就离设计出工业级的散列表不远了。</p></blockquote><ul><li>你熟悉的编程语言中，哪些数据类型底层是基于散列表实现的？散列函数是如何设计的？散列冲突是通过哪种方法解决的？是否支持动态扩容呢？</li></ul><blockquote><p><code>JDK HashMap</code>中<code>hash</code>函数的设计，确实很巧妙：</p><p>首先<code>hashcode</code>本身是个<code>32</code>位整型值，在系统中，这个值对于不同的对象必须保证唯一（<code>JAVA</code>规范），这也是常说的，重写<code>equals</code>必须重写<code>hashcode</code>的重要原因。</p><p>获取对象的<code>hashcode</code>以后，先进行移位运算，然后再和自己做异或运算，即：<code>hashcode ^ (hashcode &gt;&gt;&gt; 16)</code>，这一步甚是巧妙，是将高<code>16</code>位移到低<code>16</code>位，这样计算出来的整型值将“具有”高位和低位的性质。</p><p>最后，用<code>hash</code>表当前的容量减去一，再和刚刚计算出来的整型值做位与运算。进行位与运算，很好理解，是为了计算出数组中的位置。<br>但这里有个问题：为什么要用容量减去一？</p><p>因为 <code>A % B = A &amp; (B - 1)</code>，所以，<code>(h ^ (h &gt;&gt;&gt; 16)) &amp; (capitity -1) = (h ^ (h &gt;&gt;&gt; 16)) % capitity</code>，可以看出这里本质上是使用了<strong>「除留余数法」</strong><br>综上，可以看出，<code>hashcode</code>的随机性，加上移位异或算法，得到一个非常随机的<code>hash</code>值，再通过<strong>「除留余数法」</strong>，得到<code>index</code>，整体的设计过程与“散列函数”设计原则非常吻合！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>散列表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15.散列表（上）</title>
    <link href="/passages/15/"/>
    <url>/passages/15/</url>
    
    <content type="html"><![CDATA[<!-- more --><p><code>Word</code> 这种文本编辑器你平时应该经常用吧，那你有没有留意过它的拼写检查功能呢？一旦在 <code>Word</code> 里输入一个错误的英文单词，它就会用标红的方式提示“拼写错误”。<code>Word</code> 的这个单词拼写检查功能，虽然很小但却非常实用。你有没有想过，这个功能是如何实现的呢？</p><h2 id="散列思想"><a href="#散列思想" class="headerlink" title="散列思想"></a>散列思想</h2><p>散列表的英文叫“Hash Table”，平时也叫它“哈希表”或者“<code>Hash</code> 表”，你一定也经常听过它，但是你是不是真的理解这种数据结构呢？</p><p><strong>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</strong></p><p>用一个例子来解释一下。假如有 <code>89</code> 名选手参加学校运动会。为了方便记录成绩，每个选手胸前都会贴上自己的参赛号码。这 <code>89</code> 名选手的编号依次是 <code>1</code> 到 <code>89</code>。现在希望编程实现这样一个功能，通过编号快速找到对应的选手信息。你会怎么做呢？</p><p>可以把这 <code>89</code> 名选手的信息放在数组里。编号为 <code>1</code> 的选手，放到数组中下标为 <code>1</code> 的位置；编号为 <code>2</code> 的选手，放到数组中下标为 <code>2</code> 的位置。以此类推，编号为 <code>k</code> 的选手放到数组中下标为 <code>k</code> 的位置。</p><p>因为参赛编号跟数组下标一一对应，当需要查询参赛编号为 <code>x</code> 的选手的时候，只需要将下标为 <code>x</code> 的数组元素取出来就可以了，时间复杂度就是 $O(1)$。这样按照编号查找选手信息，效率是不是很高？</p><p>实际上，这个例子已经用到了散列的思想。在这个例子里，参赛编号是自然数，并且与数组的下标形成一一映射，所以利用数组支持根据下标随机访问的时候，时间复杂度是 $O(1)$ 这一特性，就可以实现快速查找编号对应的选手信息。</p><p>你可能要说了，这个例子中蕴含的散列思想还不够明显，那来改造一下这个例子。</p><p>假设校长说，参赛编号不能设置得这么简单，要加上年级、班级这些更详细的信息，所以把编号的规则稍微修改了一下，用 <code>6</code> 位数字来表示。比如 <code>051167</code>，其中，前两位 <code>05</code> 表示年级，中间两位 <code>11</code> 表示班级，最后两位还是原来的编号 <code>1</code> 到 <code>89</code>。这个时候该如何存储选手信息，才能够支持通过编号来快速查找选手信息呢？</p><p>思路还是跟前面类似。尽管不能直接把编号作为数组下标，但可以截取参赛编号的后两位作为数组下标，来存取选手信息数据。当通过参赛编号查询选手信息的时候，用同样的方法，取参赛编号的后两位，作为数组下标，来读取数组中的数据。</p><p>这就是典型的散列思想。其中，参赛选手的编号叫作键（<code>key</code>）或者关键字。用它来标识一个选手。把参赛编号转化为数组下标的映射方法就叫作散列函数（或“<code>Hash</code> 函数”“哈希函数”），而散列函数计算得到的值就叫作散列值（或“<code>Hash</code> 值”“哈希值”）。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/19/04155210-da91-11e9-aeb5-dd57c0620d4c.png" srcset="/img/loading.gif" alt="image.png"><br>通过这个例子，可以总结出这样的规律：散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 $O(1)$ 的特性。通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当按照键值查询元素时，用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。</p><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>从上面的例子可以看到，散列函数在散列表中起着非常关键的作用。现在就来学习下散列函数。</p><p>散列函数，顾名思义，它是一个函数。可以把它定义成<code>hash(key)</code>，其中 <code>key</code> 表示元素的键值，<code>hash(key)</code> 的值表示经过散列函数计算得到的散列值。</p><p>那第一个例子中，编号就是数组下标，所以 <code>hash(key)</code> 就等于 <code>key</code>。改造后的例子，写成散列函数稍微有点复杂。用伪代码将它写成函数就是下面这样：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(String key)</span> </span>&#123;  <span class="hljs-comment">// 获取后两位字符</span>  <span class="hljs-built_in">string</span> lastTwoChars = key.substr(length<span class="hljs-number">-2</span>, length);  <span class="hljs-comment">// 将后两位字符转换为整数</span>  <span class="hljs-keyword">int</span> hashValue = convert lastTwoChas to <span class="hljs-keyword">int</span>-type;  <span class="hljs-keyword">return</span> hashValue;&#125;</code></pre><p>刚刚举的学校运动会的例子，散列函数比较简单，也比较容易想到。但是，如果参赛选手的编号是随机生成的 <code>6</code> 位数字，又或者用的是 <code>a</code> 到 <code>z</code> 之间的字符串，<strong>该如何构造散列函数呢？总结了三点散列函数设计的基本要求：</strong></p><ul><li><p>散列函数计算得到的散列值是一个非负整数；</p></li><li><p>如果 <code>key1 = key2</code>，那 <code>hash(key1) == hash(key2)</code>；</p></li><li><p>如果 <code>key1 ≠ key2</code>，那 <code>hash(key1) ≠ hash(key2)</code>。</p></li></ul><p>来解释一下这三点。其中，第一点理解起来应该没有任何问题。因为数组下标是从 <code>0</code> 开始的，所以散列函数生成的散列值也要是非负整数。第二点也很好理解。相同的 <code>key</code>，经过散列函数得到的散列值也应该是相同的。</p><p>第三点理解起来可能会有问题，着重说一下。这个要求看起来合情合理，但是在真实的情况下，要想找到一个不同的 <code>key</code> 对应的散列值都不一样的散列函数，几乎是不可能的。即便像业界著名的<code>MD5</code>、<code>SHA</code>、<code>CRC</code>等哈希算法，也无法完全避免这种<strong>散列冲突</strong>。而且，因为数组的存储空间有限，也会加大散列冲突的概率。</p><p>所以几乎无法找到一个完美的无冲突的散列函数，即便能找到，付出的时间成本、计算成本也是很大的，所以针对散列冲突问题，需要通过其他途径来解决。</p><h2 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h2><p>再好的散列函数也无法避免散列冲突。那究竟该如何解决散列冲突问题呢？常用的散列冲突解决方法有两类，<strong>开放寻址法</strong>（<code>open addressing</code>）和<strong>链表法</strong>（<code>chaining</code>）。</p><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>开放寻址法的核心思想是，如果出现了散列冲突，就重新探测一个空闲位置，将其插入。那如何重新探测新的位置呢？先讲一个比较简单的探测方法，线性探测（<code>Linear Probing</code>）。</p><p>当往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p><p>说的可能比较抽象，举一个例子具体给你说明一下。这里面黄色的色块表示空闲位置，橙色的色块表示已经存储了数据。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/19/2b0c2f50-da92-11e9-aeb5-dd57c0620d4c.png" srcset="/img/loading.gif" alt="image.png"><br>从图中可以看出，散列表的大小为 <code>10</code>，在元素 <code>x</code> 插入散列表之前，已经有 <code>6</code> 个元素插入到散列表中。<code>x</code> 经过 <code>Hash</code> 算法之后，被散列到位置下标为 <code>7</code> 的位置，但是这个位置已经有数据了，所以就产生了冲突。于是就顺序地往后一个一个找，看有没有空闲的位置，遍历到尾部都没有找到空闲的位置，于是再从表头开始找，直到找到空闲位置 <code>2</code>，于是将其插入到这个位置。</p><p>在散列表中查找元素的过程有点儿类似插入过程。通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/19/57013c90-da92-11e9-aeb5-dd57c0620d4c.png" srcset="/img/loading.gif" alt="image.png"><br>散列表跟数组一样，不仅支持插入、查找操作，还支持删除操作。对于使用线性探测法解决冲突的散列表，删除操作稍微有些特别。不能单纯地把要删除的元素设置为空。这是为什么呢？</p><p>还记得刚讲的查找操作吗？在查找的时候，一旦通过线性探测方法，找到一个空闲位置，就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。这个问题如何解决呢？</p><p>可以将删除的元素，特殊标记为 <code>deleted</code>。当线性探测查找的时候，遇到标记为 <code>deleted</code> 的空间，并不是停下来，而是继续往下探测。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/19/9688aa10-da92-11e9-aeb5-dd57c0620d4c.png" srcset="/img/loading.gif" alt="image.png"><br>你可能已经发现了，线性探测法其实存在很大问题。当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，可能需要探测整个散列表，所以最坏情况下的时间复杂度为 $O(n)$。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据。</p><p>对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，<strong>二次探测</strong>（<code>Quadratic probing</code>）和<strong>双重散列</strong>（<code>Double hashing</code>）。</p><p>所谓二次探测，跟线性探测很像，线性探测每次探测的步长是 <code>1</code>，那它探测的下标序列就是 $hash(key)+0$，$hash(key)+1$，$hash(key)+2$……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 $hash(key)+0$，$hash(key)+1^2$，$hash(key)+2^2$……</p><p>所谓双重散列，意思就是不仅要使用一个散列函数。使用一组散列函数 <code>hash1(key)</code>，<code>hash2(key)</code>，<code>hash3(key)</code>……先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p><p>不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，会尽可能保证散列表中有一定比例的空闲槽位。用<strong>装载因子</strong>（<code>load factor</code>）来表示空位的多少。</p><p>装载因子的计算公式是：</p><pre><code class="hljs plain">散列表的装载因子 &#x3D; 填入表中的元素个数 &#x2F; 散列表的长度</code></pre><p>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p><h3 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h3><p>链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。来看这个图，在散列表中，每个“桶（<code>bucket</code>）”或者“槽（<code>slot</code>）”会对应一条链表，所有散列值相同的元素都放到相同槽位对应的链表中。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/19/879f05d0-da9c-11e9-aeb5-dd57c0620d4c.png" srcset="/img/loading.gif" alt="image.png"><br>当插入的时候，只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 $O(1)$。当查找、删除一个元素时，同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。那查找或删除操作的时间复杂度是多少呢？</p><p>实际上，这两个操作的时间复杂度跟链表的长度 <code>k</code> 成正比，也就是 $O(k)$。对于散列比较均匀的散列函数来说，理论上讲，<code>k=n/m</code>，其中 <code>n</code> 表示散列中数据的个数，<code>m</code> 表示散列表中“槽”的个数。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面讲了一些比较基础、比较偏理论的散列表知识，包括散列表的由来、散列函数、散列冲突的解决方法。</p><p>散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。散列表两个核心问题是散列函数设计和散列冲突解决。散列冲突有两种常用的解决方法，开放寻址法和链表法。散列函数设计的好坏决定了散列冲突的概率，也就决定散列表的性能。</p><p>针对散列函数和散列冲突，上面只讲了一些基础的概念、方法，下一篇会更贴近实战、更加深入探讨这两个问题。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p><code>Word</code>文档中单词拼写检查功能是如何实现的？</p><blockquote><p>常用的英文单词有 <code>20</code> 万个左右，假设单词的平均长度是 <code>10</code> 个字母，平均一个单词占用 <code>10</code> 个字节的内存空间，那 <code>20</code> 万英文单词大约占 <code>2MB</code> 的存储空间，就算放大 <code>10</code> 倍也就是 <code>20MB</code>。对于现在的计算机来说，这个大小完全可以放在内存里面。所以可以用散列表来存储整个英文单词词典。</p><p>当用户输入某个英文单词时，拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，就可以轻松实现快速判断是否存在拼写错误。</p></blockquote></li><li><p>假设有<code>10</code>万条<code>URL</code>访问日志，如何按照访问次数给<code>URL</code>排序？</p><blockquote><p>遍历<code>10</code>万条数据，以<code>URL</code>为<code>key</code>，访问次数为<code>value</code>，存入散列表，同时记录下访问次数的最大值<code>K</code>，时间复杂度 $O(n)$。<br>如果 <code>K</code> 不是很大，可以使用桶排序，时间复杂度 $O(n)$。如果 <code>K</code> 非常大（比如大于 <code>10</code> 万），就使用快速排序，复杂度 $O(nlogn)$。</p></blockquote></li><li><p>有两个字符串数组，每个数组大约有<code>10</code>万条字符串，如何快速找出两个数组中相同的字符串？</p><blockquote><p>以第一个字符串数组构建散列表，<code>key</code> 为字符串，<code>value</code> 为出现次数。再遍历第二个字符串数组，以字符串为 <code>key</code> 在散列表中查找，如果 <code>value</code> 大于零，说明存在相同字符串。时间复杂度 $O(n)$。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>散列表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14.跳表</title>
    <link href="/passages/14/"/>
    <url>/passages/14/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>上两篇讲了二分查找算法。当时讲到，因为二分查找底层依赖的是数组随机访问的特性，所以只能用数组来实现。如果数据存储在链表中，就真的没法用二分查找算法了吗？</p><p>实际上，只需要对链表稍加改造，就可以支持类似“二分”的查找算法。把改造之后的数据结构叫作<strong>跳表</strong>（<code>Skip list</code>），也就是下面的内容。</p><p>跳表这种数据结构对你来说，可能会比较陌生，因为一般的数据结构和算法书籍里都不怎么会讲。但是它确实是一种各方面性能都比较优秀的<strong>动态数据结构</strong>，可以支持快速的插入、删除、查找操作，写起来也不复杂，甚至可以替代<strong>红黑树</strong>（<code>Red-black tree</code>）。</p><p><code>Redis</code> 中的有序集合（<code>Sorted Set</code>）就是用跳表来实现的。如果你有一定基础，应该知道红黑树也可以实现快速的插入、删除和查找操作。<font color='green'>那 <code>Redis</code> 为什么会选择用跳表来实现有序集合呢？</font> 为什么不用红黑树呢？</p><h2 id="如何理解跳表？"><a href="#如何理解跳表？" class="headerlink" title="如何理解跳表？"></a>如何理解<a href="https://time.geekbang.org/column/article/42896" target="_blank" rel="noopener">跳表</a>？</h2><p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 $O(n)$。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/17/4f194b80-d911-11e9-9f8f-f11c7654af16.png" srcset="/img/loading.gif" alt="image.png"><br>那怎么来提高查找效率呢？如果像图中那样，对链表建立一级“索引”，查找起来是不是就会更快一些呢？每两个结点提取一个结点到上一级，把抽出来的那一级叫作索引或索引层。你可以看下面的图。图中的 <code>down</code> 表示 <code>down</code> 指针，指向下一级结点。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/17/72e914a0-d911-11e9-9f8f-f11c7654af16.png" srcset="/img/loading.gif" alt="image.png"><br>如果现在要查找某个结点，比如 <code>16</code>。可以先在索引层遍历，当遍历到索引层中值为 <code>13</code> 的结点时，发现下一个结点是 <code>17</code>，那要查找的结点 <code>16</code> 肯定就在这两个结点之间。然后通过索引层结点的 <code>down</code> 指针，下降到原始链表这一层，继续遍历。这个时候，只需要再遍历 <code>2</code> 个结点，就可以找到值等于 <code>16</code> 的这个结点了。这样，原来如果要查找 <code>16</code>，需要遍历 <code>10</code> 个结点，现在只需要遍历 <code>7</code> 个结点。</p><p>从这个例子里，可以看出，<strong>加来一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了。</strong>那如果再加一级索引呢？效率会不会提升更多呢？</p><p>跟前面建立第一级索引的方式相似，在第一级索引的基础之上，每两个结点就抽出一个结点到第二级索引。现在再来查找 <code>16</code>，只需要遍历 <code>6</code> 个结点了，需要遍历的结点数量又减少了。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/17/b17a1430-d911-11e9-9f8f-f11c7654af16.png" srcset="/img/loading.gif" alt="image.png"><br>上面的例子数据量不大，所以即便加了两级索引，查找效率的提升也并不明显。为了让你能真切地感受索引提升查询效率。下面画了一个包含 <code>64</code> 个结点的链表，按照前面讲的这种思路，建立了五级索引。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/17/c2f33160-d911-11e9-9f8f-f11c7654af16.png" srcset="/img/loading.gif" alt="image.png"><br>从图中可以看出，原来没有索引的时候，查找 <code>62</code> 需要遍历 <code>62</code> 个结点，现在只需要遍历 <code>11</code> 个结点，速度是不是提高了很多？所以，当链表的长度 <code>n</code> 比较大时，比如 <code>1000</code>、<code>10000</code> 的时候，在构建索引之后，查找效率的提升就会非常明显。</p><p>前面的这种<strong>链表加多级索引的结构，就是跳表</strong>。通过例子给你展示了跳表是如何减少查询次数的，现在你应该比较清晰地知道，跳表确实是可以提高查询效率的。接下来，会定量地分析一下，用跳表查询到底有多快。</p><h2 id="用跳表查询到底有多快？"><a href="#用跳表查询到底有多快？" class="headerlink" title="用跳表查询到底有多快？"></a>用跳表查询到底有多快？</h2><p>算法的执行效率可以通过时间复杂度来度量，这里依旧可以用。在一个单链表中查询某个数据的时间复杂度是 $O(n)$。那在一个具有多级索引的跳表中，查询某个数据的时间复杂度是多少呢？</p><p>这个时间复杂度的分析方法比较难想到。把问题分解一下，先来看这样一个问题，如果链表里有 <code>n</code> 个结点，会有多少级索引呢？</p><p>按照刚才讲的，每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 <code>n/2</code>，第二级索引的结点个数大约就是 <code>n/4</code>，第三级索引的结点个数大约就是 <code>n/8</code>，依次类推，也就是说，<strong>第 <code>k</code> 级索引的结点个数是第 <code>k-1</code> 级索引的结点个数的 <code>1/2</code>，那第 <code>k</code> 级索引结点的个数就是 $n/(2^k)$。</strong></p><p>假设索引有 <code>h</code> 级，最高级的索引有 <code>2</code> 个结点。通过上面的公式，可以得到 $n/(2^h)=2$，从而求得 $h=log_2n-1$。如果包含原始链表这一层，整个跳表的高度就是 $log_2n$。在跳表中查询某个数据的时候，如果每一层都要遍历 <code>m</code> 个结点，那在跳表中查询一个数据的时间复杂度就是 $O(m*logn)$。</p><p>那这个 <code>m</code> 的值是多少呢？按照前面这种索引结构，每一级索引都最多只需要遍历 <code>3</code> 个结点，也就是说 <code>m=3</code>，为什么是 <code>3</code> 呢？下面解释一下。</p><p>假设要查找的数据是 <code>x</code>，在第 <code>k</code> 级索引中，遍历到 <code>y</code> 结点之后，发现 <code>x</code> 大于 <code>y</code>，小于后面的结点 <code>z</code>，所以通过 <code>y</code> 的 <code>down</code> 指针，从第 <code>k</code> 级索引下降到第 <code>k-1</code> 级索引。在第 <code>k-1</code> 级索引中，<code>y</code> 和 <code>z</code> 之间只有 <code>3</code> 个结点（包含 <code>y</code> 和 <code>z</code>），所以，在 <code>K-1</code> 级索引中最多只需要遍历 <code>3</code> 个结点，依次类推，每一级索引都最多只需要遍历 <code>3</code> 个结点。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/17/b8495ce0-d91f-11e9-9f8f-f11c7654af16.png" srcset="/img/loading.gif" alt="image.png"><br>通过上面的分析，得到 <code>m=3</code>，所以在跳表中查询任意数据的时间复杂度就是 $O(logn)$。这个查找的时间复杂度跟二分查找是一样的。换句话说，其实是基于单链表实现了二分查找，是不是很神奇？不过，天下没有免费的午餐，这种查询效率的提升，前提是建立了很多级索引，也就是之前提到过的空间换时间的设计思路。</p><h2 id="跳表是不是很浪费内存？"><a href="#跳表是不是很浪费内存？" class="headerlink" title="跳表是不是很浪费内存？"></a>跳表是不是很浪费内存？</h2><p>比起单纯的单链表，跳表需要存储多级索引，肯定要消耗更多的存储空间。那到底需要消耗多少额外的存储空间呢？下面分析一下跳表的空间复杂度。</p><p>跳表的空间复杂度分析并不难，在前面说了，假设原始链表大小为 <code>n</code>，那第一级索引大约有 <code>n/2</code> 个结点，第二级索引大约有 <code>n/4</code> 个结点，以此类推，每上升一级就减少一半，直到剩下 <code>2</code> 个结点。如果把每层索引的结点数写出来，就是一个等比数列。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/17/f6cffc30-d91f-11e9-9f8f-f11c7654af16.png" srcset="/img/loading.gif" alt="image.png"><br>这几级索引的结点总和就是 <code>n/2+n/4+n/8…+8+4+2=n-2</code>。所以，跳表的空间复杂度是 $O(n)$。也就是说，如果将包含 <code>n</code> 个结点的单链表构造成跳表，需要额外再用接近 <code>n</code> 个结点的存储空间。那有没有办法降低索引占用的内存空间呢？</p><p>前面都是每两个结点抽一个结点到上级索引，如果每三个结点或五个结点，抽一个结点到上级索引，是不是就不用那么多索引结点了呢？下面画了一个每三个结点抽一个的示意图，你可以看下。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/17/170a90a0-d920-11e9-9f8f-f11c7654af16.png" srcset="/img/loading.gif" alt="image.png"><br>从图中可以看出，第一级索引需要大约 <code>n/3</code> 个结点，第二级索引需要大约 <code>n/9</code> 个结点。每往上一级，索引结点个数都除以 <code>3</code>。为了方便计算，假设最高一级的索引结点个数是 <code>1</code>。把每级索引的结点个数都写下来，也是一个等比数列。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/17/6535bec0-d921-11e9-9f8f-f11c7654af16.png" srcset="/img/loading.gif" alt="image.png"><br>通过等比数列求和公式，总的索引结点大约就是 <code>n/3+n/9+n/27+…+9+3+1=n/2</code>。尽管空间复杂度还是 $O(n)$，但比上面的每两个结点抽一个结点的索引构建方法，要减少了一半的索引结点存储空间。</p><p>实际上，在软件开发中，不必太在意索引占用的额外空间。在讲数据结构和算法时，习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。</p><h2 id="高效的动态插入和删除"><a href="#高效的动态插入和删除" class="headerlink" title="高效的动态插入和删除"></a>高效的动态插入和删除</h2><p>跳表长什么样子你应该已经很清楚了，它的查找操作刚才也讲过了。实际上，跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 $O(logn)$。</p><p>现在来看下，如何在跳表中插入一个数据，以及它是如何做到 $O(logn)$ 的时间复杂度的？</p><p>在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，就是 $O(1)$。但是，这里为了保证原始链表中数据的有序性，需要先找到要插入的位置，这个查找操作就会比较耗时。</p><p>对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是，对于跳表来说，讲过查找某个结点的的时间复杂度是 $O(logn)$，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是 $O(logn)$。下面有一张图，你可以很清晰地看到插入的过程。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/17/bdd98c50-d921-11e9-9f8f-f11c7654af16.png" srcset="/img/loading.gif" alt="image.png"><br>好了，再来看删除操作。</p><p>如果这个结点在索引中也有出现，除了要删除原始链表中的结点，还要删除索引中的。因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所以在查找要删除的结点的时候，一定要获取前驱结点。当然，如果用的是双向链表，就不需要考虑这个问题了。</p><h2 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h2><p>当不停地往跳表中插入数据时，如果不更新索引，就有可能出现某 <code>2</code> 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/17/32d32820-d924-11e9-9f8f-f11c7654af16.png" srcset="/img/loading.gif" alt="image.png"><br>作为一种动态数据结构，需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。</p><p>如果你了解红黑树、<code>AVL</code> 树这样平衡二叉树，你就知道它们是通过左右旋的方式保持左右子树的大小平衡（后面会提到），而跳表是通过随机函数来维护前面提到的“平衡性”。</p><p>当往跳表中插入数据的时候，可以选择同时将这个数据插入到部分索引层中。如何选择加入哪些索引层呢？</p><p>通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 <code>K</code>，那就将这个结点添加到第一级到第 <code>K</code> 级这 <code>K</code> 级索引中。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/17/5a181ad0-d924-11e9-9f8f-f11c7654af16.png" srcset="/img/loading.gif" alt="image.png"><br>随机函数的选择很有讲究，从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。至于随机函数的选择，就不展开讲解了。如果你感兴趣的话，可以看看 <code>Redis</code> 中关于有序集合的跳表实现。</p><p>跳表的实现还是稍微有点复杂的，将 <code>Java</code> 实现的代码放到了文章最后，你可以根据刚刚的讲解，对照着代码仔细思考一下。你不用死记硬背代码，跳表的实现并不是这篇的重点。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面讲了跳表这种数据结构。跳表使用空间换时间的设计思路，通过构建多级索引来提高查询的效率，实现了基于链表的“二分查找”。跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是 $O(logn)$。</p><p>跳表的空间复杂度是 $O(n)$。不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。所以很多时候，为了代码的简单、易读，比起红黑树，更倾向用跳表。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>为什么 <code>Redis</code> 要用跳表来实现有序集合，而不是红黑树？</p><blockquote><p><code>Redis</code> 中的有序集合是通过跳表来实现的，严格点讲，其实还用到了散列表。<br>如果你去查看 <code>Redis</code> 的开发手册，就会发现，<code>Redis</code> 中的有序集合支持的核心操作主要有下面这几个：</p><ul><li>插入一个数据；</li><li>删除一个数据；</li><li>查找一个数据；</li><li>按照区间查找数据（比如查找值在 <code>[100, 356]</code> 之间的数据）；</li><li>迭代输出有序序列。</li></ul><p>其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。</p><p>对于按照区间查找数据这个操作，跳表可以做到 $O(logn)$ 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。</p><p>当然，<code>Redis</code> 之所以用跳表来实现有序集合，还有其他原因，比如，跳表更容易代码实现。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。</p><p>不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的 <code>Map</code> 类型都是通过红黑树来实现的。做业务开发的时候，直接拿来用就可以了，不用费劲自己去实现一个红黑树，但是跳表并没有一个现成的实现，所以在开发中，如果你想使用跳表，必须要自己实现。</p></blockquote></li><li><p>如果每三个或者五个结点提取一个结点作为上级索引，对应的在跳表中查询数据的时间复杂度是多少呢？</p><blockquote><p>如果每三个或者五个节点提取一个节点作为上级索引，那么对应的查询数据时间复杂度，也还是$O(logn)$。<br>假设每 <code>5</code> 个节点提取，那么最高一层有 <code>5</code> 个节点，而跳表高度为 $log5n$，每层最多需要查找 <code>5</code> 个节点，即 $O(mlogn)$ 中的 <code>m = 5</code>，最终，时间复杂度为 $O(logn)$。<br>空间复杂度也还是 $O(logn)$，虽然省去了一部分索引节点，但是似乎意义不大。</p></blockquote></li></ul><h2 id="跳表代码实现"><a href="#跳表代码实现" class="headerlink" title="跳表代码实现"></a>跳表代码实现</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> skiplist;<span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-comment">/** * 跳表的一种实现方法。 * 跳表中存储的是正整数，并且存储的是不重复的。 * */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipList</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_LEVEL = <span class="hljs-number">16</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> levelCount = <span class="hljs-number">1</span>;  <span class="hljs-keyword">private</span> Node head = <span class="hljs-keyword">new</span> Node();  <span class="hljs-comment">// 带头链表</span>  <span class="hljs-keyword">private</span> Random r = <span class="hljs-keyword">new</span> Random();  <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;    Node p = head;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = levelCount - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;      <span class="hljs-keyword">while</span> (p.forwards[i] != <span class="hljs-keyword">null</span> &amp;&amp; p.forwards[i].data &lt; value) &#123;        p = p.forwards[i];      &#125;    &#125;    <span class="hljs-keyword">if</span> (p.forwards[<span class="hljs-number">0</span>] != <span class="hljs-keyword">null</span> &amp;&amp; p.forwards[<span class="hljs-number">0</span>].data == value) &#123;      <span class="hljs-keyword">return</span> p.forwards[<span class="hljs-number">0</span>];    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;    <span class="hljs-keyword">int</span> level = randomLevel();    Node newNode = <span class="hljs-keyword">new</span> Node();    newNode.data = value;    newNode.maxLevel = level;    Node update[] = <span class="hljs-keyword">new</span> Node[level];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; level; ++i) &#123;      update[i] = head;    &#125;    <span class="hljs-comment">// record every level largest value which smaller than insert value in update[]</span>    Node p = head;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = level - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;      <span class="hljs-keyword">while</span> (p.forwards[i] != <span class="hljs-keyword">null</span> &amp;&amp; p.forwards[i].data &lt; value) &#123;        p = p.forwards[i];      &#125;      update[i] = p;<span class="hljs-comment">// use update save node in search path</span>    &#125;    <span class="hljs-comment">// in search path node next node become new node forwords(next)</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; level; ++i) &#123;      newNode.forwards[i] = update[i].forwards[i];      update[i].forwards[i] = newNode;    &#125;    <span class="hljs-comment">// update node hight</span>    <span class="hljs-keyword">if</span> (levelCount &lt; level) levelCount = level;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;    Node[] update = <span class="hljs-keyword">new</span> Node[levelCount];    Node p = head;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = levelCount - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;      <span class="hljs-keyword">while</span> (p.forwards[i] != <span class="hljs-keyword">null</span> &amp;&amp; p.forwards[i].data &lt; value) &#123;        p = p.forwards[i];      &#125;      update[i] = p;    &#125;    <span class="hljs-keyword">if</span> (p.forwards[<span class="hljs-number">0</span>] != <span class="hljs-keyword">null</span> &amp;&amp; p.forwards[<span class="hljs-number">0</span>].data == value) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = levelCount - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;        <span class="hljs-keyword">if</span> (update[i].forwards[i] != <span class="hljs-keyword">null</span> &amp;&amp; update[i].forwards[i].data == value) &#123;          update[i].forwards[i] = update[i].forwards[i].forwards[i];        &#125;      &#125;    &#125;  &#125;  <span class="hljs-comment">// 随机 level 次，如果是奇数层数 +1，防止伪随机</span> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">randomLevel</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> level = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; MAX_LEVEL; ++i) &#123;      <span class="hljs-keyword">if</span> (r.nextInt() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;        level++;      &#125;    &#125;    <span class="hljs-keyword">return</span> level;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printAll</span><span class="hljs-params">()</span> </span>&#123;    Node p = head;    <span class="hljs-keyword">while</span> (p.forwards[<span class="hljs-number">0</span>] != <span class="hljs-keyword">null</span>) &#123;      System.out.print(p.forwards[<span class="hljs-number">0</span>] + <span class="hljs-string">" "</span>);      p = p.forwards[<span class="hljs-number">0</span>];    &#125;    System.out.println();  &#125;  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">private</span> Node forwards[] = <span class="hljs-keyword">new</span> Node[MAX_LEVEL];    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxLevel = <span class="hljs-number">0</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();      builder.append(<span class="hljs-string">"&#123; data: "</span>);      builder.append(data);      builder.append(<span class="hljs-string">"; levels: "</span>);      builder.append(maxLevel);      builder.append(<span class="hljs-string">" &#125;"</span>);      <span class="hljs-keyword">return</span> builder.toString();    &#125;  &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>跳表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13.二分查找（下）</title>
    <link href="/passages/13/"/>
    <url>/passages/13/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>通过 <code>IP</code> 地址来查找 <code>IP</code> 归属地的功能，不知道你有没有用过？没用过也没关系，现在可以打开百度，在搜索框里随便输一个 <code>IP</code> 地址，就会看到它的归属地。</p><p>这个功能并不复杂，它是通过维护一个很大的 <code>IP</code> 地址库来实现的。地址库中包括 <code>IP</code> 地址范围和归属地的对应关系。</p><p>当想要查询 <code>202.102.133.13</code> 这个 <code>IP</code> 地址的归属地时，就在地址库中搜索，发现这个 <code>IP</code> 地址落在 <code>[202.102.133.0, 202.102.133.255]</code> 这个地址范围内，那就可以将这个 <code>IP</code> 地址范围对应的归属地“山东东营市”显示给用户了。</p><pre><code class="hljs plain">[202.102.133.0, 202.102.133.255]  山东东营市 [202.102.135.0, 202.102.136.255]  山东烟台 [202.102.156.34, 202.102.157.255] 山东青岛 [202.102.48.0, 202.102.48.255] 江苏宿迁 [202.102.49.15, 202.102.51.251] 江苏泰州 [202.102.56.0, 202.102.56.255] 江苏连云港</code></pre><p>现在的问题是，在庞大的地址库中逐一比对 <code>IP</code> 地址所在的区间，是非常耗时的。<font color='green'>假设有 <code>12</code> 万条这样的 <code>IP</code> 区间与归属地的对应关系，如何快速定位出一个 <code>IP</code> 地址的归属地呢？</font></p><p>不知道你有没有听过这样一个说法：“十个二分九个错”。二分查找虽然原理极其简单，但是想要写出没有 <code>Bug</code> 的二分查找并不容易。<br>唐纳德·克努特（<code>Donald E.Knuth</code>）在《计算机程序设计艺术》的第 <code>3</code> 卷《排序和查找》中说到：“尽管第一个二分查找算法于 <code>1946</code> 年出现，然而第一个完全正确的二分查找算法实现直到 <code>1962</code> 年才出现。”<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/17/e7d1ebc0-d90c-11e9-9f8f-f11c7654af16.png" srcset="/img/loading.gif" alt="image.png"><br>需要特别说明一点，为了简化讲解，下面的内容，都以数据是从小到大排列为前提，如果你要处理的数据是从大到小排列的，解决思路也是一样的。</p><h2 id="变体一：查找第一个值等于给定值的元素"><a href="#变体一：查找第一个值等于给定值的元素" class="headerlink" title="变体一：查找第一个值等于给定值的元素"></a>变体一：查找第一个值等于给定值的元素</h2><p>上一篇中的二分查找是最简单的一种，即有序数据集合中不存在重复的数据，在其中查找值等于某个给定值的数据。如果将这个问题稍微修改下，有序数据集合中存在重复的数据，希望找到第一个值等于给定值的数据，这样之前的二分查找代码还能继续工作吗？</p><p>比如下面这样一个有序数组，其中，<code>a[5]</code>，<code>a[6]</code>，<code>a[7]</code> 的值都等于 <code>8</code>，是重复的数据。希望查找第一个等于 <code>8</code> 的数据，也就是下标是 <code>5</code> 的元素。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/17/39001620-d90d-11e9-9f8f-f11c7654af16.png" srcset="/img/loading.gif" alt="image.png"><br>如果用上一篇的二分查找的代码实现，首先拿 <code>8</code> 与区间的中间值 <code>a[4]</code> 比较，<code>8</code> 比 <code>6</code> 大，于是在下标 <code>5</code> 到 <code>9</code> 之间继续查找。下标 <code>5</code> 和 <code>9</code> 的中间位置是下标 <code>7</code>，<code>a[7]</code> 正好等于 <code>8</code>，所以代码就返回了。</p><p>尽管 <code>a[7]</code> 也等于 <code>8</code>，但它并不是想要找的第一个等于 <code>8</code> 的元素，因为第一个值等于 <code>8</code> 的元素是数组下标为 <code>5</code> 的元素。上一篇的二分查找代码就无法处理这种情况了。所以，针对这个变形问题，可以稍微改造一下上一节的代码。</p><p><code>100</code> 个人写二分查找就会有 <code>100</code> 种写法。网上有很多关于变形二分查找的实现方法，有很多写得非常简洁，比如下面这个写法。但是，尽管简洁，理解起来却非常烧脑，也很容易写错。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> value)</span> </span>&#123;  <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;  <span class="hljs-keyword">int</span> high = n - <span class="hljs-number">1</span>;  <span class="hljs-keyword">while</span> (low &lt;= high) &#123;    <span class="hljs-keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (a[mid] &gt;= value) &#123;      high = mid - <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      low = mid + <span class="hljs-number">1</span>;    &#125;  &#125;  <span class="hljs-keyword">if</span> (low &lt; n &amp;&amp; a[low]==value) <span class="hljs-keyword">return</span> low;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre><p>看完这个实现之后，是不是觉得很不好理解？如果你只是死记硬背这个写法，我敢保证，过不了几天，你就会全都忘光，再让你写，<code>90%</code> 的可能会写错。所以，换了一种实现方法，你看看是不是更容易理解呢？</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> value)</span> </span>&#123;  <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;  <span class="hljs-keyword">int</span> high = n - <span class="hljs-number">1</span>;  <span class="hljs-keyword">while</span> (low &lt;= high) &#123;    <span class="hljs-keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (a[mid] &gt; value) &#123;      high = mid - <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[mid] &lt; value) &#123;      low = mid + <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">if</span> ((mid == <span class="hljs-number">0</span>) || (a[mid - <span class="hljs-number">1</span>] != value)) <span class="hljs-keyword">return</span> mid;      <span class="hljs-keyword">else</span> high = mid - <span class="hljs-number">1</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre><p>稍微解释一下这段代码。<code>a[mid]</code> 跟要查找的 <code>value</code> 的大小关系有三种情况：大于、小于、等于。对于 <code>a[mid]&gt;value</code> 的情况，需要更新 <code>high= mid-1</code>；对于 <code>a[mid]&lt;value</code> 的情况，需要更新 <code>low=mid+1</code>。这两点都很好理解。那当 <code>a[mid]=value</code> 的时候应该如何处理呢？</p><p>如果查找的是任意一个值等于给定值的元素，当 <code>a[mid]</code> 等于要查找的值时，<code>a[mid]</code> 就是要找的元素。但是，如果求解的是第一个值等于给定值的元素，当 <code>a[mid]</code> 等于要查找的值时，就需要确认一下这个 <code>a[mid]</code> 是不是第一个值等于给定值的元素。</p><p>重点看第 <code>11</code> 行代码。如果 <code>mid</code> 等于 <code>0</code>，那这个元素已经是数组的第一个元素，那它肯定是要找的；如果 <code>mid</code> 不等于 <code>0</code>，但 <code>a[mid]</code> 的前一个元素 <code>a[mid-1]</code> 不等于 <code>value</code>，那也说明 <code>a[mid]</code> 就是要找的第一个值等于给定值的元素。</p><p>如果经过检查之后发现 <code>a[mid]</code> 前面的一个元素 <code>a[mid-1]</code> 也等于 <code>value</code>，那说明此时的 <code>a[mid]</code> 肯定不是要查找的第一个值等于给定值的元素。那就更新 <code>high=mid-1</code>，因为要找的元素肯定出现在 <code>[low, mid-1]</code> 之间。</p><p>对比上面的两段代码，是不是下面那种更好理解？实际上，<strong>很多人都觉得变形的二分查找很难写，主要原因是太追求第一种那样完美、简洁的写法。</strong>而对于做工程开发的人来说，代码易读懂、没 <code>Bug</code>，其实更重要，所以我觉得第二种写法更好。</p><h2 id="变体二：查找最后一个值等于给定值的元素"><a href="#变体二：查找最后一个值等于给定值的元素" class="headerlink" title="变体二：查找最后一个值等于给定值的元素"></a>变体二：查找最后一个值等于给定值的元素</h2><p>前面的问题是查找第一个值等于给定值的元素，现在把问题稍微改一下，查找最后一个值等于给定值的元素，又该如何做呢？</p><p>如果掌握了前面的写法，那这个问题你应该很轻松就能解决。你可以先试着实现一下，然后跟下面的对比一下。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> value)</span> </span>&#123;  <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;  <span class="hljs-keyword">int</span> high = n - <span class="hljs-number">1</span>;  <span class="hljs-keyword">while</span> (low &lt;= high) &#123;    <span class="hljs-keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (a[mid] &gt; value) &#123;      high = mid - <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[mid] &lt; value) &#123;      low = mid + <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">if</span> ((mid == n - <span class="hljs-number">1</span>) || (a[mid + <span class="hljs-number">1</span>] != value)) <span class="hljs-keyword">return</span> mid;      <span class="hljs-keyword">else</span> low = mid + <span class="hljs-number">1</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre><p>还是重点看第 <code>11</code> 行代码。如果 <code>a[mid]</code> 这个元素已经是数组中的最后一个元素了，那它肯定是要找的；如果 <code>a[mid]</code> 的后一个元素 <code>a[mid+1]</code> 不等于 <code>value</code>，那也说明 <code>a[mid]</code> 就是要找的最后一个值等于给定值的元素。</p><p>如果经过检查之后，发现 <code>a[mid]</code> 后面的一个元素 <code>a[mid+1]</code> 也等于 <code>value</code>，那说明当前的这个 <code>a[mid]</code> 并不是最后一个值等于给定值的元素。就更新 <code>low=mid+1</code>，因为要找的元素肯定出现在 <code>[mid+1, high]</code> 之间。</p><h2 id="变体三：查找第一个大于等于给定值的元素"><a href="#变体三：查找第一个大于等于给定值的元素" class="headerlink" title="变体三：查找第一个大于等于给定值的元素"></a>变体三：查找第一个大于等于给定值的元素</h2><p>现在再来看另外一类变形问题。在有序数组中，查找第一个大于等于给定值的元素。比如，数组中存储的这样一个序列：<code>3，4，6，7，10</code>。如果查找第一个大于等于 <code>5</code> 的元素，那就是 <code>6</code>。</p><p>实际上，实现的思路跟前面的那两种变形问题的实现思路类似，代码写起来甚至更简洁。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> value)</span> </span>&#123;  <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;  <span class="hljs-keyword">int</span> high = n - <span class="hljs-number">1</span>;  <span class="hljs-keyword">while</span> (low &lt;= high) &#123;    <span class="hljs-keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (a[mid] &gt;= value) &#123;      <span class="hljs-keyword">if</span> ((mid == <span class="hljs-number">0</span>) || (a[mid - <span class="hljs-number">1</span>] &lt; value)) <span class="hljs-keyword">return</span> mid;      <span class="hljs-keyword">else</span> high = mid - <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      low = mid + <span class="hljs-number">1</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre><p>如果 <code>a[mid]</code> 小于要查找的值 <code>value</code>，那要查找的值肯定在 <code>[mid+1, high]</code> 之间，所以，更新 <code>low=mid+1</code>。</p><p>对于 <code>a[mid]</code> 大于等于给定值 <code>value</code> 的情况，要先看下这个 <code>a[mid]</code> 是不是要找的第一个值大于等于给定值的元素。如果 <code>a[mid]</code> 前面已经没有元素，或者前面一个元素小于要查找的值 <code>value</code>，那 <code>a[mid]</code> 就是要找的元素。这段逻辑对应的代码是第 <code>7</code> 行。</p><p>如果 <code>a[mid-1]</code> 也大于等于要查找的值 <code>value</code>，那说明要查找的元素在 <code>[low, mid-1]</code> 之间，所以，将 <code>high</code> 更新为 <code>mid-1</code>。</p><h2 id="变体四：查找最后一个小于等于给定值的元素"><a href="#变体四：查找最后一个小于等于给定值的元素" class="headerlink" title="变体四：查找最后一个小于等于给定值的元素"></a>变体四：查找最后一个小于等于给定值的元素</h2><p>现在，来看最后一种二分查找的变形问题，查找最后一个小于等于给定值的元素。比如，数组中存储了这样一组数据：<code>3，5，6，8，9，10</code>。最后一个小于等于 <code>7</code> 的元素就是 <code>6</code>。是不是有点类似上面那一种？实际上，实现思路也是一样的。</p><p>有了前面的基础，完全可以自己写出来了，所以就不详细分析了。把代码贴出来，你可以写完之后对比一下。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bsearch7</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> value)</span> </span>&#123;  <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;  <span class="hljs-keyword">int</span> high = n - <span class="hljs-number">1</span>;  <span class="hljs-keyword">while</span> (low &lt;= high) &#123;    <span class="hljs-keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (a[mid] &gt; value) &#123;      high = mid - <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">if</span> ((mid == n - <span class="hljs-number">1</span>) || (a[mid + <span class="hljs-number">1</span>] &gt; value)) <span class="hljs-keyword">return</span> mid;      <span class="hljs-keyword">else</span> low = mid + <span class="hljs-number">1</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>凡是用二分查找能解决的，绝大部分更倾向于用散列表或者二叉查找树。即便是二分查找在内存使用上更节省，但是毕竟内存如此紧缺的情况并不多。那二分查找真的没什么用处了吗？</p><p>实际上，上一篇的求“值等于给定值”的二分查找确实不怎么会被用到，二分查找更适合用在“近似”查找问题，在这类问题上，二分查找的优势更加明显。比如上面的这几种变体问题，用其他数据结构，比如散列表、二叉树，就比较难实现了。</p><p>变体的二分查找算法写起来非常烧脑，很容易因为细节处理不好而产生 <code>Bug</code>，这些容易出错的细节有：<strong>终止条件、区间上下界更新方法、返回值选择</strong>。所以上面的内容你最好能用自己实现一遍，对锻炼编码能力、逻辑思维、写出 <code>Bug free</code> 代码，会很有帮助。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>如何快速定位出一个 <code>IP</code> 地址的归属地？</p><blockquote><p> 现在这个问题应该很简单了。如果 <code>IP</code> 区间与归属地的对应关系不经常更新，可以先预处理这 <code>12</code> 万条数据，让其按照起始 <code>IP</code> 从小到大排序。如何来排序呢？<code>IP</code> 地址可以转化为 <code>32</code> 位的整型数。所以，可以将起始地址，按照对应的整型值的大小关系，从小到大进行排序。<br>  然后，这个问题就可以转化第四种变形问题“在有序数组中，查找最后一个小于等于某个给定值的元素”了。<br>  当要查询某个 <code>IP</code> 归属地时，可以先通过二分查找，找到最后一个起始 <code>IP</code> 小于等于这个 <code>IP</code> 的 <code>IP</code> 区间，然后，检查这个 <code>IP</code> 是否在这个 <code>IP</code> 区间内，如果在，就取出对应的归属地显示；如果不在，就返回未查找到。</p></blockquote></li><li><p>如果有序数组是一个循环有序数组，比如 <code>4，5，6，1，2，3</code>。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法呢？</p><blockquote><p>有三种方法查找循环有序数组</p><ul><li>一、</li></ul></blockquote><ul><li>找到分界下标，分成两个有序数组</li><li>判断目标值在哪个有序数据范围内，做二分查找<blockquote><ul><li>二、</li></ul></blockquote></li><li>找到最大值的下标 <code>x</code>;</li><li>所有元素下标 <code>+x</code> 偏移，超过数组范围值的取模;</li><li>利用偏移后的下标做二分查找；</li><li>如果找到目标下标，再作 <code>-x</code> 偏移，就是目标值实际下标。<br>两种情况最高时耗都在查找分界点上，所以时间复杂度是 $O(n)$。<br>复杂度有点高，能否优化呢？<blockquote><ul><li>三、<br>循环数组存在一个性质：以数组中间点为分区，会将数组分成一个有序数组和一个循环有序数组。<br>如果首元素小于 <code>mid</code>，说明前半部分是有序的，后半部分是循环有序数组；<br>如果首元素大于 <code>mid</code>，说明后半部分是有序的，前半部分是循环有序的数组；<br>如果目标元素在有序数组范围中，使用二分查找；<br>如果目标元素在循环有序数组中，设定数组边界后，使用以上方法继续查找。<br>时间复杂度为 $O(logn)$。</li></ul></blockquote></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12.二分查找（上）</title>
    <link href="/passages/12/"/>
    <url>/passages/12/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>二分查找（<code>Binary Search</code>）算法，也叫折半查找算法。二分查找的思想非常简单，很多非计算机专业的同学很容易就能理解，但是看似越简单的东西往往越难掌握好，想要灵活应用就更加困难。</p><p>假设有 <code>1000</code> 万个整数数据，每个数据占 <code>8</code> 个字节，<strong>如何设计数据结构和算法，快速判断某个整数是否出现在这 <code>1000</code> 万数据中？</strong> 希望这个功能不要占用太多的内存空间，最多不要超过 <code>100MB</code>，你会怎么做呢？</p><h2 id="无处不在的二分思想"><a href="#无处不在的二分思想" class="headerlink" title="无处不在的二分思想"></a>无处不在的二分思想</h2><p>二分查找是一种非常简单易懂的快速查找算法，生活中到处可见。比如说，现在来做一个猜字游戏。随机写一个 <code>0</code> 到 <code>99</code> 之间的数字，然后你来猜写的是什么。猜的过程中，你每猜一次，就会告诉你猜的大了还是小了，直到猜中为止。你来想想，如何快速猜中写的数字呢？</p><p>假设写的数字是 <code>23</code>，你可以按照下面的步骤来试一试。（如果猜测范围的数字有偶数个，中间数有两个，就选择较小的那个。）<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/16/711b4d00-d862-11e9-a455-5d284282074e.png" srcset="/img/loading.gif" alt="image.png"><br><code>7</code> 次就猜出来了，是不是很快？这个例子用的就是二分思想，按照这个思想，即便让你猜的是 <code>0</code> 到 <code>999</code> 的数字，最多也只要 <code>10</code> 次就能猜中。不信的话，你可以试一试。</p><p>这是一个生活中的例子，现在回到实际的开发场景中。假设有 <code>1000</code> 条订单数据，已经按照订单金额从小到大排序，每个订单金额都不同，并且最小单位是元。现在想知道是否存在金额等于 <code>19</code> 元的订单。如果存在，则返回订单数据，如果不存在则返回 <code>null</code>。</p><p>最简单的办法当然是从第一个订单开始，一个一个遍历这 <code>1000</code> 个订单，直到找到金额等于 <code>19</code> 元的订单为止。但这样查找会比较慢，最坏情况下，可能要遍历完这 <code>1000</code> 条记录才能找到。那用二分查找能不能更快速地解决呢？</p><p>为了方便讲解，假设只有 <code>10</code> 个订单，订单金额分别是：<code>8，11，19，23，27，33，45，55，67，98</code>。</p><p>还是利用二分思想，每次都与区间的中间数据比对大小，缩小查找区间的范围。为了更加直观，下面有一张查找过程的图。其中，<code>low</code> 和 <code>high</code> 表示待查找区间的下标，<code>mid</code> 表示待查找区间的中间元素下标。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/16/ae3b0950-d862-11e9-a455-5d284282074e.png" srcset="/img/loading.gif" alt="image.png"><br>看懂这两个例子，你现在对二分的思想应该掌握得妥妥的了。这里稍微总结升华一下，<strong>二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 <code>0</code>。</strong></p><h2 id="O-logn-惊人的查找速度"><a href="#O-logn-惊人的查找速度" class="headerlink" title="O(logn) 惊人的查找速度"></a>O(logn) 惊人的查找速度</h2><p>二分查找是一种非常高效的查找算法，高效到什么程度呢？来分析一下它的时间复杂度。</p><p>假设数据大小是 <code>n</code>，每次查找后数据都会缩小为原来的一半，也就是会除以 <code>2</code>。最坏情况下，直到查找区间被缩小为空，才停止。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/16/d95546f0-d862-11e9-a455-5d284282074e.png" srcset="/img/loading.gif" alt="image.png"></p><p>可以看出来，这是一个等比数列。其中 <code>n/2k=1</code> 时，<code>k</code> 的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以，经过了 <code>k</code> 次区间缩小操作，时间复杂度就是 $O(k)$。通过 <code>n/2k=1</code>，可以求得 <code>k=log2n</code>，所以时间复杂度就是 $O(logn)$。</p><p>二分查找是目前为止遇到的第一个时间复杂度为 $O(logn)$ 的算法。后面章节还会讲堆、二叉树的操作等等，它们的时间复杂度也是 $O(logn)$。这里就再深入地讲讲 $O(logn)$ 这种<strong>对数时间复杂度</strong>。这是一种极其高效的时间复杂度，有的时候甚至比时间复杂度是常量级 $O(1)$ 的算法还要高效。为什么这么说呢？</p><p>因为 <code>logn</code> 是一个非常“恐怖”的数量级，即便 <code>n</code> 非常非常大，对应的 <code>logn</code> 也很小。比如 <code>n</code> 等于 <code>2</code> 的 <code>32</code> 次方，这个数很大了吧？大约是 <code>42</code> 亿。也就是说，如果在 <code>42</code> 亿个数据中用二分查找一个数据，最多需要比较 <code>32</code> 次。</p><p>前面讲过，用大 $O$ 标记法表示时间复杂度的时候，会省略掉常数、系数和低阶。对于常量级时间复杂度的算法来说，$O(1)$ 有可能表示的是一个非常大的常量值，比如 $O(1000)$、$O(10000)$。所以，常量级时间复杂度的算法有时候可能还没有 $O(logn)$ 的算法执行效率高。</p><p>反过来，对数对应的就是指数。有一个非常著名的“阿基米德与国王下棋的故事”，你可以自行搜索一下，感受一下指数的“恐怖”。这也是为什么说，指数时间复杂度的算法在大规模数据面前是无效的。</p><h2 id="二分查找的递归与非递归实现"><a href="#二分查找的递归与非递归实现" class="headerlink" title="二分查找的递归与非递归实现"></a>二分查找的递归与非递归实现</h2><p>实际上，简单的二分查找并不难写，注意这里的“简单”二字。下一篇，会讲到二分查找的变体问题，那才是真正烧脑的。今天，来看如何来写最简单的二分查找。</p><p><strong>最简单的情况就是有序数组中不存在重复元素</strong>，在其中用二分查找值等于给定值的数据。用 <code>Java</code> 代码实现了一个最简单的二分查找算法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> value)</span> </span>&#123;  <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;  <span class="hljs-keyword">int</span> high = n - <span class="hljs-number">1</span>;  <span class="hljs-keyword">while</span> (low &lt;= high) &#123;    <span class="hljs-keyword">int</span> mid = (low + high) / <span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span> (a[mid] == value) &#123;      <span class="hljs-keyword">return</span> mid;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[mid] &lt; value) &#123;      low = mid + <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      high = mid - <span class="hljs-number">1</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre><p>这个代码稍微解释一下，<code>low</code>、<code>high</code>、<code>mid</code> 都是指数组下标，其中 <code>low</code> 和 <code>high</code> 表示当前查找的区间范围，初始 <code>low=0</code>，<code>high=n-1</code>。<code>mid</code> 表示 <code>[low, high]</code> 的中间位置。通过对比 <code>a[mid]</code> 与 <code>value</code> 的大小，来更新接下来要查找的区间范围，直到找到或者区间缩小为 <code>0</code>，就退出。如果你有一些编程基础，看懂这些应该不成问题。现在，就着重强调一下<strong>容易出错的 <code>3</code> 个地方</strong>。</p><p><strong>1. 循环退出条件</strong></p><p>注意是 low&lt;=high，而不是 low&lt;high。</p><p><strong>2. <code>mid</code> 的取值</strong></p><p>实际上，<code>mid=(low+high)/2</code> 这种写法是有问题的。因为如果 <code>low</code> 和 <code>high</code> 比较大的话，两者之和就有可能会溢出。改进的方法是将 <code>mid</code> 的计算方式写成 <code>low+(high-low)/2</code>。更进一步，如果要将性能优化到极致的话，可以将这里的除以 <code>2</code> 操作转化成位运算 <code>low+((high-low)&gt;&gt;1)</code>。因为相比除法运算来说，计算机处理位运算要快得多。</p><p><strong>3. <code>low</code> 和 <code>high</code> 的更新</strong></p><p><code>low=mid+1</code>，<code>high=mid-1</code>。注意这里的 <code>+1</code> 和 <code>-1</code>，如果直接写成 <code>low=mid</code> 或者 <code>high=mid</code>，就可能会发生死循环。比如，当 <code>high=3</code>，<code>low=3</code> 时，如果 <code>a[3]</code> 不等于 <code>value</code>，就会导致一直循环不退出。</p><p>如果你留意刚讲的这三点，一个简单的二分查找你已经可以实现了。<strong>实际上，二分查找除了用循环来实现，还可以用递归来实现，过程也非常简单</strong>。</p><p>用 <code>Java</code> 语言实现了一下这个过程，正好你可以借此机会回顾一下写递归代码的技巧。</p><pre><code class="hljs java"><span class="hljs-comment">// 二分查找的递归实现</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> val)</span> </span>&#123;  <span class="hljs-keyword">return</span> bsearchInternally(a, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, val);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bsearchInternally</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-keyword">int</span> value)</span> </span>&#123;  <span class="hljs-keyword">if</span> (low &gt; high) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <span class="hljs-keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);  <span class="hljs-keyword">if</span> (a[mid] == value) &#123;    <span class="hljs-keyword">return</span> mid;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[mid] &lt; value) &#123;    <span class="hljs-keyword">return</span> bsearchInternally(a, mid+<span class="hljs-number">1</span>, high, value);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> bsearchInternally(a, low, mid-<span class="hljs-number">1</span>, value);  &#125;&#125;</code></pre><h2 id="二分查找应用场景的局限性"><a href="#二分查找应用场景的局限性" class="headerlink" title="二分查找应用场景的局限性"></a>二分查找应用场景的局限性</h2><p>前面分析过，二分查找的时间复杂度是 $O(logn)$，查找数据的效率非常高。不过，并不是什么情况下都可以用二分查找，它的应用场景是有很大局限性的。那什么情况下适合用二分查找，什么情况下不适合呢？</p><p><strong>首先，二分查找依赖的是顺序表结构，简单点说就是数组。</strong></p><p>那二分查找能否依赖其他数据结构呢？比如链表。答案是不可以的，主要原因是二分查找算法需要按照下标随机访问元素。在数组和链表那两节讲过，数组按照下标随机访问数据的时间复杂度是 $O(1)$，而链表随机访问的时间复杂度是 $O(n)$。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。</p><p>二分查找只能用在数据是通过顺序表来存储的数据结构上。如果你的数据是通过其他数据结构存储的，则无法应用二分查找。</p><p><strong>其次，二分查找针对的是有序数据。</strong></p><p>二分查找对这一点的要求比较苛刻，数据必须是有序的。如果数据没有序，需要先排序。前面章节里讲到，排序的时间复杂度最低是 $O(nlogn)$。所以，如果针对的是一组静态的数据，没有频繁地插入、删除，可以进行一次排序，多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。</p><p>但是，如果的数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。</p><p>所以，二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用。那针对动态数据集合，如何在其中快速查找某个数据呢？等到二叉树那一篇会详细讲。</p><p><strong>再次，数据量太小不适合二分查找。</strong></p><p>如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如在一个大小为 <code>10</code> 的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多。只有数据量比较大的时候，二分查找的优势才会比较明显。</p><p>不过，这里有一个例外。如果数据之间的比较操作非常耗时，不管数据量大小，都推荐使用二分查找。比如，数组中存储的都是长度超过 <code>300</code> 的字符串，如此长的两个字符串之间比对大小，就会非常耗时。需要尽可能地减少比较次数，而比较次数的减少会大大提高性能，这个时候二分查找就比顺序遍历更有优势。</p><p><strong>最后，数据量太大也不适合二分查找。</strong></p><p>二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如，有 <code>1GB</code> 大小的数据，如果希望用数组来存储，那就需要 <code>1GB</code> 的连续内存空间。</p><p>注意这里的“连续”二字，也就是说，即便有 <code>2GB</code> 的内存空间剩余，但是如果这剩余的 <code>2GB</code> 内存空间都是零散的，没有连续的 <code>1GB</code> 大小的内存空间，那照样无法申请一个 <code>1GB</code> 大小的数组。而二分查找是作用在数组这种数据结构之上的，所以太大的数据用数组存储就比较吃力了，也就不能用二分查找了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面学习了一种针对有序数据的高效查找算法，二分查找，它的时间复杂度是 $O(logn)$。</p><p>二分查找的核心思想理解起来非常简单，有点类似分治思想。即每次都通过跟区间中的中间元素对比，将待查找的区间缩小为一半，直到找到要查找的元素，或者区间被缩小为 <code>0</code>。但是二分查找的代码实现比较容易写错。你需要着重掌握它的三个容易出错的地方：循环退出条件、<code>mid</code> 的取值，<code>low</code> 和 <code>high</code> 的更新。</p><p>二分查找虽然性能比较优秀，但应用场景也比较有限。底层必须依赖数组，并且还要求数据是有序的。对于较小规模的数据查找，直接使用顺序遍历就可以了，二分查找的优势并不明显。二分查找更适合处理静态数据，也就是没有频繁的数据插入、删除操作。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>如何在 <code>1000</code> 万个整数中快速查找某个整数？</p><blockquote><p>这个问题并不难。内存限制是 <code>100MB</code>，每个数据大小是 <code>8</code> 字节，最简单的办法就是将数据存储在数组中，内存占用差不多是 <code>80MB</code>，符合内存的限制。借助上面的内容，可以先对这 <code>1000</code> 万数据从小到大排序，然后再利用二分查找算法，就可以快速地查找想要的数据了。</p><p>看起来这个问题并不难，很轻松就能解决。实际上，它暗藏了“玄机”。如果你对数据结构和算法有一定了解，知道散列表、二叉树这些支持快速查找的动态数据结构。你可能会觉得，用散列表和二叉树也可以解决这个问题。实际上是不行的。</p><p>虽然大部分情况下，用二分查找可以解决的问题，用散列表、二叉树都可以解决。但是，后面会讲，不管是散列表还是二叉树，都会需要比较多的额外的内存空间。如果用散列表或者二叉树来存储这 <code>1000</code> 万的数据，用 <code>100MB</code> 的内存肯定是存不下的。而二分查找底层依赖的是数组，除了数据本身之外，不需要额外存储其他信息，是最省内存空间的存储方式，所以刚好能在限定的内存大小下解决这个问题。</p></blockquote></li><li><p>如果数据使用链表存储，二分查找的时间复杂就会变得很高，那查找的时间复杂度究竟是多少呢？</p><blockquote><p>假设链表长度为<code>n</code>，二分查找每次都要找到中间点(计算中忽略奇偶数差异):<br> 第一次查找中间点，需要移动指针<code>n/2</code>次；<br> 第二次，需要移动指针<code>n/4</code>次；<br> 第三次需要移动指针<code>n/8</code>次；<br> ……<br> 以此类推，一直到<code>1</code>次为值<br> 总共指针移动次数(查找次数) = <code>n/2 + n/4 + n/8 + ...+ 1</code>，这显然是个等比数列，根据等比数列求和公式：<code>Sum = n - 1</code>.<br> 最后算法时间复杂度是：$O(n-1)$，忽略常数，记为$O(n)$，时间复杂度和顺序查找时间复杂度相同<br> 但是稍微思考下，在二分查找的时候，由于要进行多余的运算，严格来说，会比顺序查找时间慢</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11.排序优化</title>
    <link href="/passages/11/"/>
    <url>/passages/11/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><p>几乎所有的编程语言都会提供排序函数，比如 <code>C</code> 语言中 <code>qsort()</code>，<code>C++ STL</code> 中的 <code>sort()</code>、<code>stable_sort()</code>，还有 <code>Java</code> 语言中的 <code>Collections.sort()</code>。在平时的开发中，也都是直接使用这些现成的函数来实现业务逻辑中的排序功能。那你知道这些排序函数是如何实现的吗？底层都利用了哪种排序算法呢？</p><h2 id="如何选择合适的排序算法"><a href="#如何选择合适的排序算法" class="headerlink" title="如何选择合适的排序算法"></a>如何选择合适的排序算法</h2><p>如果要实现一个通用的、高效率的排序函数，应该选择哪种排序算法？先回顾一下前面讲的几种排序算法。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/16/2cc2cc40-d85e-11e9-a455-5d284282074e.png" srcset="/img/loading.gif" alt="image.png"><br>前面讲过，线性排序算法的时间复杂度比较低，适用场景比较特殊。所以如果要写一个通用的排序函数，不能选择线性排序算法。</p><p>如果对小规模数据进行排序，可以选择时间复杂度是 $O(n^2)$ 的算法；如果对大规模数据进行排序，时间复杂度是 $O(nlogn)$ 的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 $O(nlogn)$ 的排序算法来实现排序函数。</p><p>时间复杂度是 $O(nlogn)$ 的排序算法不止一个，已经讲的有归并排序、快速排序，后面还会提到堆排序。堆排序和快速排序都有比较多的应用，比如 <code>Java</code> 语言采用堆排序实现排序函数，<code>C</code> 语言使用快速排序实现排序函数。</p><p>不知道你有没有发现，使用归并排序的情况其实并不多。快排在最坏情况下的时间复杂度是 $O(n^2)$，而归并排序可以做到平均情况、最坏情况下的时间复杂度都是 $O(nlogn)$，从这点上看起来很诱人，那为什么它还是没能得到“宠信”呢？</p><p>还记得上一篇讲的归并排序的空间复杂度吗？归并排序并不是原地排序算法，空间复杂度是 $O(n)$。所以，粗略点、夸张点讲，如果要排序 <code>100MB</code> 的数据，除了数据本身占用的内存之外，排序算法还要额外再占用 <code>100MB</code> 的内存空间，空间耗费就翻倍了。</p><p>前面讲到，快速排序比较适合来实现排序函数，但是，快速排序在最坏情况下的时间复杂度是 $O(n^2)$，如何来解决这个“复杂度恶化”的问题呢？</p><h2 id="如何优化快速排序？"><a href="#如何优化快速排序？" class="headerlink" title="如何优化快速排序？"></a>如何优化快速排序？</h2><p>先来看下，为什么最坏情况下快速排序的时间复杂度是 $O(n^2)$ 呢？前面讲过，如果数据原来就是有序的或者接近有序的，每次分区点都选择最后一个数据，那快速排序算法就会变得非常糟糕，时间复杂度就会退化为 $O(n^2)$。实际上，这种 $O(n^2)$ 时间复杂度出现的主要原因还是因为分区点选的不够合理。</p><p>那什么样的分区点是好的分区点呢？或者说如何来选择分区点呢？</p><p>最理想的分区点是：<strong>被分区点分开的两个分区中，数据的数量差不多。</strong></p><p>如果很粗暴地直接选择第一个或者最后一个数据作为分区点，不考虑数据的特点，肯定会出现之前讲的那样，在某些情况下，排序的最坏情况时间复杂度是 $O(n^2)$。为了提高排序算法的性能，也要尽可能地让每次分区都比较平均。</p><p>这里介绍两个比较常用、比较简单的分区算法，你可以直观地感受一下。</p><p><strong>1. 三数取中法</strong></p><p>从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 <code>3</code> 个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。</p><p><strong>2. 随机法</strong></p><p>随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选的很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的 $O(n^2)$ 的情况，出现的可能性不大。</p><p>这里也只是抛砖引玉，如果想了解更多寻找分区点的方法，可以自己课下深入去学习一下。</p><p>快速排序是用递归来实现的。在递归那一节讲过，递归要警惕堆栈溢出。为了避免快速排序里，递归过深而堆栈过小，导致堆栈溢出，有两种解决办法：第一种是限制递归深度。一旦递归过深，超过了事先设定的阈值，就停止递归。第二种是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。</p><h2 id="举例分析排序函数"><a href="#举例分析排序函数" class="headerlink" title="举例分析排序函数"></a>举例分析排序函数</h2><p>这里拿 <code>Glibc</code> 中的 <code>qsort()</code> 函数举例说明一下。虽说 <code>qsort()</code> 从名字上看，很像是基于快速排序算法实现的，实际上它并不仅仅用了快排这一种算法。</p><p>如果你去看源码，你就会发现，<strong><code>qsort()</code> 会优先使用归并排序来排序输入数据</strong>，因为归并排序的空间复杂度是 $O(n)$，所以对于小数据量的排序，比如 <code>1KB</code>、<code>2KB</code> 等，归并排序额外需要 <code>1KB</code>、<code>2KB</code> 的内存空间，这个问题不大。现在计算机的内存都挺大的，很多时候追求的是速度。还记得前面讲过的用空间换时间的技巧吗？这就是一个典型的应用。</p><p>但如果数据量太大，就跟前面提到的，排序 <code>100MB</code> 的数据，这个时候再用归并排序就不合适了。所以，<strong>要排序的数据量比较大的时候，<code>qsort()</code> 会改为用快速排序算法来排序。</strong></p><p>那 <code>qsort()</code> 是如何选择快速排序算法的分区点的呢？如果去看源码，你就会发现，<code>qsort()</code> 选择分区点的方法就是“三数取中法”。是不是也并不复杂？</p><p>还有前面提到的递归太深会导致堆栈溢出的问题，<code>qsort()</code> 是通过自己实现一个堆上的栈，手动模拟递归来解决的。</p><p>实际上，<code>qsort()</code> 并不仅仅用到了归并排序和快速排序，它还用到了插入排序。在快速排序的过程中，当要排序的区间中，元素的个数小于等于 <code>4</code> 时，<code>qsort()</code> 就退化为插入排序，不再继续用递归来做快速排序，因为前面也讲过，在小规模数据面前，<strong>$O(n^2)$ 时间复杂度的算法并不一定比 $O(nlogn)$ 的算法执行时间长。</strong>现在就来分析下这个说法。</p><p>在讲复杂度分析的时候讲过，算法的性能可以通过时间复杂度来分析，但是，这种复杂度分析是比较偏理论的，如果深究的话，实际上时间复杂度并不等于代码实际的运行时间。</p><p>时间复杂度代表的是一个增长趋势，如果画成增长曲线图，你会发现 $O(n^2)$ 比 $O(nlogn)$ 要陡峭，也就是说增长趋势要更猛一些。但是，前面讲过，在大 $O$ 复杂度表示法中，会省略低阶、系数和常数，也就是说，$O(nlogn)$ 在没有省略低阶、系数、常数之前可能是 $O(knlogn + c)$，而且 <code>k</code> 和 <code>c</code> 有可能还是一个比较大的数。</p><p>假设 <code>k=1000</code>，<code>c=200</code>，当对小规模数据（比如 <code>n=100</code>）排序时，$n^2$的值实际上比 $knlogn+c$ 还要小。</p><pre><code class="hljs plain">knlogn+c &#x3D; 1000 * 100 * log100 + 200 远大于 10000n^2 &#x3D; 100*100 &#x3D; 10000</code></pre><p>所以，对于小规模数据的排序，$O(n^2)$ 的排序算法并不一定比 $O(nlogn)$ 排序算法执行的时间长。对于小数据量的排序，选择比较简单、不需要递归的插入排序算法。</p><p>还记得之前讲到的哨兵来简化代码，提高执行效率吗？在 <code>qsort()</code> 插入排序的算法实现中，也利用了这种编程技巧。虽然哨兵可能只是少做一次判断，但是毕竟排序函数是非常常用、非常基础的函数，性能的优化要做到极致。</p><p><code>C</code> 语言的 <code>qsort()</code> 已经分析完了，你有没有觉得其实也不是很难？基本上都是用了前面的知识点，有了前面的知识积累，看一些底层的类库的时候是不是也更容易了呢？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上文分析了一下如何来实现一个工业级的通用的、高效的排序函数，内容比较偏实战，而且贯穿了一些前面几节的内容。大部分排序函数都是采用 $O(nlogn)$ 排序算法来实现，但是为了尽可能地提高性能，会做很多优化。</p><p>还着重讲了快速排序的一些优化策略，比如合理选择分区点、避免递归太深等等。最后，还分析了一个 <code>C</code> 语言中 <code>qsort()</code> 的底层实现原理，希望你对此能有一个更加直观的感受。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>你能否分析一下你所熟悉的语言中的排序函数都是用什么排序算法实现的呢？都有哪些优化技巧？</li></ul><p>欢迎留言和我分享。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10.线性排序</title>
    <link href="/passages/10/"/>
    <url>/passages/10/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>桶排序、计数排序、基数排序，这些排序算法的时间复杂度是线性的，所以把这类排序算法叫作<strong>线性排序</strong>（<code>Linear sort</code>）。之所以能做到线性的时间复杂度，主要原因是，这三个算法是非基于比较的排序算法，都不涉及元素之间的比较操作。</p><p>这几种排序算法理解起来都不难，时间、空间复杂度分析起来也很简单，但是对要排序的数据要求很苛刻，所以今天重点的是掌握这些排序算法的适用场景。</p><p>按照惯例，先给出一道思考题：如何根据年龄给 <code>100</code> 万用户排序？你可能会说，用归并、快排就可以搞定啊！是的，它们也可以完成功能，但是时间复杂度最低也是 $O(nlogn)$。有没有更快的排序方法呢？</p><h2 id="桶排序（Bucket-sort）"><a href="#桶排序（Bucket-sort）" class="headerlink" title="桶排序（Bucket sort）"></a>桶排序（Bucket sort）</h2><p>桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/12/d8e6c130-d542-11e9-98af-f301859595e1.png" srcset="/img/loading.gif" alt="image.png"><br>桶排序的时间复杂度为什么是 $O(n)$ 呢？一块儿来分析一下。</p><p>如果要排序的数据有 <code>n</code> 个，把它们均匀地划分到 <code>m</code> 个桶内，每个桶里就有 <code>k=n/m</code> 个元素。每个桶内部使用快速排序，时间复杂度为 $O(k * logk)$。<code>m</code> 个桶排序的时间复杂度就是 $O(m * k * logk)$，因为 <code>k=n/m</code>，所以整个桶排序的时间复杂度就是 $O(n * log(\frac n m))$。当桶的个数 <code>m</code> 接近数据个数 <code>n</code> 时，$log(\frac n m)$ 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 $O(n)$。</p><p><strong>桶排序看起来很优秀，那它是不是可以替代之前讲的排序算法呢？</strong></p><p>答案当然是否定的。为了轻松理解桶排序的核心思想，刚才做了很多假设。实际上，桶排序对要排序数据的要求是非常苛刻的。</p><p>首先，要排序的数据需要很容易就能划分成 <code>m</code> 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。</p><p>其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 $O(nlogn)$ 的排序算法了。</p><p><strong>桶排序比较适合用在外部排序中</strong>。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p><p>比如说有 <code>10GB</code> 的订单数据，希望按订单金额（假设金额都是正整数）进行排序，但是内存有限，只有几百 <code>MB</code>，没办法一次性把 <code>10GB</code> 的数据都加载到内存中。这个时候该怎么办呢？</p><p>下面来讲一下，如何借助桶排序的处理思想来解决这个问题。</p><p>可以先扫描一遍文件，看订单金额所处的数据范围。假设经过扫描之后得到，订单金额最小是 <code>1</code> 元，最大是 <code>10</code> 万元。将所有订单根据金额划分到 <code>100</code> 个桶里，第一个桶存储金额在 <code>1</code> 元到 <code>1000</code> 元之内的订单，第二个桶存储金额在 <code>1001</code> 元到 <code>2000</code> 元之内的订单，以此类推。每一个桶对应一个文件，并且按照金额范围的大小顺序编号命名（<code>00</code>，<code>01</code>，<code>02</code>…<code>99</code>）。</p><p>理想的情况下，如果订单金额在 <code>1</code> 到 <code>10</code> 万之间均匀分布，那订单会被均匀划分到 <code>100</code> 个文件中，每个小文件中存储大约 <code>100MB</code> 的订单数据，就可以将这 <code>100</code> 个小文件依次放到内存中，用快排来排序。等所有文件都排好序之后，只需要按照文件编号，从小到大依次读取每个小文件中的订单数据，并将其写入到一个文件中，那这个文件中存储的就是按照金额从小到大排序的订单数据了。</p><p>不过，你可能也发现了，订单按照金额在 <code>1</code> 元到 <code>10</code> 万元之间并不一定是均匀分布的 ，所以 <code>10GB</code> 订单数据是无法均匀地被划分到 <code>100</code> 个文件中的。有可能某个金额区间的数据特别多，划分之后对应的文件就会很大，没法一次性读入内存。这又该怎么办呢？</p><p>针对这些划分之后还是比较大的文件，可以继续划分，比如，订单金额在 <code>1</code> 元到 <code>1000</code> 元之间的比较多，就将这个区间继续划分为 <code>10</code> 个小区间，<code>1</code> 元到 <code>100</code> 元，<code>101</code> 元到 <code>200</code> 元，<code>201</code> 元到 <code>300</code> 元…<code>901</code> 元到 <code>1000</code> 元。如果划分之后，<code>101</code> 元到 <code>200</code> 元之间的订单还是太多，无法一次性读入内存，那就继续再划分，直到所有的文件都能读入内存为止。</p><h2 id="计数排序（Counting-sort）"><a href="#计数排序（Counting-sort）" class="headerlink" title="计数排序（Counting sort）"></a>计数排序（Counting sort）</h2><p>个人觉得，计数排序其实是桶排序的一种特殊情况。当要排序的 <code>n</code> 个数据，所处的范围并不大的时候，比如最大值是 <code>k</code>，就可以把数据划分成 <code>k</code> 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p><p>都经历过高考，高考查分数系统你还记得吗？查分数的时候，系统会显示成绩以及所在省的排名。如果你所在的省有 <code>50</code> 万考生，如何通过成绩快速排序得出名次呢？</p><p>考生的满分是 <code>900</code> 分，最小是 <code>0</code> 分，这个数据的范围很小，所以可以分成 <code>901</code> 个桶，对应分数从 <code>0</code> 分到 <code>900</code> 分。根据考生的成绩，将这 <code>50</code> 万考生划分到这 <code>901</code> 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 <code>50</code> 万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是 $O(n)$。</p><p>计数排序的算法思想就是这么简单，跟桶排序非常类似，只是桶的大小粒度不一样。不过，<strong>为什么这个排序算法叫“计数”排序呢？“计数”的含义来自哪里呢？</strong></p><p>想弄明白这个问题，就要来看计数排序算法的实现方法。还拿考生那个例子来解释。为了方便说明，对数据规模做了简化。假设只有 <code>8</code> 个考生，分数在 <code>0</code> 到 <code>5</code> 分之间。这 <code>8</code> 个考生的成绩放在一个数组 <code>A[8]</code> 中，它们分别是：<code>2</code>，<code>5</code>，<code>3</code>，<code>0</code>，<code>2</code>，<code>3</code>，<code>0</code>，<code>3</code>。</p><p>考生的成绩从 <code>0</code> 到 <code>5</code> 分，使用大小为 <code>6</code> 的数组 <code>C[6]</code> 表示桶，其中下标对应分数。不过，<code>C[6]</code> 内存储的并不是考生，而是对应的考生个数。像刚刚举的那个例子，只需要遍历一遍考生分数，就可以得到 <code>C[6]</code> 的值。</p><p>从图中可以看出，分数为 <code>3</code> 分的考生有 <code>3</code> 个，小于 <code>3</code> 分的考生有 <code>4</code> 个，所以，成绩为 <code>3</code> 分的考生在排序之后的有序数组 <code>R[8]</code> 中，会保存下标 <code>4</code>，<code>5</code>，<code>6</code> 的位置。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/12/af12ad40-d544-11e9-98af-f301859595e1.png" srcset="/img/loading.gif" alt="image.png"><br>那如何快速计算出，每个分数的考生在有序数组中对应的存储位置呢？这个处理方法非常巧妙，很不容易想到。</p><p>思路是这样的：对 <code>C[6]</code> 数组顺序求和，<code>C[6]</code> 存储的数据就变成了下面这样子。<code>C[k]</code> 里存储小于等于分数 <code>k</code> 的考生个数。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/12/c8457b80-d544-11e9-98af-f301859595e1.png" srcset="/img/loading.gif" alt="image.png"><br>有了前面的数据准备之后，现在就要讲计数排序中最复杂、最难理解的一部分了！</p><p>从后到前依次扫描数组 <code>A</code>。比如，当扫描到 <code>3</code> 时，可以从数组 <code>C</code> 中取出下标为 <code>3</code> 的值 <code>7</code>，也就是说，到目前为止，包括自己在内，分数小于等于 <code>3</code> 的考生有 <code>7</code> 个，也就是说 <code>3</code> 是数组 <code>R</code> 中的第 <code>7</code> 个元素（也就是数组 <code>R</code> 中下标为 <code>6</code> 的位置）。当 <code>3</code> 放入到数组 <code>R</code> 中后，小于等于 <code>3</code> 的元素就只剩下了 <code>6</code> 个了，所以相应的 <code>C[3]</code> 要减 <code>1</code>，变成 <code>6</code>。</p><p>以此类推，当扫描到第 <code>2</code> 个分数为 <code>3</code> 的考生的时候，就会把它放入数组 <code>R</code> 中的第 <code>6</code> 个元素的位置（也就是下标为 <code>5</code> 的位置）。当扫描完整个数组 <code>A</code> 后，数组 <code>R</code> 内的数据就是按照分数从小到大有序排列的了。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/12/1a03d7f0-d545-11e9-98af-f301859595e1.png" srcset="/img/loading.gif" alt="image.png"><br>上面的过程有点复杂，写成了代码，你可以对照着看下。</p><pre><code class="hljs java"><span class="hljs-comment">// 计数排序，a 是数组，n 是数组大小。假设数组中存储的都是非负整数。</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countingSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 查找数组中数据的范围</span>  <span class="hljs-keyword">int</span> max = a[<span class="hljs-number">0</span>];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;    <span class="hljs-keyword">if</span> (max &lt; a[i]) &#123;      max = a[i];    &#125;  &#125;  <span class="hljs-keyword">int</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[max + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 申请一个计数数组 c，下标大小 [0,max]</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= max; ++i) &#123;    c[i] = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-comment">// 计算每个元素的个数，放入 c 中</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;    c[a[i]]++;  &#125;  <span class="hljs-comment">// 依次累加</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= max; ++i) &#123;    c[i] = c[i-<span class="hljs-number">1</span>] + c[i];  &#125;  <span class="hljs-comment">// 临时数组 r，存储排序之后的结果</span>  <span class="hljs-keyword">int</span>[] r = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];  <span class="hljs-comment">// 计算排序的关键步骤，有点难理解</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;    <span class="hljs-keyword">int</span> index = c[a[i]]-<span class="hljs-number">1</span>;    r[index] = a[i];    c[a[i]]--;  &#125;  <span class="hljs-comment">// 将结果拷贝给 a 数组</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;    a[i] = r[i];  &#125;&#125;</code></pre><p>这种利用另外一个数组来计数的实现方式是不是很巧妙呢？这也是为什么这种排序算法叫计数排序的原因。不过，你千万不要死记硬背上面的排序过程，重要的是理解和会用。</p><p>总结一下，<strong>计数排序只能用在数据范围不大的场景中，如果数据范围 <code>k</code> 比要排序的数据 <code>n</code> 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</strong></p><p>比如，还是拿考生这个例子。如果考生成绩精确到小数后一位，就需要将所有的分数都先乘以 <code>10</code>，转化成整数，然后再放到 <code>9010</code> 个桶内。再比如，如果要排序的数据中有负数，数据的范围是 <code>[-1000, 1000]</code>，那就需要先对每个数据都加 <code>1000</code>，转化成非负整数。</p><h2 id="基数排序（Radix-sort）"><a href="#基数排序（Radix-sort）" class="headerlink" title="基数排序（Radix sort）"></a>基数排序（Radix sort）</h2><p>再来看这样一个排序问题。假设有 <code>10</code> 万个手机号码，希望将这 <code>10</code> 万个手机号码从小到大排序，你有什么比较快速的排序方法呢？</p><p>之前讲的快排，时间复杂度可以做到 $O(nlogn)$，还有更高效的排序算法吗？桶排序、计数排序能派上用场吗？手机号码有 <code>11</code> 位，范围太大，显然不适合用这两种排序算法。针对这个排序问题，有没有时间复杂度是 $O(n)$ 的算法呢？现在就来介绍一种新的排序算法，基数排序。</p><p>刚刚这个问题里有这样的规律：假设要比较两个手机号码 <code>a</code>，<code>b</code> 的大小，如果在前面几位中，<code>a</code> 手机号码已经比 <code>b</code> 手机号码大了，那后面的几位就不用看了。</p><p>借助稳定排序算法，这里有一个巧妙的实现思路。还记得在阐述排序算法的稳定性的时候举的订单的例子吗？这里也可以借助相同的处理思路，先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 <code>11</code> 次排序之后，手机号码就都有序了。</p><p>手机号码稍微有点长，画图比较不容易看清楚，用字符串排序的例子，下面有一张基数排序的过程分解图，你可以看下。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/12/875fc110-d545-11e9-98af-f301859595e1.png" srcset="/img/loading.gif" alt="image.png"><br>注意，这里按照每位来排序的排序算法要是稳定的，否则这个实现思路就是不正确的。因为如果是非稳定排序算法，那最后一次排序只会考虑最高位的大小顺序，完全不管其他位的大小关系，那么低位的排序就完全没有意义了。</p><p>根据每一位来排序，可以用刚讲过的桶排序或者计数排序，它们的时间复杂度可以做到 $O(n)$。如果要排序的数据有 <code>k</code> 位，那就需要 <code>k</code> 次桶排序或者计数排序，总的时间复杂度是 $O(k*n)$。当 <code>k</code> 不大的时候，比如手机号码排序的例子，<code>k</code> 最大就是 <code>11</code>，所以基数排序的时间复杂度就近似于 $O(n)$。</p><p>实际上，有时候要排序的数据并不都是等长的，比如排序牛津字典中的 <code>20</code> 万个英文单词，最短的只有 <code>1</code> 个字母，最长的有 <code>45</code> 个字母，中文翻译是尘肺病。对于这种不等长的数据，基数排序还适用吗？</p><p>实际上，可以把所有的单词补齐到相同长度，位数不够的可以在后面补“0”，因为根据 <code>ASCII</code> 值，所有字母都大于“0”，所以补“0”不会影响到原有的大小顺序。这样就可以继续用基数排序了。</p><p>总结一下，<strong>基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 <code>a</code> 数据的高位比 <code>b</code> 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 $O(n)$ 了。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天学习了 <code>3</code> 种线性时间复杂度的排序算法，有桶排序、计数排序、基数排序。它们对要排序的数据都有比较苛刻的要求，应用不是非常广泛。但是如果数据特征比较符合这些排序算法的要求，应用这些算法，会非常高效，线性时间复杂度可以达到 $O(n)$。</p><p>桶排序和计数排序的排序思想是非常相似的，都是针对范围不大的数据，将数据划分成不同的桶来实现排序。基数排序要求数据可以划分成高低位，位之间有递进关系。比较两个数，只需要比较高位，高位相同的再比较低位。而且每一位的数据范围不能太大，因为基数排序算法需要借助桶排序或者计数排序来完成每一个位的排序工作。</p><h2 id="五、思考"><a href="#五、思考" class="headerlink" title="五、思考"></a>五、思考</h2><ul><li><p><strong>如何根据年龄给<code>100</code>万用户数据排序？</strong></p><blockquote><p> 实际上，根据年龄给 <code>100</code> 万用户排序，就类似按照成绩给 <code>50</code> 万考生排序。假设年龄的范围最小 <code>1</code> 岁，最大不超过 <code>120</code> 岁。<br>  可以遍历这 <code>100</code> 万用户，根据年龄将其划分到这 <code>120</code> 个桶里，然后依次顺序遍历这 <code>120</code> 个桶中的元素。<br>  这样就得到了按照年龄排序的 <code>100</code> 万用户数据。</p></blockquote></li><li><p>对<code>D，a，F，B，c，A，z</code>这几个字符串进行排序，要求将其中所有小写字母都排在大写字母前面，但是小写字母内部和大写字母内部不要求有序。比如经过排序后为<code>a，c，z，D，F，B，A</code>，这个如何实现呢？如果字符串中处理大小写，还有数字，将数字放在最前面，又该如何解决呢？</p><blockquote><p> 用两个指针<code>a、b</code>：<br>   <code>a</code>指针从头开始往后遍历，遇到大写字母就停下，<code>b</code>从后往前遍历，遇到小写字母就停下，交换<code>a、b</code>指针对应的元素；<br>   重复如上过程，直到<code>a、b</code>指针相交。<br>   对于小写字母放前面，数字放中间，大写字母放后面，可以先将数据分为小写字母和非小写字母两大类，进行如上交换后再在非小写字母区间内分为数字和大写字母做同样处理</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.排序（下）</title>
    <link href="/passages/9/"/>
    <url>/passages/9/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>归并排序和快速排序都用到了分治思想，非常巧妙。我们可以借鉴这个思想，来解决非排序的问题，比如：如何在 $O(n)$ 的时间复杂度内查找一个无序数组中的第 <code>K</code> 大元素？</p><h2 id="归并排序-Merge-Sort-的原理"><a href="#归并排序-Merge-Sort-的原理" class="headerlink" title="归并排序(Merge Sort)的原理"></a>归并排序(Merge Sort)的原理</h2><p>归并排序的核心思想还是蛮简单的。如果要排序一个数组，先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/11/9c85bfb0-d43f-11e9-8ff2-7340a5031e46.png" srcset="/img/loading.gif" alt="image.png"><br>归并排序使用的就是<strong>分治思想</strong>。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。</p><p>从刚才的描述，你有没有感觉到，分治思想跟前面讲的递归思想很像。是的，分治算法一般都是用递归来实现的。<strong>分治是一种解决问题的处理思想，递归是一种编程技巧</strong>，这两者并不冲突。</p><p>前面通过举例对归并有了一个感性的认识，归并排序用的是分治思想，可以用递归来实现。现在就来看看如何用递归代码来实现归并排序。</p><p>递归代码的编写技巧你还记得吗？写递归代码的技巧就是，分析得出递推公式，然后找到终止条件，最后将递推公式翻译成递归代码。所以，要想写出归并排序的代码，先写出归并排序的递推公式。</p><pre><code class="hljs plain">递推公式：merge_sort(p…r) &#x3D; merge(merge_sort(p…q), merge_sort(q+1…r))终止条件：p &gt;&#x3D; r 不用再继续分解</code></pre><p>解释一下这个递推公式。</p><p><code>merge_sort(p…r)</code> 表示，给下标从 <code>p</code> 到 <code>r</code> 之间的数组排序。将这个排序问题转化为了两个子问题，<code>merge_sort(p…q)</code> 和 <code>merge_sort(q+1…r)</code>，其中下标 <code>q</code> 等于 <code>p</code> 和 <code>r</code> 的中间位置，也就是 <code>(p+r)/2</code>。当下标从 <code>p</code> 到 <code>q</code> 和从 <code>q+1</code> 到 <code>r</code> 这两个子数组都排好序之后，再将两个有序的子数组合并在一起，这样下标从 <code>p</code> 到 <code>r</code> 之间的数据就也排好序了。</p><p>有了递推公式，转化成代码就简单多了。为了阅读方便，这里只给出伪代码，你可以翻译成你熟悉的编程语言。</p><pre><code class="hljs c"><span class="hljs-comment">// 归并排序算法, A 是数组，n 表示数组大小</span>merge_sort(A, n) &#123;  merge_sort_c(A, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>)&#125;<span class="hljs-comment">// 递归调用函数</span>merge_sort_c(A, p, r) &#123;  <span class="hljs-comment">// 递归终止条件</span>  <span class="hljs-keyword">if</span> p &gt;= r  then <span class="hljs-keyword">return</span>  <span class="hljs-comment">// 取 p 到 r 之间的中间位置 q</span>  q = (p+r) / <span class="hljs-number">2</span>  <span class="hljs-comment">// 分治递归</span>  merge_sort_c(A, p, q)  merge_sort_c(A, q+<span class="hljs-number">1</span>, r)  <span class="hljs-comment">// 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]</span>  merge(A[p...r], A[p...q], A[q+<span class="hljs-number">1.</span>..r])&#125;</code></pre><p>你可能已经发现了，<code>merge(A[p…r], A[p…q], A[q+1…r])</code> 这个函数的作用就是，将已经有序的 <code>A[p…q]</code> 和 <code>A[q+1…r]</code> 合并成一个有序的数组，并且放入 <code>A[p…r]</code>。那这个过程具体该如何做呢？</p><p>如图所示，申请一个临时数组 <code>tmp</code>，大小与 <code>A[p…r]</code> 相同。用两个游标 <code>i</code> 和 <code>j</code>，分别指向 <code>A[p…q]</code> 和 <code>A[q+1…r]</code> 的第一个元素。比较这两个元素 <code>A[i]</code> 和 <code>A[j]</code>，如果 <code>A[i]&lt;=A[j]</code>，就把 <code>A[i]</code> 放入到临时数组 <code>tmp</code>，并且 <code>i</code> 后移一位，否则将 <code>A[j]</code> 放入到数组 <code>tmp</code>，<code>j</code> 后移一位。</p><p>继续上述比较过程，直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中的数据依次加入到临时数组的末尾，这个时候，临时数组中存储的就是两个子数组合并之后的结果了。最后再把临时数组 <code>tmp</code> 中的数据拷贝到原数组 <code>A[p…r]</code> 中。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/11/deb72ca0-d441-11e9-8ff2-7340a5031e46.png" srcset="/img/loading.gif" alt="image.png"><br>把 <code>merge()</code> 函数写成伪代码，就是下面这样：</p><pre><code class="hljs c">merge(A[p...r], A[p...q], A[q+<span class="hljs-number">1.</span>..r]) &#123;  var i := p，j := q+<span class="hljs-number">1</span>，k := <span class="hljs-number">0</span> <span class="hljs-comment">// 初始化变量 i, j, k</span>  var tmp := <span class="hljs-keyword">new</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">0.</span>..r-p] <span class="hljs-comment">// 申请一个大小跟 A[p...r] 一样的临时数组</span>  <span class="hljs-keyword">while</span> i&lt;=q AND j&lt;=r <span class="hljs-keyword">do</span> &#123;    <span class="hljs-keyword">if</span> A[i] &lt;= A[j] &#123;      tmp[k++] = A[i++] <span class="hljs-comment">// i++ 等于 i:=i+1</span>    &#125; <span class="hljs-keyword">else</span> &#123;      tmp[k++] = A[j++]    &#125;  &#125;    <span class="hljs-comment">// 判断哪个子数组中有剩余的数据</span>  var start := i，end := q  <span class="hljs-keyword">if</span> j&lt;=r then start := j, end:=r    <span class="hljs-comment">// 将剩余的数据拷贝到临时数组 tmp</span>  <span class="hljs-keyword">while</span> start &lt;= end <span class="hljs-keyword">do</span> &#123;    tmp[k++] = A[start++]  &#125;    <span class="hljs-comment">// 将 tmp 中的数组拷贝回 A[p...r]</span>  <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span> to r-p <span class="hljs-keyword">do</span> &#123;    A[p+i] = tmp[i]  &#125;&#125;</code></pre><p>还记得利用哨兵简化编程的处理技巧吗？<code>merge()</code> 合并函数如果借助哨兵，代码就会简洁很多，这个问题留你可以思考一下。</p><h2 id="归并排序的性能分析"><a href="#归并排序的性能分析" class="headerlink" title="归并排序的性能分析"></a>归并排序的性能分析</h2><p>接下来，来看归并排序的三个问题。</p><p><strong>第一，归并排序是稳定的排序算法吗？</strong></p><p>结合前面那张图和归并排序的伪代码，你应该能发现，归并排序稳不稳定关键要看 <code>merge()</code> 函数，也就是两个有序子数组合并成一个有序数组的那部分代码。</p><p>在合并的过程中，如果 <code>A[p…q]</code> 和 <code>A[q+1…r]</code> 之间有值相同的元素，那可以像伪代码中那样，先把 <code>A[p…q]</code> 中的元素放入 <code>tmp</code> 数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个稳定的排序算法。</p><p><strong>第二，归并排序的时间复杂度是多少？</strong></p><p>归并排序涉及递归，时间复杂度的分析稍微有点复杂。正好借此机会来学习一下，如何分析递归代码的时间复杂度。</p><p>在递归那一节讲过，递归的适用场景是，一个问题 <code>a</code> 可以分解为多个子问题 <code>b</code>、<code>c</code>，那求解问题 <code>a</code> 就可以分解为求解问题 <code>b</code>、<code>c</code>。问题 <code>b</code>、<code>c</code> 解决之后，再把 <code>b</code>、<code>c</code> 的结果合并成 <code>a</code> 的结果。</p><p>如果定义求解问题 <code>a</code> 的时间是 $T(a)$，求解问题 <code>b</code>、<code>c</code> 的时间分别是 $T(b)$ 和 $T(c)$，那就可以得到这样的递推关系式：</p><pre><code class="hljs plain">T(a) &#x3D; T(b) + T(c) + K</code></pre><p>其中 <code>K</code> 等于将两个子问题 <code>b</code>、<code>c</code> 的结果合并成问题 <code>a</code> 的结果所消耗的时间。</p><p>从刚刚的分析，可以得到一个重要的结论：<strong>不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。</strong></p><p>套用这个公式，来分析一下归并排序的时间复杂度。</p><p>假设对 <code>n</code> 个元素进行归并排序需要的时间是 $T(n)$，那分解成两个子数组排序的时间都是 $T(\frac n 2)$。<code>merge()</code> 函数合并两个有序子数组的时间复杂度是 $O(n)$。所以，套用前面的公式，归并排序的时间复杂度的计算公式就是：</p><pre><code class="hljs plain">T(1) &#x3D; C；   n&#x3D;1 时，只需要常量级的执行时间，所以表示为 C。T(n) &#x3D; 2*T(n&#x2F;2) + n； n&gt;1</code></pre><p>通过这个公式，如何来求解 $T(n)$ 呢？还不够直观？那再进一步分解一下计算过程。</p><pre><code class="hljs plain">T(n) &#x3D; 2*T(n&#x2F;2) + n     &#x3D; 2*(2*T(n&#x2F;4) + n&#x2F;2) + n &#x3D; 4*T(n&#x2F;4) + 2*n     &#x3D; 4*(2*T(n&#x2F;8) + n&#x2F;4) + 2*n &#x3D; 8*T(n&#x2F;8) + 3*n     &#x3D; 8*(2*T(n&#x2F;16) + n&#x2F;8) + 3*n &#x3D; 16*T(n&#x2F;16) + 4*n     ......     &#x3D; 2^k * T(n&#x2F;2^k) + k * n     ......</code></pre><p>通过这样一步一步分解推导，可以得到 $T(n) = 2^kT(\frac n {2^k}) + kn$。当 $T(\frac n {2^k})=T(1)$ 时，也就是 $\frac n {2^k}=1$，可以得到 $k=log_2n$ 。将 <code>k</code> 值代入上面的公式，得到 $T(n)=Cn+nlog_2n$ 。如果用大 $O$ 标记法来表示的话，$T(n)$ 就等于 $O(nlogn)$。所以归并排序的时间复杂度是 $O(nlogn)$。</p><p>从上面的原理分析和伪代码可以看出，归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 $O(nlogn)$。</p><p><strong>第三，归并排序的空间复杂度是多少？</strong></p><p>归并排序的时间复杂度任何情况下都是 $O(nlogn)$，看起来非常优秀。（待会儿你会发现，即便是快速排序，最坏情况下，时间复杂度也是 $O(n^2)$。）但是，归并排序并没有像快排那样，应用广泛，这是为什么呢？因为它有一个致命的“弱点”，那就是归并排序不是原地排序算法。</p><p>这是因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。这一点你应该很容易理解。那现在问你，归并排序的空间复杂度到底是多少呢？是 $O(n)$，还是 $O(nlogn)$，应该如何分析呢？</p><p>如果继续按照分析递归时间复杂度的方法，通过递推公式来求解，那整个归并过程需要的空间复杂度就是 $O(nlogn)$。不过，类似分析时间复杂度那样来分析空间复杂度，这个思路对吗？</p><p>实际上，递归代码的空间复杂度并不能像时间复杂度那样累加。刚刚忘记了最重要的一点，那就是，尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，<code>CPU</code> 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 <code>n</code> 个数据的大小，所以空间复杂度是 $O(n)$。</p><h2 id="快速排序（Quicksort）的原理"><a href="#快速排序（Quicksort）的原理" class="headerlink" title="快速排序（Quicksort）的原理"></a>快速排序（Quicksort）的原理</h2><p>再来看快速排序算法，习惯性把它简称为“快排”。快排利用的也是分治思想。乍看起来，它有点像归并排序，但是思路其实完全不一样。待会儿会讲两者的区别。现在，先来看下快排的核心思想。</p><p>快排的思想是这样的：如果要排序数组中下标从 <code>p</code> 到 <code>r</code> 之间的一组数据，选择 <code>p</code> 到 <code>r</code> 之间的任意一个数据作为 <code>pivot</code>（分区点）。</p><p>遍历 <code>p</code> 到 <code>r</code> 之间的数据，将小于 <code>pivot</code> 的放到左边，将大于 <code>pivot</code> 的放到右边，将 <code>pivot</code> 放到中间。经过这一步骤之后，数组 <code>p</code> 到 <code>r</code> 之间的数据就被分成了三个部分，前面 <code>p</code> 到 <code>q-1</code> 之间都是小于 <code>pivot</code> 的，中间是 <code>pivot</code>，后面的 <code>q+1</code> 到 <code>r</code> 之间是大于 <code>pivot</code> 的。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/11/cc2317a0-d443-11e9-8ff2-7340a5031e46.png" srcset="/img/loading.gif" alt="image.png"><br>根据分治、递归的处理思想，可以用递归排序下标从 <code>p</code> 到 <code>q-1</code> 之间的数据和下标从 <code>q+1</code> 到 <code>r</code> 之间的数据，直到区间缩小为 <code>1</code>，就说明所有的数据都有序了。</p><p>如果用递推公式来将上面的过程写出来的话，就是这样：</p><pre><code class="hljs plain">递推公式：quick_sort(p…r) &#x3D; quick_sort(p…q-1) + quick_sort(q+1, r)终止条件：p &gt;&#x3D; r</code></pre><p>将递推公式转化成递归代码。跟归并排序一样，还是用伪代码来实现，你可以翻译成你熟悉的任何语言。</p><pre><code class="hljs c"><span class="hljs-comment">// 快速排序，A 是数组，n 表示数组的大小</span>quick_sort(A, n) &#123;  quick_sort_c(A, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>)&#125;<span class="hljs-comment">// 快速排序递归函数，p,r 为下标</span>quick_sort_c(A, p, r) &#123;  <span class="hljs-keyword">if</span> p &gt;= r then <span class="hljs-keyword">return</span>    q = partition(A, p, r) <span class="hljs-comment">// 获取分区点</span>  quick_sort_c(A, p, q<span class="hljs-number">-1</span>)  quick_sort_c(A, q+<span class="hljs-number">1</span>, r)&#125;</code></pre><p>归并排序中有一个 <code>merge()</code> 合并函数，这里有一个 <code>partition()</code> 分区函数。<code>partition()</code> 分区函数实际上前面已经讲过了，就是随机选择一个元素作为 <code>pivot</code>（一般情况下，可以选择 <code>p</code> 到 <code>r</code> 区间的最后一个元素），然后对 <code>A[p…r]</code> 分区，函数返回 <code>pivot</code> 的下标。</p><p>如果不考虑空间消耗的话，<code>partition()</code> 分区函数可以写得非常简单。申请两个临时数组 <code>X</code> 和 <code>Y</code>，遍历 <code>A[p…r]</code>，将小于 <code>pivot</code> 的元素都拷贝到临时数组 <code>X</code>，将大于 <code>pivot</code> 的元素都拷贝到临时数组 <code>Y</code>，最后再将数组 <code>X</code> 和数组 <code>Y</code> 中数据顺序拷贝到 <code>A[p…r]</code>。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/11/392791f0-d444-11e9-8ff2-7340a5031e46.png" srcset="/img/loading.gif" alt="image.png"><br>但是，如果按照这种思路实现的话，<code>partition()</code> 函数就需要很多额外的内存空间，所以快排就不是原地排序算法了。如果希望快排是原地排序算法，那它的空间复杂度得是 $O(1)$，那 <code>partition()</code> 分区函数就不能占用太多额外的内存空间，就需要在 <code>A[p…r]</code> 的原地完成分区操作。</p><p>原地分区函数的实现思路非常巧妙，写成了伪代码，一起来看一下。</p><pre><code class="hljs c">partition(A, p, r) &#123;  pivot := A[r]  i := p  <span class="hljs-keyword">for</span> j := p to r<span class="hljs-number">-1</span> <span class="hljs-keyword">do</span> &#123;    <span class="hljs-keyword">if</span> A[j] &lt; pivot &#123;      swap A[i] with A[j]      i := i+<span class="hljs-number">1</span>    &#125;  &#125;  swap A[i] with A[r]  <span class="hljs-keyword">return</span> i</code></pre><p>这里的处理有点类似选择排序。通过游标 <code>i</code> 把 <code>A[p…r-1]</code> 分成两部分。<code>A[p…i-1]</code> 的元素都是小于 <code>pivot</code> 的，暂且叫它“已处理区间”，<code>A[i…r-1]</code> 是“未处理区间”。每次都从未处理的区间 <code>A[i…r-1]</code> 中取一个元素 <code>A[j]</code>，与 <code>pivot</code> 对比，如果小于 <code>pivot</code>，则将其加入到已处理区间的尾部，也就是 <code>A[i]</code> 的位置。</p><p>数组的插入操作还记得吗？在数组某个位置插入元素，需要搬移数据，非常耗时。当时也讲了一种处理技巧，就是交换，在 $O(1)$ 的时间复杂度内完成插入操作。这里也借助这个思想，只需要将 <code>A[i]</code> 与 <code>A[j]</code> 交换，就可以在 $O(1)$ 时间复杂度内将 <code>A[j]</code> 放到下标为 <code>i</code> 的位置。</p><p>文字不如图直观，所以下面有一张图来展示分区的整个过程。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/11/c4a8c410-d444-11e9-8ff2-7340a5031e46.png" srcset="/img/loading.gif" alt="image.png"><br>因为分区的过程涉及交换操作，如果数组中有两个相同的元素，比如序列 <code>6，8，7，6，3，5，9，4</code>，在经过第一次分区操作之后，两个 <code>6</code> 的相对先后顺序就会改变。所以，快速排序并不是一个稳定的排序算法。</p><p>到此，快速排序的原理应该也掌握了。现在，再来看另外一个问题：快排和归并用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢？<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/11/e0bf5150-d444-11e9-8ff2-7340a5031e46.png" srcset="/img/loading.gif" alt="image.png"><br>可以发现，归并排序的处理过程是<strong>由下到上</strong>的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是<strong>由上到下</strong>的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 $O(nlogn)$ 的排序算法，但是它是非原地排序算法。前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p><h2 id="快速排序的性能分析"><a href="#快速排序的性能分析" class="headerlink" title="快速排序的性能分析"></a>快速排序的性能分析</h2><p>现在来分析一下快速排序的性能。在讲解快排的实现原理的时候，已经分析了稳定性和空间复杂度。快排是一种原地、不稳定的排序算法。现在，集中精力来看快排的时间复杂度。</p><p>快排也是用递归来实现的。对于递归代码的时间复杂度，前面总结的公式，这里也还是适用的。如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的。所以，快排的时间复杂度也是 $O(nlogn)$。</p><pre><code class="hljs plain">T(1) &#x3D; C；   n&#x3D;1 时，只需要常量级的执行时间，所以表示为 C。T(n) &#x3D; 2*T(n&#x2F;2) + n； n&gt;1</code></pre><p>但是，公式成立的前提是每次分区操作，选择的 <code>pivot</code> 都很合适，正好能将大区间对等地一分为二。但实际上这种情况是很难实现的。</p><p>举一个比较极端的例子。如果数组中的数据原来已经是有序的了，比如 <code>1，3，5，6，8</code>。如果每次选择最后一个元素作为 <code>pivot</code>，那每次分区得到的两个区间都是不均等的。需要进行大约 <code>n</code> 次分区操作，才能完成快排的整个过程。每次分区平均要扫描大约 <code>n/2</code> 个元素，这种情况下，快排的时间复杂度就从 $O(nlogn)$ 退化成了 $O(n^2)$。</p><p>刚刚讲了两个极端情况下的时间复杂度，一个是分区极其均衡，一个是分区极其不均衡。它们分别对应快排的最好情况时间复杂度和最坏情况时间复杂度。那快排的平均情况时间复杂度是多少呢？</p><p>假设每次分区操作都将区间分成大小为 <code>9:1</code> 的两个小区间。继续套用递归时间复杂度的递推公式，就会变成这样：</p><pre><code class="hljs plain">T(1) &#x3D; C；   n&#x3D;1 时，只需要常量级的执行时间，所以表示为 C。T(n) &#x3D; T(n&#x2F;10) + T(9*n&#x2F;10) + n； n&gt;1</code></pre><p>这个公式的递推求解的过程非常复杂，虽然可以求解，但不推荐用这种方法。实际上，递归的时间复杂度的求解方法除了递推公式之外，还有递归树，这里暂时不说。这里直接给你结论：$T(n)$ 在大部分情况下的时间复杂度都可以做到 $O(nlogn)$，只有在极端情况下，才会退化到 $O(n^2)$。而且，也有很多方法将这个概率降到很低，如何来做？后面再讲。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>归并排序和快速排序是两种稍微复杂的排序算法，它们用的都是分治的思想，代码都通过递归来实现，过程非常相似。理解归并排序的重点是理解递推公式和 <code>merge()</code> 合并函数。同理，理解快排的重点也是理解递推公式，还有 <code>partition()</code> 分区函数。</p><p>归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法，这也使它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是 $O(n)$。正因为此，它也没有快排应用广泛。</p><p>快速排序算法虽然最坏情况下的时间复杂度是 $O(n^2)$，但是平均情况下时间复杂度都是 $O(nlogn)$。不仅如此，快速排序算法时间复杂度退化到 $O(n^2)$ 的概率非常小，可以通过合理地选择 <code>pivot</code> 来避免这种情况。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p><strong>$O(n)$时间复杂度内求无序数组中第<code>K</code>大元素?</strong>比如<code>4，2，5，12，3</code>这样一组数据，第<code>3</code>大元素是<code>4</code>。</p><blockquote><p>选择数组区间 <code>A[0…n-1]</code> 的最后一个元素 <code>A[n-1]</code> 作为 <code>pivot</code>，对数组 <code>A[0…n-1]</code> 原地分区，这样数组就分成了三部分，<code>A[0…p-1]</code>、<code>A[p]</code>、<code>A[p+1…n-1]</code>。</p><p>如果 <code>p+1=K</code>，那 <code>A[p]</code> 就是要求解的元素；如果 <code>K&gt;p+1</code>, 说明第 <code>K</code> 大元素出现在 <code>A[p+1…n-1]</code> 区间，再按照上面的思路递归地在 <code>A[p+1…n-1]</code> 这个区间内查找。同理，如果 <code>K&lt;p+1</code>，那就在 <code>A[0…p-1]</code> 区间查找。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/11/e404a660-d446-11e9-8ff2-7340a5031e46.png" srcset="/img/loading.gif" alt="image.png"><br>再来看，为什么上述解决思路的时间复杂度是 $O(n)$？</p><p>第一次分区查找，需要对大小为 <code>n</code> 的数组执行分区操作，需要遍历 <code>n</code> 个元素。第二次分区查找，只需要对大小为 <code>n/2</code> 的数组执行分区操作，需要遍历 <code>n/2</code> 个元素。依次类推，分区遍历元素的个数分别为、<code>n/2</code>、<code>n/4</code>、<code>n/8</code>、<code>n/16</code>.……直到区间缩小为 <code>1</code>。</p><p>如果把每次分区遍历的元素个数加起来，就是：<code>n+n/2+n/4+n/8+…+1</code>。这是一个等比数列求和，最后的和等于 <code>2n-1</code>。所以，上述解决思路的时间复杂度就为 $O(n)$。</p><p>你可能会说，有个很笨的办法，每次取数组中的最小值，将其移动到数组的最前面，然后在剩下的数组中继续找最小值，以此类推，执行 <code>K</code> 次，找到的数据不就是第 <code>K</code> 大元素了吗？</p><p>不过，时间复杂度就并不是 $O(n)$ 了，而是 $O(K * n)$。你可能会说，时间复杂度前面的系数不是可以忽略吗？$O(K * n)$ 不就等于 $O(n)$ 吗？</p><p>这个可不能这么简单地划等号。当 <code>K</code> 是比较小的常量时，比如 <code>1</code>、<code>2</code>，那最好时间复杂度确实是 $O(n)$；但当 <code>K</code> 等于 <code>n/2</code> 或者 <code>n</code> 时，这种最坏情况下的时间复杂度就是 $O(n^2)$ 了。</p></blockquote></li><li><p>有<code>10</code>个访问日志文件，每个日志文件大小约为<code>300MB</code>，每个文件里的日志都是按照时间戳从小到大排序的。现在需要将这<code>10</code>个较小的日志文件合并为<code>1</code>个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述任务的机器内存只有<code>1GB</code>，你有什么好的解决思路能快速地将这<code>10</code>个日志文件合并？</p><blockquote><p>  每次从各个文件中取一条数据，在内存中根据数据时间戳构建一个最小堆，然后每次把最小值给写入新文件，同时将最小值来自的那个文件再出来一个数据，加入到最小堆中。<br>  这个空间复杂度为常数，但没能很好利用<code>1G</code>内存，而且磁盘单个读取比较慢，所以考虑每次读取一批数据，没了再从磁盘中取，时间复杂度还是一样$O(n)$。</p></blockquote></li></ul><h2 id="归并排序-Java-实现代码："><a href="#归并排序-Java-实现代码：" class="headerlink" title="归并排序 Java 实现代码："></a>归并排序 Java 实现代码：</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MergeSort</span> </span>&#123;  <span class="hljs-comment">// 归并排序算法, a是数组，n表示数组大小</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    mergeSortInternally(a, <span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>);  &#125;  <span class="hljs-comment">// 递归调用函数</span>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSortInternally</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span> </span>&#123;    <span class="hljs-comment">// 递归终止条件</span>    <span class="hljs-keyword">if</span> (p &gt;= r) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">// 取p到r之间的中间位置q,防止（p+r）的和超过int类型最大值</span>    <span class="hljs-keyword">int</span> q = p + (r - p)/<span class="hljs-number">2</span>;    <span class="hljs-comment">// 分治递归</span>    mergeSortInternally(a, p, q);    mergeSortInternally(a, q+<span class="hljs-number">1</span>, r);    <span class="hljs-comment">// 将A[p...q]和A[q+1...r]合并为A[p...r]</span>    merge(a, p, q, r);  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q, <span class="hljs-keyword">int</span> r)</span> </span>&#123;    <span class="hljs-keyword">int</span> i = p;    <span class="hljs-keyword">int</span> j = q+<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化变量i, j, k</span>    <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r-p+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 申请一个大小跟a[p...r]一样的临时数组</span>    <span class="hljs-keyword">while</span> (i&lt;=q &amp;&amp; j&lt;=r) &#123;      <span class="hljs-keyword">if</span> (a[i] &lt;= a[j]) &#123;        tmp[k++] = a[i++]; <span class="hljs-comment">// i++等于i:=i+1</span>      &#125; <span class="hljs-keyword">else</span> &#123;        tmp[k++] = a[j++];      &#125;    &#125;    <span class="hljs-comment">// 判断哪个子数组中有剩余的数据</span>    <span class="hljs-keyword">int</span> start = i;    <span class="hljs-keyword">int</span> end = q;    <span class="hljs-keyword">if</span> (j &lt;= r) &#123;      start = j;      end = r;    &#125;    <span class="hljs-comment">// 将剩余的数据拷贝到临时数组tmp</span>    <span class="hljs-keyword">while</span> (start &lt;= end) &#123;      tmp[k++] = a[start++];    &#125;    <span class="hljs-comment">// 将tmp中的数组拷贝回a[p...r]</span>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= r-p; ++i) &#123;      a[p+i] = tmp[i];    &#125;  &#125;  <span class="hljs-comment">/**   * 合并(哨兵)   *   * <span class="hljs-doctag">@param</span> arr   * <span class="hljs-doctag">@param</span> p   * <span class="hljs-doctag">@param</span> q   * <span class="hljs-doctag">@param</span> r   */</span>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeBySentry</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q, <span class="hljs-keyword">int</span> r)</span> </span>&#123;    <span class="hljs-keyword">int</span>[] leftArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[q - p + <span class="hljs-number">2</span>];    <span class="hljs-keyword">int</span>[] rightArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r - q + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= q - p; i++) &#123;      leftArr[i] = arr[p + i];    &#125;    <span class="hljs-comment">// 第一个数组添加哨兵（最大值）</span>    leftArr[q - p + <span class="hljs-number">1</span>] = Integer.MAX_VALUE;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; r - q; i++) &#123;      rightArr[i] = arr[q + <span class="hljs-number">1</span> + i];    &#125;    <span class="hljs-comment">// 第二个数组添加哨兵（最大值）</span>    rightArr[r-q] = Integer.MAX_VALUE;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> k = p;    <span class="hljs-keyword">while</span> (k &lt;= r) &#123;      <span class="hljs-comment">// 当左边数组到达哨兵值时，i不再增加，直到右边数组读取完剩余值，同理右边数组也一样</span>      <span class="hljs-keyword">if</span> (leftArr[i] &lt;= rightArr[j]) &#123;        arr[k++] = leftArr[i++];      &#125; <span class="hljs-keyword">else</span> &#123;        arr[k++] = rightArr[j++];      &#125;    &#125;  &#125;&#125;</code></pre><h2 id="快速排序-Java-实现代码："><a href="#快速排序-Java-实现代码：" class="headerlink" title="快速排序 Java 实现代码："></a>快速排序 Java 实现代码：</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickSort</span> </span>&#123;  <span class="hljs-comment">// 快速排序，a是数组，n表示数组的大小</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    quickSortInternally(a, <span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>);  &#125;  <span class="hljs-comment">// 快速排序递归函数，p,r为下标</span>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSortInternally</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span> </span>&#123;    <span class="hljs-keyword">if</span> (p &gt;= r) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> q = partition(a, p, r); <span class="hljs-comment">// 获取分区点</span>    quickSortInternally(a, p, q-<span class="hljs-number">1</span>);    quickSortInternally(a, q+<span class="hljs-number">1</span>, r);  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span> </span>&#123;    <span class="hljs-keyword">int</span> pivot = a[r];    <span class="hljs-keyword">int</span> i = p;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = p; j &lt; r; ++j) &#123;      <span class="hljs-keyword">if</span> (a[j] &lt; pivot) &#123;        <span class="hljs-keyword">if</span> (i == j) &#123;          ++i;        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-keyword">int</span> tmp = a[i];          a[i++] = a[j];          a[j] = tmp;        &#125;      &#125;    &#125;    <span class="hljs-keyword">int</span> tmp = a[i];    a[i] = a[r];    a[r] = tmp;    System.out.println(<span class="hljs-string">"i="</span> + i);    <span class="hljs-keyword">return</span> i;  &#125;&#125;</code></pre><p>欢迎留言和我分享。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.排序（上）</title>
    <link href="/passages/8/"/>
    <url>/passages/8/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>排序对于任何一个程序员来说，可能都不会陌生。你学的第一个算法，可能就是排序。大部分编程语言中，也都提供了排序函数。在平常的项目中，也经常会用到排序。排序非常重要，所以会花多一点时间来详细讲一讲经典的排序算法。</p><p>排序算法太多了，有很多可能连名字都没听说过，比如猴子排序、睡眠排序、面条排序等。只讲众多排序算法中的一小撮，也是最经典的、最常用的：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。</p><p>带着问题去学习，是最有效的学习方法。先给出一个思考题：<font color='green'>插入排序和冒泡排序的时间复杂度相同，都是 $O(n^2)$，在实际的软件开发里，为什么更倾向于使用插入排序算法而不是冒泡排序算法呢？</font></p><h2 id="如何分析一个“排序算法”？"><a href="#如何分析一个“排序算法”？" class="headerlink" title="如何分析一个“排序算法”？"></a>如何分析一个“排序算法”？</h2><p>学习排序算法，除了学习它的算法原理、代码实现之外，更重要的是要学会如何评价、分析一个排序算法。那分析一个排序算法，要从哪几个方面入手呢？</p><h3 id="排序算法的执行效率"><a href="#排序算法的执行效率" class="headerlink" title="排序算法的执行效率"></a>排序算法的执行效率</h3><p>对于排序算法执行效率的分析，一般会从这几个方面来衡量：</p><p><strong>1. 最好情况、最坏情况、平均情况时间复杂度</strong></p><p>在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。除此之外，还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。</p><p>为什么要区分这三种时间复杂度呢？第一，有些排序算法会区分，为了好对比，所以最好都做一下区分。第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，要知道排序算法在不同数据下的性能表现。</p><p><strong>2. 时间复杂度的系数、常数 、低阶</strong></p><p>时间复杂度反应的是数据规模 <code>n</code> 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，排序的可能是 <code>10</code> 个、<code>100</code> 个、<code>1000</code> 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，就要把系数、常数、低阶也考虑进来。</p><p><strong>3. 比较次数和交换（或移动）次数</strong></p><p>基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。</p><h3 id="排序算法的内存消耗"><a href="#排序算法的内存消耗" class="headerlink" title="排序算法的内存消耗"></a>排序算法的内存消耗</h3><p>前面讲过，算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，还引入了一个新的概念，<strong>原地排序</strong>（<code>Sorted in place</code>）。原地排序算法，就是特指空间复杂度是 $O(1)$ 的排序算法。下面讲的三种排序算法，都是原地排序算法。</p><h3 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h3><p>仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，还有一个重要的度量指标，<strong>稳定性</strong>。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p><p>通过一个例子来解释一下。比如有一组数据 <code>2，9，3，4，8，3</code>，按照大小排序之后就是 <code>2，3，3，4，8，9</code>。</p><p>这组数据里有两个 <code>3</code>。经过某种排序算法排序之后，如果两个 <code>3</code> 的前后顺序没有改变，那就把这种排序算法叫作<strong>稳定的排序算法</strong>；如果前后顺序发生变化，那对应的排序算法就叫作<strong>不稳定的排序算法</strong>。</p><p>你可能要问了，两个 <code>3</code> 哪个在前，哪个在后有什么关系啊，稳不稳定又有什么关系呢？为什么要考察排序算法的稳定性呢？</p><p>很多数据结构和算法课程，在讲排序的时候，都是用整数来举例，但在真正软件开发中，要排序的往往不是单纯的整数，而是一组对象，需要按照对象的某个 <code>key</code> 来排序。</p><p>比如说，现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果现在有 <code>10</code> 万条订单数据，希望按照金额从小到大对订单数据排序。对于金额相同的订单，希望按照下单时间从早到晚有序。对于这样一个排序需求，怎么来做呢？</p><p>最先想到的方法是：先按照金额对订单数据进行排序，然后，再遍历排序之后的订单数据，对于每个金额相同的小区间再按照下单时间排序。这种排序思路理解起来不难，但是实现起来会很复杂。</p><p>借助稳定排序算法，这个问题可以非常简洁地解决。解决思路是这样的：先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后，用稳定排序算法，按照订单金额重新排序。两遍排序之后，得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。为什么呢？</p><p><strong>稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变</strong>。第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/10/a7152310-d39c-11e9-b66f-d76c8c3e613a.png" srcset="/img/loading.gif" alt="image.png"></p><h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 <code>n</code> 次，就完成了 <code>n</code> 个数据的排序工作。</p><p>用一个例子，看下冒泡排序的整个过程。要对一组数据 <code>4，5，6，3，2，1</code>，从小到到大进行排序。第一次冒泡操作的详细过程就是这样：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/10/f4e52e50-d39c-11e9-b66f-d76c8c3e613a.png" srcset="/img/loading.gif" alt="image.png"><br>可以看出，经过一次冒泡操作之后，<code>6</code> 这个元素已经存储在正确的位置上。要想完成所有数据的排序，只要进行 <code>6</code> 次这样的冒泡操作就行了。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/10/040d2f90-d39d-11e9-b66f-d76c8c3e613a.png" srcset="/img/loading.gif" alt="image.png"><br>实际上，刚讲的冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。这里还有另外一个例子，这里面给 <code>6</code> 个元素排序，只需要 <code>4</code> 次冒泡操作就可以了。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/10/155e0440-d39d-11e9-b66f-d76c8c3e613a.png" srcset="/img/loading.gif" alt="image.png"><br>冒泡排序算法的原理比较容易理解，具体的代码贴到下面，你可以结合着代码来看前面讲的原理。</p><pre><code class="hljs java"><span class="hljs-comment">// 冒泡排序，a 表示数组，n 表示数组大小</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;    <span class="hljs-comment">// 提前退出冒泡循环的标志位</span>    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; ++j) &#123;      <span class="hljs-keyword">if</span> (a[j] &gt; a[j+<span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 交换</span>        <span class="hljs-keyword">int</span> tmp = a[j];        a[j] = a[j+<span class="hljs-number">1</span>];        a[j+<span class="hljs-number">1</span>] = tmp;        flag = <span class="hljs-keyword">true</span>;  <span class="hljs-comment">// 表示有数据交换      </span>      &#125;    &#125;    <span class="hljs-keyword">if</span> (!flag) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 没有数据交换，提前退出</span>  &#125;&#125;</code></pre><p>现在，结合刚才分析排序算法的三个方面，有三个问题。</p><p><strong>第一，冒泡排序是原地排序算法吗？</strong></p><p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 $O(1)$，是一个原地排序算法。</p><p><strong>第二，冒泡排序是稳定的排序算法吗？</strong></p><p>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。</p><p><strong>第三，冒泡排序的时间复杂度是多少？</strong></p><p>最好情况下，要排序的数据已经是有序的了，只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 $O(n)$。而最坏的情况是，要排序的数据刚好是倒序排列的，需要进行 <code>n</code> 次冒泡操作，所以最坏情况时间复杂度为 $O(n^2)$。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/10/6e8fe100-d39d-11e9-b66f-d76c8c3e613a.png" srcset="/img/loading.gif" alt="image.png"><br>最好、最坏情况下的时间复杂度很容易分析，那平均情况下的时间复杂是多少呢？前面讲过，平均时间复杂度就是加权平均期望时间复杂度，分析的时候要结合概率论的知识。</p><p>对于包含 <code>n</code> 个数据的数组，这 <code>n</code> 个数据就有 <code>n!</code> 种排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的。比如前面举的那两个例子，其中一个要进行 <code>6</code> 次冒泡，而另一个只需要 <code>4</code> 次。如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算就会很复杂。这里还有一种思路，通过“<strong>有序度</strong>”和“<strong>逆序度</strong>”这两个概念来进行分析。</p><p><strong>有序度</strong>是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示就是这样：</p><pre><code class="hljs plain">有序元素对：a[i] &lt;&#x3D; a[j], 如果 i &lt; j。</code></pre><p><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/10/99cd8520-d39d-11e9-b66f-d76c8c3e613a.png" srcset="/img/loading.gif" alt="image.png"><br>同理，对于一个倒序排列的数组，比如 <code>6，5，4，3，2，1</code>，有序度是 <code>0</code>；对于一个完全有序的数组，比如 <code>1，2，3，4，5，6</code>，有序度就是 <code>n*(n-1)/2</code>，也就是 <code>15</code>。把这种完全有序的数组的有序度叫作满有序度。</p><p>逆序度的定义正好跟有序度相反（默认从小到大为有序），你应该已经想到了。关于逆序度，就不举例子了。可以对照上面讲的有序度的例子自己看下。</p><pre><code class="hljs plain">逆序元素对：a[i] &gt; a[j], 如果 i &lt; j。</code></pre><p>关于这三个概念，还可以得到一个公式：<strong>逆序度 = 满有序度 - 有序度</strong>。排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。</p><p>还是拿前面举的那个冒泡排序的例子来说明。要排序的数组的初始状态是 <code>4，5，6，3，2，1</code> ，其中，有序元素对有 <code>(4，5)</code> <code>(4，6)</code> <code>(5，6)</code>，所以有序度是 <code>3</code>。<code>n=6</code>，所以排序完成之后终态的满有序度为 <code>n*(n-1)/2=15</code>。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/10/e92b3540-d39d-11e9-b66f-d76c8c3e613a.png" srcset="/img/loading.gif" alt="image.png"><br>冒泡排序包含两个操作原子，<strong>比较</strong>和<strong>交换</strong>。每交换一次，有序度就加 <code>1</code>。不管算法怎么改进，交换次数总是确定的，即为逆序度，<strong>也就是 <code>n*(n-1)/2–初始有序度</code></strong>。此例中就是 <code>15–3=12</code>，要进行 <code>12</code> 次交换操作。</p><p>对于包含 <code>n</code> 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是 <code>0</code>，所以要进行 <code>n*(n-1)/2</code> 次交换。最好情况下，初始状态的有序度是 <code>n*(n-1)/2</code>，就不需要进行交换。可以取个中间值 <code>n*(n-1)/4</code>，来表示初始有序度既不是很高也不是很低的平均情况。</p><p>换句话说，平均情况下，需要 <code>n*(n-1)/4</code> 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 $O(n^2)$，所以平均情况下的时间复杂度就是 $O(n^2)$。</p><p>这个平均时间复杂度推导过程其实并不严格，但是很多时候很实用，毕竟概率论的定量分析太复杂，不太好用。</p><h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><p>先来看一个问题。一个有序的数组，往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，只要遍历数组，找到数据应该插入的位置将其插入即可。</p><p><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/10/54a9d2e0-d39e-11e9-b66f-d76c8c3e613a.png" srcset="/img/loading.gif" alt="image.png"><br>这是一个动态排序的过程，即动态地往有序集合中添加数据，可以通过这种方法保持集合中的数据一直有序。而对于一组静态数据，也可以借鉴上面讲的插入方法，来进行排序，于是就有了插入排序算法。</p><p><strong>插入排序具体是如何借助上面的思想来实现排序的呢？</strong></p><p>首先，将数组中的数据分为两个区间，<strong>已排序区间</strong>和<strong>未排序区间</strong>。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。</p><p>如图所示，要排序的数据是 <code>4，5，6，1，3，2</code>，其中左侧为已排序区间，右侧是未排序区间。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/10/a816f0c0-d39e-11e9-b66f-d76c8c3e613a.png" srcset="/img/loading.gif" alt="image.png"><br>插入排序也包含两种操作，一种是<strong>元素的比较</strong>，一种是<strong>元素的移动</strong>。当需要将一个数据 <code>a</code> 插入到已排序区间时，需要拿 <code>a</code> 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 <code>a</code> 插入。</p><p>对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度。</p><p>为什么说移动次数就等于逆序度呢？拿刚才的例子画了一个图表，你一看就明白了。满有序度是 <code>n*(n-1)/2=15</code>，初始序列的有序度是 <code>5</code>，所以逆序度是 <code>10</code>。插入排序中，数据移动的个数总和也等于 <code>10=3+3+4</code>。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/10/d3aaa420-d39e-11e9-b66f-d76c8c3e613a.png" srcset="/img/loading.gif" alt="image.png"><br>插入排序的原理也很简单吧？也将代码实现贴在这里，你可以结合着代码再看下。</p><pre><code class="hljs java"><span class="hljs-comment">// 插入排序，a 表示数组，n 表示数组大小</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;    <span class="hljs-keyword">int</span> value = a[i];    <span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 查找插入的位置</span>    <span class="hljs-keyword">for</span> (; j &gt;= <span class="hljs-number">0</span>; --j) &#123;      <span class="hljs-keyword">if</span> (a[j] &gt; value) &#123;        a[j+<span class="hljs-number">1</span>] = a[j];  <span class="hljs-comment">// 数据移动</span>      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">break</span>;      &#125;    &#125;    a[j+<span class="hljs-number">1</span>] = value; <span class="hljs-comment">// 插入数据</span>  &#125;&#125;</code></pre><p>现在，来看点稍微复杂的东西。这里还是有三个问题。</p><p><strong>第一，插入排序是原地排序算法吗？</strong></p><p>从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 $O(1)$，也就是说，这是一个原地排序算法。</p><p><strong>第二，插入排序是稳定的排序算法吗？</strong></p><p>在插入排序中，对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</p><p><strong>第三，插入排序的时间复杂度是多少？</strong></p><p>如果要排序的数据已经是有序的，并不需要搬移任何数据。如果从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 $O(n)$。注意，这里是<strong>从尾到头遍历已经有序的数据</strong>。</p><p>如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 $O(n^2)$。</p><p>还记得在数组中插入一个数据的平均时间复杂度是多少吗？没错，是 $O(n)$。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 <code>n</code> 次插入操作，所以平均时间复杂度为 $O(n^2)$。</p><h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><p><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/10/084812c0-d3a0-11e9-b66f-d76c8c3e613a.png" srcset="/img/loading.gif" alt="image.png"><br>也有三个问题需要思考，不过前面两种排序算法已经分析得很详细了，这里就直接公布答案了。</p><p>首先，选择排序空间复杂度为 $O(1)$，是一种原地排序算法。选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 $O(n^2)$。你可以自己来分析看看。</p><p>那选择排序是稳定的排序算法吗？这个问题着重来说一下。</p><p>答案是否定的，选择排序是一种不稳定的排序算法。从前面的那张图中，可以看出来，选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。</p><p>比如 <code>5，8，5，2，9</code> 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 <code>2</code>，与第一个 <code>5</code> 交换位置，那第一个 <code>5</code> 和中间的 <code>5</code> 顺序就变了，所以就不稳定了。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要想分析、评价一个排序算法，需要从执行效率、内存消耗和稳定性三个方面来看。因此，上面分析了三种时间复杂度是 $O(n^2)$ 的排序算法，冒泡排序、插入排序、选择排序。需要重点掌握的是它们的分析方法。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/10/cef3c0e0-d3a0-11e9-b66f-d76c8c3e613a.png" srcset="/img/loading.gif" alt="image.png"><br>这三种时间复杂度为 $O(n^2)$ 的排序算法中，冒泡排序、选择排序，可能就纯粹停留在理论的层面了，学习的目的也只是为了开拓思维，实际开发中应用并不多，但是插入排序还是挺有用的。有些编程语言中的排序函数的实现原理会用到插入排序算法。</p><p>上面的这三种排序算法，实现代码都非常简单，对于小规模数据的排序，用起来非常高效。但是在大规模数据排序的时候，这个时间复杂度还是稍微有点高，所以更倾向于用下一篇的时间复杂度为 $O(nlogn)$ 的排序算法。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>选择排序和插入排序的时间复杂度相同，都是$O(n^2)$，在实际的软件开发中，为什么更倾向于使用插入排序而不是冒泡排序算法呢？</p><blockquote><p>前面分析冒泡排序和插入排序的时候讲到，冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。</p><p>但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 <code>3</code> 个赋值操作，而插入排序只需要 <code>1</code> 个。来看这段操作：</p></blockquote><pre><code class="hljs java">冒泡排序中数据的交换操作：<span class="hljs-keyword">if</span> (a[j] &gt; a[j+<span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 交换</span>   <span class="hljs-keyword">int</span> tmp = a[j];   a[j] = a[j+<span class="hljs-number">1</span>];   a[j+<span class="hljs-number">1</span>] = tmp;   flag = <span class="hljs-keyword">true</span>;&#125;插入排序中数据的移动操作：<span class="hljs-keyword">if</span> (a[j] &gt; value) &#123;  a[j+<span class="hljs-number">1</span>] = a[j];  <span class="hljs-comment">// 数据移动</span>&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-keyword">break</span>;&#125;</code></pre><blockquote><p>把执行一个赋值语句的时间粗略地计为单位时间（<code>unit_time</code>），然后分别用冒泡排序和插入排序对同一个逆序度是 <code>K</code> 的数组进行排序。用冒泡排序，需要 <code>K</code> 次交换操作，每次需要 <code>3</code> 个赋值语句，所以交换操&gt; 作总耗时就是 <code>3*K</code> 单位时间。而插入排序中数据移动操作只需要 <code>K</code> 个单位时间。</p><p>这个只是非常理论的分析，为了实验，针对上面的冒泡排序和插入排序的 <code>Java</code> 代码，写了一个性能对比测试程序，随机生成 <code>10000</code> 个数组，每个数组中包含 <code>200</code> 个数据，然后在机器上分别用冒泡和插入排序算&gt; 法来排序，冒泡排序算法大约 <code>700ms</code> 才能执行完成，而插入排序只需要 <code>100ms</code> 左右就能搞定！</p><p>所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 $O(n^2)$，但是如果希望把性能优化做到极致，那肯定首选插入排序。插入排序的算法思路也有很大的优化空间，只是讲了最基础的一种。如果你对插入排&gt; 序的优化感兴趣，可以自行学习一下希尔排序。</p></blockquote></li><li><p>特定算法是依赖特定的数据结构的。上面的几种排序算法，都是基于数组实现的。如果数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？</p></li></ul><p>欢迎留言和我分享。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归算法</title>
    <link href="/passages/recursion/"/>
    <url>/passages/recursion/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>推荐注册返佣金的这个功能你应该不陌生吧？现在很多 <code>App</code> 都有这个功能。这个功能中，用户 <code>A</code> 推荐用户 <code>B</code> 来注册，用户 <code>B</code> 又推荐了用户 <code>C</code> 来注册。可以说，用户 <code>C</code> 的“最终推荐人”为用户 <code>A</code>，用户 <code>B</code> 的“最终推荐人”也为用户 <code>A</code>，而用户 <code>A</code> 没有“最终推荐人”。</p><p>一般来说，会通过数据库来记录这种推荐关系。在数据库表中，可以记录两行数据，其中 <code>actor_id</code> 表示用户 <code>id</code>，<code>referrer_id</code> 表示推荐人 <code>id</code>。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/10/3b8e2dc0-d3ac-11e9-b66f-d76c8c3e613a.png" srcset="/img/loading.gif" alt="image.png"><br>基于这个背景的问题是，给定一个用户 <code>ID</code>，如何查找这个用户的“最终推荐人”？</p><h2 id="如何理解“递归”？"><a href="#如何理解“递归”？" class="headerlink" title="如何理解“递归”？"></a>如何理解“递归”？</h2><p>个人觉得，有两个最难理解的知识点，一个是<strong>动态规划</strong>，另一个就是<strong>递归</strong>。</p><p>递归是一种应用非常广泛的算法（或者编程技巧）。很多数据结构和算法的编码实现都要用到递归，比如 <code>DFS</code> 深度优先搜索、前中后序二叉树遍历等等。所以，搞懂递归非常重要，否则，后面复杂一些的数据结构和算法学起来就会比较吃力。</p><p>不过，别看说了这么多，递归本身可是一点儿都不“高冷”，生活中就有很多用到递归的例子。</p><p>周末你带着女朋友去电影院看电影，女朋友问你，咱们现在坐在第几排啊？电影院里面太黑了，看不清，没法数，现在你怎么办？</p><p>别忘了你是程序员，这个可难不倒你，递归就开始排上用场了。于是你就问前面一排的人他是第几排，你想只要在他的数字上加一，就知道自己在哪一排了。但是，前面的人也看不清啊，所以他也问他前面的人。就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排再把数字传回来。直到你前面的人告诉你他在哪一排，于是你就知道答案了。</p><p>这就是一个非常标准的递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以用递推公式来表示。刚刚这个生活中的例子，用递推公式将它表示出来就是这样的：</p><pre><code class="hljs plain">f(n)&#x3D;f(n-1)+1 其中，f(1)&#x3D;1</code></pre><p><code>f(n)</code> 表示你想知道自己在哪一排，<code>f(n-1)</code> 表示前面一排所在的排数，<code>f(1)=1</code> 表示第一排的人知道自己在第一排。有了这个递推公式，就可以很轻松地将它改为递归代码，如下：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-keyword">return</span> f(n<span class="hljs-number">-1</span>) + <span class="hljs-number">1</span>;&#125;</code></pre><h2 id="递归需要满足的三个条件"><a href="#递归需要满足的三个条件" class="headerlink" title="递归需要满足的三个条件"></a>递归需要满足的三个条件</h2><p>刚刚这个例子是非常典型的递归，那究竟什么样的问题可以用递归来解决呢？这里总结了三个条件，只要同时满足以下三个条件，就可以用递归来解决。</p><p><strong>1. 一个问题的解可以分解为几个子问题的解</strong></p><p>何为子问题？子问题就是数据规模更小的问题。比如，前面讲的电影院的例子，你要知道，“自己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样一个子问题。</p><p><strong>2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</strong></p><p>比如电影院那个例子，你求解“自己在哪一排”的思路，和前面一排人求解“自己在哪一排”的思路，是一模一样的。</p><p><strong>3. 存在递归终止条件</strong></p><p>把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。</p><p>还是电影院的例子，第一排的人不需要再继续询问任何人，就知道自己在哪一排，也就是 <code>f(1)=1</code>，这就是递归的终止条件。</p><h2 id="如何编写递归代码？"><a href="#如何编写递归代码？" class="headerlink" title="如何编写递归代码？"></a>如何编写递归代码？</h2><p>刚刚铺垫了这么多，现在来看，如何来写递归代码？个人觉得，写递归代码最关键的是写出递推公式，找到终止条件，剩下将递推公式转化为代码就很简单了。</p><p>先记住这个理论。举一个例子，一步一步实现一个递归代码。</p><p>假如这里有 <code>n</code> 个台阶，每次可以跨 <code>1</code> 个台阶或者 <code>2</code> 个台阶，请问走这 <code>n</code> 个台阶有多少种走法？如果有 <code>7</code> 个台阶，可以 <code>2，2，2，1</code> 这样子上去，也可以 <code>1，2，1，1，2</code> 这样子上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？</p><p>仔细想下，实际上，可以根据第一步的走法把所有走法分为两类，第一类是第一步走了 <code>1</code> 个台阶，另一类是第一步走了 <code>2</code> 个台阶。所以 <code>n</code> 个台阶的走法就等于先走 <code>1</code> 阶后，<code>n-1</code> 个台阶的走法加上先走 <code>2</code> 阶后，<code>n-2</code> 个台阶的走法。用公式表示就是：</p><pre><code class="hljs plain">f(n) &#x3D; f(n-1)+f(n-2)</code></pre><p>有了递推公式，递归代码基本上就完成了一半。再来看下终止条件。当有一个台阶时，不需要再继续递归，就只有一种走法。所以 <code>f(1)=1</code>。这个递归终止条件足够吗？可以用 <code>n=2</code>，<code>n=3</code> 这样比较小的数试验一下。</p><p><code>n=2</code> 时，<code>f(2)=f(1)+f(0)</code>。如果递归终止条件只有一个 <code>f(1)=1</code>，那 <code>f(2)</code> 就无法求解了。所以除了 <code>f(1)=1</code> 这一个递归终止条件外，还要有 <code>f(0)=1</code>，表示走 <code>0</code> 个台阶有一种走法，不过这样子看起来就不符合正常的逻辑思维了。所以，可以把 <code>f(2)=2</code> 作为一种终止条件，表示走 <code>2</code> 个台阶，有两种走法，一步走完或者分两步来走。</p><p>所以，递归终止条件就是 <code>f(1)=1</code>，<code>f(2)=2</code>。这个时候，可以再拿 <code>n=3</code>，<code>n=4</code> 来验证一下，这个终止条件是否足够并且正确。</p><p>把递归终止条件和刚刚得到的递推公式放到一起就是这样的：</p><pre><code class="hljs plain">f(1) &#x3D; 1;f(2) &#x3D; 2;f(n) &#x3D; f(n-1)+f(n-2)</code></pre><p>有了这个公式，转化成递归代码就简单多了。最终的递归代码是这样的：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;  <span class="hljs-keyword">return</span> f(n<span class="hljs-number">-1</span>) + f(n<span class="hljs-number">-2</span>);&#125;</code></pre><p>总结一下，<strong>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</strong></p><p>虽然讲了这么多方法，但是作为初学者，现在是不是还是有种想不太清楚的感觉呢？实际上，刚学递归的时候，都有这种感觉，这也是文章开头说递归代码比较难理解的地方。</p><p>刚讲的电影院的例子，递归调用只有一个分支，也就是说“一个问题只需要分解为一个子问题”，很容易能够想清楚“递“和”归”的每一个步骤，所以写起来、理解起来都不难。</p><p>但是，当面对的是一个问题要分解为多个子问题的情况，递归代码就没那么好理解了。</p><p>像刚刚讲的第二个例子，人脑几乎没办法把整个“递”和“归”的过程一步一步都想清楚。</p><p>计算机擅长做重复的事情，所以递归正和它的胃口。而人脑更喜欢平铺直叙的思维方式。当看到递归时，总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。</p><p>对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。那正确的思维方式应该是怎样的呢？</p><p>如果一个问题 <code>A</code> 可以分解为若干子问题 <code>B</code>、<code>C</code>、<code>D</code>，你可以假设子问题 <code>B</code>、<code>C</code>、<code>D</code> 已经解决，在此基础上思考如何解决问题 <code>A</code>。而且，你只需要思考问题 <code>A</code> 与子问题 <code>B</code>、<code>C</code>、<code>D</code> 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。</p><p>因此，<strong>编写递归代码的关键是，只要遇到递归，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</strong></p><h2 id="递归代码要警惕堆栈溢出"><a href="#递归代码要警惕堆栈溢出" class="headerlink" title="递归代码要警惕堆栈溢出"></a>递归代码要警惕堆栈溢出</h2><p>在实际的软件开发中，编写递归代码时，会遇到很多问题，比如堆栈溢出。而堆栈溢出会造成系统崩溃，后果会非常严重。为什么递归代码容易造成堆栈溢出呢？又该如何预防堆栈溢出呢？</p><p>在“栈”那一篇讲过，函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p><p>比如前面的讲到的电影院的例子，如果将系统栈或者 <code>JVM</code> 堆栈大小设置为 <code>1KB</code>，在求解 <code>f(19999)</code> 时便会出现如下堆栈报错：</p><pre><code class="hljs plain">Exception in thread &quot;main&quot; java.lang.StackOverflowError</code></pre><p>那么，如何避免出现堆栈溢出呢？</p><p>可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度（比如 <code>1000</code>）之后，就不继续往下再递归了，直接返回报错。还是电影院那个例子，可以改造成下面这样子，就可以避免堆栈溢出了。不过，代码是伪代码，为了代码简洁，有些边界条件没有考虑，比如 <code>x&lt;=0</code>。</p><pre><code class="hljs c"><span class="hljs-comment">// 全局变量，表示递归的深度。</span><span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;  ++depth；  <span class="hljs-keyword">if</span> (depth &gt; <span class="hljs-number">1000</span>) <span class="hljs-keyword">throw</span> exception;    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-keyword">return</span> f(n<span class="hljs-number">-1</span>) + <span class="hljs-number">1</span>;&#125;</code></pre><p>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 <code>10</code>、<code>50</code>，就可以用这种方法，否则这种方法并不是很实用。</p><h2 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="headerlink" title="递归代码要警惕重复计算"></a>递归代码要警惕重复计算</h2><p>除此之外，使用递归时还会出现重复计算的问题。刚才的第二个递归代码的例子，如果把整个递归过程分解一下的话，那就是这样的：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/10/3ad4ddf0-d3ae-11e9-b66f-d76c8c3e613a.png" srcset="/img/loading.gif" alt="image.png"><br>从图中，可以直观地看到，想要计算 <code>f(5)</code>，需要先计算 <code>f(4)</code> 和 <code>f(3)</code>，而计算 <code>f(4)</code> 还需要计算 <code>f(3)</code>，因此，<code>f(3)</code> 就被计算了很多次，这就是重复计算问题。</p><p>为了避免重复计算，可以通过一个数据结构（比如散列表）来保存已经求解过的 <code>f(k)</code>。当递归调用到 <code>f(k)</code> 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。</p><p>按照上面的思路，来改造一下刚才的代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;    <span class="hljs-comment">// hasSolvedList 可以理解成一个 Map，key 是 n，value 是 f(n)</span>  <span class="hljs-keyword">if</span> (hasSolvedList.containsKey(n)) &#123;    <span class="hljs-keyword">return</span> hasSovledList.get(n);  &#125;    <span class="hljs-keyword">int</span> ret = f(n-<span class="hljs-number">1</span>) + f(n-<span class="hljs-number">2</span>);  hasSovledList.put(n, ret);  <span class="hljs-keyword">return</span> ret;&#125;</code></pre><p>除了堆栈溢出、重复计算这两个常见的问题。递归代码还有很多别的问题。</p><p>在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销，比如我们前面讲到的电影院递归代码，空间复杂度并不是 $O(1)$，而是 $O(n)$。</p><h2 id="怎么将递归代码改写为非递归代码？"><a href="#怎么将递归代码改写为非递归代码？" class="headerlink" title="怎么将递归代码改写为非递归代码？"></a>怎么将递归代码改写为非递归代码？</h2><p>刚说了递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。所以，在开发过程中，要根据实际情况来选择是否需要用递归的方式来实现。</p><p>那是否可以把递归代码改写为非递归代码呢？比如刚才那个电影院的例子，抛开场景，只看 <code>f(x) = f(x-1)+1</code> 这个递推公式。这样改写看看：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-keyword">int</span> ret = <span class="hljs-number">1</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;    ret = ret + <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">return</span> ret;&#125;</code></pre><p>同样，第二个例子也可以改为非递归的实现方式。</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;  <span class="hljs-keyword">int</span> pre = <span class="hljs-number">2</span>;  <span class="hljs-keyword">int</span> prepre = <span class="hljs-number">1</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; ++i) &#123;    ret = pre + prepre;    prepre = pre;    pre = ret;  &#125;  <span class="hljs-keyword">return</span> ret;&#125;</code></pre><p>那是不是所有的递归代码都可以改为这种迭代循环的非递归写法呢？</p><p>笼统地讲，是的。因为递归本身就是借助栈来实现的，只不过使用的栈是系统或者虚拟机本身提供的，没有感知罢了。如果自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。</p><p>但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于递归的知识，这里来总结一下。</p><p>递归是一种非常高效、简洁的编码技巧。只要是满足“三个条件”的问题就可以通过递归代码来解决。</p><p>不过递归代码也比较难写、难理解。编写递归代码的关键就是不要把自己绕进去，正确姿势是写出递推公式，找出终止条件，然后再翻译成递归代码。</p><p>递归代码虽然简洁高效，但是，递归代码也有很多弊端。比如，堆栈溢出、重复计算、函数调用耗时多、空间复杂度高等，所以，在编写递归代码的时候，一定要控制好这些副作用。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>如何找到“最终推荐人”？解决方案是这样的：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">findRootReferrerId</span><span class="hljs-params">(<span class="hljs-keyword">long</span> actorId)</span> </span>&#123;  Long referrerId = select referrer_id from [table] where actor_id = actorId;  <span class="hljs-keyword">if</span> (referrerId == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> actorId;  <span class="hljs-keyword">return</span> findRootReferrerId(referrerId);&#125;</code></pre><blockquote><p>是不是非常简洁？用三行代码就能搞定了，不过在实际项目中，上面的代码并不能工作，为什么呢？这里面有两个问题。</p><p>第一，如果递归很深，可能会有堆栈溢出的问题。</p><p>第二，如果数据库里存在脏数据，还需要处理由此产生的无限递归问题。比如 <code>demo</code> 环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果 <code>A</code> 的推荐人是 <code>B</code>，<code>B</code> 的推荐人是 <code>C</code>，<code>C</code> 的推荐人是 <code>A</code>，这样就会发生死循环。</p><p>第一个问题，前面已经解答过了，可以用限制递归深度来解决。第二个问题，也可以用限制递归深度来解决。不过，还有一个更高级的处理方法，就是自动检测 <code>A-B-C-A</code> 这种“环”的存在。如何来检测环的存在呢？这个暂时不细说，你可以自己思考下。</p></blockquote></li><li><p>平时调试代码喜欢使用 <code>IDE</code> 的单步跟踪功能，像规模比较大、递归层次很深的递归代码，几乎无法使用这种调试方式。对于递归代码，有什么好的调试方法呢？</p></li></ul><p>欢迎留言和我分享。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.队列</title>
    <link href="/passages/7/"/>
    <url>/passages/7/</url>
    
    <content type="html"><![CDATA[<!-- more --><p><code>CPU</code> 资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致 <code>CPU</code> 频繁切换，处理性能下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。</p><p><font color='green'>当向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？</font></p><h2 id="如何理解“队列”？"><a href="#如何理解“队列”？" class="headerlink" title="如何理解“队列”？"></a>如何理解“队列”？</h2><p>队列这个概念非常好理解。你可以把它想象成排队买票，先来的先买，后来的人只能站末尾，不允许插队。<strong>先进者先出，这就是典型的“队列”。</strong></p><p>栈只支持两个基本操作：<strong>入栈 <code>push()</code> 和出栈 <code>pop()</code></strong>。队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个：<strong>入队 <code>enqueue()</code></strong>，放一个数据到队列尾部；<strong>出队 <code>dequeue()</code></strong>，从队列头部取一个元素。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/10/ce9ec840-d38e-11e9-b66f-d76c8c3e613a.png" srcset="/img/loading.gif" alt="image.png"><br>所以，队列跟栈一样，也是一种<strong>操作受限的线性表数据结构。</strong></p><p>队列的概念很好理解，基本操作也很容易掌握。作为一种非常基础的数据结构，队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列 <code>Disruptor</code>、<code>Linux</code> 环形缓存，都用到了循环并发队列；<code>Java concurrent</code> 并发包利用 <code>ArrayBlockingQueue</code> 来实现公平锁等。</p><h2 id="顺序队列和链式队列"><a href="#顺序队列和链式队列" class="headerlink" title="顺序队列和链式队列"></a>顺序队列和链式队列</h2><p>队列跟栈一样，也是一种抽象的数据结构。它具有先进先出的特性，支持在队尾插入元素，在队头删除元素，那究竟该如何实现一个队列呢？</p><p>跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的栈叫作<strong>顺序栈</strong>，用链表实现的栈叫作<strong>链式栈</strong>。同样，用数组实现的队列叫作<strong>顺序队列</strong>，用链表实现的队列叫作<strong>链式队列</strong>。</p><p>先来看下基于数组的实现方法。下面用 <code>Java</code> 语言实现了一下，不过并不包含 <code>Java</code> 语言的高级语法，而且做了比较详细的注释，你应该可以看懂。</p><pre><code class="hljs java"><span class="hljs-comment">// 用数组实现的队列</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayQueue</span> </span>&#123;  <span class="hljs-comment">// 数组：items，数组大小：n</span>  <span class="hljs-keyword">private</span> String[] items;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;  <span class="hljs-comment">// head 表示队头下标，tail 表示队尾下标</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tail = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 申请一个大小为 capacity 的数组</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;    items = <span class="hljs-keyword">new</span> String[capacity];    n = capacity;  &#125;  <span class="hljs-comment">// 入队</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(String item)</span> </span>&#123;    <span class="hljs-comment">// 如果 tail == n 表示队列已经满了</span>    <span class="hljs-keyword">if</span> (tail == n) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    items[tail] = item;    ++tail;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  &#125;  <span class="hljs-comment">// 出队</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 如果 head == tail 表示队列为空</span>    <span class="hljs-keyword">if</span> (head == tail) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 为了让其他语言的同学看的更加明确，把 -- 操作放到单独一行来写了</span>    String ret = items[head];    ++head;    <span class="hljs-keyword">return</span> ret;  &#125;&#125;</code></pre><p>比起栈的数组实现，队列的数组实现稍微有点儿复杂，但是没关系。稍微解释一下实现思路，很容易就能明白了。</p><p>对于栈来说，只需要一个栈顶指针就可以了。但是队列需要两个指针：一个是 <code>head</code> 指针，指向队头；一个是 <code>tail</code> 指针，指向队尾。</p><p>你可以结合下面这幅图来理解。当 <code>a</code>、<code>b</code>、<code>c</code>、<code>d</code> 依次入队之后，队列中的 <code>head</code> 指针指向下标为 <code>0</code> 的位置，<code>tail</code> 指针指向下标为 <code>4</code> 的位置。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/10/78401340-d38f-11e9-b66f-d76c8c3e613a.png" srcset="/img/loading.gif" alt="image.png"><br>当调用两次出队操作之后，队列中 <code>head</code> 指针指向下标为 <code>2</code> 的位置，<code>tail</code> 指针仍然指向下标为 <code>4</code> 的位置。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/10/88a687f0-d38f-11e9-b66f-d76c8c3e613a.png" srcset="/img/loading.gif" alt="image.png"><br>你肯定已经发现了，随着不停地进行入队、出队操作，<code>head</code> 和 <code>tail</code> 都会持续往后移动。当 <code>tail</code> 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。这个问题该如何解决呢？</p><p>你是否还记得，在数组那一篇，也遇到过类似的问题，就是数组的删除操作会导致数组中的数据不连续。你还记得当时是怎么解决的吗？对，用<strong>数据搬移</strong>！但是，每次进行出队操作都相当于删除数组下标为 <code>0</code> 的数据，要搬移整个队列中的数据，这样出队操作的时间复杂度就会从原来的 $O(1)$ 变为 $O(n)$。能不能优化一下呢？</p><p>实际上，在出队时可以不用搬移数据。如果没有空闲空间了，只需要在入队时，再集中触发一次数据的搬移操作。借助这个思想，出队函数 <code>dequeue()</code> 保持不变，稍加改造一下入队函数 <code>enqueue()</code> 的实现，就可以轻松解决刚才的问题了。下面是具体的代码：</p><pre><code class="hljs java"> <span class="hljs-comment">// 入队操作，将 item 放入队尾</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(String item)</span> </span>&#123;  <span class="hljs-comment">// tail == n 表示队列末尾没有空间了</span>  <span class="hljs-keyword">if</span> (tail == n) &#123;    <span class="hljs-comment">// tail ==n &amp;&amp; head==0，表示整个队列都占满了</span>    <span class="hljs-keyword">if</span> (head == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-comment">// 数据搬移</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head; i &lt; tail; ++i) &#123;      items[i-head] = items[i];    &#125;    <span class="hljs-comment">// 搬移完之后重新更新 head 和 tail</span>    tail -= head;    head = <span class="hljs-number">0</span>;  &#125;    items[tail] = item;  ++tail;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><p>从代码中看到，当队列的 <code>tail</code> 指针移动到数组的最右边后，如果有新的数据入队，可以将 <code>head</code> 到 <code>tail</code> 之间的数据，整体搬移到数组中 <code>0</code> 到 <code>tail-head</code> 的位置。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/10/f105bd20-d38f-11e9-b66f-d76c8c3e613a.png" srcset="/img/loading.gif" alt="image.png"><br>这种实现思路中，出队操作的时间复杂度仍然是 $O(1)$，但入队操作的时间复杂度还是 $O(1)$ 吗？你可以用算法复杂度分析方法，自己试着分析一下。</p><p>接下来，再来看下基于链表的队列实现方法。</p><p>基于链表的实现，同样需要两个指针：<code>head</code> 指针和 <code>tail</code> 指针。它们分别指向链表的第一个结点和最后一个结点。如图所示，入队时，<code>tail-&gt;next= new_node</code>, <code>tail = tail-&gt;next</code>；出队时，<code>head = head-&gt;next</code>。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/10/200af090-d390-11e9-b66f-d76c8c3e613a.png" srcset="/img/loading.gif" alt="image.png"></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueueBasedOnLinkedList</span> </span>&#123;  <span class="hljs-comment">// 队列的队首和队尾</span>  <span class="hljs-keyword">private</span> Node head = <span class="hljs-keyword">null</span>;  <span class="hljs-keyword">private</span> Node tail = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">// 入队</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(String value)</span> </span>&#123;    <span class="hljs-keyword">if</span> (tail == <span class="hljs-keyword">null</span>) &#123;      Node newNode = <span class="hljs-keyword">new</span> Node(value, <span class="hljs-keyword">null</span>);      head = newNode;      tail = newNode;    &#125; <span class="hljs-keyword">else</span> &#123;      tail.next = <span class="hljs-keyword">new</span> Node(value, <span class="hljs-keyword">null</span>);      tail = tail.next;    &#125;  &#125;  <span class="hljs-comment">// 出队</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    String value = head.data;    head = head.next;    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      tail = <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-keyword">return</span> value;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printAll</span><span class="hljs-params">()</span> </span>&#123;    Node p = head;    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;      System.out.print(p.data + <span class="hljs-string">" "</span>);      p = p.next;    &#125;    System.out.println();  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">private</span> String data;    <span class="hljs-keyword">private</span> Node next;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(String data, Node next)</span> </span>&#123;      <span class="hljs-keyword">this</span>.data = data;      <span class="hljs-keyword">this</span>.next = next;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> data;    &#125;  &#125;&#125;</code></pre><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>刚才用数组来实现队列的时候，在 <code>tail==n</code> 时，会有数据搬移操作，这样入队操作性能就会受到影响。那有没有办法能够避免数据搬移呢？来看看循环队列的解决思路。</p><p>循环队列，顾名思义，它长得像一个环。原本数组是有头有尾的，是一条直线。现在把首尾相连，扳成了一个环。下面有一张图，你可以直观地感受一下。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/10/99377290-d390-11e9-b66f-d76c8c3e613a.png" srcset="/img/loading.gif" alt="image.png"><br>可以看到，图中这个队列的大小为 <code>8</code>，当前 <code>head=4，tail=7</code>。当有一个新的元素 <code>a</code> 入队时，放入下标为 <code>7</code> 的位置。但这个时候，并不把 <code>tail</code> 更新为 <code>8</code>，而是将其在环中后移一位，到下标为 <code>0</code> 的位置。当再有一个元素 <code>b</code> 入队时，将 <code>b</code> 放入下标为 <code>0</code> 的位置，然后 <code>tail</code> 加 <code>1</code> 更新为 <code>1</code>。所以，在 <code>a</code>，<code>b</code> 依次入队之后，循环队列中的元素就变成了下面的样子：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/10/be4476a0-d390-11e9-b66f-d76c8c3e613a.png" srcset="/img/loading.gif" alt="image.png"><br>通过这样的方法，成功避免了数据搬移操作。看起来不难理解，但是循环队列的代码实现难度要比前面讲的非循环队列难多了。要想写出没有 <code>bug</code> 的循环队列的实现代码，个人觉得，最关键的是，<strong>确定好队空和队满的判定条件</strong>。</p><p>在用数组实现的非循环队列中，队满的判断条件是 <code>tail == n</code>，队空的判断条件是 <code>head == tail</code>。那针对循环队列，如何判断队空和队满呢？</p><p>队列为空的判断条件仍然是 <code>head == tail</code>。但队列满的判断条件就稍微有点复杂了。下面有一张队列满的图，你可以看一下，试着总结一下规律。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/10/e7058200-d390-11e9-b66f-d76c8c3e613a.png" srcset="/img/loading.gif" alt="image.png"><br>就像图中画的队满的情况，<code>tail=3，head=4，n=8</code>，所以总结一下规律就是：<code>(3+1)%8=4</code>。多画几张队满的图，你就会发现，当队满时，<code>(tail+1)%n=head</code>。</p><p>你有没有发现，当队列满时，图中的 <code>tail</code> 指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间。</p><p><code>Talk is cheap</code>，如果还是没怎么理解，那就 <code>show you code</code> 吧。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircularQueue</span> </span>&#123;  <span class="hljs-comment">// 数组：items，数组大小：n</span>  <span class="hljs-keyword">private</span> String[] items;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;  <span class="hljs-comment">// head 表示队头下标，tail 表示队尾下标</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tail = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 申请一个大小为 capacity 的数组</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CircularQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;    items = <span class="hljs-keyword">new</span> String[capacity];    n = capacity;  &#125;  <span class="hljs-comment">// 入队</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(String item)</span> </span>&#123;    <span class="hljs-comment">// 队列满了</span>    <span class="hljs-keyword">if</span> ((tail + <span class="hljs-number">1</span>) % n == head) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    items[tail] = item;    tail = (tail + <span class="hljs-number">1</span>) % n;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  &#125;  <span class="hljs-comment">// 出队</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 如果 head == tail 表示队列为空</span>    <span class="hljs-keyword">if</span> (head == tail) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    String ret = items[head];    head = (head + <span class="hljs-number">1</span>) % n;    <span class="hljs-keyword">return</span> ret;  &#125;&#125;</code></pre><h2 id="阻塞队列和并发队列"><a href="#阻塞队列和并发队列" class="headerlink" title="阻塞队列和并发队列"></a>阻塞队列和并发队列</h2><p>前面讲的内容理论比较多，看起来很难跟实际的项目开发扯上关系。确实，队列这种数据结构很基础，平时的业务开发不大可能从零实现一个队列，甚至都不会直接用到。而一些具有特殊特性的队列应用却比较广泛，比如阻塞队列和并发队列。</p><p><strong>阻塞队列</strong>其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/10/3efc46b0-d391-11e9-b66f-d76c8c3e613a.png" srcset="/img/loading.gif" alt="image.png"><br>你应该已经发现了，上述的定义就是一个“生产者 - 消费者模型”！是的，可以使用阻塞队列，轻松实现一个“生产者 - 消费者模型”！</p><p>这种基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。</p><p>而且不仅如此，基于阻塞队列，还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如前面的例子，可以多配置几个“消费者”，来应对一个“生产者”。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/10/662af240-d391-11e9-b66f-d76c8c3e613a.png" srcset="/img/loading.gif" alt="image.png"><br>前面讲了阻塞队列，在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题，那如何实现一个线程安全的队列呢？</p><p>线程安全的队列叫作<strong>并发队列</strong>。最简单直接的实现方式是直接在 <code>enqueue()</code>、<code>dequeue()</code> 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 <code>CAS</code> 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。在实战篇讲 <code>Disruptor</code> 的时候，会再详细讲并发队列的应用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面讲了一种跟栈很相似的数据结构，队列。关于队列，能掌握下面的内容，就没问题了。</p><p>队列最大的特点就是先进先出，主要的两个操作是<strong>入队和出队</strong>。跟栈一样，它既可以用数组来实现，也可以用链表来实现。用数组实现的叫顺序队列，用链表实现的叫链式队列。特别的是长得像一个环的循环队列。在数组实现队列的时候，会有数据搬移操作，要想解决数据搬移的问题，就需要像环一样的循环队列。</p><p>循环队列是这篇的重点。要想写出没有 <code>bug</code> 的循环队列实现代码，关键要确定好队空和队满的判定条件，具体的代码要能写出来。</p><p>除此之外，还讲了几种高级的队列结构，阻塞队列、并发队列，底层都还是队列这种数据结构，只不过在之上附加了很多其他功能。阻塞队列就是入队、出队操作可以阻塞，并发队列就是队列的操作多线程安全。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？</p><blockquote><p>一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。那如何存储排队的请求呢？</p><p>希望公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求。前面说过，队列有基于链表和基于数组这两种实现方式。这两种实现方式对于排队请求又有什么区别呢？</p><p>基于链表的实现方式，可以实现一个支持无限排队的无界队列（<code>unbounded queue</code>），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。</p><p>而基于数组实现的有界队列（<code>bounded queue</code>），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。</p><p>除了前面讲到队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。<strong>实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</strong></p></blockquote></li><li><p>除了线程池这种池结构会用到队列排队请求，还有哪些类似线程池结构或者场景中会用到队列的排队请求呢？</p><blockquote><p>分布式应用中的消息队列，也是一种队列结构</p></blockquote></li><li><p>关于如何实现无锁的并发队列，网上有很多讨论。对这个问题，你怎么看？</p><blockquote><p>考虑使用<code>CAS</code>实现无锁队列，则在入队前，获取<code>tail</code>位置，入队时比较<code>tail</code>是否发生变化，如果否，则允许入队，反之，本次入队失败。<br>  出队则是获取<code>head</code>位置，进行<code>CAS</code>。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(中级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot Kafka的配置</title>
    <link href="/passages/Kafka/"/>
    <url>/passages/Kafka/</url>
    
    <content type="html"><![CDATA[<!-- more --><p><code>Kafka</code>作为一个优秀的消息中间件一直被大量开发者使用，本文以<code>Spring Boot 2.1.6.RELEASE</code> 为例。</p><blockquote><p>PS：此文是已在服务端安装好<code>Kafka</code>的前提下进行的。（请自行查找怎么安装<code>Kafka</code>及创建<code>Topic</code>等）</p></blockquote><h2 id="引入Maven依赖"><a href="#引入Maven依赖" class="headerlink" title="引入Maven依赖"></a>引入Maven依赖</h2><pre><code class="hljs properties"><span class="hljs-attr">&lt;dependency&gt;</span><span class="hljs-attr">&lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;</span><span class="hljs-attr">&lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;</span><span class="hljs-attr">&lt;/dependency&gt;</span></code></pre><h2 id="配置文件配置Kafka"><a href="#配置文件配置Kafka" class="headerlink" title="配置文件配置Kafka"></a>配置文件配置Kafka</h2><pre><code class="hljs properties"><span class="hljs-comment">#============== kafka ===================</span><span class="hljs-comment"># 指定kafka 代理地址，可以多个</span><span class="hljs-meta">kafka.bootstrap.servers</span>=<span class="hljs-string">xxxxxxx:9092</span><span class="hljs-comment">#=============== provider  =======================</span><span class="hljs-meta">kafka.producer.retries</span>=<span class="hljs-string">2</span><span class="hljs-comment"># 每次批量发送消息的数量</span><span class="hljs-meta">kafka.producer.batch.size</span>=<span class="hljs-string">16384</span><span class="hljs-meta">kafka.producer.buffer.memory</span>=<span class="hljs-string">33554432</span><span class="hljs-meta">kafka.producer.linger</span>=<span class="hljs-string">1</span><span class="hljs-meta">kafka.producer.acks</span>=<span class="hljs-string">all</span><span class="hljs-comment"># 指定消息key和消息体的编解码方式</span><span class="hljs-meta">producer.key-serializer</span>=<span class="hljs-string">org.apache.kafka.common.serialization.StringSerializer</span><span class="hljs-meta">producer.value-serializer</span>=<span class="hljs-string">org.apache.kafka.common.serialization.StringSerializer</span><span class="hljs-comment">#=============== consumer  =======================</span><span class="hljs-comment"># 指定默认消费者group id</span><span class="hljs-meta">kafka.consumer.group.id</span>=<span class="hljs-string">dev-consumer-group</span><span class="hljs-comment">#earliest 当分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，从头开始消费。</span><span class="hljs-comment">#latest 当分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，消费新产生的该分区下的数据。</span><span class="hljs-comment">#none 当该topic下所有分区中存在未提交的offset时，抛出异常。</span><span class="hljs-meta">kafka.consumer.auto.offset.reset</span>=<span class="hljs-string">earliest</span><span class="hljs-meta">kafka.consumer.enable.auto.commit</span>=<span class="hljs-string">true</span><span class="hljs-meta">kafka.consumer.session.timeout</span>=<span class="hljs-string">60000</span><span class="hljs-meta">kafka.consumer.auto.commit.interval</span>=<span class="hljs-string">1000</span><span class="hljs-comment"># 指定listener 容器中的线程数，用于提高并发量</span><span class="hljs-meta">kafka.consumer.concurrency</span>=<span class="hljs-string">2</span><span class="hljs-comment"># 指定消息key和消息体的编解码方式</span><span class="hljs-meta">kafka.consumer.key-deserializer</span>=<span class="hljs-string">org.apache.kafka.common.serialization.StringDeserializer</span><span class="hljs-meta">kafka.consumer.value-deserializer</span>=<span class="hljs-string">org.apache.kafka.common.serialization.StringDeserializer</span></code></pre><blockquote><p>其中<code>kafka.bootstrap.servers</code>是<code>Kafka</code>的地址，如果是服务器地址，要确保打开对应端口的外网访问，如果多个可以用逗号隔开</p></blockquote><h2 id="Kafka生产者的配置"><a href="#Kafka生产者的配置" class="headerlink" title="Kafka生产者的配置"></a>Kafka生产者的配置</h2><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableKafka</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaProducerConfig</span> </span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;kafka.bootstrap.servers&#125;"</span>)    <span class="hljs-keyword">private</span> String servers;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;kafka.producer.retries&#125;"</span>)    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> retries;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;kafka.producer.batch.size&#125;"</span>)    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> batchSize;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;kafka.producer.linger&#125;"</span>)    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> linger;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;kafka.producer.buffer.memory&#125;"</span>)    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> bufferMemory;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;kafka.producer.acks&#125;"</span>)    <span class="hljs-keyword">private</span> String acks;    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">producerConfigs</span><span class="hljs-params">()</span> </span>&#123;        Map&lt;String, Object&gt; props = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, servers);        props.put(ProducerConfig.RETRIES_CONFIG, retries);        props.put(ProducerConfig.BATCH_SIZE_CONFIG, batchSize);        props.put(ProducerConfig.LINGER_MS_CONFIG, linger);        props.put(ProducerConfig.BUFFER_MEMORY_CONFIG, bufferMemory);        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);        props.put(ProducerConfig.ACKS_CONFIG, acks);        <span class="hljs-keyword">return</span> props;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> ProducerFactory&lt;String, String&gt; <span class="hljs-title">producerFactory</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultKafkaProducerFactory&lt;&gt;(producerConfigs());    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> KafkaTemplate&lt;String, String&gt; <span class="hljs-title">kafkaTemplate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> KafkaTemplate&lt;&gt;(producerFactory());    &#125;&#125;</code></pre><h2 id="Kafka消费者的配置"><a href="#Kafka消费者的配置" class="headerlink" title="Kafka消费者的配置"></a>Kafka消费者的配置</h2><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableKafka</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaConsumerConfig</span> </span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;kafka.bootstrap.servers&#125;"</span>)    <span class="hljs-keyword">private</span> String servers;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;kafka.consumer.enable.auto.commit&#125;"</span>)    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> enableAutoCommit;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;kafka.consumer.session.timeout&#125;"</span>)    <span class="hljs-keyword">private</span> String sessionTimeout;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;kafka.consumer.auto.commit.interval&#125;"</span>)    <span class="hljs-keyword">private</span> String autoCommitInterval;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;kafka.consumer.group.id&#125;"</span>)    <span class="hljs-keyword">private</span> String groupId;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;kafka.consumer.auto.offset.reset&#125;"</span>)    <span class="hljs-keyword">private</span> String autoOffsetReset;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;kafka.consumer.concurrency&#125;"</span>)    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> concurrency;    <span class="hljs-meta">@Bean</span>(name = <span class="hljs-string">"kafkaListenerContainerFactory"</span>)    <span class="hljs-keyword">public</span> KafkaListenerContainerFactory&lt;ConcurrentMessageListenerContainer&lt;String, String&gt;&gt; kafkaListenerContainerFactory() &#123;        ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory = <span class="hljs-keyword">new</span> ConcurrentKafkaListenerContainerFactory&lt;&gt;();        factory.setConsumerFactory(consumerFactory());        factory.setConcurrency(concurrency);        factory.getContainerProperties().setPollTimeout(<span class="hljs-number">1500</span>);        <span class="hljs-keyword">return</span> factory;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> ConsumerFactory&lt;String, String&gt; <span class="hljs-title">consumerFactory</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultKafkaConsumerFactory&lt;&gt;(consumerConfigs());    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">consumerConfigs</span><span class="hljs-params">()</span> </span>&#123;        Map&lt;String, Object&gt; propsMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<span class="hljs-comment">//        propsMap.put("zookeeper.connect", "master1.hdp.com:2181,master2.hdp.com:2181,slave1.hdp.com:2181");</span>        propsMap.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, servers);        propsMap.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, enableAutoCommit);        propsMap.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, autoCommitInterval);        propsMap.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, sessionTimeout);        propsMap.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);        propsMap.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);        propsMap.put(ConsumerConfig.GROUP_ID_CONFIG, groupId + HostUtil.getLocalHost().getHostAddress().replace(<span class="hljs-string">"."</span>,<span class="hljs-string">""</span>));        propsMap.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, autoOffsetReset);        <span class="hljs-keyword">return</span> propsMap;    &#125;&#125;</code></pre><blockquote><p>配置都完成了，先往<code>Topic</code>里发送几条消息：<br>PS:这里的<code>KafkaMessage</code>是自己创建的类</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><span class="hljs-keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;<span class="hljs-keyword">private</span> Gson gson = <span class="hljs-keyword">new</span> GsonBuilder().create();<span class="hljs-comment">//发送消息方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;    KafkaMessage message = <span class="hljs-keyword">new</span> KafkaMessage();    message.setId(System.currentTimeMillis());    message.setMsg(UUID.randomUUID().toString());    message.setSendTime(<span class="hljs-keyword">new</span> Date());    log.info(<span class="hljs-string">"++ message = &#123;&#125;"</span>, gson.toJson(message));    <span class="hljs-comment">//发送消息到 test</span>    ListenableFuture&lt;SendResult&lt;String, String&gt;&gt; listenableFuture = kafkaTemplate.send(<span class="hljs-string">"test"</span>, gson.toJson(message));    sendCallBack(listenableFuture);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendCallBack</span><span class="hljs-params">(ListenableFuture&gt; listenableFuture)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            SendResult sendResult = listenableFuture.get(<span class="hljs-number">3</span>, TimeUnit.SECONDS);            listenableFuture.addCallback(                    successCallBack -&gt; log.info(<span class="hljs-string">"kafka Producer发送消息成功！topic="</span> + sendResult.getRecordMetadata().topic()                            \+ <span class="hljs-string">",partition="</span> + sendResult.getRecordMetadata().partition()                            \+ <span class="hljs-string">",offset="</span> + sendResult.getRecordMetadata().offset()),                    failureCallBack -&gt;                            log.error(<span class="hljs-string">"kafka Producer发送消息失败！sendResult="</span> + gson.toJson(sendResult.getProducerRecord())));        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            log.error(<span class="hljs-string">"获取producer返回值失败"</span>, e);        &#125;&#125;</code></pre><blockquote><p>发送完成了，还要有消费方消费消息：</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@KafkaListener</span>(topics = &#123;<span class="hljs-string">"test"</span>&#125;, containerFactory = <span class="hljs-string">"kafkaListenerContainerFactory"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listen</span><span class="hljs-params">(ConsumerRecord&lt;?, ?&gt; record)</span> </span>&#123;    Optional&lt;?&gt; kafkaMessage = Optional.ofNullable(record.value());    <span class="hljs-keyword">if</span> (kafkaMessage.isPresent()) &#123;        Object message = kafkaMessage.get();        log.info(<span class="hljs-string">"----------------- record ="</span> + record);        log.info(<span class="hljs-string">"------------------ message ="</span> + message);    &#125;&#125;</code></pre><blockquote><p>这样就可以接收<code>test</code>这个<code>topic</code>的消息了。</p></blockquote><blockquote><p>注意这里的<code>Topic</code> <code>test</code>是已经在<code>Kafka</code>里面创建好的，如果没有创建<code>Topic</code> <code>test</code>，是发送不到这个<code>Topic</code>里面的，怎么创建<code>Topic</code>这里不再多做介绍。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.栈</title>
    <link href="/passages/6/"/>
    <url>/passages/6/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>浏览器的前进、后退功能，你肯定很熟悉吧？</p><p>当你依次访问完一串页面 <code>a-b-c</code> 之后，点击浏览器的后退按钮，就可以查看之前浏览过的页面 <code>b</code> 和 <code>a</code>。当你后退到页面 <code>a</code>，点击前进按钮，就可以重新查看页面 <code>b</code> 和 <code>c</code>。但是，如果你后退到页面 <code>b</code> 后，点击了新的页面 <code>d</code>，那就无法再通过前进、后退功能查看页面 <code>c</code> 了。</p><p><font color='green'>假设你是 <code>Chrome</code> 浏览器的开发工程师，你会如何实现这个功能呢？</font></p><h2 id="如何理解“栈”？"><a href="#如何理解“栈”？" class="headerlink" title="如何理解“栈”？"></a>如何理解“栈”？</h2><p>关于“栈”，有一个非常贴切的例子，就是一摞叠在一起的盘子。平时放盘子的时候，都是从下往上一个一个放；取的时候，也是从上往下一个一个地依次取，不能从中间任意抽出。<strong>后进者先出，先进者后出，这就是典型的“栈”结构。</strong><br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/06/c3929f00-d0a8-11e9-913b-a197b4ae75d3.png" srcset="/img/loading.gif" alt="image.png"><br>从栈的操作特性上来看，<strong>栈是一种“操作受限”的线性表</strong>，只允许在一端插入和删除数据。</p><p>第一次接触这种数据结构的时候，就对它存在的意义产生了很大的疑惑。因为我觉得，相比数组和链表，栈带给我的只有限制，并没有任何优势。那直接使用数组或者链表不就好了吗？为什么还要用这个“操作受限”的“栈”呢？</p><p>事实上，从功能上来说，数组或链表确实可以替代栈，但你要知道，特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。</p><p><strong>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，就应该首选“栈”这种数据结构。</strong></p><h2 id="如何实现一个“栈”？"><a href="#如何实现一个“栈”？" class="headerlink" title="如何实现一个“栈”？"></a>如何实现一个“栈”？</h2><p>从刚才栈的定义里，可以看出，栈主要包含两个操作，入栈和出栈，也就是在栈顶插入一个数据和从栈顶删除一个数据。理解了栈的定义之后，来看一看如何用代码实现一个栈。</p><p>实际上，栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作<strong>顺序栈</strong>，用链表实现的栈，我们叫作<strong>链式栈</strong>。</p><p>这里实现一个基于数组的顺序栈。基于链表实现的链式栈的代码，你可以自己试着写一下。</p><p>下面这段代码是用 <code>Java</code> 来实现的，但是不涉及任何高级语法，并且还用中文做了详细的注释，所以你应该是可以看懂的。</p><pre><code class="hljs java"><span class="hljs-comment">// 基于数组实现的顺序栈</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayStack</span> </span>&#123;  <span class="hljs-keyword">private</span> String[] items;  <span class="hljs-comment">// 数组</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;       <span class="hljs-comment">// 栈中元素个数</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;           <span class="hljs-comment">// 栈的大小</span>  <span class="hljs-comment">// 初始化数组，申请一个大小为 n 的数组空间</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayStack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">this</span>.items = <span class="hljs-keyword">new</span> String[n];    <span class="hljs-keyword">this</span>.n = n;    <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-comment">// 入栈操作</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">push</span><span class="hljs-params">(String item)</span> </span>&#123;    <span class="hljs-comment">// 数组空间不够了，直接返回 false，入栈失败。</span>    <span class="hljs-keyword">if</span> (count == n) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-comment">// 将 item 放到下标为 count 的位置，并且 count 加一</span>    items[count] = item;    ++count;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  &#125;    <span class="hljs-comment">// 出栈操作</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 栈为空，则直接返回 null</span>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 返回下标为 count-1 的数组元素，并且栈中元素个数 count 减一</span>    String tmp = items[count-<span class="hljs-number">1</span>];    --count;    <span class="hljs-keyword">return</span> tmp;  &#125;&#125;</code></pre><p>链表实现</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackOfLinked</span>&lt;<span class="hljs-title">Item</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">Item</span>&gt; </span>&#123;    <span class="hljs-comment">//定义一个内部类，就可以直接使用类型参数</span>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;        Item item;        Node next;    &#125;    <span class="hljs-keyword">private</span> Node first;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> N;    <span class="hljs-comment">//构造器</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StackOfLinked</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">//添加</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Item item)</span> </span>&#123;        Node oldFirst = first;        first = <span class="hljs-keyword">new</span> Node();        first.item = item;        first.next = oldFirst;        N++;    &#125;    <span class="hljs-comment">//删除</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Item <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        Item item = first.item;        first = first.next;        N--;        <span class="hljs-keyword">return</span> item;    &#125;    <span class="hljs-comment">//是否为空</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> N == <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">//元素数量</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> N;    &#125;    <span class="hljs-comment">//返回栈中最近添加的元素而不删除它</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Item <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> first.item;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;Item&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LinkedIterator();    &#125;    <span class="hljs-comment">//内部类：迭代器</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span> </span>&#123;        <span class="hljs-keyword">int</span> i = N;        Node t = first;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> i &gt; <span class="hljs-number">0</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Item <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;            Item item = t.item;            t = t.next;            i--;            <span class="hljs-keyword">return</span> item;        &#125;    &#125;&#125;</code></pre><p>了解了定义和基本操作，那它的操作的时间、空间复杂度是多少呢？</p><p>不管是顺序栈还是链式栈，存储数据只需要一个大小为 <code>n</code> 的数组就够了。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是 $O(1)$。</p><p>注意，这里存储数据需要一个大小为 <code>n</code> 的数组，并不是说空间复杂度就是 $O(n)$。因为，这 <code>n</code> 个空间是必须的，无法省掉。所以<strong>在说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。</strong></p><p>空间复杂度分析是不是很简单？时间复杂度也不难。不管是顺序栈还是链式栈，入栈、出栈只涉及栈顶个别数据的操作，所以时间复杂度都是 $O(1)$。</p><h2 id="支持动态扩容的顺序栈"><a href="#支持动态扩容的顺序栈" class="headerlink" title="支持动态扩容的顺序栈"></a>支持动态扩容的顺序栈</h2><p>刚才那个基于数组实现的栈，是一个固定大小的栈，也就是说，在初始化栈时需要事先指定栈的大小。当栈满之后，就无法再往栈里添加数据了。尽管链式栈的大小不受限，但要存储 <code>next</code> 指针，内存消耗相对较多。那如何基于数组实现一个可以支持动态扩容的栈呢？</p><p>你还记得，在数组那一篇，是如何来实现一个支持动态扩容的数组的吗？当数组空间不够时，就重新申请一块更大的内存，将原来数组中数据统统拷贝过去。这样就实现了一个支持动态扩容的数组。</p><p>所以，如果要实现一个支持动态扩容的栈，只需要底层依赖一个支持动态扩容的数组就可以了。当栈满了之后，就申请一个更大的数组，将原来的数据搬移到新数组中。下面有一张图，你可以对照着理解一下。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/06/dc56d780-d0a9-11e9-913b-a197b4ae75d3.png" srcset="/img/loading.gif" alt="image.png"><br>实际上，支持动态扩容的顺序栈，平时开发中并不常用到。讲这一块的目的，主要还是希望练习一下前面讲的复杂度分析方法。所以这一小节的重点是复杂度分析。</p><p>你不用死记硬背入栈、出栈的时间复杂度，你需要掌握的是分析方法。能够自己分析才算是真正掌握了。现在就分析一下支持动态扩容的顺序栈的入栈、出栈操作的时间复杂度。</p><p>对于出栈操作来说，不会涉及内存的重新申请和数据的搬移，所以出栈的时间复杂度仍然是 $O(1)$。但是，对于入栈操作来说，情况就不一样了。当栈中有空闲空间时，入栈操作的时间复杂度为 $O(1)$。但当空间不够时，就需要重新申请内存和数据搬移，所以时间复杂度就变成了 $O(n)$。</p><p>也就是说，对于入栈操作来说，最好情况时间复杂度是 $O(1)$，最坏情况时间复杂度是 $O(n)$。那平均情况下的时间复杂度又是多少呢？还记得在复杂度分析那一节中讲的摊还分析法吗？这个入栈操作的平均情况下的时间复杂度可以用摊还分析法来分析。也正好借此来实战一下摊还分析法。</p><p>为了分析的方便，需要事先做一些假设和定义：</p><ul><li><p>栈空间不够时，重新申请一个是原来大小两倍的数组；</p></li><li><p>为了简化分析，假设只有入栈操作没有出栈操作；</p></li><li><p>定义不涉及内存搬移的入栈操作为 <code>simple-push</code> 操作，时间复杂度为 $O(1)$。</p></li></ul><p>如果当前栈大小为 <code>K</code>，并且已满，当再有新的数据要入栈时，就需要重新申请 <code>2</code> 倍大小的内存，并且做 <code>K</code> 个数据的搬移操作，然后再入栈。但是，接下来的 <code>K-1</code> 次入栈操作，都不需要再重新申请内存和搬移数据，所以这 <code>K-1</code> 次入栈操作都只需要一个 <code>simple-push</code> 操作就可以完成。为了更加直观地理解这个过程，下面有一张图。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/06/49128900-d0aa-11e9-913b-a197b4ae75d3.png" srcset="/img/loading.gif" alt="image.png"><br>你应该可以看出来，这 <code>K</code> 次入栈操作，总共涉及了 <code>K</code> 个数据的搬移，以及 <code>K</code> 次 <code>simple-push</code> 操作。将 <code>K</code> 个数据搬移均摊到 <code>K</code> 次入栈操作，那每个入栈操作只需要一个数据搬移和一个 <code>simple-push</code> 操作。以此类推，入栈操作的均摊时间复杂度就为 $O(1)$。</p><p>通过这个例子的实战分析，也印证了前面讲到的，均摊时间复杂度一般都等于最好情况时间复杂度。因为在大部分情况下，入栈操作的时间复杂度都是 $O(1)$，只有在个别时刻才会退化为 $O(n)$，所以把耗时多的入栈操作的时间均摊到其他入栈操作上，平均情况下的耗时就接近 $O(1)$。</p><h2 id="栈在函数调用中的应用"><a href="#栈在函数调用中的应用" class="headerlink" title="栈在函数调用中的应用"></a>栈在函数调用中的应用</h2><p>前面的都比较偏理论，现在来看下，栈在软件工程中的实际应用。栈作为一个比较基础的数据结构，应用场景还是蛮多的。其中，比较经典的一个应用场景就是<strong>函数调用栈</strong>。</p><p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。为了更好地理解，下面一块来看下这段代码的执行过程。</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;   ret = add(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>);   res = a + ret;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, res);   reuturn <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;   <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;   sum = x + y;   <span class="hljs-keyword">return</span> sum;&#125;</code></pre><p>从代码中可以看出，<code>main()</code> 函数调用了 <code>add()</code> 函数，获取计算结果，并且与临时变量 <code>a</code> 相加，最后打印 <code>res</code> 的值。为了清晰地看到这个过程对应的函数栈里出栈、入栈的操作，下面有一张图。图中显示的是，在执行到 <code>add()</code> 函数时，函数调用栈的情况。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/06/df55ca30-d0aa-11e9-913b-a197b4ae75d3.png" srcset="/img/loading.gif" alt="image.png"></p><h2 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h2><p>再来看栈的另一个常见的应用场景，编译器如何利用栈来实现<strong>表达式求值</strong>。</p><p>为了方便解释，这里将算术表达式简化为只包含加减乘除四则运算，比如：<code>34 + 13 * 9 + 44 - 12 / 3</code>。对于这个四则运算，人脑可以很快求解出答案，但是对于计算机来说，理解这个表达式本身就是个挺难的事儿。如果换作你，让你来实现这样一个表达式求值的功能，你会怎么做呢？</p><p>实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。从左向右遍历表达式，当遇到数字，就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。</p><p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 <code>2</code> 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p><p>下面将 <code>3 + 5 * 8 - 6</code> 这个表达式的计算过程画成了一张图，可以结合图来理解刚讲的计算过程。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/06/3bee9fb0-d0ab-11e9-913b-a197b4ae75d3.png" srcset="/img/loading.gif" alt="image.png"><br>这样用两个栈来解决的思路是不是非常巧妙？你有没有想到呢？</p><h2 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h2><p>除了用栈来实现表达式求值，还可以借助栈来检查表达式中的括号是否匹配。</p><p>同样简化一下背景。假设表达式中只包含三种括号，圆括号 <code>()</code>、方括号 <code>[]</code> 和花括号 <code>{}</code>，并且它们可以任意嵌套。比如，<code>{[{}]}</code>或 <code>[{()}([])]</code> 等都为合法格式，而 <code>{[}()]</code> 或 <code>[({)]</code> 为不合法的格式。现在给你一个包含三种括号的表达式字符串，如何检查它是否合法呢？</p><p>这里也可以用栈来解决。用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。</p><p>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>来回顾一下上面讲的内容。栈是一种操作受限的数据结构，只支持入栈和出栈操作。后进先出是它最大的特点。栈既可以通过数组实现，也可以通过链表来实现。不管基于数组还是链表，入栈、出栈的时间复杂度都为 $O(1)$。除此之外，还讲了一种支持动态扩容的顺序栈，需要重点掌握它的均摊时间复杂度分析方法。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>如何实现浏览器的前进、后退功能？</p><blockquote><p>其实，用两个栈就可以非常完美地解决这个问题。<br>使用两个栈，<code>X</code> 和 <code>Y</code>，把首次浏览的页面依次压入栈 <code>X</code>，当点击后退按钮时，再依次从栈 <code>X</code> 中出栈，并将出栈的数据依次放入栈 <code>Y</code>。当点击前进按钮时，依次从栈 <code>Y</code> 中取出数据，放入栈 <code>X</code> 中。当栈 <code>X</code> 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 <code>Y</code> 中没有数据，那就说明没有页面可以点击前进按钮浏览了。</p><p>比如你顺序查看了 <code>a</code>，<code>b</code>，<code>c</code> 三个页面，就依次把 <code>a</code>，<code>b</code>，<code>c</code> 压入栈，这个时候，两个栈的数据就是这个样子：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/06/d3c10c60-d0ab-11e9-913b-a197b4ae75d3.png" srcset="/img/loading.gif" alt="image.png"><br>当你通过浏览器的后退按钮，从页面 <code>c</code> 后退到页面 <code>a</code> 之后，就依次把 <code>c</code> 和 <code>b</code> 从栈 <code>X</code> 中弹出，并且依次放入到栈 <code>Y</code>。这个时候，两个栈的数据就是这个样子：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/06/e749cfb0-d0ab-11e9-913b-a197b4ae75d3.png" srcset="/img/loading.gif" alt="image.png"><br>这个时候你又想看页面 <code>b</code>，于是你又点击前进按钮回到 <code>b</code> 页面，就把 <code>b</code> 再从栈 <code>Y</code> 中出栈，放入栈 <code>X</code> 中。此时两个栈的数据是这个样子：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/06/0ffad580-d0ac-11e9-913b-a197b4ae75d3.png" srcset="/img/loading.gif" alt="image.png"><br>这个时候，你通过页面 <code>b</code> 又跳转到新的页面 <code>d</code> 了，页面 <code>c</code> 就无法再通过前进、后退按钮重复查看了，所以需要清空栈 <code>Y</code>。此时两个栈的数据这个样子：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/06/218f1bd0-d0ac-11e9-913b-a197b4ae75d3.png" srcset="/img/loading.gif" alt="image.png"></p></blockquote></li><li><p>在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？</p><blockquote><p>答：因为函数调用的执行顺序符合后进者先出，先进者后出的特点。<br>  比如函数中的局部变量的生命周期的长短是先定义的生命周期长，后定义的生命周期短；<br>  还有函数中调用函数也是这样，先开始执行的函数只有等到内部调用的其他函数执行完毕，该函数才能执行结束。<br>  正是由于函数调用的这些特点，根据数据结构是特定应用场景的抽象的原则，优先考虑栈结构。</p></blockquote></li><li><p><code>JVM</code> 内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储 <code>Java</code> 中的对象。那 <code>JVM</code> 里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？</p><blockquote><p>答：<code>JVM</code>里面的栈和我们这里说的是一回事，被称为方法栈。<br>  和前面函数调用的作用是一致的，用来存储方法中的局部变量。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(初级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.链表（下）</title>
    <link href="/passages/5/"/>
    <url>/passages/5/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>为什么链表代码这么难写？究竟怎样才能比较轻松地写出正确的链表代码呢？</p><h2 id="技巧一：理解指针或引用的含义"><a href="#技巧一：理解指针或引用的含义" class="headerlink" title="技巧一：理解指针或引用的含义"></a>技巧一：理解指针或引用的含义</h2><p>事实上，看懂链表的结构并不是很难，但是一旦把它和指针混在一起，就很容易让人摸不着头脑。所以，要想写对链表代码，首先就要理解好指针。</p><p>有些语言有“指针”的概念，比如 <code>C</code> 语言；有些语言没有指针，取而代之的是“引用”，比如 <code>Java</code>、<code>Python</code>。不管是“指针”还是“引用”，实际上，它们的意思都是一样的，都是存储所指对象的内存地址。</p><p>接下来，拿 <code>C</code> 语言中的“指针”来讲解，如果你用的是 <code>Java</code> 或者其他没有指针的语言也没关系，把它理解成“引用”就可以了。</p><p>实际上，对于指针的理解，只需要记住下面这句话就可以了：</p><p><strong>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</strong></p><p>这句话听起来还挺拗口的，你可以先记住。回到链表代码的编写过程中，慢慢解释。</p><p>在编写链表代码的时候，经常会有这样的代码：<code>p-&gt;next = q</code>。这行代码是说，<code>p</code> 结点中的 <code>next</code> 指针存储了 <code>q</code> 结点的内存地址。</p><p>还有一个更复杂的，也是写链表代码经常会用到的：<code>p-&gt;next = p-&gt;next-&gt;next</code>。这行代码表示，<code>p</code> 结点的 <code>next</code> 指针存储了 <code>p</code> 结点的下下一个结点的内存地址。</p><p>掌握了指针或引用的概念，你应该可以很轻松地看懂链表代码。恭喜你，已经离写出链表代码近了一步！</p><h2 id="技巧二：警惕指针丢失和内存泄漏"><a href="#技巧二：警惕指针丢失和内存泄漏" class="headerlink" title="技巧二：警惕指针丢失和内存泄漏"></a>技巧二：警惕指针丢失和内存泄漏</h2><p>不知道你有没有这样的感觉，写链表代码的时候，指针指来指去，一会儿就不知道指到哪里了。所以，在写的时候，一定注意不要弄丢了指针。</p><p>指针往往都是怎么弄丢的呢？拿单链表的插入操作为例来分析一下。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/26/0e021610-c7d5-11e9-bd0a-57cc00d1a72f.png" srcset="/img/loading.gif" alt="image.png"><br>如图所示，希望在结点 <code>a</code> 和相邻的结点 <code>b</code> 之间插入结点 <code>x</code>，假设当前指针 <code>p</code> 指向结点 <code>a</code>。如果将代码实现变成下面这个样子，就会发生指针丢失和内存泄露。</p><pre><code class="hljs c">p-&gt;next = x;  <span class="hljs-comment">// 将 p 的 next 指针指向 x 结点；</span>x-&gt;next = p-&gt;next;  <span class="hljs-comment">// 将 x 的结点的 next 指针指向 b 结点；</span></code></pre><p><code>p-&gt;next</code> 指针在完成第一步操作之后，已经不再指向结点 <code>b</code> 了，而是指向结点 <code>x</code>。第 <code>2</code> 行代码相当于将 <code>x</code> 赋值给 <code>x-&gt;next</code>，自己指向自己。因此，整个链表也就断成了两半，从结点 <code>b</code> 往后的所有结点都无法访问到了。</p><p>对于有些语言来说，比如 <code>C</code> 语言，内存管理是由程序员负责的，如果没有手动释放结点对应的内存空间，就会产生内存泄露。所以，<strong>插入结点时，一定要注意操作的顺序</strong>，要先将结点 <code>x</code> 的 <code>next</code> 指针指向结点 <code>b</code>，再把结点 <code>a</code> 的 <code>next</code> 指针指向结点 <code>x</code>，这样才不会丢失指针，导致内存泄漏。所以，对于刚刚的插入代码，只需要把第 <code>1</code> 行和第 <code>2</code> 行代码的顺序颠倒一下就可以了。</p><p>同理，<strong>删除链表结点时，也一定要记得手动释放内存空间</strong>，否则，也会出现内存泄漏的问题。当然，对于像 <code>Java</code> 这种虚拟机自动管理内存的编程语言来说，就不需要考虑这么多了。</p><h2 id="技巧三：利用哨兵简化实现难度"><a href="#技巧三：利用哨兵简化实现难度" class="headerlink" title="技巧三：利用哨兵简化实现难度"></a>技巧三：利用哨兵简化实现难度</h2><p>首先，先来回顾一下单链表的插入和删除操作。如果在结点 <code>p</code> 后面插入一个新的结点，只需要下面两行代码就可以搞定。</p><pre><code class="hljs c">new_node-&gt;next = p-&gt;next;p-&gt;next = new_node;</code></pre><p>但是，当要向一个空链表中插入第一个结点，刚刚的逻辑就不能用了。需要进行下面这样的特殊处理，其中 <code>head</code> 表示链表的头结点。所以，从这段代码，可以发现，对于单链表的插入操作，第一个结点和其他结点的插入逻辑是不一样的。</p><pre><code class="hljs c"><span class="hljs-keyword">if</span> (head == null) &#123;  head = new_node;&#125;</code></pre><p>再来看单链表结点删除操作。如果要删除结点 <code>p</code> 的后继结点，只需要一行代码就可以搞定。</p><pre><code class="hljs c">p-&gt;next = p-&gt;next-&gt;next;</code></pre><p>但是，如果要删除链表中的最后一个结点，前面的删除代码就不 <code>work</code> 了。跟插入类似，也需要对于这种情况特殊处理。写成代码是这样子的：</p><pre><code class="hljs c"><span class="hljs-keyword">if</span> (head-&gt;next == null) &#123;   head = null;&#125;</code></pre><p>从前面的一步一步分析，可以看出，<strong>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理</strong>。这样代码实现起来就会很繁琐，不简洁，而且也容易因为考虑不全而出错。如何来解决这个问题呢？</p><p>技巧三中提到的哨兵就要登场了。哨兵，解决的是国家之间的边界问题。同理，这里说的哨兵也是解决“边界问题”的，不直接参与业务逻辑。</p><p>还记得如何表示一个空链表吗？<code>head=null</code> 表示链表中没有结点了。其中 <code>head</code> 表示头结点指针，指向链表中的第一个结点。</p><p>如果引入哨兵结点，在任何时候，不管链表是不是空，<code>head</code> 指针都会一直指向这个哨兵结点。也把这种有哨兵结点的链表叫<strong>带头链表</strong>。相反，没有哨兵结点的链表就叫作<strong>不带头链表</strong>。</p><p>下图是一个带头链表，你可以发现，哨兵结点是不存储数据的。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/26/17368ad0-c7d6-11e9-bd0a-57cc00d1a72f.png" srcset="/img/loading.gif" alt="image.png"><br>实际上，这种利用哨兵简化编程难度的技巧，在很多代码实现中都有用到，比如插入排序、归并排序、动态规划等。现在为了让你感受更深，再举一个非常简单的例子。代码是用 <code>C</code> 语言实现的，不涉及语言方面的高级语法，很容易看懂，你可以类比到你熟悉的语言。</p><p>代码一：</p><pre><code class="hljs c"><span class="hljs-comment">// 在数组 a 中，查找 key，返回 key 所在的位置</span><span class="hljs-comment">// 其中，n 表示数组 a 的长度</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span> key)</span> </span>&#123;  <span class="hljs-comment">// 边界条件处理，如果 a 为空，或者 n&lt;=0，说明数组中没有数据，就不用 while 循环比较了</span>  <span class="hljs-keyword">if</span>(a == null || n &lt;= <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  &#125;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 这里有两个比较操作：i&lt;n 和 a[i]==key.</span>  <span class="hljs-keyword">while</span> (i &lt; n) &#123;    <span class="hljs-keyword">if</span> (a[i] == key) &#123;      <span class="hljs-keyword">return</span> i;    &#125;    ++i;  &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;</code></pre><p>代码二：</p><pre><code class="hljs c"><span class="hljs-comment">// 在数组 a 中，查找 key，返回 key 所在的位置</span><span class="hljs-comment">// 其中，n 表示数组 a 的长度</span><span class="hljs-comment">// 我举 2 个例子，你可以拿例子走一下代码</span><span class="hljs-comment">// a = &#123;4, 2, 3, 5, 9, 6&#125;  n=6 key = 7</span><span class="hljs-comment">// a = &#123;4, 2, 3, 5, 9, 6&#125;  n=6 key = 6</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span> key)</span> </span>&#123;  <span class="hljs-keyword">if</span>(a == null || n &lt;= <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  &#125;    <span class="hljs-comment">// 这里因为要将 a[n-1] 的值替换成 key，所以要特殊处理这个值</span>  <span class="hljs-keyword">if</span> (a[n<span class="hljs-number">-1</span>] == key) &#123;    <span class="hljs-keyword">return</span> n<span class="hljs-number">-1</span>;  &#125;    <span class="hljs-comment">// 把 a[n-1] 的值临时保存在变量 tmp 中，以便之后恢复。tmp=6。</span>  <span class="hljs-comment">// 之所以这样做的目的是：希望 find() 代码不要改变 a 数组中的内容</span>  <span class="hljs-keyword">char</span> tmp = a[n<span class="hljs-number">-1</span>];  <span class="hljs-comment">// 把 key 的值放到 a[n-1] 中，此时 a = &#123;4, 2, 3, 5, 9, 7&#125;</span>  a[n<span class="hljs-number">-1</span>] = key;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;  <span class="hljs-comment">// while 循环比起代码一，少了 i&lt;n 这个比较操作</span>  <span class="hljs-keyword">while</span> (a[i] != key) &#123;    ++i;  &#125;    <span class="hljs-comment">// 恢复 a[n-1] 原来的值, 此时 a= &#123;4, 2, 3, 5, 9, 6&#125;</span>  a[n<span class="hljs-number">-1</span>] = tmp;    <span class="hljs-keyword">if</span> (i == n<span class="hljs-number">-1</span>) &#123;    <span class="hljs-comment">// 如果 i == n-1 说明，在 0...n-2 之间都没有 key，所以返回 -1</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 否则，返回 i，就是等于 key 值的元素的下标</span>    <span class="hljs-keyword">return</span> i;  &#125;&#125;</code></pre><p>对比两段代码，在字符串 <code>a</code> 很长的时候，比如几万、几十万，你觉得哪段代码运行得更快点呢？答案是代码二，因为两段代码中执行次数最多就是 <code>while</code> 循环那一部分。第二段代码中，通过一个哨兵 <code>a[n-1] = key</code>，成功省掉了一个比较语句 <code>i&lt;n</code>，不要小看这一条语句，当累积执行万次、几十万次时，累积的时间就很明显了。</p><p>当然，这只是为了举例说明哨兵的作用，写代码的时候千万不要写第二段那样的代码，因为可读性太差了。大部分情况下，并不需要如此追求极致的性能。</p><h2 id="技巧四：重点留意边界条件处理"><a href="#技巧四：重点留意边界条件处理" class="headerlink" title="技巧四：重点留意边界条件处理"></a>技巧四：重点留意边界条件处理</h2><p>软件开发中，代码在一些边界或者异常情况下，最容易产生 <code>Bug</code>。链表代码也不例外。要实现没有 <code>Bug</code> 的链表代码，一定要在编写的过程中以及编写完成之后，检查边界条件是否考虑全面，以及代码在边界条件下是否能正确运行。</p><p>经常用来检查链表代码是否正确的边界条件有这样几个：</p><ul><li><p>如果链表为空时，代码是否能正常工作？</p></li><li><p>如果链表只包含一个结点时，代码是否能正常工作？</p></li><li><p>如果链表只包含两个结点时，代码是否能正常工作？</p></li><li><p>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</p></li></ul><p>当你写完链表代码之后，除了看下写的代码在正常的情况下能否工作，还要看下在上面列举的几个边界条件下，代码仍然能否正确工作。如果这些边界条件下都没有问题，那基本上可以认为没有问题了。</p><p>当然，边界条件不止列举的那些。针对不同的场景，可能还有特定的边界条件，这个需要自己去思考，不过套路都是一样的。</p><p>实际上，不光光是写链表代码，在写任何代码时，也千万不要只是实现业务正常情况下的功能就好了，一定要多想想，你的代码在运行的时候，可能会遇到哪些边界情况或者异常情况。遇到了应该如何应对，这样写出来的代码才够健壮！</p><h2 id="技巧五：举例画图，辅助思考"><a href="#技巧五：举例画图，辅助思考" class="headerlink" title="技巧五：举例画图，辅助思考"></a>技巧五：举例画图，辅助思考</h2><p>对于稍微复杂的链表操作，比如前面提到的单链表反转，指针一会儿指这，一会儿指那，一会儿就被绕晕了。总感觉脑容量不够，想不清楚。所以这个时候就要使用大招了，<strong>举例法</strong>和<strong>画图法</strong>。</p><p>你可以找一个具体的例子，把它画在纸上，释放一些脑容量，留更多的给逻辑思考，这样就会感觉到思路清晰很多。比如往单链表中插入一个数据这样一个操作，一般都是把各种情况都举一个例子，画出插入前和插入后的链表变化，如图所示：<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/08/26/d685c310-c7d6-11e9-bd0a-57cc00d1a72f.png" srcset="/img/loading.gif" alt="image.png"></p><p>看图写代码，是不是就简单多了？而且，当写完代码之后，也可以举几个例子，画在纸上，照着代码走一遍，很容易就能发现代码中的 <code>Bug</code>。</p><h2 id="技巧六：多写多练，没有捷径"><a href="#技巧六：多写多练，没有捷径" class="headerlink" title="技巧六：多写多练，没有捷径"></a>技巧六：多写多练，没有捷径</h2><p>如果你已经理解并掌握了前面所讲的方法，但是手写链表代码还是会出现各种各样的错误，也不要着急。因为我最开始学的时候，这种状况也持续了一段时间。</p><p>其实也没有什么技巧，就是把常见的链表操作都自己多写几遍，出问题就一点一点调试，熟能生巧！</p><p>所以，精选了 <code>5</code> 个常见的链表操作。你只要把这几个操作都能写熟练，不熟就多写几遍，保证你之后再也不会害怕写链表代码。</p><ul><li><p>单链表反转</p></li><li><p>链表中环的检测</p></li><li><p>两个有序的链表合并</p></li><li><p>删除链表倒数第 n 个结点</p></li><li><p>求链表的中间结点</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这节主要讲了写出正确链表代码的六个技巧。分别是理解指针或引用的含义、警惕指针丢失和内存泄漏、利用哨兵简化实现难度、重点留意边界条件处理，以及举例画图、辅助思考，还有多写多练。</p><p><strong>写链表代码是最考验逻辑思维能力的</strong>。因为，链表代码到处都是指针的操作、边界条件的处理，稍有不慎就容易产生 <code>Bug</code>。链表代码写得好坏，可以看出一个人写代码是否够细心，考虑问题是否全面，思维是否缜密。所以，这也是很多面试官喜欢让人手写链表代码的原因。所以，这一节讲到的东西，你一定要自己写代码实现一下，才有效果。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>上面讲到用哨兵来简化编码实现，你是否还能够想到其他场景，利用哨兵可以大大地简化编码难度？欢迎留言和我分享。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(初级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.链表（上）</title>
    <link href="/passages/4/"/>
    <url>/passages/4/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>下面来聊聊“链表（<code>Linked list</code>）”这个数据结构。学习链表有什么用呢？为了回答这个问题，先来讨论一个经典的链表应用场景，那就是 <code>LRU</code> 缓存淘汰算法。</p><p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 <code>CPU</code> 缓存、数据库缓存、浏览器缓存等等。</p><p>缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：先进先出策略 <code>FIFO</code>（<code>First In，First Out</code>）、最少使用策略 <code>LFU</code>（<code>Least Frequently Used</code>）、最近最少使用策略 <code>LRU</code>（<code>Least Recently Used</code>）。</p><p>这些策略不用死记，打个比方你很容易就明白了。假如说，你买了很多本技术书，但有一天你发现，这些书太多了，太占书房空间了，你要做个大扫除，扔掉一些书籍。那这个时候，你会选择扔掉哪些书呢？对应一下，你的选择标准是不是和上面的三种策略神似呢？</p><p>好了，回到正题，<font color='green'><strong>如何用链表来实现 <code>LRU</code> 缓存淘汰策略呢？</strong></font></p><h2 id="五花八门的链表结构"><a href="#五花八门的链表结构" class="headerlink" title="五花八门的链表结构"></a>五花八门的链表结构</h2><p>相比数组，链表是一种稍微复杂一点的数据结构。对于初学者来说，掌握起来也要比数组稍难一些。这两个非常基础、非常常用的数据结构，常常会放到一块儿来比较。所以先来看，这两者有什么区别。</p><p>先从<strong>底层的存储结构</strong>上来看一看。</p><p>为了直观地对比，下面有一张图。从图中看到，数组需要一块<strong>连续的内存空间</strong>来存储，对内存的要求比较高。如果申请一个 <code>100MB</code> 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 <code>100MB</code>，仍然会申请失败。</p><p>而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组<strong>零散的内存块</strong>串联起来使用，所以如果申请的是 <code>100MB</code> 大小的链表，根本不会有问题。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/02/4d5036c0-cd49-11e9-949b-39df729e553b.png" srcset="/img/loading.gif" alt="image.png"><br>链表结构五花八门，下面重点介绍三种最常见的链表结构，它们分别是：单链表、双向链表和循环链表。首先来看最简单、最常用的<strong>单链表</strong>。</p><p>刚刚讲到，链表通过指针将一组零散的内存块串联在一起。其中，把内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，把这个记录下个结点地址的指针叫作后继指针 <code>next</code>。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/02/73f87440-cd49-11e9-949b-39df729e553b.png" srcset="/img/loading.gif" alt="image.png"><br>从上面的单链表图中，你应该可以发现，其中有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。习惯性地把第一个结点叫作<strong>头结点</strong>，把最后一个结点叫作<strong>尾结点</strong>。其中，头结点用来记录链表的基地址。有了它，就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个<strong>空地址 <code>NULL</code></strong>，表示这是链表上最后一个结点。</p><p>与数组一样，链表也支持数据的查找、插入和删除操作。</p><p>在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 $O(n)$。而在链表中插入或者删除一个数据，并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。</p><p>为了方便理解，下面有一张图，从图中可以看出，针对链表的插入和删除操作，只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 $O(1)$。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/02/baa2aa00-cd49-11e9-949b-39df729e553b.png" srcset="/img/loading.gif" alt="image.png"><br>但是，有利就有弊。链表要想随机访问第 <code>k</code> 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</p><p>你可以把链表想象成一个队伍，队伍中的每个人都只知道自己后面的人是谁，所以当希望知道排在第 <code>k</code> 位的人是谁的时候，就需要从第一个人开始，一个一个地往下数。所以，链表随机访问的性能没有数组好，需要 $O(n)$ 的时间复杂度。</p><p>好了，单链表就简单介绍完了，接着来看另外两个复杂的升级版，<strong>循环链表</strong>和<strong>双向链表</strong>。</p><p><strong>循环链表是一种特殊的单链表</strong>。实际上，循环链表也很简单。它跟单链表唯一的区别就在尾结点。单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。从下面的循环链表图中，你应该可以看出来，它像一个环一样首尾相连，所以叫作“循环”链表。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/02/f6a27760-cd49-11e9-949b-39df729e553b.png" srcset="/img/loading.gif" alt="image.png"><br>和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的<strong>约瑟夫斯问题</strong>。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。</p><p>单链表和循环链表是不是都不难？接下来我们再来看一个稍微复杂的，在实际的软件开发中，也更加常用的链表结构：<strong>双向链表</strong>。</p><p>单向链表只有一个方向，结点只有一个后继指针 <code>next</code> 指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 <code>next</code> 指向后面的结点，还有一个前驱指针 <code>prev</code> 指向前面的结点。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/02/5de78a00-cd4a-11e9-949b-39df729e553b.png" srcset="/img/loading.gif" alt="image.png"><br>从图中可以看出来，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。那相比单链表，双向链表适合解决哪种问题呢？</p><p>从结构上来看，双向链表可以支持 $O(1)$ 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</p><p>你可能会说，刚讲到单链表的插入、删除操作的时间复杂度已经是 $O(1)$ 了，双向链表还能再怎么高效呢？别着急，刚刚的分析比较偏理论，很多数据结构和算法书籍中都会这么讲，但是这种说法实际上是不准确的，或者说是有先决条件的。再来带你分析一下链表的两个操作。</p><p>先来看<strong>删除操作</strong>。</p><p>在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：</p><ul><li><p>删除结点中“值等于某个给定值”的结点；</p></li><li><p>删除给定指针指向的结点。</p></li></ul><p>对于第一种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过前面讲的指针操作将其删除。</p><p>尽管单纯的删除操作时间复杂度是 $O(1)$，但遍历查找的时间是主要的耗时点，对应的时间复杂度为 $O(n)$。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为 $O(n)$。</p><p>对于第二种情况，已经找到了要删除的结点，但是删除某个结点 <code>q</code> 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，还是要从头结点开始遍历链表，直到 <code>p-&gt;next = q</code>，说明 <code>p</code> 是 <code>q</code> 的前驱结点。</p><p>但是对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要 $O(n)$ 的时间复杂度，而双向链表只需要在 $O(1)$ 的时间复杂度内就搞定了！</p><p>同理，如果希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在 $O(1)$ 时间复杂度搞定，而单向链表需要 $O(n)$ 的时间复杂度。可以参照刚刚讲过的删除操作自己分析一下。</p><p>除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，可以记录上次查找的位置 <code>p</code>，每次查询时，根据要查找的值与 <code>p</code> 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</p><p>现在，你有没有觉得双向链表要比单链表更加高效呢？这就是为什么在实际的软件开发中，双向链表尽管比较费内存，但还是比单链表的应用更加广泛的原因。如果你熟悉 <code>Java</code> 语言，你肯定用过 <code>LinkedHashMap</code> 这个容器。如果你深入研究 <code>LinkedHashMap</code> 的实现原理，就会发现其中就用到了双向链表这种数据结构。</p><p>实际上，这里有一个更加重要的知识点需要掌握，那就是用空间换时间的设计思想。当内存空间充足的时候，如果更加追求代码的执行速度，就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。</p><p>还是缓存的例子。缓存实际上就是利用了空间换时间的设计思想。如果把数据存储在硬盘上，会比较节省内存，但每次查找数据都要询问一次硬盘，会比较慢。但如果通过缓存技术，事先将数据加载在内存中，虽然会比较耗费内存空间，但是每次数据查询的速度就大大提高了。</p><p>所以总结一下，对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。你还能想到其他时间换空间或者空间换时间的例子吗？</p><p>了解了循环链表和双向链表，如果把这两种链表整合在一起就是一个新的版本：双向循环链表。我想不用多讲，你应该知道双向循环链表长什么样子了吧？你可以自己试着在纸上画一画。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/02/aa42b310-cd4b-11e9-949b-39df729e553b.png" srcset="/img/loading.gif" alt="image.png"></p><h2 id="链表-VS-数组性能大比拼"><a href="#链表-VS-数组性能大比拼" class="headerlink" title="链表 VS 数组性能大比拼"></a>链表 VS 数组性能大比拼</h2><p>通过前面内容的学习，你应该已经知道，数组和链表是两种截然不同的内存组织方式。正是因为内存存储的区别，它们插入、删除、随机访问操作的时间复杂度正好相反。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/02/df7d1a70-cd4b-11e9-949b-39df729e553b.png" srcset="/img/loading.gif" alt="image.png"><br>不过，数组和链表的对比，并不能局限于时间复杂度。而且，在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。</p><p>数组简单易用，在实现上使用的是连续的内存空间，可以借助 <code>CPU</code> 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 <code>CPU</code> 缓存不友好，没办法有效预读。</p><p>数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（<code>out of memory</code>）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。</p><p>你可能会说，<code>Java</code> 中的 <code>ArrayList</code> 容器，也可以支持动态扩容啊？上一篇讲过，当我们往支持动态扩容的数组中插入一个数据时，如果数组中没有空闲空间了，就会申请一个更大的空间，将数据拷贝过去，而数据拷贝的操作是非常耗时的。</p><p>举一个稍微极端的例子。如果用 <code>ArrayList</code> 存储了了 <code>1GB</code> 大小的数据，这个时候已经没有空闲空间了，当再插入数据的时候，<code>ArrayList</code> 会申请一个 <code>1.5GB</code> 大小的存储空间，并且把原来那 <code>1GB</code> 的数据拷贝到新申请的空间上。听起来是不是就很耗时？</p><p>除此之外，如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 <code>Java</code> 语言，就有可能会导致频繁的 <code>GC</code>（<code>Garbage Collection</code>，垃圾回收）。</p><p>所以，在实际的开发中，针对不同类型的项目，要根据具体情况，权衡究竟是选择数组还是链表。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天讲了一种跟数组“相反”的数据结构，链表。它跟数组一样，也是非常基础、非常常用的数据结构。不过链表要比数组稍微复杂，从普通的单链表衍生出来好几种链表结构，比如双向链表、循环链表、双向循环链表。</p><p>和数组相比，链表更适合插入、删除操作频繁的场景，查询的时间复杂度较高。不过，在具体软件开发中，要对数组和链表的各种性能进行对比，综合来选择使用两者中的哪一个。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>如何基于链表实现 <code>LRU</code> 缓存淘汰算法？</li></ul><p>思路是这样的：维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，从链表头开始顺序遍历链表。</p><ol><li><p>如果此数据之前已经被缓存在链表中了，遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</p></li><li><p>如果此数据没有在缓存链表中，又可以分为两种情况：</p></li></ol><blockquote><ul><li><p>如果此时缓存未满，则将此结点直接插入到链表的头部；</p></li><li><p>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</p></li></ul></blockquote><p>这样就用链表实现了一个 <code>LRU</code> 缓存，是不是很简单？</p><p>现在来看下 <code>m</code> 缓存访问的时间复杂度是多少。因为不管缓存有没有满，都需要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为 $O(n)$。</p><p>实际上，可以继续优化这个实现思路，比如引入<strong>散列表</strong>（<code>Hash table</code>）来记录每个数据的位置，将缓存访问的时间复杂度降到 $O(1)$。因为要涉及还没有讲到的数据结构，所以这个优化方案，现在就不详细说了，等讲到散列表的时候，会再拿出来讲。</p><p>除了基于链表的实现思路，实际上还可以用数组来实现 <code>LRU</code> 缓存淘汰策略。如何利用数组实现 <code>LRU</code> 缓存淘汰策略呢？把这个问题留给你思考。</p><ul><li>如何判断一个字符串是否是回文字符串的问题，你应该听过，今天的题目就是基于这个问题的改造版本。如果字符串是通过单链表来存储的，那该如何来判断是一个回文串呢？你有什么好的解决思路呢？相应的时间空间复杂度又是多少呢？</li></ul><p>欢迎留言和我分享。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(初级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.数组</title>
    <link href="/passages/3/"/>
    <url>/passages/3/</url>
    
    <content type="html"><![CDATA[<!-- more --><p>提到数组，我想你肯定不陌生，甚至还会自信地说，它很简单啊。</p><p>是的，在每一种编程语言中，基本都会有数组这种数据类型。不过，它不仅仅是一种编程语言中的数据类型，还是一种最基础的数据结构。尽管数组看起来非常基础、简单，但是估计很多人都并没有理解这个基础数据结构的精髓。</p><p>在大部分编程语言中，数组都是从 <code>0</code> 开始编号的，但你是否下意识地想过，为什么数组要从 <code>0</code> 开始编号，而不是从 <code>1</code> 开始呢？ 从 <code>1</code> 开始不是更符合人类的思维习惯吗？</p><h2 id="如何实现随机访问？"><a href="#如何实现随机访问？" class="headerlink" title="如何实现随机访问？"></a>如何实现随机访问？</h2><p>什么是数组？估计你心中已经有了答案。不过，还是想用专业的话来做下解释。<strong>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</strong></p><p>这个定义里有几个关键词，理解了这几个关键词，你就能彻底掌握数组的概念了。下面就来看一下。</p><p>第一是<strong>线性表</strong>（<code>Linear List</code>）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/02/09337bf0-cd44-11e9-949b-39df729e553b.png" srcset="/img/loading.gif" alt="image.png"><br>而与它相对立的概念是<strong>非线性表</strong>，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/02/124961a0-cd44-11e9-949b-39df729e553b.png" srcset="/img/loading.gif" alt="image.png"><br>第二个是<strong>连续的内存空间和相同类型的数据</strong>。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p><p>说到数据的访问，那你知道数组是如何实现根据下标随机访问数组元素的吗？</p><p>拿一个长度为 <code>10</code> 的 <code>int</code> 类型的数组 <code>int[] a = new int[10]</code> 来举例。下面的这个图中，计算机给数组 <code>a[10]</code>分配了一块连续内存空间 <code>1000～1039</code>，其中，内存块的首地址为 <code>base_address = 1000</code>。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/02/4000df60-cd44-11e9-949b-39df729e553b.png" srcset="/img/loading.gif" alt="image.png"><br>计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p><pre><code class="hljs plain">a[i]_address &#x3D; base_address + i * data_type_size</code></pre><p>其中 <code>data_type_size</code> 表示数组中每个元素的大小。上面举的这个例子里，数组中存储的是 <code>int</code> 类型数据，所以 <code>data_type_size</code> 就为 4 个字节。这个公式非常简单，就不多做解释了。</p><p>这里要特别纠正一个“错误”。在面试的时候，常常会问数组和链表的区别，很多人都回答说，“链表适合插入、删除，时间复杂度 $O(1)$；数组适合查找，查找时间复杂度为 $O(1)$”。</p><p>实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 $O(1)$。即便是排好序的数组，你用二分查找，时间复杂度也是 $O(logn)$。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 $O(1)$。</p><h2 id="低效的“插入”和“删除”"><a href="#低效的“插入”和“删除”" class="headerlink" title="低效的“插入”和“删除”"></a>低效的“插入”和“删除”</h2><p>数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效。现在就来详细说一下，究竟为什么会导致低效？又有哪些改进方法呢？</p><p>先来看<strong>插入操作</strong>。</p><p>假设数组的长度为 <code>n</code>，现在，如果需要将一个数据插入到数组中的第 <code>k</code> 个位置。为了把第 <code>k</code> 个位置腾出来，给新来的数据，需要将第 <code>k～n</code> 这部分的元素都顺序地往后挪一位。那插入操作的时间复杂度是多少呢？你可以自己先试着分析一下。</p><p>如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 $O(1)$。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 $O(n)$。 因为在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 $(1+2+…n) / n = O(n)$。</p><p>如果数组中的数据是有序的，在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 <code>k</code> 之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数组插入到第 <code>k</code> 个位置，为了避免大规模的数据搬移，还有一个简单的办法就是，直接将第 <code>k</code> 位的数据搬移到数组元素的最后，把新的元素直接放入第 <code>k</code> 个位置。</p><p>为了更好地理解，举一个例子。假设数组 <code>a[10]</code> 中存储了如下 <code>5</code> 个元素：<code>a</code>，<code>b</code>，<code>c</code>，<code>d</code>，<code>e</code>。</p><p>现在需要将元素 <code>x</code> 插入到第 <code>3</code> 个位置。只需要将 <code>c</code> 放入到 <code>a[5]</code>，将 <code>a[2]</code> 赋值为 <code>x</code> 即可。最后，数组中的元素如下：<code>a</code>，<code>b</code>，<code>x</code>，<code>d</code>，<code>e</code>，<code>c</code>。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/02/012db140-cd45-11e9-949b-39df729e553b.png" srcset="/img/loading.gif" alt="image.png"><br>利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)。这个处理思想在快排中也会用到，我会在排序那一节具体来讲，这里就说到这儿。</p><p>我们再来看<strong>删除操作</strong>。</p><p>跟插入数据类似，如果要删除第 <code>k</code> 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。</p><p>和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 $O(1)$；如果删除开头的数据，则最坏情况时间复杂度为 $O(n)$；平均情况时间复杂度也为 $O(n)$。</p><p>实际上，在某些特殊场景下，并不一定非得追求数组中数据的连续性。如果将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？</p><p>继续来看例子。数组 <code>a[10]</code> 中存储了 <code>8</code> 个元素：<code>a</code>，<code>b</code>，<code>c</code>，<code>d</code>，<code>e</code>，<code>f</code>，<code>g</code>，<code>h</code>。现在，要依次删除 <code>a</code>，<code>b</code>，<code>c</code> 三个元素。<br><img src="https://muchen-img.oss-cn-hongkong.aliyuncs.com/hexo-client/2019/09/02/3114b930-cd45-11e9-949b-39df729e553b.png" srcset="/img/loading.gif" alt="image.png"><br>为了避免 <code>d</code>，<code>e</code>，<code>f</code>，<code>g</code>，<code>h</code> 这几个数据会被搬移三次，可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p><p>如果你了解 <code>JVM</code>，你会发现，这不就是 <code>JVM</code> 标记清除垃圾回收算法的核心思想吗？没错，数据结构和算法的魅力就在于此，<font color='red'><strong>很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的</strong></font>。如果你细心留意，不管是在软件开发还是架构设计中，总能找到某些算法和数据结构的影子。</p><h2 id="警惕数组的访问越界问题"><a href="#警惕数组的访问越界问题" class="headerlink" title="警惕数组的访问越界问题"></a>警惕数组的访问越界问题</h2><p>了解了数组的几个基本操作后，来聊聊数组访问越界的问题。</p><p>首先，请你来分析一下这段 <code>C</code> 语言代码的运行结果：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span>&#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">for</span>(; i&lt;=<span class="hljs-number">3</span>; i++)&#123;        arr[i] = <span class="hljs-number">0</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello world\n"</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>你发现问题了吗？这段代码的运行结果并非是打印三行“hello word”，而是会无限打印“hello world”，这是为什么呢？</p><p>因为，数组大小为 <code>3</code>，<code>a[0]</code>，<code>a[1]</code>，<code>a[2]</code>，而代码因为书写错误，导致 <code>for</code> 循环的结束条件错写为了 <code>i &lt;= 3</code> 而非 <code>i &lt; 3</code>，所以当 <code>i = 3</code> 时，数组 <code>a[3]</code> 访问越界。</p><p>在 <code>C</code> 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据前面讲的数组寻址公式，<code>a[3]</code> 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 <code>i</code> 的内存地址，那么 <code>a[3] = 0</code> 就相当于 <code>i = 0</code>，所以就会导致代码无限循环。</p><p>数组越界在 <code>C</code> 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。</p><p>这种情况下，一般都会出现莫名其妙的逻辑错误，就像刚刚举的那个例子，<code>debug</code> 的难度非常的大。而且，很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统，所以写代码的时候一定要警惕数组越界。</p><p>但并非所有的语言都像 <code>C</code> 一样，把数组越界检查的工作丢给程序员来做，像 <code>Java</code> 本身就会做越界检查，比如下面这几行 <code>Java</code> 代码，就会抛出 <code>java.lang.ArrayIndexOutOfBoundsException</code>。</p><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];a[<span class="hljs-number">3</span>] = <span class="hljs-number">10</span>;</code></pre><h2 id="容器能否完全替代数组？"><a href="#容器能否完全替代数组？" class="headerlink" title="容器能否完全替代数组？"></a>容器能否完全替代数组？</h2><p>针对数组类型，很多语言都提供了容器类，比如 <code>Java</code> 中的 <code>ArrayList</code>、<code>C++ STL</code> 中的 <code>vector</code>。在项目开发中，什么时候适合用数组，什么时候适合用容器呢？</p><p>这里拿 <code>Java</code> 语言来举例。如果你是 <code>Java</code> 工程师，几乎天天都在用 <code>ArrayList</code>，对它应该非常熟悉。那它与数组相比，到底有哪些优势呢？</p><p>个人觉得，<code>ArrayList</code> 最大的优势就是<strong>可以将很多数组操作的细节封装起来</strong>。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是<strong>支持动态扩容</strong>。</p><p>数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果申请了大小为 <code>10</code> 的数组，当第 <code>11</code> 个数据需要存储到数组中时，就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。</p><p>如果使用 <code>ArrayList</code>，就完全不需要关心底层的扩容逻辑，<code>ArrayList</code> 已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为 <code>1.5</code> 倍大小。</p><p>不过，这里需要注意一点，因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，<strong>最好在创建 <code>ArrayList</code> 的时候事先指定数据大小</strong>。</p><p>比如要从数据库中取出 <code>10000</code> 条数据放入 <code>ArrayList</code>。看下面这几行代码，你会发现，相比之下，事先指定数据大小可以省掉很多次内存申请和数据搬移操作。</p><pre><code class="hljs java">ArrayList&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList(<span class="hljs-number">10000</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; ++i) &#123;  users.add(xxx);&#125;</code></pre><p>作为高级语言编程者，是不是数组就无用武之地了呢？当然不是，有些时候，用数组会更合适些，总结了几点经验。</p><ol><li><p><code>Java ArrayList</code> 无法存储基本类型，比如 <code>int</code>、<code>long</code>，需要封装为 <code>Integer</code>、<code>Long</code> 类，而 <code>Autoboxing</code>、<code>Unboxing</code> 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</p></li><li><p>如果数据大小事先已知，并且对数据的操作非常简单，用不到 <code>ArrayList</code> 提供的大部分方法，也可以直接使用数组。</p></li><li><p>还有一个是当要表示多维数组时，用数组往往会更加直观。比如 <code>Object[][] array</code>；而用容器的话则需要这样定义：<code>ArrayList&lt;ArrayList &gt; array</code>。<br>总结一下，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面学习了数组。它可以说是最基础、最简单的数据结构了。数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 $O(n)$。在平时的业务开发中，可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>为什么大多数编程语言中，数组要从 <code>0</code> 开始编号，而不是从 <code>1</code> 开始呢？</li></ul><p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（<code>offset</code>）”。前面也讲到，如果用 <code>a</code> 来表示数组的首地址，<code>a[0]</code> 就是偏移为 <code>0</code> 的位置，也就是首地址，<code>a[k]</code> 就表示偏移 <code>k</code> 个 <code>type_size</code> 的位置，所以计算 <code>a[k]</code> 的内存地址只需要用这个公式：</p><pre><code class="hljs plain">a[k]_address &#x3D; base_address + k * type_size</code></pre><p>但是，如果数组从 <code>1</code> 开始计数，那计算数组元素 <code>a[k]</code> 的内存地址就会变为：</p><pre><code class="hljs plain">a[k]_address &#x3D; base_address + (k-1)*type_size</code></pre><p>对比两个公式，不难发现，从 <code>1</code> 开始编号，每次随机访问数组元素都多了一次减法运算，对于 <code>CPU</code> 来说，就是多了一次减法指令。</p><p>数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 <code>0</code> 开始编号，而不是从 <code>1</code> 开始。</p><p>不过我认为，上面解释得再多其实都算不上压倒性的证明，说数组起始编号非 <code>0</code> 开始不可。所以最主要的原因可能是历史原因。</p><p><code>C</code> 语言设计者用 <code>0</code> 开始计数数组下标，之后的 <code>Java</code>、<code>JavaScript</code> 等高级语言都效仿了 <code>C</code> 语言，或者说，为了在一定程度上减少 <code>C</code> 语言程序员学习 <code>Java</code> 的学习成本，因此继续沿用了从 <code>0</code> 开始计数的习惯。实际上，很多语言中数组也并不是从 <code>0</code> 开始计数的，比如 <code>Matlab</code>。甚至还有一些语言支持负数下标，比如 <code>Python</code>。</p><ul><li><p>前面基于数组的原理引出 <code>JVM</code> 的标记清除垃圾回收算法的核心理念。不知道你是否使用 <code>Java</code> 语言，理解 <code>JVM</code>，如果你熟悉，可以在评论区回顾下你理解的标记清除垃圾回收算法。</p></li><li><p>前面讲到一维数组的内存寻址公式，那你可以思考一下，类比一下，二维数组的内存寻址公式是怎样的呢？</p></li></ul><p>欢迎留言和我分享。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(初级)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.浅析最好、最坏、平均、均摊时间复杂度</title>
    <link href="/passages/2/"/>
    <url>/passages/2/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="一、复杂度分析的4个概念"><a href="#一、复杂度分析的4个概念" class="headerlink" title="一、复杂度分析的4个概念"></a>一、复杂度分析的4个概念</h2><ul><li>最坏情况时间复杂度：代码在最理想情况下执行的时间复杂度。</li><li>最好情况时间复杂度：代码在最坏情况下执行的时间复杂度。</li><li>平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。</li><li>均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。</li></ul><h2 id="二、为什么要引入这4个概念"><a href="#二、为什么要引入这4个概念" class="headerlink" title="二、为什么要引入这4个概念"></a>二、为什么要引入这4个概念</h2><ul><li>同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。</li><li>代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。</li></ul><h2 id="三、如何分析平均、均摊时间复杂度"><a href="#三、如何分析平均、均摊时间复杂度" class="headerlink" title="三、如何分析平均、均摊时间复杂度"></a>三、如何分析平均、均摊时间复杂度</h2><ul><li>平均时间复杂度<blockquote><p>代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。</p></blockquote></li><li>均摊时间复杂度<blockquote><p>两个条件满足时使用：</p><ul><li>代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；</li><li>低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。</li></ul></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(入门)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.复杂度分析</title>
    <link href="/passages/1/"/>
    <url>/passages/1/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="一、什么是复杂度分析？"><a href="#一、什么是复杂度分析？" class="headerlink" title="一、什么是复杂度分析？"></a>一、什么是复杂度分析？</h2><ul><li>数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。</li><li>因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。</li><li>分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。</li><li>复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。</li></ul><h2 id="二、为什么要进行复杂度分析？"><a href="#二、为什么要进行复杂度分析？" class="headerlink" title="二、为什么要进行复杂度分析？"></a>二、为什么要进行复杂度分析？</h2><ul><li>和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。</li><li>掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。</li></ul><h2 id="三、如何进行复杂度分析？"><a href="#三、如何进行复杂度分析？" class="headerlink" title="三、如何进行复杂度分析？"></a>三、如何进行复杂度分析？</h2><h3 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h3><h4 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h4><blockquote><p>算法的执行时间与每行代码的执行次数成正比，用$T(n) = O(f(n))$表示，其中$T(n)$表示算法执行总时间，$f(n)$表示每行代码执行总次数，而n往往表示数据的规模。</p></blockquote><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><blockquote><p>以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。</p></blockquote><h3 id="复杂度分析法则"><a href="#复杂度分析法则" class="headerlink" title="复杂度分析法则"></a>复杂度分析法则</h3><ul><li>单段代码看高频：比如循环。</li><li>多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。</li><li>嵌套代码求乘积：比如递归、多重循环等</li><li>多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。</li></ul><h2 id="四、常用的复杂度级别"><a href="#四、常用的复杂度级别" class="headerlink" title="四、常用的复杂度级别"></a>四、常用的复杂度级别</h2><ul><li>多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，$O(1)$（常数阶）、$O(logn)$（对数阶）、$O(n)$（线性阶）、$O(nlogn)$（线性对数阶）、$O(n^2)$（平方阶）、$O(n^3)$（立方阶）</li><li>非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，$O(2^n)$（指数阶）、$O(n!)$（阶乘阶）</li></ul><h2 id="五、如何掌握好复杂度分析方法？"><a href="#五、如何掌握好复杂度分析方法？" class="headerlink" title="五、如何掌握好复杂度分析方法？"></a>五、如何掌握好复杂度分析方法？</h2><blockquote><p><strong>复杂度分析关键在于多练，所谓孰能生巧。</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法(入门)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
